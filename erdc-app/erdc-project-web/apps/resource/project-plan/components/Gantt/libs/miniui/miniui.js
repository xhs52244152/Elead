var mini = {
    components: {},
    uids: {},
    ux: {},

    isReady: false,

    byClass: function (cls, el) {
        if (typeof el == 'string') el = mini.byId(el);
        return jQuery('.' + cls, el)[0];
    },
    getComponents: function () {
        var cs = [];
        for (var id in mini.components) {
            var c = mini.components[id];
            cs.push(c);
        }
        return cs;
    },
    get: function (id) {
        if (!id) return null;
        if (mini.isControl(id)) return id;

        if (typeof id == 'string') {
            if (id.charAt(0) == '#') id = id.substr(1);
        }
        if (typeof id == 'string') return mini.components[id];
        else {
            var control = mini.uids[id.uid];
            if (control && control.el == id) return control;
        }
        return null;
    },
    getbyUID: function (uid) {
        return mini.uids[uid];
    },
    findControls: function (fn, scope) {
        if (!fn) return [];
        scope = scope || mini;
        var controls = [];
        var uids = mini.uids;
        for (var uid in uids) {
            var control = uids[uid];
            var ret = fn.call(scope, control);
            if (ret === true || ret === 1) {
                controls.push(control);
                if (ret === 1) break;
            }
        }
        return controls;
    },
    getChildControls: function (parent) {
        var p = mini.get(parent);
        if (!p) return [];
        var pel = parent.el ? parent.el : parent;
        var controls = mini.findControls(function (control) {
            if (!control.el || parent == control) return false;
            if (mini.isAncestor(pel, control.el) && control.within) return true;
            return false;
        });
        return controls;
    },
    emptyFn: function () {},

    createNameControls: function (obj, pre) {
        if (!obj || !obj.el) return;
        if (!pre) pre = '_';
        var el = obj.el;
        var controls = mini.findControls(function (control) {
            if (!control.el || !control.name) return false;
            if (mini.isAncestor(el, control.el)) return true;
            return false;
        });

        for (var i = 0, l = controls.length; i < l; i++) {
            var c = controls[i];
            var name = pre + c.name;
            if (pre === true) {
                name = c.name[0].toUpperCase() + c.name.substring(1, c.name.length);
            }
            obj[name] = c;
        }
    },
    getsbyName: function (name, parentNode) {
        var isControl = mini.isControl(parentNode);
        var parentControl = parentNode;
        if (parentNode && isControl) {
            parentNode = parentNode.el;
        }
        parentNode = mini.byId(parentNode);
        parentNode = parentNode || document.body;
        var controls = mini.findControls(function (control) {
            if (!control.el) return false;
            if (control.name == name && mini.isAncestor(parentNode, control.el)) return true;
            return false;
        }, this);

        return controls;
    },
    getbyName: function (name, parentNode) {
        return mini.getsbyName(name, parentNode)[0];
    },

    getByName: function (name, parentNode) {
        return mini.getbyName(name, parentNode);
    },

    getParams: function (url) {
        if (!url) url = location.href;
        url = url.split('?')[1];
        var params = {};
        if (url) {
            var us = url.split('&');
            for (var i = 0, l = us.length; i < l; i++) {
                var ps = us[i].split('=');

                try {
                    params[ps[0]] = decodeURIComponent(unescape(ps[1]));
                } catch (ex) {}
            }
        }
        return params;
    },

    reg: function (cmp) {
        this.components[cmp.id] = cmp;
        this.uids[cmp.uid] = cmp;
    },
    unreg: function (cmp) {
        delete mini.components[cmp.id];
        delete mini.uids[cmp.uid];
    },

    classes: {},
    uiClasses: {},
    getClass: function (className) {
        if (!className) return null;
        return this.classes[className.toLowerCase()];
    },
    getClassByUICls: function (uiCls) {
        return this.uiClasses[uiCls.toLowerCase()];
    },

    idPre: 'mini-',
    idIndex: 1,
    newId: function (idPre) {
        return (idPre || this.idPre) + this.idIndex++;
    },

    copyTo: function (to, from) {
        if (to && from) {
            for (var p in from) {
                to[p] = from[p];
            }
        }
        return to;
    },
    copyIf: function (to, from) {
        if (to && from) {
            for (var p in from) {
                if (mini.isNull(to[p])) {
                    to[p] = from[p];
                }
            }
        }
        return to;
    },
    createDelegate: function (fn, scope) {
        if (!fn) return function () {};
        return function () {
            return fn.apply(scope, arguments);
        };
    },

    isControl: function (obj) {
        return !!(obj && obj.isControl);
    },
    isElement: function (obj) {
        return obj && obj.appendChild;
    },
    isDate: function (value) {
        return value && value.getFullYear;
    },
    isArray: function (value) {
        return value && !!value.unshift;
    },
    isNull: function (value) {
        return value === null || value === undefined;
    },

    isNumber: function (value) {
        return !isNaN(value) && typeof value == 'number';
    },
    isEquals: function (a, b) {
        if (a !== 0 && b !== 0 && !(a instanceof Array) && !(b instanceof Array)) {
            if ((mini.isNull(a) || a == '') && (mini.isNull(b) || b == '')) return true;
        }

        if (a && b && a.getFullYear && b.getFullYear) return a?.getTime() === b?.getTime();

        if (typeof a == 'object' && typeof b == 'object') {
            return a === b;
        }

        return String(a) === String(b);
    },
    forEach: function (array, method, scope) {
        var list = array.clone();
        for (var i = 0, l = list.length; i < l; i++) {
            var o = list[i];
            if (method.call(scope, o, i, array) === false) break;
        }
    },
    sort: function (array, fn, scope) {
        scope = scope || array;
        array.sort(fn);
    },

    removeNode: function (el) {
        jQuery(el).remove();
    },
    elWarp: document.createElement('div')
};

window.mini = mini;

mini.namespace = function (names) {
    if (typeof names != 'string') return;
    names = names.split('.');
    var parent = window;
    for (var i = 0, l = names.length; i < l; i++) {
        var name = names[i];
        var obj = parent[name];
        if (!obj) {
            obj = parent[name] = {};
        }
        parent = obj;
    }
};

if (typeof mini_debugger == 'undefined') {
    window.mini_debugger = true;
}

mini.getMapData = function (map, includes) {
    if (!includes) return map;
    var obj = {};
    if (map) {
        for (var name in map) {
            if (includes.indexOf(name) != -1) {
                obj[name] = map[name];
            }
        }
    }
    return obj;
};

mini.apply = function (a, b) {
    return jQuery.extend(a, b);
};

mini.applyIf = function (to, from, defineOptions) {
    if (to && from) {
        for (var key in from) {
            var value = from[key];
            if (!(key in to)) {
                if (defineOptions) {
                    defineOptions.value = value;
                    Object.defineProperty(to, key, defineOptions);
                } else {
                    to[key] = value;
                }
            }
        }
    }
    return to;
};

function mini_regClass(clazz, className) {
    className = className.toLowerCase();
    if (!mini.classes[className]) {
        mini.classes[className] = clazz;
        clazz.prototype.type = className;
    }
    var uiCls = clazz.prototype.uiCls;
    if (!mini.isNull(uiCls) && !mini.uiClasses[uiCls] && !!uiCls) {
        mini.uiClasses[uiCls] = clazz;
    }
}

mini.copyTo(mini, {
    regClass: mini_regClass,
    debug: false
});

mini._BindCallbacks = [];
mini._BindEvents = function (fn, scope) {
    mini._BindCallbacks.push([fn, scope]);
    if (!mini._EventTimer) {
        mini._EventTimer = setTimeout(function () {
            if (scope.el) {
                mini._FireBindEvents();
            }
        }, 50);
    }
};
mini._FireBindEvents = function () {
    for (var i = 0, l = mini._BindCallbacks.length; i < l; i++) {
        var e = mini._BindCallbacks[i];
        if (e[1] instanceof mini.Control && e[1].el) {
            e[0].call(e[1]);
        }
    }
    mini._BindCallbacks = [];
    mini._EventTimer = null;
};

mini._getFunctoin = function (fnName) {
    if (typeof fnName != 'string') return null;
    var names = fnName.split('.');
    var fn = null;
    for (var i = 0, l = names.length; i < l; i++) {
        var name = names[i];
        if (!fn) fn = window[name];
        else fn = fn[name];
        if (!fn) break;
    }
    return fn;
};

mini._getMap = function (name, obj) {
    if (!name) return null;
    var index = name.indexOf('.');
    if (index == -1 && name.indexOf('[') == -1) return obj[name];
    if (index == name.length - 1) return obj[name];
    var s = 'obj.' + name;
    try {
        var v = eval(s);
    } catch (e) {
        return null;
    }
    return v;
};
mini._setMap = function (name, value, obj) {
    if (!obj) return;
    if (typeof name != 'string') return;

    var names = name.split('.');

    function createArray(obj, name, num, defaultValue) {
        var arr = obj[name];
        if (!arr) {
            arr = obj[name] = [];
        }
        for (var i = 0; i <= num; i++) {
            var arrObj = arr[i];
            if (!arrObj) {
                if (defaultValue === null || defaultValue === undefined) {
                    arrObj = arr[i] = {};
                } else {
                    arrObj = arr[i] = defaultValue;
                }
            }
        }
        return obj[name][num];
    }

    var obj2 = null;
    for (var i = 0, l = names.length; i <= l - 1; i++) {
        var name = names[i];

        if (i == l - 1) {
            if (name.indexOf(']') == -1) {
                obj[name] = value;
            } else {
                var as = name.split('[');
                var n1 = as[0],
                    n2 = parseInt(as[1]);
                createArray(obj, n1, n2, '');
                obj[n1][n2] = value;
            }

            break;
        }

        if (name.indexOf(']') == -1) {
            obj2 = obj[name];
            if (i <= l - 2 && obj2 == null) {
                obj[name] = obj2 = {};
            }
            obj = obj2;
        } else {
            var as = name.split('[');
            var n1 = as[0],
                n2 = parseInt(as[1]);
            obj = createArray(obj, n1, n2);
        }
    }
    return value;
};

mini.getAndCreate = function (id) {
    if (!id) return null;
    if (typeof id == 'string') return mini.components[id];

    if (typeof id == 'object') {
        if (mini.isControl(id)) {
            return id;
        } else if (mini.isElement(id)) {
            return mini.uids[id.uid];
        } else {
            return mini.create(id);
        }
    }
    return null;
};
mini.create = function (uiConfig) {
    if (!uiConfig) return null;
    if (mini.get(uiConfig.id) === uiConfig) return uiConfig;
    var clazz = this.getClass(uiConfig.type);
    if (!clazz) return null;
    var ui = new clazz();

    ui.set(uiConfig);
    return ui;
};

mini.layoutChildren = function (children) {
    if (!children) return;
    for (var i = 0, l = children.length; i < l; i++) {
        var node = children[i];
        mini.doLayout(node);
    }
};

mini._Layouts = {};
mini.layout = function (el, mustLayout) {
    if (!document.body) return;
    function doLayout(el) {
        if (!el) return;
        var control = mini.get(el);
        if (control) {
            if (control.doLayout) {
                if (!mini._Layouts[control.uid]) {
                    mini._Layouts[control.uid] = control;

                    if (mustLayout !== false || control.isFixedSize() == false) {
                        control.doLayout();
                    }

                    delete mini._Layouts[control.uid];
                }
            }
        } else {
            var cs = el.childNodes;
            if (cs) {
                for (var i = 0, l = cs.length; i < l; i++) {
                    var cel = cs[i];
                    doLayout(cel);
                }
            }
        }
    }

    if (!el) el = document.body;

    doLayout(el);

    if (el == document.body && mini._layoutTimeout) {
        mini.clearTimeout(mini._layoutTimeout);
        mini._layoutTimeout = null;
    }

    if (el == document.body) {
        mini.layoutIFrames();
    }
};

mini.doLayout = mini.layout;

mini.invalidateLayout = function () {
    if (!mini._layoutTimeout) {
        mini._layoutTimeout = mini.defer(function () {
            mini.doLayout();
        });
    }
};

mini.layoutIFrames = function (parentNode) {
    if (!parentNode) parentNode = document.body;
    if (!parentNode) return;
    var iframes = parentNode.getElementsByTagName('iframe');
};

$.ajaxSetup({
    cache: false
});

if (typeof mini_debugger == 'undefined') {
    mini_debugger = true;
}
if (typeof mini_useShims == 'undefined') {
    mini_useShims = false;
}
if (typeof mini_ajaxAsyncInvoke == 'undefined') {
    mini_ajaxAsyncInvoke = true;
}

mini._Resizer = function (grid) {
    this.owner = grid;
    mini.on(this.owner.el, 'mousedown', this.__OnMouseDown, this);
};
mini._Resizer.prototype = {
    __OnMouseDown: function (e) {
        var has = mini.hasClass(e.target, 'mini-resizer-trigger');
        if (has && this.owner.allowResize) {
            var drag = this._getResizeDrag();
            drag.start(e);
        }
    },
    _getResizeDrag: function () {
        if (!this._resizeDragger) {
            this._resizeDragger = new mini.Drag({
                capture: true,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this._resizeDragger;
    },
    _OnDragStart: function (drag) {
        this.proxy = mini.append(document.body, '<div class="mini-resizer-proxy"></div>');
        this.proxy.style.cursor = 'se-resize';

        this.elBox = mini.getBox(this.owner.el);
        mini.setBox(this.proxy, this.elBox);
    },
    _OnDragMove: function (drag) {
        var grid = this.owner;
        var xOffset = drag.now[0] - drag.init[0];
        var yOffset = drag.now[1] - drag.init[1];

        var w = this.elBox.width + xOffset;
        var h = this.elBox.height + yOffset;
        if (w < grid.minWidth) w = grid.minWidth;
        if (h < grid.minHeight) h = grid.minHeight;
        if (w > grid.maxWidth) w = grid.maxWidth;
        if (h > grid.maxHeight) h = grid.maxHeight;

        mini.setSize(this.proxy, w, h);
    },
    _OnDragStop: function (drag, success) {
        if (!this.proxy) return;
        var box = mini.getBox(this.proxy);

        jQuery(this.proxy).remove();
        this.proxy = null;
        this.elBox = null;

        if (success) {
            this.owner.setWidth(box.width);
            this.owner.setHeight(box.height);
            this.owner.fire('resize');
        }
    }
};

mini._topWindow = null;
mini._getTopWindow = function () {
    if (mini._topWindow) return mini._topWindow;
    var ps = [];
    function getParents(me) {
        try {
            me['___try'] = 1;
            ps.push(me);
        } catch (ex) {}
        if (me.parent && me.parent != me) {
            getParents(me.parent);
        }
    }
    getParents(window);
    mini._topWindow = ps[ps.length - 1];
    return mini._topWindow;
};

var __ps = mini.getParams();

if (__ps._winid) {
    try {
        window.Owner = mini._getTopWindow()[__ps._winid];
    } catch (ex) {}
}

mini._WindowID = 'w' + Math.floor(Math.random() * 10000);
mini._getTopWindow()[mini._WindowID] = window;

mini.__IFrameCreateCount = 1;
mini.createIFrame = function (url, onIFrameLoad) {
    var fnName = '__iframe_onload' + mini.__IFrameCreateCount++;
    window[fnName] = __OnLoad;

    if (!url) url = '';
    var urls = url.split('#');
    url = urls[0];

    var t = '_t=' + Math.floor(Math.random() * 1000000);
    if (url.indexOf('?') == -1) {
        url += '?' + t;
    } else {
        url += '&' + t;
    }
    if (urls[1]) {
        url = url + '#' + urls[1];
    }

    var s = '<iframe style="width:100%;height:100%;" onload="' + fnName + '()"  frameborder="0"></iframe>';

    var div = document.createElement('div');
    var iframe = mini.append(div, s);

    var canFireLoad = false;
    setTimeout(function () {
        if (iframe) {
            iframe.src = url;
            canFireLoad = true;
        }
    }, 5);

    var firstLoad = true;
    function __OnLoad() {
        if (canFireLoad == false) return;

        setTimeout(function () {
            if (onIFrameLoad) onIFrameLoad(iframe, firstLoad);
            firstLoad = false;
        }, 1);
    }

    iframe._ondestroy = function () {
        window[fnName] = mini.emptyFn;

        iframe.src = '';
        try {
            iframe.contentWindow.document.write('');
            iframe.contentWindow.document.close();
        } catch (ex) {}
        iframe._ondestroy = null;
        iframe = null;
    };

    return iframe;
};

mini._doOpen = function (options) {
    if (typeof options == 'string') {
        options = { url: options };
    }

    options = mini.copyTo(
        {
            width: 700,
            height: 400,
            allowResize: true,
            allowModal: true,
            closeAction: 'destroy',

            title: '',
            titleIcon: '',
            iconCls: '',
            iconStyle: '',
            bodyStyle: 'padding: 0',

            url: '',

            showCloseButton: true,
            showFooter: false
        },
        options
    );

    options.closeAction = 'destroy';

    var onload = options.onload;
    delete options.onload;
    var ondestroy = options.ondestroy;
    delete options.ondestroy;
    var url = options.url;
    delete options.url;

    var box = mini.getViewportBox();
    if (options.width && String(options.width).indexOf('%') != -1) {
        var w = parseInt(options.width);
        options.width = parseInt(box.width * (w / 100));
    }
    if (options.height && String(options.height).indexOf('%') != -1) {
        var h = parseInt(options.height);
        options.height = parseInt(box.height * (h / 100));
    }

    var win = new mini.Window();
    win.set(options);
    win.load(url, onload, ondestroy);
    win.show();

    return win;
};

mini.open = function (options) {
    if (!options) return;

    var url = options.url;
    if (!url) url = '';
    var urls = url.split('#');
    var url = urls[0];

    var t = '_winid=' + mini._WindowID;
    if (url.indexOf('?') == -1) {
        url += '?' + t;
    } else {
        url += '&' + t;
    }
    if (urls[1]) {
        url = url + '#' + urls[1];
    }

    options.url = url;

    options.Owner = window;
    var ps = [];
    function getParents(me) {
        if (me.mini) ps.push(me);
        if (me.parent && me.parent != me) {
            getParents(me.parent);
        }
    }
    getParents(window);

    var win = ps[ps.length - 1];
    return win['mini']._doOpen(options);
};
mini.openTop = mini.open;

mini.getData = function (url, params, success, error, type) {
    var text = mini.getText(url, params, success, error, type);
    var data = mini.decode(text);
    return data;
};
mini.getText = function (url, params, success, error, type) {
    var returnText = null;
    mini.ajax({
        url: url,
        data: params,
        async: false,
        type: type ? type : 'get',
        cache: false,
        success: function (text, http) {
            returnText = text;
            if (success) success(text, http);
        },
        error: error
    });
    return returnText;
};

if (!window.mini_RootPath) {
    mini_RootPath = '/';
}
mini_CreateJSPath = function (js) {
    var scripts = document.getElementsByTagName('script');
    var path = '';
    for (var i = 0, l = scripts.length; i < l; i++) {
        var src = scripts[i].src;
        if (src.indexOf(js) != -1) {
            var ss = src.split(js);
            path = ss[0];
            break;
        }
    }
    var href = location.href;
    href = href.split('#')[0];
    href = href.split('?')[0];
    var ss = href.split('/');
    ss.length = ss.length - 1;
    href = ss.join('/');

    if (path.indexOf('https:') == -1 && path.indexOf('http:') == -1 && path.indexOf('file:') == -1) {
        path = href + '/' + path;
    }
    return path;
};
if (!window.mini_JSPath) {
    mini_JSPath = mini_CreateJSPath('miniui.js');
}

mini.update = function (options, el) {
    if (typeof options == 'string') options = { url: options };
    if (el) options.el = el;
    var html = mini.loadText(options.url);
    mini.innerHTML(options.el, html);
    mini.parse(options.el);
};

mini.createSingle = function (Type) {
    if (typeof Type == 'string') {
        Type = mini.getClass(Type);
    }
    if (typeof Type != 'function') return;
    var obj = Type.single;
    if (!obj) {
        obj = Type.single = new Type();
    }
    return obj;
};
mini.createTopSingle = function (Type) {
    if (typeof Type != 'function') return;

    var typeName = Type.prototype.type;
    if (top && top != window && top.mini && top.mini.getClass(typeName)) {
        return top.mini.createSingle(typeName);
    } else {
        return mini.createSingle(Type);
    }
};

mini.sortTypes = {
    string: function (s) {
        return String(s).toUpperCase();
    },
    date: function (s) {
        if (!s) {
            return 0;
        }
        if (mini.isDate(s)) {
            return s?.getTime();
        }
        return mini.parseDate(String(s));
    },
    float: function (s) {
        var val = parseFloat(String(s).replace(/,/g, ''));
        return isNaN(val) ? 0 : val;
    },
    int: function (s) {
        var val = parseInt(String(s).replace(/,/g, ''), 10);
        return isNaN(val) ? 0 : val;
    },
    currency: function (s) {
        var val = parseFloat(String(s).replace(/,/g, ''));
        return isNaN(val) ? 0 : val;
    }
};

mini._ValidateVType = function (vtype, value, e, scope) {
    var vtypes = vtype.split(';');
    for (var i = 0, l = vtypes.length; i < l; i++) {
        var vtype = vtypes[i].trim();
        var vv = vtype.split(':');
        var vt = vv[0];
        var args = vtype.substr(vt.length + 1, 1000);
        if (args) args = args.split(',');
        else args = [];

        var fn = mini.VTypes[vt];
        if (fn) {
            var isValid = fn(value, args);
            if (isValid !== true) {
                e.isValid = false;
                var vtext = vv[0] + 'ErrorText';
                e.errorText = scope[vtext] || mini.VTypes[vtext] || '';
                e.errorText = String.format(e.errorText, args[0], args[1], args[2], args[3], args[4]);
                break;
            }
        }
    }
};
mini._getErrorText = function (obj, field) {
    if (obj && obj[field]) {
        return obj[field];
    } else {
        return mini.VTypes[field];
    }
};
mini.VTypes = {
    uniqueErrorText: 'This field is unique.',
    requiredErrorText: 'This field is required.',
    emailErrorText: 'Please enter a valid email address.',
    urlErrorText: 'Please enter a valid URL.',
    floatErrorText: 'Please enter a valid number.',
    intErrorText: 'Please enter only digits',
    dateErrorText: 'Please enter a valid date. Date format is {0}',
    maxLengthErrorText: 'Please enter no more than {0} characters.',
    minLengthErrorText: 'Please enter at least {0} characters.',
    maxErrorText: 'Please enter a value less than or equal to {0}.',
    minErrorText: 'Please enter a value greater than or equal to {0}.',
    rangeLengthErrorText: 'Please enter a value between {0} and {1} characters long.',
    rangeCharErrorText: 'Please enter a value between {0} and {1} characters long.',
    rangeErrorText: 'Please enter a value between {0} and {1}.',

    required: function (v, args) {
        if (mini.isNull(v) || v === '') return false;
        return true;
    },
    email: function (v, args) {
        if (mini.isNull(v) || v === '') return true;
        if (v.search(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/) != -1) return true;
        else return false;
    },
    url: function (v, args) {
        if (mini.isNull(v) || v === '') return true;
        function IsURL(str_url) {
            str_url = str_url.toLowerCase();

            var strRegex =
                '^((https|http|ftp|rtsp|mms)?://)' +
                "?(([0-9a-z_!~*'().&=+$%-]+: )?[0-9a-z_!~*'().&=+$%-]+@)?" +
                '(([0-9]{1,3}.){3}[0-9]{1,3}' +
                '|' +
                "([0-9a-z_!~*'()-]+.)*" +
                '([0-9a-z][0-9a-z-]{0,61})?[0-9a-z].' +
                '[a-z]{2,6})' +
                '(:[0-9]{1,4})?' +
                '((/?)|' +
                "(/[0-9a-z_!~*'().;?:@&=+$,%#-]+)+/?)$";
            var re = new RegExp(strRegex);

            if (re.test(str_url)) {
                return true;
            } else {
                return false;
            }
        }
        return IsURL(v);
    },
    int: function (v, args) {
        if (mini.isNull(v) || v === '') return true;
        function isInteger(s) {
            if (s < 0) {
                s = -s;
            }
            var n = String(s);
            return n.length > 0 && !/[^0-9]/.test(n);
        }
        return isInteger(v);
    },
    float: function (v, args) {
        if (mini.isNull(v) || v === '') return true;
        function isFloat(s) {
            if (s < 0) {
                s = -s;
            }
            var n = String(s);
            if (n.split('.').length > 2) return false;
            return n.length > 0 && !/[^0-9.]/.test(n);
        }
        return isFloat(v);
    },
    date: function (v, args) {
        if (mini.isNull(v) || v === '') return true;
        if (!v) return false;
        var d = null;
        var format = args[0];

        if (format) {
            d = mini.parseDate(v, format);
            if (d && d.getFullYear) {
                if (mini.formatDate(d, format) == v) return true;
            }
        } else {
            d = mini.parseDate(v, 'yyyy-MM-dd');
            if (!d) d = mini.parseDate(v, 'yyyy/MM/dd');
            if (!d) d = mini.parseDate(v, 'MM/dd/yyyy');
            if (d && d.getFullYear) return true;
        }

        return false;
    },
    maxLength: function (v, args) {
        if (mini.isNull(v) || v === '') return true;
        var n = parseInt(args);
        if (!v || isNaN(n)) return true;
        if (v.length <= n) return true;
        else return false;
    },
    minLength: function (v, args) {
        if (mini.isNull(v) || v === '') return true;
        var n = parseInt(args);
        if (isNaN(n)) return true;
        if (v.length >= n) return true;
        else return false;
    },
    rangeLength: function (v, args) {
        if (mini.isNull(v) || v === '') return true;
        if (!v) return false;
        var min = parseFloat(args[0]),
            max = parseFloat(args[1]);
        if (isNaN(min) || isNaN(max)) return true;
        if (min <= v.length && v.length <= max) return true;
        return false;
    },
    rangeChar: function (v, args) {
        if (mini.isNull(v) || v === '') return true;

        var min = parseFloat(args[0]),
            max = parseFloat(args[1]);
        if (isNaN(min) || isNaN(max)) return true;

        function isChinese(v) {
            var re = new RegExp('^[\u4e00-\u9fa5]+$');
            if (re.test(v)) return true;
            return false;
        }

        var len = 0;
        var ss = String(v).split('');
        for (var i = 0, l = ss.length; i < l; i++) {
            if (isChinese(ss[i])) {
                len += 2;
            } else {
                len += 1;
            }
        }

        if (min <= len && len <= max) return true;
        return false;
    },
    range: function (v, args) {
        if (mini.VTypes['float'](v, args) == false) return false;

        if (mini.isNull(v) || v === '') return true;
        v = parseFloat(v);
        if (isNaN(v)) return false;
        var min = parseFloat(args[0]),
            max = parseFloat(args[1]);
        if (isNaN(min) || isNaN(max)) return true;
        if (min <= v && v <= max) return true;
        return false;
    },
    min: function (v, args) {
        if (mini.VTypes['float'](v, args) == false) return false;
        if (mini.isNull(v) || v === '') return true;
        v = parseFloat(v);
        if (isNaN(v)) return false;
        var min = parseFloat(args[0]);
        if (isNaN(min)) return true;
        if (min <= v) return true;
        return false;
    },
    max: function (v, args) {
        if (mini.VTypes['float'](v, args) == false) return false;
        if (mini.isNull(v) || v === '') return true;
        v = parseFloat(v);
        if (isNaN(v)) return false;
        var max = parseFloat(args[0]);
        if (isNaN(max)) return true;
        if (v <= max) return true;
        return false;
    }
};

mini.summaryTypes = {
    count: function (data) {
        if (!data) data = [];
        return data.length;
    },
    max: function (data, field) {
        if (!data) data = [];
        var max = null;
        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];
            var value = parseFloat(o[field]);
            if (value === null || value === undefined || isNaN(value)) continue;
            if (max == null || max < value) {
                max = value;
            }
        }
        return max;
    },
    min: function (data, field) {
        if (!data) data = [];
        var min = null;
        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];
            var value = parseFloat(o[field]);
            if (value === null || value === undefined || isNaN(value)) continue;
            if (min == null || min > value) {
                min = value;
            }
        }
        return min;
    },
    avg: function (data, field) {
        if (!data) data = [];
        if (data.length == 0) return 0;
        var total = 0;
        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];
            var value = parseFloat(o[field]);
            if (value === null || value === undefined || isNaN(value)) continue;
            total += value;
        }
        var v = total / data.length;
        return v;
    },
    sum: function (data, field) {
        if (!data) data = [];
        var total = 0;
        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];
            var value = parseFloat(o[field]);
            if (value === null || value === undefined || isNaN(value)) continue;
            total += value;
        }
        return total;
    }
};

mini.formatCurrency = function (num, prefix) {
    if (num === null || num === undefined) num == 0;
    num = String(num).replace(/\$|\,/g, '');
    if (isNaN(num)) {
        num = '0';
    }
    sign = num == (num = Math.abs(num));
    num = Math.floor(num * 100 + 0.50000000001);
    cents = num % 100;
    num = Math.floor(num / 100).toString();
    if (cents < 10) {
        cents = '0' + cents;
    }
    for (var i = 0; i < Math.floor((num.length - (1 + i)) / 3); i++) {
        num = num.substring(0, num.length - (4 * i + 3)) + ',' + num.substring(num.length - (4 * i + 3));
    }
    prefix = prefix || '';
    return prefix + ((sign ? '' : '-') + num + '.' + cents);
};

if (!window.requestAnimationFrame) {
    var lastTime = 0;
    window.requestAnimationFrame = function (callback) {
        var currTime = new Date()?.getTime();
        var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
        var id = window.setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}
if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
    };
}
mini.Array = {
    add: function (array, item) {
        array[array.length] = item;
        return array;
    },
    getRange: function (array, start, end) {
        var arr = [];
        for (var i = start; i <= end; i++) {
            var o = array[i];
            if (o) {
                arr[arr.length] = o;
            }
        }
        return arr;
    },
    addRange: function (source, array) {
        for (var i = 0, j = array.length; i < j; i++) source[source.length] = array[i];
        return array;
    },
    clear: function (array) {
        array.length = 0;
        return array;
    },
    clone: function (array) {
        if (array.length === 1) {
            return [array[0]];
        } else {
            return Array.apply(null, array);
        }
    },
    contains: function (array, item) {
        return array.indexOf(item) >= 0;
    },

    insert: function (array, index, item) {
        array.splice(index, 0, item);
        return array;
    },
    insertRange: function (array, index, items) {
        for (var i = items.length - 1; i >= 0; i--) {
            var item = items[i];
            array.splice(index, 0, item);
        }
        return array;
    },
    remove: function (array, item) {
        var index = array.indexOf(item);
        if (index >= 0) {
            array.splice(index, 1);
        }
        return index >= 0;
    },
    removeAt: function (array, index) {
        var ritem = array[index];
        array.splice(index, 1);
        return ritem;
    },
    removeRange: function (array, items) {
        items = mini.Array.clone(items);
        for (var i = 0, l = items.length; i < l; i++) {
            mini.Array.remove(array, items[i]);
        }
    }
};

mini.emptyFn = function () {};
mini.Drag = function (options) {
    mini.copyTo(this, options);
};
mini.Drag.prototype = {
    onStart: mini.emptyFn,
    onMove: mini.emptyFn,
    onStop: mini.emptyFn,
    capture: false,
    fps: 20,
    event: null,
    delay: 80,

    disabled: false,

    start: function (e) {
        e.preventDefault();
        if (e) this.event = e;

        this.now = this.init = [this.event.pageX, this.event.pageY];

        var bd = document;
        mini.on(bd, 'mousemove', this.move, this);
        mini.on(bd, 'mouseup', this.stop, this);
        mini.on(bd, 'contextmenu', this.contextmenu, this);
        if (this.context) mini.on(this.context, 'contextmenu', this.contextmenu, this);

        this.trigger = e.target;
        mini.selectable(this.trigger, false);
        mini.selectable(bd.body, false);

        if (this.capture) {
            if (isIE) this.trigger.setCapture(true);
            else if (document.captureEvents) document.captureEvents(Event.MOUSEMOVE | Event.MOUSEUP | Event.MOUSEDOWN);
        }
        this.started = false;

        this.startTime = new Date();
    },
    contextmenu: function (e) {
        if (this.context) mini.un(this.context, 'contextmenu', this.contextmenu, this);
        mini.un(document, 'contextmenu', this.contextmenu, this);
        e.preventDefault();
        e.stopPropagation();
    },
    move: function (e) {
        if (this.disabled) return;

        if (this.delay) {
            if (new Date() - this.startTime < this.delay) return;
        }

        if (!this.started) {
            this.started = true;
            this.onStart(this);
        }

        var sf = this;

        if (!this.timer) {
            this.timer = setTimeout(function () {
                sf.now = [e.pageX, e.pageY];
                sf.event = e;
                sf.onMove(sf);
                sf.timer = null;
            }, 5);
        }
    },
    stop: function (e) {
        this.now = [e.pageX, e.pageY];
        this.event = e;

        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        var bd = document;

        mini.selectable(this.trigger, true);
        mini.selectable(bd.body, true);

        if (isIE) {
            this.trigger.setCapture(false);
            this.trigger.releaseCapture();
        }

        var success = mini.MouseButton.Right != e.button;
        if (success == false) {
            e.preventDefault();
        }

        mini.un(bd, 'mousemove', this.move, this);
        mini.un(bd, 'mouseup', this.stop, this);
        var sf = this;
        setTimeout(function () {
            mini.un(document, 'contextmenu', sf.contextmenu, sf);
            if (sf.context) mini.un(sf.context, 'contextmenu', sf.contextmenu, sf);
        }, 1);

        if (this.started) {
            if (!this.disabled) {
                sf.onStop(sf, success);
            }
        }
    }
};

var DAY_MS = 86400000,
    HOUR_MS = 3600000,
    MINUTE_MS = 60000;

mini.copyTo(mini, {
    clearTime: function (date) {
        if (!date) return null;
        return new Date(date?.getFullYear(), date?.getMonth(), date?.getDate());
    },
    maxTime: function (date) {
        if (!date) return null;
        return new Date(date?.getFullYear(), date?.getMonth(), date?.getDate(), 23, 59, 59);
    },
    cloneDate: function (date) {
        if (!date) return null;
        return new Date(date?.getTime());
    },
    addDate: function (date, num, type) {
        if (!type) type = 'D';
        date = new Date(date?.getTime());
        switch (type.toUpperCase()) {
            case 'Y':
                date?.setFullYear(date?.getFullYear() + num);
                break;
            case 'MO':
                date?.setMonth(date?.getMonth() + num);
                break;
            case 'D':
                date?.setDate(date?.getDate() + num);
                break;
            case 'H':
                date?.setHours(date?.getHours() + num);
                break;
            case 'M':
                date?.setMinutes(date?.getMinutes() + num);
                break;
            case 'S':
                date?.setSeconds(date?.getSeconds() + num);
                break;
            case 'MS':
                date?.setMilliseconds(date?.getMilliseconds() + num);
                break;
        }
        return date;
    },
    getWeek: function (year, month, day) {
        month += 1;

        var a = Math.floor((14 - month) / 12);
        var y = year + 4800 - a;
        var m = month + 12 * a - 3;
        var jd =
            day +
            Math.floor((153 * m + 2) / 5) +
            365 * y +
            Math.floor(y / 4) -
            Math.floor(y / 100) +
            Math.floor(y / 400) -
            32045;

        var d4 = (((jd + 31741 - (jd % 7)) % 146097) % 36524) % 1461;
        var L = Math.floor(d4 / 1460);
        var d1 = ((d4 - L) % 365) + L;
        NumberOfWeek = Math.floor(d1 / 7) + 1;
        return NumberOfWeek;
    },

    getWeekStartDate: function (date, weekStartDay) {
        if (!weekStartDay) weekStartDay = 0;
        if (weekStartDay > 6 || weekStartDay < 0) throw new Error('out of weekday');
        var day = date?.getDay();
        var num = weekStartDay - day;
        if (day < weekStartDay) {
            num -= 7;
        }
        var d = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate() + num);
        return d;
    },
    getShortWeek: function (week) {
        var weeks = this.dateInfo.daysShort;
        return weeks[week];
    },
    getLongWeek: function (week) {
        var weeks = this.dateInfo.daysLong;
        return weeks[week];
    },
    getShortMonth: function (month) {
        var months = this.dateInfo.monthsShort;
        return months[month];
    },
    getLongMonth: function (month) {
        var months = this.dateInfo.monthsLong;
        return months[month];
    },
    dateInfo: {
        monthsLong: [
            'January',
            'Febraury',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ],
        monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        daysLong: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        daysShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
        quarterLong: ['Q1', 'Q2', 'Q3', 'Q4'],
        quarterShort: ['Q1', 'Q2', 'Q3', 'Q4'],
        halfYearLong: ['first half', 'second half'],
        patterns: {
            d: 'M/d/yyyy',
            D: 'dddd, MMMM dd, yyyy',
            f: 'dddd, MMMM dd, yyyy H:mm tt',
            F: 'dddd, MMMM dd, yyyy H:mm:ss tt',
            g: 'M/d/yyyy H:mm tt',
            G: 'M/d/yyyy H:mm:ss tt',
            m: 'MMMM dd',
            o: 'yyyy-MM-ddTHH:mm:ss.fff',
            s: 'yyyy-MM-ddTHH:mm:ss',
            t: 'H:mm tt',
            T: 'H:mm:ss tt',
            U: 'dddd, MMMM dd, yyyy HH:mm:ss tt',
            y: 'MMM, yyyy'
        },
        tt: {
            AM: 'AM',
            PM: 'PM'
        },
        ten: {
            Early: 'Early',
            Mid: 'Mid',
            Late: 'Late'
        },
        today: 'Today',
        clockType: 24
    },

    getHalfYear: function (date) {
        if (!date.getMonth) return null;
        var m = date?.getMonth();
        if (m < 6) return 0;
        return 1;
    },
    getQuarter: function (date) {
        if (!date.getMonth) return null;
        var m = date?.getMonth();
        if (m < 3) return 0;
        if (m < 6) return 1;
        if (m < 9) return 2;
        return 3;
    }
});
Date.prototype.getHalfYear = function () {
    if (!this.getMonth) return null;
    var m = this?.getMonth();
    if (m < 6) return 0;
    return 1;
};
Date.prototype.getQuarter = function () {
    if (!this.getMonth) return null;
    var m = this?.getMonth();
    if (m < 3) return 0;
    if (m < 6) return 1;
    if (m < 9) return 2;
    return 3;
};

mini.formatDate = function (date, format, locale) {
    if (!date || !date.getFullYear || isNaN(date)) return '';
    var fd = date?.toString();

    var dateFormat = mini.dateInfo;
    if (!dateFormat) dateFormat = mini.dateInfo;

    if (typeof dateFormat !== 'undefined') {
        var pattern = typeof dateFormat.patterns[format] !== 'undefined' ? dateFormat.patterns[format] : format;

        var year = date?.getFullYear();
        var month = date?.getMonth();
        var day = date?.getDate();

        if (format == 'yyyy-MM-dd') {
            month = month + 1 < 10 ? '0' + (month + 1) : month + 1;
            day = day < 10 ? '0' + day : day;
            return year + '-' + month + '-' + day;
        }
        if (format == 'MM/dd/yyyy') {
            month = month + 1 < 10 ? '0' + (month + 1) : month + 1;
            day = day < 10 ? '0' + day : day;
            return month + '/' + day + '/' + year;
        }

        fd = pattern.replace(/yyyy/g, year);
        fd = fd.replace(/yy/g, (year + '').substring(2));

        var halfyear = mini.getHalfYear(date);
        fd = fd.replace(/hy/g, dateFormat.halfYearLong[halfyear]);

        var quarter = mini.getQuarter(date);
        fd = fd.replace(/Q/g, dateFormat.quarterLong[quarter]);
        fd = fd.replace(/q/g, dateFormat.quarterShort[quarter]);

        fd = fd.replace(/MMMM/g, dateFormat.monthsLong[month].escapeDateTimeTokens());
        fd = fd.replace(/MMM/g, dateFormat.monthsShort[month].escapeDateTimeTokens());
        fd = fd.replace(/MM/g, month + 1 < 10 ? '0' + (month + 1) : month + 1);
        fd = fd.replace(/(\\)?M/g, function ($0, $1) {
            return $1 ? $0 : month + 1;
        });

        var dayOfWeek = date?.getDay();
        fd = fd.replace(/dddd/g, dateFormat.daysLong[dayOfWeek].escapeDateTimeTokens());
        fd = fd.replace(/ddd/g, dateFormat.daysShort[dayOfWeek].escapeDateTimeTokens());

        fd = fd.replace(/dd/g, day < 10 ? '0' + day : day);
        fd = fd.replace(/(\\)?d/g, function ($0, $1) {
            return $1 ? $0 : day;
        });

        var hour = date?.getHours();
        var halfHour = hour > 12 ? hour - 12 : hour;
        if (dateFormat.clockType == 12) {
            if (hour > 12) {
                hour -= 12;
            }
        }

        fd = fd.replace(/HH/g, hour < 10 ? '0' + hour : hour);
        fd = fd.replace(/(\\)?H/g, function ($0, $1) {
            return $1 ? $0 : hour;
        });

        fd = fd.replace(/hh/g, halfHour < 10 ? '0' + halfHour : halfHour);
        fd = fd.replace(/(\\)?h/g, function ($0, $1) {
            return $1 ? $0 : halfHour;
        });

        var minutes = date?.getMinutes();
        fd = fd.replace(/mm/g, minutes < 10 ? '0' + minutes : minutes);
        fd = fd.replace(/(\\)?m/g, function ($0, $1) {
            return $1 ? $0 : minutes;
        });

        var seconds = date?.getSeconds();
        fd = fd.replace(/ss/g, seconds < 10 ? '0' + seconds : seconds);
        fd = fd.replace(/(\\)?s/g, function ($0, $1) {
            return $1 ? $0 : seconds;
        });

        fd = fd.replace(/fff/g, date?.getMilliseconds());

        fd = fd.replace(
            /tt/g,
            date?.getHours() > 12 || date?.getHours() == 0 ? dateFormat.tt['PM'] : dateFormat.tt['AM']
        );

        var date = date?.getDate();
        var tenF = '';
        if (date <= 10) tenF = dateFormat.ten['Early'];
        else if (date <= 20) tenF = dateFormat.ten['Mid'];
        else tenF = dateFormat.ten['Late'];
        fd = fd.replace(/ten/g, tenF);
    }

    return fd.replace(/\\/g, '');
};
String.prototype.escapeDateTimeTokens = function () {
    return this.replace(/([dMyHmsft])/g, '\\$1');
};

mini.fixDate = function (d, check) {
    if (+d) {
        while (d?.getDate() != check?.getDate()) {
            d.setTime(+d + (d < check ? 1 : -1) * HOUR_MS);
        }
    }
};

mini.parseDate = function (s, ignoreTimezone) {
    try {
        var d = eval(s);
        if (d && d.getFullYear) return d;
    } catch (ex) {}

    if (typeof s == 'object') {
        return isNaN(s) ? null : s;
    }
    if (typeof s == 'number') {
        var d = new Date(s * 1000);
        if (d?.getTime() != s) return null;
        return isNaN(d) ? null : d;
    }
    if (typeof s == 'string') {
        m = s.match(/^([0-9]{4}).([0-9]*)$/);
        if (m) {
            var date = new Date(m[1], m[2] - 1);
            return date;
        }

        if (s.match(/^\d+(\.\d+)?$/)) {
            var d = new Date(parseFloat(s) * 1000);
            if (d?.getTime() != s) return null;
            else return d;
        }
        if (ignoreTimezone === undefined) {
            ignoreTimezone = true;
        }
        var d = mini.parseISO8601(s, ignoreTimezone) || (s ? new Date(s) : null);
        return isNaN(d) ? null : d;
    }

    return null;
};
mini.parseISO8601 = function (s, ignoreTimezone) {
    var m = s.match(
        /^([0-9]{4})([-\/]([0-9]{1,2})([-\/]([0-9]{1,2})([T ]([0-9]{1,2}):([0-9]{1,2})(:([0-9]{1,2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:?([0-9]{2}))?))?)?)?)?$/
    );
    if (!m) {
        m = s.match(/^([0-9]{4})[-\/]([0-9]{2})[-\/]([0-9]{2})[T ]([0-9]{1,2})/);
        if (m) {
            var date = new Date(m[1], m[2] - 1, m[3], m[4]);
            return date;
        }

        m = s.match(/^([0-9]{4}).([0-9]*)/);
        if (m) {
            var date = new Date(m[1], m[2] - 1);
            return date;
        }

        m = s.match(/^([0-9]{4}).([0-9]*).([0-9]*)/);
        if (m) {
            var date = new Date(m[1], m[2] - 1, m[3]);
            return date;
        }

        m = s.match(/^([0-9]{2})-([0-9]{2})-([0-9]{4})$/);
        if (!m) return null;
        else {
            var date = new Date(m[3], m[1] - 1, m[2]);
            return date;
        }
    }
    var date = new Date(m[1], 0, 1);
    if (ignoreTimezone || !m[14]) {
        var check = new Date(m[1], 0, 1, 9, 0);
        if (m[3]) {
            date?.setMonth(m[3] - 1);
            check?.setMonth(m[3] - 1);
        }
        if (m[5]) {
            date?.setDate(m[5]);
            check?.setDate(m[5]);
        }
        mini.fixDate(date, check);
        if (m[7]) {
            date?.setHours(m[7]);
        }
        if (m[8]) {
            date?.setMinutes(m[8]);
        }
        if (m[10]) {
            date?.setSeconds(m[10]);
        }
        if (m[12]) {
            date?.setMilliseconds(Number('0.' + m[12]) * 1000);
        }
        mini.fixDate(date, check);
    } else {
        date?.setUTCFullYear(m[1], m[3] ? m[3] - 1 : 0, m[5] || 1);
        date?.setUTCHours(m[7] || 0, m[8] || 0, m[10] || 0, m[12] ? Number('0.' + m[12]) * 1000 : 0);
        var offset = Number(m[16]) * 60 + (m[18] ? Number(m[18]) : 0);
        offset *= m[15] == '-' ? 1 : -1;
        date = new Date(+date + offset * 60 * 1000);
    }
    return date;
};

mini.parseTime = function (s, format) {
    if (!s) return null;
    var n = parseInt(s);

    if (n == s && format) {
        d = new Date(0);
        if (format[0] == 'H') {
            d?.setHours(n);
        } else if (format[0] == 'm') {
            d?.setMinutes(n);
        } else if (format[0] == 's') {
            d?.setSeconds(n);
        }
        return d;
    }

    var d = mini.parseDate(s);
    if (!d) {
        var ss = s.split(':');
        var t1 = parseInt(parseFloat(ss[0]));
        var t2 = parseInt(parseFloat(ss[1]));
        var t3 = parseInt(parseFloat(ss[2]));
        if (!isNaN(t1) && !isNaN(t2) && !isNaN(t3)) {
            d = new Date(0);
            d?.setHours(t1);
            d?.setMinutes(t2);
            d?.setSeconds(t3);
        }
        if (!isNaN(t1) && (format == 'H' || format == 'HH')) {
            d = new Date(0);
            d?.setHours(t1);
        } else if (!isNaN(t1) && !isNaN(t2) && (format == 'H:mm' || format == 'HH:mm')) {
            d = new Date(0);
            d?.setHours(t1);
            d?.setMinutes(t2);
        } else if (!isNaN(t1) && !isNaN(t2) && format == 'mm:ss') {
            d = new Date(0);
            d?.setMinutes(t1);
            d?.setSeconds(t2);
        }
    }
    return d;
};

mini.dateInfo = {
    monthsLong: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    monthsShort: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
    daysLong: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
    daysShort: ['日', '一', '二', '三', '四', '五', '六'],
    quarterLong: ['一季度', '二季度', '三季度', '四季度'],
    quarterShort: ['Q1', 'Q2', 'Q2', 'Q4'],
    halfYearLong: ['上半年', '下半年'],
    patterns: {
        d: 'yyyy-M-d',
        D: 'yyyy年M月d日',
        f: 'yyyy年M月d日 H:mm',
        F: 'yyyy年M月d日 H:mm:ss',
        g: 'yyyy-M-d H:mm',
        G: 'yyyy-M-d H:mm:ss',
        m: 'MMMd日',
        o: 'yyyy-MM-ddTHH:mm:ss.fff',
        s: 'yyyy-MM-ddTHH:mm:ss',
        t: 'H:mm',
        T: 'H:mm:ss',
        U: 'yyyy年M月d日 HH:mm:ss',
        y: 'yyyy年MM月'
    },
    tt: {
        AM: '上午',
        PM: '下午'
    },
    ten: {
        Early: '上旬',
        Mid: '中旬',
        Late: '下旬'
    },
    today: '今天',
    clockType: 24
};

mini.Date = {
    clearTime: mini.clearTime,
    maxTime: mini.maxTime,
    clone: mini.cloneDate,
    add: mini.addDate
};

mini.defer = function (fn) {
    if (window.Promise) {
        function callback() {
            if (callback.__cancel !== true) {
                fn();
            } else {
            }
        }

        new Promise(function (resolve) {
            resolve(null);
        }).then(callback);

        return callback;
    } else {
        return setTimeout(fn, 1);
    }
};

mini.clearTimeout = function (timer) {
    if (typeof timer == 'number') {
        clearTimeout(timer);
    } else {
        timer.__cancel = true;
    }
};

function _isMobile() {
    var isMobile = {
        Android: function () {
            return navigator.userAgent.match(/Android/i) ? true : false;
        },
        BlackBerry: function () {
            return navigator.userAgent.match(/BlackBerry/i) ? true : false;
        },
        iOS: function () {
            return navigator.userAgent.match(/iPhone|iPad|iPod/i) ? true : false;
        },
        Windows: function () {
            return navigator.userAgent.match(/IEMobile/i) ? true : false;
        },
        any: function () {
            return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Windows();
        }
    };

    return isMobile.any();
}

mini.isTouch = _isMobile();

var isToFixedBroken = (0.9).toFixed() !== '1';

var NumberUtil = {
    add: function (num1, num2) {
        var sq1, sq2, m;
        try {
            sq1 = num1.toString().split('.')[1].length;
        } catch (e) {
            sq1 = 0;
        }
        try {
            sq2 = num2.toString().split('.')[1].length;
        } catch (e) {
            sq2 = 0;
        }
        m = Math.pow(10, Math.max(sq1, sq2));
        return parseInt((num1 * m + num2 * m).toFixed(0)) / m;
    }
};

NumberUtil.toFixed = isToFixedBroken
    ? function (value, precision) {
          precision = precision || 0;
          var pow = Math.pow(10, precision);
          return (Math.round(value * pow) / pow).toFixed(precision);
      }
    : function (value, precision) {
          return value.toFixed(precision);
      };

mini.append = function (to, html) {
    to = mini.byId(to);
    if (!html || !to) return;
    if (typeof html == 'string') {
        if (html.charAt(0) == '#') {
            html = mini.byId(html);
            if (!html) return;
            to.appendChild(html);
            return html;
        } else {
            if (html.indexOf('<tr') == 0) {
                return jQuery(to).append(html)[0].lastChild;
                return;
            }

            var d = document.createElement('div');
            d.innerHTML = html;
            html = d.firstChild;
            while (d.firstChild) {
                to.appendChild(d.firstChild);
            }
            return html;
        }
    } else {
        to.appendChild(html);
        return html;
    }
};
mini.prepend = function (to, html) {
    if (typeof html == 'string') {
        if (html.charAt(0) == '#') {
            html = mini.byId(html);
        } else {
            var d = document.createElement('div');
            d.innerHTML = html;
            html = d.firstChild;
        }
    }
    return jQuery(to).prepend(html)[0].firstChild;
};
mini.after = function (to, html) {
    if (typeof html == 'string') {
        if (html.charAt(0) == '#') {
            html = mini.byId(html);
        } else {
            var d = document.createElement('div');
            d.innerHTML = html;
            html = d.firstChild;
        }
    }
    if (!html || !to) return;
    to.nextSibling ? to.parentNode.insertBefore(html, to.nextSibling) : to.parentNode.appendChild(html);
    return html;
};
mini.before = function (to, html) {
    if (typeof html == 'string') {
        if (html.charAt(0) == '#') {
            html = mini.byId(html);
        } else {
            var d = document.createElement('div');
            d.innerHTML = html;
            html = d.firstChild;
        }
    }
    if (!html || !to) return;
    to.parentNode.insertBefore(html, to);
    return html;
};

mini.__wrap = document.createElement('div');
mini.createElements = function (html) {
    mini.removeChilds(mini.__wrap);
    var isTr = html.indexOf('<tr') == 0;
    if (isTr) {
        html = '<table>' + html + '</table>';
    }
    mini.__wrap.innerHTML = html;
    return isTr ? mini.__wrap.firstChild.rows : mini.__wrap.childNodes;
};

mini_byId = function (id, context) {
    if (typeof id == 'string') {
        if (id.charAt(0) == '#') id = id.substr(1);
        var el = document.getElementById(id);
        if (el) return el;
        if (context && !mini.isAncestor(document.body, context)) {
            var els = context.getElementsByTagName('*');
            for (var i = 0, l = els.length; i < l; i++) {
                var el = els[i];
                if (el.id == id) return el;
            }
            el = null;
        }
        return el;
    } else {
        return id;
    }
};
mini_hasClass = function (el, className) {
    el = mini.byId(el);
    if (!el) return;
    if (!el.className) return false;
    var clss = String(el.className).split(' ');
    return clss.indexOf(className) != -1;
};
mini_addClass = function (el, className) {
    if (!className) return;
    if (mini.hasClass(el, className) == false) {
        jQuery(el).addClass(className);
    }
};
mini_removeClass = function (el, className) {
    if (!className) return;
    jQuery(el).removeClass(className);
};

mini.toggleClass = function (el, cls, value) {
    jQuery(el).toggleClass(cls, value);
};

var _ceil = function (n) {
    return Math.ceil(parseFloat(n));
};

mini_getMargins = function (el) {
    el = mini.byId(el);
    var jq = jQuery(el);
    return {
        top: _ceil(jq.css('margin-top'), 10) || 0,
        left: _ceil(jq.css('margin-left'), 10) || 0,
        bottom: _ceil(jq.css('margin-bottom'), 10) || 0,
        right: _ceil(jq.css('margin-right'), 10) || 0
    };
};
mini_getBorders = function (el) {
    el = mini.byId(el);
    var jq = jQuery(el);
    return {
        top: _ceil(jq.css('border-top-width'), 10) || 0,
        left: _ceil(jq.css('border-left-width'), 10) || 0,
        bottom: _ceil(jq.css('border-bottom-width'), 10) || 0,
        right: _ceil(jq.css('border-right-width'), 10) || 0
    };
};

mini_getPaddings = function (el) {
    el = mini.byId(el);
    var jq = jQuery(el);
    return {
        top: _ceil(jq.css('padding-top'), 10) || 0,
        left: _ceil(jq.css('padding-left'), 10) || 0,
        bottom: _ceil(jq.css('padding-bottom'), 10) || 0,
        right: _ceil(jq.css('padding-right'), 10) || 0
    };
};
mini_setWidth = function (el, width) {
    el = mini.byId(el);
    width = parseInt(width);
    if (isNaN(width) || !el) return;

    if (width < 0) width = 0;
    el.style.width = width + 'px';
};
mini_setHeight = function (el, height) {
    el = mini.byId(el);
    height = parseInt(height);
    if (isNaN(height) || !el) return;

    if (height < 0) height = 0;
    el.style.height = height + 'px';
};
mini_getWidth = function (el, content) {
    el = mini.byId(el);
    if (el.style.display == 'none' || el.type == 'text/javascript') return 0;
    return content ? jQuery(el).width() : jQuery(el).outerWidth();
};
mini_getHeight = function (el, content) {
    el = mini.byId(el);
    if (el.style.display == 'none' || el.type == 'text/javascript') return 0;
    return content ? jQuery(el).height() : jQuery(el).outerHeight();
};
mini_setBox = function (el, x, y, width, height) {
    if (y === undefined) {
        y = x.y || x.top;
        width = x.width;
        height = x.height;
        x = x.x || x.left;
    }
    mini.setXY(el, x, y);
    mini.setWidth(el, width);
    mini.setHeight(el, height);
};
mini_getBox = function (el) {
    var xy = mini.getXY(el);
    var box = {
        x: xy[0],
        y: xy[1],
        width: mini.getWidth(el),
        height: mini.getHeight(el)
    };
    box.left = box.x;
    box.top = box.y;
    box.right = box.x + box.width;
    box.bottom = box.y + box.height;
    return box;
};
mini_setStyle = function (el, style) {
    el = mini.byId(el);
    if (!el || typeof style != 'string') return;

    var jq = jQuery(el);
    var styles = style.toLowerCase().split(';');
    for (var i = 0, l = styles.length; i < l; i++) {
        var s = styles[i];
        var ss = s.split(':');
        if (ss.length > 1) {
            if (ss.length > 2) {
                var s1 = ss[0].trim();
                ss.removeAt(0);
                var s2 = ss.join(':').trim();
                jq.css(s1, s2);
            } else {
                jq.css(ss[0].trim(), ss[1].trim());
            }
        }
    }
};

mini_getStyle = function (el, style) {
    return jQuery(el).css(style);
};

mini_isAncestor = function (p, c) {
    var ret = false;
    p = mini.byId(p);
    c = mini.byId(c);
    if (p === c) return true;
    if (p && c) {
        if (p.contains) {
            try {
                return p.contains(c);
            } catch (e) {
                return false;
            }
        } else if (p.compareDocumentPosition) {
            return !!(p.compareDocumentPosition(c) & 16);
        } else {
            while ((c = c.parentNode)) {
                ret = c == p || ret;
            }
        }
    }
    return ret;
};
mini_findParent = function (p, cls, maxDepth) {
    p = mini.byId(p);
    var b = document.body,
        depth = 0,
        stopEl;
    maxDepth = maxDepth || 50;
    if (typeof maxDepth != 'number') {
        stopEl = mini.byId(maxDepth);
        maxDepth = 10;
    }
    while (p && p.nodeType == 1 && depth < maxDepth && p != b && p != stopEl) {
        if (mini.hasClass(p, cls)) {
            return p;
        }
        depth++;
        p = p.parentNode;
    }
    return null;
};
mini.copyTo(mini, {
    byId: mini_byId,
    hasClass: mini_hasClass,
    addClass: mini_addClass,
    removeClass: mini_removeClass,

    getMargins: mini_getMargins,
    getBorders: mini_getBorders,
    getPaddings: mini_getPaddings,
    setWidth: mini_setWidth,
    setHeight: mini_setHeight,
    getWidth: mini_getWidth,
    getHeight: mini_getHeight,
    setBox: mini_setBox,
    getBox: mini_getBox,

    setStyle: mini_setStyle,
    getStyle: mini_getStyle,

    repaint: function (el) {
        if (!el) el = document.body;
        mini.addClass(el, 'mini-repaint');
        setTimeout(function () {
            mini.removeClass(el, 'mini-repaint');
        }, 1);
    },

    getSize: function (el, content) {
        return {
            width: mini.getWidth(el, content),
            height: mini.getHeight(el, content)
        };
    },
    setSize: function (el, width, height) {
        mini.setWidth(el, width);
        mini.setHeight(el, height);
    },
    setX: function (el, x) {
        x = parseInt(x);
        var xy = jQuery(el).offset();

        var y = parseInt(xy.top);
        if (y === undefined) y = xy[1];
        mini.setXY(el, x, y);
    },
    setY: function (el, y) {
        y = parseInt(y);
        var xy = jQuery(el).offset();
        var x = parseInt(xy.left);
        if (x === undefined) x = xy[0];
        mini.setXY(el, x, y);
    },
    setXY: function (el, x, y) {
        var xy = {
            left: parseInt(x),
            top: parseInt(y)
        };
        jQuery(el).offset(xy);
        jQuery(el).offset(xy);
    },
    getXY: function (el) {
        var xy = jQuery(el).offset();

        return [parseInt(xy.left), parseInt(xy.top)];
    },
    getViewportBox: function () {
        var w = jQuery(window).width(),
            h = jQuery(window).height();
        var x = jQuery(document).scrollLeft(),
            y = jQuery(document.body).scrollTop();

        if (y == 0 && document.documentElement) y = document.documentElement.scrollTop;

        return {
            x: x,
            y: y,
            width: w,
            height: h,
            right: x + w,
            bottom: y + h
        };
    },

    getChildNodes: function (el, all) {
        el = mini.byId(el);
        if (!el) return;
        var nodes = el.childNodes;
        var cs = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var c = nodes[i];
            if (c.nodeType == 1 || all === true) {
                cs.push(c);
            }
        }
        return cs;
    },

    removeChilds: function (el, butEl) {
        el = mini.byId(el);
        if (!el) return;
        var cs = mini.getChildNodes(el, true);
        for (var i = 0, l = cs.length; i < l; i++) {
            var c = cs[i];
            if (butEl && c == butEl) {
            } else {
                el.removeChild(cs[i]);
            }
        }
    },
    isAncestor: mini_isAncestor,
    findParent: mini_findParent,
    findChild: function (el, cls) {
        el = mini.byId(el);
        var els = el.getElementsByTagName('*');
        for (var i = 0, l = els.length; i < l; i++) {
            var el = els[i];
            if (mini.hasClass(el, cls)) return el;
        }
    },
    isAncestor: function (p, c) {
        var ret = false;
        p = mini.byId(p);
        c = mini.byId(c);
        if (p === c) return true;
        if (p && c) {
            if (p.contains) {
                try {
                    return p.contains(c);
                } catch (e) {
                    return false;
                }
            } else if (p.compareDocumentPosition) {
                return !!(p.compareDocumentPosition(c) & 16);
            } else {
                while ((c = c.parentNode)) {
                    ret = c == p || ret;
                }
            }
        }
        return ret;
    },
    getOffsetsTo: function (el, target) {
        var o = this.getXY(el),
            e = this.getXY(target);
        return [o[0] - e[0], o[1] - e[1]];
    },
    scrollIntoView: function (el, container, hscroll) {
        var c = mini.byId(container) || document.body,
            o = this.getOffsetsTo(el, c),
            l = o[0] + c.scrollLeft,
            t = o[1] + c.scrollTop,
            b = t + el.offsetHeight,
            r = l + el.offsetWidth,
            ch = c.clientHeight,
            ct = parseInt(c.scrollTop, 10),
            cl = parseInt(c.scrollLeft, 10),
            cb = ct + ch,
            cr = cl + c.clientWidth;

        if (el.offsetHeight > ch || t < ct) {
            c.scrollTop = t;
        } else if (b > cb) {
            c.scrollTop = b - ch;
        }
        c.scrollTop = c.scrollTop;

        if (hscroll !== false) {
            if (el.offsetWidth > c.clientWidth || l < cl) {
                c.scrollLeft = l;
            } else if (r > cr) {
                c.scrollLeft = r - c.clientWidth;
            }
            c.scrollLeft = c.scrollLeft;
        }
        return this;
    },
    setOpacity: function (el, opacity) {
        jQuery(el).css({
            opacity: opacity
        });
    },
    selectable: function (el, selected) {
        el = mini.byId(el);
        if (!!selected) {
            jQuery(el).removeClass('mini-unselectable');
            if (isIE) el.unselectable = 'off';
            else {
                el.style.MozUserSelect = '';
                el.style.KhtmlUserSelect = '';
                el.style.UserSelect = '';
            }
        } else {
            jQuery(el).addClass('mini-unselectable');
            if (isIE) el.unselectable = 'on';
            else {
                el.style.MozUserSelect = 'none';
                el.style.UserSelect = 'none';
                el.style.KhtmlUserSelect = 'none';
            }
        }
    },
    selectRange: function (el, iStart, iEnd) {
        if (el.createTextRange) {
            var oRange = el.createTextRange();
            oRange.moveStart('character', iStart);
            oRange.moveEnd('character', iEnd - el.value.length);
            oRange.select();
        } else {
            if (el.setSelectionRange) {
                el.setSelectionRange(iStart, iEnd);
            }
        }
        try {
            el.focus();
        } catch (e) {}
    },
    getSelectRange: function (el) {
        el = mini.byId(el);
        if (!el) return;
        try {
            el.focus();
        } catch (e) {}
        var start = 0,
            end = 0;
        if (el.createTextRange && document.selection) {
            var r = document.selection.createRange().duplicate();
            r.moveEnd('character', el.value.length);
            if (r.text === '') {
                start = el.value.length;
            } else {
                start = el.value.lastIndexOf(r.text);
            }

            var r = document.selection.createRange().duplicate();
            r.moveStart('character', -el.value.length);
            end = r.text.length;
        } else {
            start = el.selectionStart;
            end = el.selectionEnd;
        }

        return [start, end];
    }
});
(function () {
    var fixAttr = {
        tabindex: 'tabIndex',
        readonly: 'readOnly',
        for: 'htmlFor',
        class: 'className',
        maxlength: 'maxLength',
        cellspacing: 'cellSpacing',
        cellpadding: 'cellPadding',
        rowspan: 'rowSpan',
        colspan: 'colSpan',
        usemap: 'useMap',
        frameborder: 'frameBorder',
        contenteditable: 'contentEditable'
    };

    var div = document.createElement('div');
    div.setAttribute('class', 't');
    var supportSetAttr = div.className === 't';

    mini.setAttr = function (el, name, val) {
        el.setAttribute(supportSetAttr ? name : fixAttr[name] || name, val);
    };
    mini.getAttr = function (el, name) {
        if (name == 'value' && (isIE6 || isIE7)) {
            var a = el.attributes[name];
            return a ? a.value : null;
        }

        var v = el.getAttribute(supportSetAttr ? name : fixAttr[name] || name);

        if (typeof v == 'function') {
            v = el.attributes[name].value;
        }

        if (v == null && name == 'onload') {
            var node = el.getAttributeNode ? el.getAttributeNode(name) : null;
            if (node) {
                v = node.nodeValue;
            }
        }

        return v;
    };
})();

mini_preventDefault = function () {
    if (window.event) {
        window.event.returnValue = false;
    }
};
mini_stopPropogation = function () {
    if (window.event) {
        window.event.cancelBubble = true;
    }
};
mini_onOne = function (el, type, fn, scope) {
    if (!el) return;
    var name = 'on' + type.toLowerCase();

    el[name] = function (e) {
        e = e || window.event;
        e.target = e.target || e.srcElement;
        if (!e.preventDefault) {
            e.preventDefault = mini_preventDefault;
        }
        if (!e.stopPropogation) {
            e.stopPropogation = mini_stopPropogation;
        }
        var ret = fn.call(scope, e);
        if (ret === false) return false;
    };
};

mini_on = function (el, type, fn, scope) {
    el = mini.byId(el);
    scope = scope || el;
    if (!el || !type || !fn || !scope) return false;
    var listener = mini.findListener(el, type, fn, scope);
    if (listener) return false;
    var method = mini.createDelegate(fn, scope);
    mini.listeners.push([el, type, fn, scope, method]);
    if (isFirefox && type == 'mousewheel') type = 'DOMMouseScroll';
    jQuery(el).bind(type, method);
};
mini_un = function (el, type, fn, scope) {
    el = mini.byId(el);
    scope = scope || el;
    if (!el || !type || !fn || !scope) return false;
    var listener = mini.findListener(el, type, fn, scope);
    if (!listener) return false;

    mini.Array.remove(mini.listeners, listener);
    if (isFirefox && type == 'mousewheel') type = 'DOMMouseScroll';
    jQuery(el).unbind(type, listener[4]);
};

mini.copyTo(mini, {
    listeners: [],
    on: mini_on,
    un: mini_un,
    findListener: function (el, type, fn, scope) {
        el = mini.byId(el);
        scope = scope || el;
        if (!el || !type || !fn || !scope) return false;
        var listeners = mini.listeners;
        for (var i = 0, l = listeners.length; i < l; i++) {
            var listener = listeners[i];
            if (listener[0] == el && listener[1] == type && listener[2] == fn && listener[3] == scope) {
                return listener;
            }
        }
    },
    clearEvent: function (el, type) {
        el = mini.byId(el);
        if (!el) return false;
        var listeners = mini.listeners;
        for (var i = listeners.length - 1; i >= 0; i--) {
            var listener = listeners[i];
            if (listener[0] == el) {
                if (!type || type == listener[1]) {
                    mini.un(el, listener[1], listener[2], listener[3]);
                }
            }
        }
        el.onmouseover = el.onmousedown = null;
    }
});

mini.__windowResizes = [];
mini.onWindowResize = function (fn, scope) {
    mini.__windowResizes.push([fn, scope]);
};
mini.on(window, 'resize', function (e) {
    var events = mini.__windowResizes;
    for (var i = 0, l = events.length; i < l; i++) {
        var event = events[i];
        event[0].call(event[1], e);
    }
});

mini.htmlEncode = function (str) {
    if (typeof str !== 'string') return str;
    var s = '';
    if (str.length == 0) return '';
    s = str;
    s = s.replace(/&/g, '&amp;');
    s = s.replace(/</g, '&lt;');
    s = s.replace(/>/g, '&gt;');
    s = s.replace(/ /g, '&nbsp;');
    s = s.replace(/\'/g, '&#39;');
    s = s.replace(/\"/g, '&quot;');

    return s;
};

mini.htmlDecode = function (str) {
    if (typeof str !== 'string') return str;
    var s = '';
    if (str.length == 0) return '';
    s = str.replace(/&gt;/g, '&');
    s = s.replace(/&lt;/g, '<');
    s = s.replace(/&gt;/g, '>');
    s = s.replace(/&nbsp;/g, ' ');
    s = s.replace(/&#39;/g, "'");
    s = s.replace(/&quot;/g, '"');

    return s;
};

mini.applyIf(
    Array.prototype,
    {
        add: function (item) {
            this[this.length] = item;
            return this;
        },
        clear: function () {
            this.length = 0;
            return this;
        },
        clone: function () {
            if (this.length === 1) {
                return [this[0]];
            } else {
                return Array.apply(null, this);
            }
        },
        contains: function (item) {
            return this.indexOf(item) >= 0;
        },

        insert: function (index, item) {
            this.splice(index, 0, item);
            return this;
        },
        remove: function (item) {
            var index = this.indexOf(item);
            if (index >= 0) {
                this.splice(index, 1);
            }
            return index >= 0;
        },
        removeAt: function (index) {
            var ritem = this[index];
            this.splice(index, 1);
            return ritem;
        },

        getRange: function (start, end) {
            var arr = [];
            for (var i = start; i <= end; i++) {
                var o = this[i];
                if (o) {
                    arr[arr.length] = o;
                }
            }
            return arr;
        },
        addRange: function (array) {
            for (var i = 0, j = array.length; i < j; i++) this[this.length] = array[i];
            return this;
        },
        insertRange: function (index, items) {
            for (var i = items.length - 1; i >= 0; i--) {
                var item = items[i];
                this.splice(index, 0, item);
            }
            return this;
        },
        removeRange: function (items) {
            items = items.clone();
            for (var i = 0, l = items.length; i < l; i++) {
                this.remove(items[i]);
            }
        }
    },
    {
        enumerable: false,
        writable: true,
        configurable: true
    }
);

mini.Keyboard = {
    Left: 37,
    Top: 38,
    Right: 39,
    Bottom: 40,

    PageUp: 33,
    PageDown: 34,
    End: 35,
    Home: 36,

    Enter: 13,
    ESC: 27,
    Space: 32,
    Tab: 9,
    Del: 46,

    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123
};
mini.Keys = mini.Keyboard;

var ua = navigator.userAgent.toLowerCase(),
    check = function (r) {
        return r.test(ua);
    },
    DOC = document,
    isStrict = DOC.compatMode == 'CSS1Compat',
    isOpera = Object.prototype.toString.call(window.opera) == '[object Opera]',
    isChrome = check(/chrome/),
    isWebKit = check(/webkit/),
    isSafari = !isChrome && check(/safari/),
    isSafari2 = isSafari && check(/applewebkit\/4/),
    isSafari3 = isSafari && check(/version\/3/),
    isSafari4 = isSafari && check(/version\/4/),
    isIE = !!window.attachEvent && !isOpera,
    isIE7 = isIE && check(/msie 7/),
    isIE8 = isIE && check(/msie 8/),
    isIE9 = isIE && check(/msie 9/),
    isIE10 = isIE && document.documentMode == 10,
    isIE6 = isIE && !isIE7 && !isIE8 && !isIE9 && !isIE10,
    isFirefox = navigator.userAgent.indexOf('Firefox') > 0,
    isGecko = !isWebKit && check(/gecko/),
    isGecko2 = isGecko && check(/rv:1\.8/),
    isGecko3 = isGecko && check(/rv:1\.9/),
    isBorderBox = isIE && !isStrict,
    isWindows = check(/windows|win32/),
    isMac = check(/macintosh|mac os x/),
    isAir = check(/adobeair/),
    isLinux = check(/linux/),
    isSecure = /^https/i.test(window.location.protocol);

if (isIE6) {
    try {
        DOC.execCommand('BackgroundImageCache', false, true);
    } catch (e) {}
}

mini.boxModel = !isBorderBox;
mini.isIE = isIE;
mini.isIE6 = isIE6;
mini.isIE7 = isIE7;
mini.isIE8 = isIE8;
mini.isIE9 = isIE9;
mini.isIE10 = isIE10;
mini.isFirefox = isFirefox;
mini.isOpera = isOpera;
mini.isSafari = isSafari;
mini.isChrome = isChrome;

if (jQuery) jQuery.boxModel = mini.boxModel;

mini.noBorderBox = false;
if (jQuery.boxModel == false && isIE && isIE9 == false) mini.noBorderBox = true;

mini.MouseButton = {
    Left: 0,
    Middle: 1,
    Right: 2
};
if (isIE && !isIE9 && !isIE10) {
    mini.MouseButton = {
        Left: 1,
        Middle: 4,
        Right: 2
    };
}

mini._MaskID = 1;
mini._MaskObjects = {};
mini.mask = function (options) {
    var el = mini.byId(options);
    if (mini.isElement(el)) options = { el: el };
    else if (typeof options == 'string') options = { html: options };

    options = mini.copyTo(
        {
            html: '',
            cls: '',
            style: '',

            backStyle: 'background:#ccc'
        },
        options
    );
    options.el = mini.byId(options.el);
    if (!options.el) options.el = document.body;
    var el = options.el;

    mini['unmask'](options.el);
    el._maskid = mini._MaskID++;
    mini._MaskObjects[el._maskid] = options;

    var maskEl = mini.append(
        el,
        '<div class="mini-mask">' +
            '<div class="mini-mask-background" style="' +
            options.backStyle +
            '"></div>' +
            '<div class="mini-mask-msg ' +
            options.cls +
            '" style="' +
            options.style +
            '">' +
            options.html +
            '</div>' +
            '</div>'
    );

    options.maskEl = maskEl;
    if (!mini.isNull(options.opacity)) {
        mini.setOpacity(maskEl.firstChild, options.opacity);
    }

    function center() {
        msgEl.style.display = 'block';
        var size = mini.getSize(msgEl);
        msgEl.style.marginLeft = -size.width / 2 + 'px';
        msgEl.style.marginTop = -size.height / 2 + 'px';
    }

    var msgEl = maskEl.lastChild;
    msgEl.style.display = 'none';

    setTimeout(function () {
        center();
    }, 0);
};
mini['unmask'] = function (el) {
    el = mini.byId(el);
    if (!el) el = document.body;
    var options = mini._MaskObjects[el._maskid];
    if (!options) return;
    delete mini._MaskObjects[el._maskid];
    var maskEl = options.maskEl;
    options.maskEl = null;
    if (maskEl && maskEl.parentNode) {
        maskEl.parentNode.removeChild(maskEl);
    }
};

mini.Cookie = {
    get: function (sName) {
        var aCookie = document.cookie.split('; ');
        var lastMatch = null;
        for (var i = 0; i < aCookie.length; i++) {
            var aCrumb = aCookie[i].split('=');
            if (sName == aCrumb[0]) {
                lastMatch = aCrumb;
            }
        }
        if (lastMatch) {
            var v = lastMatch[1];
            if (v === undefined) return v;
            return unescape(v);
        }
        return null;
    },
    set: function (name, value, expires, domain) {
        var LargeExpDate = new Date();
        if (expires != null) {
            LargeExpDate = new Date(LargeExpDate?.getTime() + expires * 1000 * 3600 * 24);
        }

        document.cookie =
            name +
            '=' +
            escape(value) +
            (expires == null ? '' : '; expires=' + LargeExpDate.toGMTString()) +
            ';path=/' +
            (domain ? '; domain=' + domain : '');
    },
    del: function (name, domain) {
        this.set(name, null, -100, domain);
    }
};

mini.copyTo(mini, {
    treeToArray: function (nodes = [], nodesField, idField, parentIdField, parentId) {
        if (!nodesField) nodesField = 'children';
        var array = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            array[array.length] = node;

            if (parentIdField) node[parentIdField] = parentId;

            var childrenNodes = node[nodesField];
            if (childrenNodes && childrenNodes.length > 0) {
                var id = node[idField];
                var childrenArray = this.treeToArray(childrenNodes, nodesField, idField, parentIdField, id);
                mini.Array.addRange(array, childrenArray);
            }
        }
        return array;
    },

    arrayToTree: function (data, nodesField, idField, parentIdField) {
        if (!nodesField) nodesField = 'children';
        idField = idField || '_id';
        parentIdField = parentIdField || '_pid';

        var nodes = [];

        var idHash = {};
        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];
            if (!o) continue;
            var id = o[idField];
            if (id !== null && id !== undefined) {
                idHash[id] = o;
            }
            delete o[nodesField];
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];
            var p = idHash[o[parentIdField]];
            if (!p) {
                nodes.push(o);
                continue;
            }
            if (!p[nodesField]) {
                p[nodesField] = [];
            }
            p[nodesField].push(o);
        }
        return nodes;
    }
});
mini.treeToList = mini.treeToArray;
mini.listToTree = mini.arrayToTree;

function UUID() {
    var s = [],
        itoh = '0123456789ABCDEF'.split('');
    for (var i = 0; i < 36; i++) s[i] = Math.floor(Math.random() * 0x10);
    s[14] = 4;
    s[19] = (s[19] & 0x3) | 0x8;
    for (var i = 0; i < 36; i++) s[i] = itoh[s[i]];
    s[8] = s[13] = s[18] = s[23] = '-';
    return s.join('');
}

String.format = function (format) {
    var args = Array.prototype.slice.call(arguments, 1);
    format = format || '';
    return format.replace(/\{(\d+)\}/g, function (m, i) {
        return args[i];
    });
};
String.prototype.trim = (function () {
    var re = /^\s+|\s+$/g;
    return function () {
        return this.replace(re, '');
    };
})();

mini.copyTo(mini, {
    measureText: function (el, text, style) {
        if (!this.measureEl) {
            this.measureEl = mini.append(document.body, '<div></div>');
        }

        this.measureEl.style.cssText = 'position:absolute;left:-1000px;top:-1000px;visibility:hidden;';
        if (typeof el == 'string') {
            this.measureEl.className = el;
        } else {
            this.measureEl.className = '';

            var j1 = jQuery(el);
            var j2 = jQuery(this.measureEl);
            var csses = [
                'font-size',
                'font-style',
                'font-weight',
                'font-family',
                'line-height',
                'text-transform',
                'letter-spacing'
            ];
            for (var i = 0, l = csses.length; i < l; i++) {
                var css = csses[i];
                j2.css(css, j1.css(css));
            }
        }
        if (style) mini.setStyle(this.measureEl, style);
        this.measureEl.innerHTML = text;
        return mini.getSize(this.measureEl);
    }
});

jQuery(function () {
    mini.defer(function () {
        document.body.style.visibility = 'visible';

        var sss = new Date();
        mini.isReady = true;
        mini.parse();
        mini._FireBindEvents();

        if (
            (mini.getStyle(document.body, 'overflow') == 'hidden' ||
                mini.getStyle(document.documentElement, 'overflow') == 'hidden') &&
            (isIE6 || isIE7)
        ) {
            jQuery(document.body).css('overflow', 'visible');
            jQuery(document.documentElement).css('overflow', 'visible');
        }
        mini.__LastWindowWidth = document.documentElement.clientWidth;
        mini.__LastWindowHeight = document.documentElement.clientHeight;
    });
});
mini_onload = function (e) {
    if (mini.isIE8) {
        $(document.body).addClass('ie8');
    }

    mini.layout(null, false);
    mini.on(window, 'resize', mini_onresize);
};
mini.on(window, 'load', mini_onload);

mini.__LastWindowWidth = document.documentElement.clientWidth;
mini.__LastWindowHeight = document.documentElement.clientHeight;
mini.doWindowResizeTimer = null;

mini.allowLayout = true;

mini_onresize = function (e) {
    mini.invalidateLayout();
};

mini.isDisplay = function (p, body) {
    var doc = body || document.body;
    while (1) {
        if (p == null || !p.style) return false;
        if (p && p.style && p.style.display == 'none') return false;
        if (p == doc) return true;

        p = p.parentNode;
    }
    return true;
};

mini.isWindowDisplay = function () {
    try {
        var parentWindow = window.parent;
        var isIFrame = parentWindow != window;

        if (isIFrame) {
            var _iframes = parentWindow.document.getElementsByTagName('iframe');
            var _frames = parentWindow.document.getElementsByTagName('frame');
            var iframes = [];
            for (var i = 0, l = _iframes.length; i < l; i++) {
                iframes.push(_iframes[i]);
            }
            for (var i = 0, l = _frames.length; i < l; i++) {
                iframes.push(_frames[i]);
            }

            var iframe = null;
            for (var i = 0, l = iframes.length; i < l; i++) {
                var el = iframes[i];
                if (el.contentWindow == window) {
                    iframe = el;
                    break;
                }
            }
            if (!iframe) return false;

            return mini.isDisplay(iframe, parentWindow.document.body);
        } else {
            return true;
        }
    } catch (e) {
        return true;
    }
};
mini.isWindowDisplay = function () {
    return true;
};

mini.WindowVisible = mini.isWindowDisplay();

if (isIE) {
}

mini_unload = function (e) {
    if (!window.mini) return;

    try {
        var win = mini._getTopWindow();
        win[mini._WindowID] = '';
        delete win[mini._WindowID];
    } catch (ex) {}

    mini._destroying = true;

    var cs = mini.getComponents();
    for (var i = 0, l = cs.length; i < l; i++) {
        var control = cs[i];
        if (control.destroyed !== true) {
            control.destroy();
        }
    }

    cs.length = 0;
    cs = null;

    mini.un(window, 'unload', mini_unload);
    mini.un(window, 'load', mini_onload);
    mini.un(window, 'resize', mini_onresize);

    mini.components = {};
    mini.classes = {};
    mini.uiClasses = {};
    mini.uids = {};

    mini._topWindow = null;
    window.mini = null;
    window.Owner = null;
    window.CloseOwnerWindow = null;

    try {
    } catch (e) {}
};
mini.on(window, 'unload', mini_unload);

function __OnIFrameMouseDown() {}
function __BindIFrames() {
    if (mini.isIE10) return;
    var iframes = document.getElementsByTagName('iframe');
    for (var i = 0, l = iframes.length; i < l; i++) {
        var iframe = iframes[i];

        try {
        } catch (e) {}
    }
}

mini.zIndex = 1000;
mini.getMaxZIndex = function () {
    return mini.zIndex++;
};

function js_isTouchDevice() {
    try {
        document.createEvent('TouchEvent');
        return true;
    } catch (e) {
        return false;
    }
}
function js_touchScroll(id) {
    if (js_isTouchDevice()) {
        var el = typeof id == 'string' ? document.getElementById(id) : id;
        var scrollStartPos = 0;

        el.addEventListener(
            'touchstart',
            function (event) {
                scrollStartPos = this.scrollTop + event.touches[0].pageY;
                event.preventDefault();
            },
            false
        );

        el.addEventListener(
            'touchmove',
            function (event) {
                this.scrollTop = scrollStartPos - event.touches[0].pageY;
                event.preventDefault();
            },
            false
        );
    }
}

mini._placeholder = function (el) {
    el = mini.byId(el);
    if (!el || !isIE || isIE10) return;

    function doLabel() {
        var label = el._placeholder_label;

        if (!label) return;

        var placeholder = el.getAttribute('placeholder');
        if (!placeholder) placeholder = el.placeholder;
        if (!el.value && !el.disabled) {
            label.innerHTML = placeholder;
            label.style.display = '';
        } else {
            label.style.display = 'none';
        }
    }

    if (el._placeholder) {
        doLabel();
        return;
    }
    el._placeholder = true;

    var label = document.createElement('label');
    label.className = 'mini-placeholder-label';
    el.parentNode.appendChild(label);
    el._placeholder_label = label;

    label.onmousedown = function () {
        el.focus();
    };

    el.onpropertychange = function (e) {
        e = e || window.event;
        if (e.propertyName == 'value') {
            doLabel();
        }
    };

    doLabel();

    mini.on(el, 'focus', function (e) {
        if (!el.readOnly) {
            label.style.display = 'none';
        }
    });
    mini.on(el, 'blur', function (e) {
        doLabel();
    });
};

mini.ajax = function (options) {
    if (!options.dataType) {
        options.dataType = 'text';
    }

    return window.jQuery.ajax(options);
};

mini._evalAjaxData = function (ajaxData, scope) {
    var obj = ajaxData;
    var t = typeof ajaxData;
    if (t == 'string') {
        obj = window['ev' + 'al']('(' + ajaxData + ')');
        if (typeof obj == 'function') {
            obj = obj.call(scope);
        }
    }
    return obj;
};

mini.camelCase = function (s) {
    s = s.replace(/\-(\w)/g, function (all, letter) {
        return letter.toUpperCase();
    });
    return s;
};

mini._textBindReg = /\{(.+?)\}/g;

mini._parseTextBinding = function (text) {
    var m = text.match(mini._textBindReg);

    if (m && m.length > 0) {
        var tokens = [];
        var begin = 0;
        for (var i = 0, l = m.length; i < l; i++) {
            var s = m[i];
            var index = text.indexOf(s, begin);
            var end = index + s.length;
            var first = text.substring(begin, index);
            if (first) tokens.push(first);

            var msg = text.substring(index, end);
            tokens.push({
                '@binding': msg.substring(1, msg.length - 1)
            });
            begin = end;
            if (i == l - 1 && end < text.length) {
                var last = text.substring(end, text.length);
                if (last) tokens.push(last);
            }
        }
        return tokens;
    }
};

mini._createTextBindingCode = function (tokens) {
    var code = '';
    tokens.forEach(function (token) {
        if (typeof token == 'string') {
            var text = mini._replaceAll(token, '\n', '\\n');
            code += '"' + text + '"+';
        } else {
            code += '(' + token['@binding'] + ')+';
        }
    });
    code = code.substr(0, code.length - 1);
    return code;
};

mini._replaceAll = function (str, oldText, newText) {
    str.replace(new RegExp(oldText, 'gm'), newText);
    return str;
};

mini._parseTextNode = function (node, context) {
    var text = node.nodeValue.trim();
    if (text) {
        var tokens = mini._parseTextBinding(text);
        if (tokens) {
            var getter = mini._createGetter(mini._createTextBindingCode(tokens));
            function fn() {
                var val = getter.call(context);
                if (val == null) val = '';

                if (val != node.textContent) {
                    node.textContent = val;
                }
            }
            context._updateFns.push(fn);
        }
    } else {
        mini.removeNode(node);
    }
};

mini._handleEvent = function (node, name, value, context, cmp) {
    node.removeAttribute(name);

    name = name.substr(1);

    name = mini.camelCase(name).toLowerCase();

    var fn = context[value];
    if (!fn) {
        fn = mini._createGetter(value);
    }
    if (fn) {
        var me = context;
        function method(e) {
            if (me.isDisabled && me.isDisabled()) return false;
            if (me.disabled) return false;
            if (me.enabled === false) return false;
            if (me.requestUpdate) me.requestUpdate();
            return fn.call(context, e);
        }

        if (cmp) {
            cmp.on(name, method);
        } else {
            jQuery(node).bind(name, method);
        }
    }
};

mini._handleBind = function (node, name, value, context, cmp) {
    node.removeAttribute(name);
    name = name.substr(1);
    name = name.indexOf('v-') == 0 ? name : mini.camelCase(name);

    if (cmp) name = mini.__getClassPropName(cmp.constructor, name);

    var getter = mini._createGetter(value);
    function fn() {
        var val = getter.call(context);

        var props = {};
        props[name] = val;
        context.updateProps(cmp || node, props);
    }
    context._updateFns.push(fn);
};

mini._handleDirective = function (node, name, value, context, cmp) {
    node.removeAttribute(name);

    if (name == 'v-for') {
        throw new Error('v-for error');
    } else if (name == 'v-if') {
        throw new Error('v-if error');
    } else if (name.indexOf('v-model') != -1) {
        name = name.substr('v-model'.length);
        if (!name) name = ':value';

        name = mini.camelCase(name.substr(1));

        if (cmp) name = mini.__getClassPropName(cmp.constructor, name);

        mini._handleBind(node, ':' + name, value, context, cmp);

        var getName = 'get' + name[0].toUpperCase() + name.substr(1);
        var setter = mini._createGetter(value + '=e.sender.' + getName + '()');
        var method = function (e) {
            if (e.type == 'propertychange' && e.property != name) {
                return;
            }
            setter.call(context, e);
            if (context.requestUpdate) context.requestUpdate();
        };

        if (cmp) {
            cmp.on('propertychange', method);
            if (name == 'value' || name == 'checked') {
                cmp.on('change', method);
            }
        } else {
            $(node).on('propertychange', method);
        }
    } else {
        mini._handleBind(node, ':' + name, value, context, cmp);
    }
};

mini._createGetter = function (expr) {
    var code = 'with(this){\nreturn ' + expr + '\n}';
    return new Function('e', code);
};

mini._parseContext = function (node, context, cmp) {
    if (!context.refs) context.refs = {};
    if (!context._updateFns) context._updateFns = [];

    var ref = mini.getAttr(node, 'ref');
    if (ref) {
        context.refs[ref] = cmp || jQuery(node);
        jQuery(node).removeAttr('ref');
    }

    var attrs = [].concat.apply([], node.attributes);
    $.each(attrs, function (i, attr) {
        var name = attr.name,
            value = attr.value;
        var dir = mini._directives[name];
        if (dir || name.indexOf('v-model') != -1) {
            mini._handleDirective(node, name, value, context, cmp);
        } else if (name[0] == ':') {
            mini._handleBind(node, name, value, context, cmp);
        } else if (name[0] == '@') {
            mini._handleEvent(node, name, value, context, cmp);
        }
    });
};

mini.__getElementContext = function (el) {
    while (el) {
        if (el.context) return el.context;
        el = el.parentElement;
    }
};

mini.applyTo = function (el, context) {
    el = mini.byId(el);
    if (!el) return this;
    if (mini.get(el)) throw new Error('not applyTo a mini control');

    el.context = context;

    var config = this.getAttrs(el);
    delete config._applyTo;

    delete el.context;

    if (mini.isNull(config.defaultValue) && !mini.isNull(config.value)) {
        config.defaultValue = config.value;
    }
    if (mini.isNull(config.defaultText) && !mini.isNull(config.text)) {
        config.defaultText = config.text;
    }

    var p = el.parentNode;
    if (p && this.el != el) {
        p.replaceChild(this.el, el);
    }

    if (context) {
        mini._parseContext(el, context, this);
    }

    this.context = context;
    this.set(config);

    this._afterApply(el);

    return this;
};

mini._parseComponent = function (el, cls, context) {
    var clazz = mini.getClassByUICls(cls);
    if (clazz) {
        mini.removeClass(el, cls);
        var ui = new clazz();
        mini.applyTo.call(ui, el, context);
        return ui;
    }
};

mini._parseElement = function (el, context) {
    if (!el) return;
    var nodeName = el.nodeName.toLowerCase();

    if (!nodeName) return;

    var ui = mini._parseComponent(el, nodeName, context);
    if (ui) {
        el = ui.el;
    } else {
        var className = el.className;

        if (className && className.split) {
            var control = mini.get(el);
            if (!control) {
                var classes = jQuery.trim(className).split(' ');
                for (var i = 0, l = classes.length; i < l; i++) {
                    var cls = classes[i];

                    var ui = mini._parseComponent(el, cls, context);
                    if (ui) {
                        el = ui.el;
                        break;
                    }
                }
            }
        }
    }

    if (
        nodeName == 'select' ||
        mini.hasClass(el, 'mini-menu') ||
        mini.hasClass(el, 'mini-datagrid') ||
        mini.hasClass(el, 'mini-treegrid') ||
        mini.hasClass(el, 'mini-tree') ||
        mini.hasClass(el, 'mini-button') ||
        mini.hasClass(el, 'mini-textbox') ||
        mini.hasClass(el, 'mini-buttonedit')
    ) {
        return;
    }

    if (context) mini._parseContext(el, context);

    mini._parseChildren(el.childNodes, context);
};

mini._parseChildren = function (children, context) {
    children = [].concat.apply([], children);
    for (var i = 0, l = children.length; i < l; i++) {
        var node = children[i];
        if (node.nodeType == 1) {
            mini._parseElement(node, context);
        } else if (node.nodeType == 3) {
            if (context) mini._parseTextNode(node, context);
        }
    }
};

mini._Removes = [];
mini._firstParse = true;
mini.parse = function (el, layout, context) {
    if (mini._firstParse) {
        mini._firstParse = false;

        var doms = document.getElementsByTagName('iframe');
        for (var i = 0, l = doms.length; i < l; i++) {
            var d = doms[i];

            var src = jQuery(d).attr('src');

            if (src == '' || src == 'about:blank') continue;

            d._onload = d.onload;
            d._src = src;
            d.onload = function () {};
            d.src = '';
        }
        setTimeout(function () {
            for (var i = 0, l = doms.length; i < l; i++) {
                var d = doms[i];
                if (d._src) {
                    d.onload = d._onload;
                    d.src = d._src;
                    d._src = null;
                }
            }
        }, 10);
    }

    if (typeof el == 'string') {
        var id = el;
        el = mini.byId(id);
        if (!el) el = document.body;
    }
    if (el && !mini.isElement(el)) el = el.el;
    if (!el) el = document.body;

    var visible = mini.WindowVisible;
    if (isIE) {
        mini.WindowVisible = false;
    }

    mini._parseElement(el, context);

    mini.WindowVisible = visible;

    mini.layout(el);
};
mini._ParseString = function (el, config, attrs) {
    for (var i = 0, l = attrs.length; i < l; i++) {
        var property = attrs[i];

        var value = mini.getAttr(el, property);
        if (value) {
            config[property] = value;
        }
    }
};
mini._ParseBool = function (el, config, attrs) {
    for (var i = 0, l = attrs.length; i < l; i++) {
        var property = attrs[i];
        var value = mini.getAttr(el, property);
        if (value) {
            config[property] = value == 'true' ? true : false;
        }
    }
};
mini._ParseInt = function (el, config, attrs) {
    for (var i = 0, l = attrs.length; i < l; i++) {
        var property = attrs[i];
        var value = parseInt(mini.getAttr(el, property));
        if (!isNaN(value)) {
            config[property] = value;
        }
    }
};

mini._parseConfigByNode = function (el) {
    var config;
    var clazz = mini.getClassByUICls(el.nodeName);
    if (clazz) config = clazz.parseConfig(el);
    else {
        var classes = el.className.split(' ');
        for (var i3 = 0, l3 = classes.length; i3 < l3; i3++) {
            var cls = classes[i3];
            var clazz = mini.getClassByUICls(cls);
            if (clazz) {
                config = clazz.parseConfig(el);
                break;
            }
        }
    }
    return config;
};

mini._ParseColumns = function (el) {
    var columns = [];
    var cs = mini.getChildNodes(el);
    for (var i = 0, l = cs.length; i < l; i++) {
        var node = cs[i];

        var column = {};

        var editor = null,
            filter = null;

        var subCs = mini.getChildNodes(node);
        if (subCs) {
            for (var ii = 0, li = subCs.length; ii < li; ii++) {
                var subNode = subCs[ii];

                var property = mini.getAttr(subNode, 'property') || '';
                property = property.toLowerCase();
                var tag = subNode.nodeName.toLowerCase();

                var remove = false;
                if (property == 'columns' || tag == 'columns') {
                    column.columns = mini._ParseColumns(subNode);
                    remove = true;
                }

                if (tag == 'editor' && subNode.children[0]) {
                    editor = mini._parseConfigByNode(subNode.children[0]);

                    remove = true;
                }

                if (tag == 'filter' && subNode.children[0]) {
                    filter = mini._parseConfigByNode(subNode.children[0]);
                    remove = true;
                }

                if (property == 'editor') {
                    editor = mini._parseConfigByNode(subNode);
                    remove = true;
                }

                if (property == 'filter') {
                    filter = mini._parseConfigByNode(subNode);
                    remove = true;
                }

                if (remove) mini.removeNode(subNode);
            }
        }

        column.header = node.innerHTML;

        mini._ParseString(node, column, [
            'name',
            'header',
            'field',
            'editor',
            'filter',
            'renderer',
            'width',
            'type',
            'renderer',
            'headerAlign',
            'align',
            'headerCls',
            'cellCls',
            'headerStyle',
            'cellStyle',
            'displayField',
            'dateFormat',
            'listFormat',
            'mapFormat',
            'numberFormat',
            'trueValue',
            'falseValue',
            'dataType',
            'vtype',
            'currencyUnit',
            'summaryType',
            'summaryRenderer',
            'groupSummaryType',
            'groupSummaryRenderer',
            'defaultValue',
            'defaultText',
            'decimalPlaces',
            'data-options',
            'sortField',
            'sortType'
        ]);
        mini._ParseBool(node, column, [
            'allowCellWrap',
            'visible',
            'readOnly',
            'allowSort',
            'allowResize',
            'allowMove',
            'allowDrag',
            'autoShowPopup',
            'unique',
            'autoEscape',
            'enabled',
            'hideable',
            'showCellTip',
            'valueFromSelect',
            'navUpdown'
        ]);
        mini._ParseInt(node, column, ['minWidth']);

        if (editor) column.editor = editor;
        if (filter) column.filter = filter;

        if (typeof column.editor == 'string') {
            try {
                column.editor = window['ev' + 'al']('(' + column.editor + ')');
            } catch (e) {}
        }

        if (column.dataType) column.dataType = column.dataType.toLowerCase();

        if (column.defaultValue === 'true') column.defaultValue = true;
        if (column.defaultValue === 'false') column.defaultValue = false;

        columns.push(column);

        var options = column['data-options'];
        if (options) {
            options = window['ev' + 'al']('(' + options + ')');
            if (options) {
                mini.copyTo(column, options);
            }
        }
    }

    return columns;
};

mini.JSON = new (function () {
    var sb = [];
    var _dateFormat = null;
    var useHasOwn = !!{}.hasOwnProperty,
        replaceString = function (a, b) {
            var c = m[b];
            if (c) {
                return c;
            }
            c = b.charCodeAt();
            return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
        },
        doEncode = function (o, field) {
            if (o === null) {
                sb[sb.length] = 'null';
                return;
            }
            var t = typeof o;
            if (t == 'undefined') {
                sb[sb.length] = 'null';
                return;
            } else if (o.push) {
                sb[sb.length] = '[';
                var b,
                    i,
                    l = o.length,
                    v;
                for (i = 0; i < l; i += 1) {
                    v = o[i];
                    t = typeof v;
                    if (t == 'undefined' || t == 'function' || t == 'unknown') {
                    } else {
                        if (b) {
                            sb[sb.length] = ',';
                        }
                        doEncode(v);

                        b = true;
                    }
                }
                sb[sb.length] = ']';
                return;
            } else if (o.getFullYear) {
                if (_dateFormat) {
                    sb[sb.length] = _dateFormat(o, field);
                } else {
                    var n;
                    sb[sb.length] = '"';
                    sb[sb.length] = o?.getFullYear();
                    sb[sb.length] = '-';
                    n = o?.getMonth() + 1;
                    sb[sb.length] = n < 10 ? '0' + n : n;
                    sb[sb.length] = '-';
                    n = o?.getDate();
                    sb[sb.length] = n < 10 ? '0' + n : n;
                    sb[sb.length] = 'T';
                    n = o?.getHours();
                    sb[sb.length] = n < 10 ? '0' + n : n;
                    sb[sb.length] = ':';
                    n = o?.getMinutes();
                    sb[sb.length] = n < 10 ? '0' + n : n;
                    sb[sb.length] = ':';
                    n = o?.getSeconds();
                    sb[sb.length] = n < 10 ? '0' + n : n;
                    sb[sb.length] = '"';
                    return;
                }
            } else if (t == 'string') {
                if (strReg1.test(o)) {
                    sb[sb.length] = '"';

                    sb[sb.length] = o.replace(strReg2, replaceString);
                    sb[sb.length] = '"';
                    return;
                }
                sb[sb.length] = '"' + o + '"';
                return;
            } else if (t == 'number') {
                sb[sb.length] = o;
                return;
            } else if (t == 'boolean') {
                sb[sb.length] = String(o);
                return;
            } else {
                sb[sb.length] = '{';
                var b, i, v;
                for (i in o) {
                    if (!useHasOwn || Object.prototype.hasOwnProperty.call(o, i)) {
                        v = o[i];
                        t = typeof v;
                        if (t == 'undefined' || t == 'function' || t == 'unknown') {
                        } else {
                            if (b) {
                                sb[sb.length] = ',';
                            }
                            doEncode(i);
                            sb[sb.length] = ':';
                            doEncode(v, i);

                            b = true;
                        }
                    }
                }
                sb[sb.length] = '}';
                return;
            }
        },
        m = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        },
        strReg1 = /["\\\x00-\x1f]/,
        strReg2 = /([\x00-\x1f\\"])/g;

    this.encode = (function () {
        var ec;
        return function (o, dateFormat) {
            sb = [];

            _dateFormat = dateFormat;
            doEncode(o);

            _dateFormat = null;

            return sb.join('');
        };
    })();
    this.decode = (function () {
        var dateRe1 = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2}(?:\.*\d*)?)Z*$/;

        var dateRe2 = new RegExp('^/+Date\\((-?[0-9]+).*\\)/+$', 'g');

        var re = /[\"\'](\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})[\"\']/g;
        return function (json, parseDate) {
            if (json === '' || json === null || json === undefined) return json;

            if (typeof json == 'object') {
                json = this.encode(json);
            }

            function evalParse(json) {
                if (parseDate !== false) {
                    json = json.replace(__js_dateRegEx, '$1new Date($2)');
                    json = json.replace(re, 'new Date($1,$2-1,$3,$4,$5,$6)');
                    json = json.replace(__js_dateRegEx2, 'new Date($1)');
                }
                return eval('(' + json + ')');
            }

            var data = null;

            if (window.JSON && window.JSON.parse) {
                var dateReviver = function (key, value) {
                    if (typeof value === 'string' && parseDate !== false) {
                        dateRe1.lastIndex = 0;
                        var a = dateRe1.exec(value);
                        if (a) {
                            value = new Date(a[1], a[2] - 1, a[3], a[4], a[5], a[6]);

                            return value;
                        }

                        dateRe2.lastIndex = 0;
                        var a = dateRe2.exec(value);
                        if (a) {
                            value = new Date(parseInt(a[1]));

                            return value;
                        }
                    }
                    return value;
                };

                try {
                    var json2 = json.replace(__js_dateRegEx, '$1"/Date($2)/"');
                    data = window.JSON.parse(json2, dateReviver);
                } catch (ex) {
                    data = evalParse(json);
                }
            } else {
                data = evalParse(json);
            }
            return data;
        };
    })();
})();
__js_dateRegEx = new RegExp('(^|[^\\\\])\\"\\\\/Date\\((-?[0-9]+)(?:[a-zA-Z]|(?:\\+|-)[0-9]{4})?\\)\\\\/\\"', 'g');
__js_dateRegEx2 = new RegExp('["\']/Date\\(([0-9]+)\\)/["\']', 'g');
mini.encode = mini.JSON.encode;
mini.decode = mini.JSON.decode;

mini.clone = function (o, _clear) {
    if (o === null || o === undefined) return o;
    var json = mini.encode(o);
    var obj = mini.decode(json);

    function clearProp(arr) {
        for (var i = 0, l = arr.length; i < l; i++) {
            var o = arr[i];
            delete o._state;
            delete o._id;
            delete o._pid;
            delete o._uid;
            for (var p in o) {
                var v = o[p];
                if (v instanceof Array) clearProp(v);
            }
        }
    }
    if (_clear !== false) {
        clearProp(obj instanceof Array ? obj : [obj]);
    }

    return obj;
};

if (typeof window.rootpath == 'undefined') {
    rootpath = '/';
}

mini.loadJS = function (src, callback) {
    if (!src) return;
    if (typeof callback == 'function') {
        return loadJS._async(src, callback);
    } else {
        return loadJS._sync(src);
    }
};
mini.loadJS._js = {};
mini.loadJS._async = function (src, callback) {
    var state = mini.loadJS._js[src];
    if (!state) {
        state = mini.loadJS._js[src] = { create: false, loaded: false, callbacks: [] };
    }
    if (state.loaded) {
        setTimeout(function () {
            callback();
        }, 1);
        return;
    } else {
        state.callbacks.push(callback);
        if (state.create) return;
    }

    state.create = true;

    var head = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.src = src;
    js.type = 'text/javascript';

    function doCallback() {
        for (var i = 0; i < state.callbacks.length; i++) {
            var fn = state.callbacks[i];
            if (fn) fn();
        }
        state.callbacks.length = 0;
    }

    setTimeout(function () {
        if (document.all) {
            js.onreadystatechange = function () {
                if (js.readyState == 'loaded' || js.readyState == 'complete') {
                    doCallback();
                    state.loaded = true;
                }
            };
        } else {
            js.onload = function () {
                doCallback();
                state.loaded = true;
            };
        }
        head.appendChild(js);
    }, 1);
    return js;
};
mini.loadJS._sync = function (src) {
    if (loadJS._js[src]) return;
    loadJS._js[src] = { create: true, loaded: true, callbacks: [] };

    var head = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.type = 'text/javascript';
    js.text = loadText(src);
    head.appendChild(js);
    return js;
};

mini.loadText = function (url) {
    var text = '';
    var isLocal = document.all && location.protocol == 'file:';

    var xmlhttp = null;
    if (isLocal) {
        xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
    } else {
        if (window.XMLHttpRequest) {
            xmlhttp = new XMLHttpRequest();
        } else if (window.ActiveXObject) {
            xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
        }
    }

    xmlhttp.onreadystatechange = state_Change;

    var d = '_t=' + new Date()?.getTime();
    if (url.indexOf('?') == -1) d = '?' + d;
    else d = '&' + d;
    url += d;

    xmlhttp.open('GET', url, false);
    xmlhttp.send(null);

    function state_Change() {
        if (xmlhttp.readyState == 4) {
            var statusCode = isLocal ? 0 : 200;
            if (xmlhttp.status == statusCode) {
                text = xmlhttp.responseText;
            } else {
            }
        }
    }
    return text;
};

mini.loadJSON = function (url) {
    var text = loadText(url);
    var o = eval('(' + text + ')');
    return o;
};

mini.loadCSS = function (src, id) {
    if (!src) return;
    if (loadCSS._css[src]) return;
    var head = document.getElementsByTagName('head')[0];
    var link = document.createElement('link');
    if (id) link.id = id;
    link.href = src;
    link.rel = 'stylesheet';
    link.type = 'text/css';
    head.appendChild(link);
    return link;
};
mini.loadCSS._css = {};

mini.innerHTML = function (el, html) {
    if (typeof el == 'string') el = document.getElementById(el);
    if (!el) return;
    html = '<div style="display:none">&nbsp;</div>' + html;
    el.innerHTML = html;
    mini.__executeScripts(el);
    var d = el.firstChild;
};
mini.__executeScripts = function (d) {
    var scripts = d.getElementsByTagName('script');
    for (var i = 0, l = scripts.length; i < l; i++) {
        var sc = scripts[i];
        var src = sc.src;
        if (src) {
            mini.loadJS(src);
        } else {
            var ns = document.createElement('script');
            ns.type = 'text/javascript';
            ns.text = sc.text;
            d.appendChild(ns);
        }
    }
    for (var i = scripts.length - 1; i >= 0; i--) {
        var sc = scripts[i];
        sc.parentNode.removeChild(sc);
    }
};
mini.Group = {
    groupByFn: function (data, fn) {
        return this.groupByFields(data, [{ convert: fn }]);
    },

    groupByFields: function (data, fields) {
        var me = this,
            groups = [],
            pathHash = {},
            nameHash = null;

        var sortFields = [];
        for (var i = 0, l = fields.length; i < l; i++) {
            var field = fields[i];
            if (field.direction) {
                var sortField = { property: field.property, direction: field.direction };
                sortFields.push(sortField);
            }
        }
        var sortFn;
        if (sortFields.length > 0) {
            sortFn = mini._createSortFn(sortFields);
            mini.sort(data, sortFn);
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var record = data[i],
                parentGroups = groups,
                path = '';

            for (var j = 0, k = fields.length; j < k; j++) {
                var field = fields[j],
                    name = me._groupNameFromRecord(record, field),
                    isBottomLevel = j == k - 1;

                var value = name;
                if (name instanceof Date) name = name?.getTime();

                nameHash = pathHash[path];

                if (!nameHash) {
                    nameHash = {};
                    pathHash[path] = nameHash;
                }

                var group = me._getGroup(field, parentGroups, nameHash, name, value, j, isBottomLevel);

                path += '/' + name;
                group.path = path;

                group.items.push(record);

                parentGroups = group.groups;
            }
        }

        return groups;
    },

    findGroupByPath: function (groups, path) {
        for (var i = 0, l = groups.length; i < l; i++) {
            var group = groups[i];
            if (group.path == path) return group;
            if (group.groups) {
                var child = this.findGroupByPath(group.groups, path);
                if (child) return child;
            }
        }
    },

    dataFromGroups: function (groups, hasGroupItem, hasCollapsedItem) {
        var items = [];
        function each(groups) {
            for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                if (hasGroupItem !== false) {
                    items.push(group);
                }

                if (group.expanded === false && !hasCollapsedItem) {
                    continue;
                }

                if (group.isBottomLevel) {
                    items = items.concat(group.items);
                } else {
                    each(group.groups);
                }
            }
        }
        each(groups);
        return items;
    },

    idSeed: 1,

    createGroupId: function () {
        return 'group_' + mini.Group.idSeed++;
    },

    createGroup: function (config) {
        var item = {
            _group: true,
            _id: this.createGroupId(),
            expanded: true,
            items: [],
            groups: [],
            isBottomLevel: false
        };
        $.extend(item, config);

        if (item.field.height) item.__height = item.field.height;

        return item;
    },

    _getGroup: function (field, groups, nameHash, name, value, level, isBottomLevel) {
        var group;

        if (nameHash) {
            group = nameHash[name];
            if (group) return group;
        } else {
            for (var i = 0, l = groups.length; i < l; i++) {
                var groupItem = groups[i];
                if (this._groupNamesMatch(groupItem.name, name)) return groupItem;
            }
        }

        group = this.createGroup({
            field: field,
            name: name,
            value: value,
            level: level,
            isBottomLevel: isBottomLevel
        });
        groups.push(group);
        if (nameHash) nameHash[name] = group;

        return group;
    },

    _groupNameFromRecord: function (record, field) {
        if (field.convert) return field.convert.call(field, record);
        var value = record[field.property];
        return value;
    },

    _groupNamesMatch: function (a, b) {
        if (a instanceof Date) a = a?.getTime();
        if (b instanceof Date) b = b?.getTime();
        return a === b;
    }
};

mini.Group.colors = ['#FFF6C1', '#D2EEFF', '#D3F5CC', '#E1E3FA'];

mini.Group.getColor = function (level) {
    var num = level % 4;
    return mini.Group.colors[num];
};

mini._createSortFn = function (sorters) {
    var out = 0;

    var comparer = function (first, second) {
        var s1, s2;
        for (var i = 0, l = sorters.length; i < l; i++) {
            var sorter = sorters[i],
                v1 = first[sorter.property],
                v2 = second[sorter.property];

            if (v1 instanceof Date) v1 = v1?.getTime();
            if (v2 instanceof Date) v2 = v2?.getTime();

            if (v1 !== v1) v1 = null;
            if (v2 !== v2) v2 = null;
            if (typeof v1 == 'string' && typeof v2 == 'string') {
                s1 = v1.toLowerCase();
                s2 = v2.toLowerCase();
                if (s1 != s2) {
                    v1 = s1;
                    v2 = s2;
                }
            }

            if (v1 === v2) return 0;

            if (v1 != null && v2 == null) return -1;

            if (v1 == null && v2 != null) return 1;

            out = v1 < v2 ? -1 : v1 > v2 ? 1 : 0;

            if (out != 0) return sorter.direction == 'asc' ? +out : -out;
        }
        return 0;
    };

    return comparer;
};
mini.updateStack = [];

mini.requestUpdate = function (item) {
    if (!item) return;

    if (mini.updateStack.indexOf(item) == -1) {
        mini.updateStack.push(item);
    }
    if (mini._updateTimeout) {
        mini.clearTimeout(mini._updateTimeout);
    }
    mini._updateTimeout = mini.defer(mini.flushUpdate);
};

mini.unqueueUpdate = function (item) {
    var index = mini.updateStack.indexOf(item);
    if (index != -1) mini.updateStack.removeAt(index);
};

mini.flushUpdate = function () {
    var items = mini.updateStack.clone();
    items.sort(function (a, b) {
        return mini.getDomLevel(a.el) - mini.getDomLevel(b.el);
    });

    items.forEach(function (item) {
        if (mini.updateStack.indexOf(item) != -1) {
            item.render();
        } else {
        }
    });
};

mini.getDomLevel = function (el) {
    var level = 0;
    while (el) {
        level++;
        el = el.parentElement;
    }
    return level;
};

mini.hookComponent = null;
mini.hookIndex = null;
mini.hooksMap = {};

mini.getHook = function () {
    var hooks = mini.hooksMap[mini.hookComponent.id];
    if (!hooks) {
        hooks = [];
        mini.hooksMap[mini.hookComponent.id] = hooks;
    }
    var hook = hooks[mini.hookIndex];
    if (!hook) {
        hook = hooks[mini.hookIndex] = {};
    }
    mini.hookIndex++;
    return hook;
};

mini.updateByHook = function (el, props) {
    if (!el) throw new Error('sync el is null');
    props = props || {};

    var hook = mini.getHook();
    var oldProps = hook.props || {};

    var isDOM = el instanceof Element || el instanceof jQuery;

    props = mini.apply({}, props);
    props = mini.applyIf(props, oldProps);

    var cmp = isDOM ? null : el;
    if (cmp) el = cmp.el;

    for (var key in props) {
        var value = props[key];
        var oldValue = oldProps[key];

        var hasSet = key in oldProps;
        var equal = mini.isEquals(value, oldValue);

        if (hasSet && equal) {
            var getName = 'get' + key[0].toUpperCase() + key.substr(1);
            if (cmp[getName]) {
                var cmpValue = cmp[getName]();
                if (!mini.isEquals(value, cmpValue)) {
                    equal = false;
                    console.warn('Component(' + cmp.id + ")'s property(" + key + ') is bind, value: ', cmpValue);
                }
            }
        }

        if (!hasSet || !equal) {
            var param = { el: el, name: key, value: value, oldValue: oldValue };
            var dir = mini._directives[key] || mini._directives.bind;

            if (cmp) {
                if (key == 'v-show') {
                    param.el = cmp.el;
                    dir(param);
                } else {
                    if (key == 'class' || key == 'style') {
                        param.el = cmp.el;
                        dir(param);
                    } else {
                        cmp.set(key, value);
                    }
                }
            } else {
                dir(param);
            }
        }
    }

    hook.props = props;
};

mini._directives = {
    'v-bind': function (options) {
        var el = options.el,
            name = options.name,
            value = options.value,
            oldValue = options.oldValue;

        el = $(el)[0];
        if (name == 'class') {
            mini._updateClass(el, value, oldValue);
        } else if (name == 'style') {
            mini._updateStyle(el, value, oldValue);
        } else {
            if (isSvgElement(el.tagName)) {
                if (el.tagName == 'svg') {
                    if (name == 'view-box') name = 'viewBox';
                }
                el.setAttribute(name, value);
            } else {
                el[name] = value;
            }
        }
    },
    'v-show': function (options) {
        var el = options.el,
            value = options.value;
        mini._showIf(el, value);
    },
    'v-html': function (options) {
        var el = options.el,
            value = options.value;
        el = $(el)[0];
        while (el.firstChild) {
            mini.removeNode(el.firstChild);
        }
        if (value == null) value = '';
        var child = value && !mini.isString(value) ? value : $(value)[0];

        $(el).append(child);
    }
};

mini._getClassMap = function (cls) {
    var map = {};
    var type = typeof cls;
    if (type == 'string') {
        var arr = cls.split(' ');

        for (var i = 0, l = arr.length; i < l; i++) {
            var s = arr[i];
            map[s] = true;
        }
    } else if (type instanceof Array) {
        for (var i = 0, l = cls.length; i < l; i++) {
            var item = cls[i];
            map[item] = true;
        }
    } else {
        $.extend(map, cls);
    }
    return map;
};

mini._updateClass = function (el, cls, oldCls) {
    var newMap = mini._getClassMap(cls),
        oldMap = mini._getClassMap(oldCls);

    for (var key in oldMap) {
        if (!(key in newMap)) {
            mini.removeClass(el, key);
        }
    }

    for (var key in newMap) {
        var value = newMap[key];
        if (key in oldMap) {
            if (value !== oldMap[key]) {
                mini.toggleClass(el, key, value);
            }
        } else {
            if (value) {
                mini.addClass(el, key);
            }
        }
    }
};

mini._updateStyle = function (el, style, oldStyle) {
    if (typeof style == 'string') {
        el.style.cssText = style;
    } else {
        if (!oldStyle) oldStyle = {};

        for (var key in oldStyle) {
            if (!(key in style)) {
                el.style[key] = '';
            }
        }
        for (var key in style) {
            var value = style[key];
            if (oldStyle[key] !== value) {
                el.style[key] = value;
            }
        }
    }
};

mini._showIf = function (el, value) {
    mini.toggleClass(el, 'mini-hidden', !value);
};

mini.svgElements = 'svg,path,g,defs,linearGradient,stop'.split(',');
mini.isSvgElement = function (tag) {
    return mini.svgElements.indexOf(tag) != -1;
};

function mini_extend(newClass, sp, overrides) {
    if (typeof sp != 'function') {
        overrides = sp;
        sp = newClass;

        if (overrides.constructor === Object.prototype.constructor) overrides.constructor = null;

        newClass = overrides.constructor =
            overrides.constructor ||
            function () {
                sp.apply(this, arguments);
            };

        return mini_extend(newClass, sp, overrides);
    }

    var sb = newClass,
        sbp = sb.prototype,
        spp = sp.prototype;
    if (sb.superclass == spp) return;

    if (!overrides) overrides = {};

    overrides.uiCls = overrides.uiCls || overrides.tag || '';
    if (!overrides.type) overrides.type = '';

    var F = function () {};
    F.prototype = sp.prototype;
    sbp = sb.prototype = new F();

    sb.fn = sbp;
    sb.fn.constructor = sb;
    sb.base = sp;

    sb.baseFn = spp;
    sb.superclass = spp;
    sb.superclass.constructor = sp;

    var props = overrides.props;
    if (props) {
        for (var name in props) {
            sbp[name] = props[name];
            __makeProperty(sbp, name);
        }
    }

    if (overrides) {
        for (var p in overrides) {
            sbp[p] = overrides[p];
        }
    }

    sb.extend = sp.extend;
    if (!sb.extend) {
        sb.extend = function (proto) {
            var sub = mini_extend(this, proto);
            return sub;
        };
    }

    sb.parseConfig = sp.parseConfig;
    if (!sb.parseConfig && mini['Control']) sb.parseConfig = mini['Control'].parseConfig;

    var tag = sbp.uiCls;
    if (tag) {
        if (tag.indexOf('-') != -1) {
            document.createElement(tag);
        }
    }

    mini.regClass(sb, overrides.type);

    return sb;
}

mini.extend = mini_extend;

mini.Base = function () {
    var set = this.set;
    this.set = function (key, value) {
        var options = key;
        if (typeof key == 'string') {
            options = {};
            options[key] = value;
        }
        return set.call(this, options);
    };
};
mini.Base.prototype = {
    props: {},

    set: function (options) {
        for (var name in options) {
            var value = options[name];

            var setName = 'set' + name.charAt(0).toUpperCase() + name.substr(1);
            var setter = this[setName];
            if (setter) {
                setter.call(this, value);
            } else {
                this[name] = value;
            }
        }

        return this;
    }
};
mini.Base.extend = function (proto) {
    var sub = mini_extend(this, proto);
    return sub;
};

function __makeProperty(fn, name) {
    var upperName = name[0].toUpperCase() + name.substr(1),
        getName = 'get' + upperName,
        setName = 'set' + upperName,
        updateName = 'update' + upperName;

    if (!fn[getName]) {
        fn[getName] = function () {
            return this[name];
        };
    }

    if (!fn[setName]) {
        fn[setName] = function (value) {
            var oldValue = this[name];
            this[name] = value;
            var updater = this[updateName];
            if (updater) {
                updater.call(this, value, oldValue);
            }
            if (this.events && this.events.propertychange) {
                this.fireEvent('propertychange', { property: name, value: value, oldValue: oldValue });
            }
            if (this.requestUpdate) this.requestUpdate();
            if (this.invalidateLayout) this.invalidateLayout();
        };
    }
}

function __findParentHas(parent, name, fn) {
    var next = false;
    while (parent) {
        if (next == false) {
            if (parent.fn[name] == fn) {
                next = true;
            }
        } else {
            if (parent.fn[name] != fn) {
                break;
            }
        }
        parent = parent.base;
    }
    return parent;
}

mini.Base.prototype.callParent = function (name) {
    var fn = arguments.callee.caller;

    var parent = __findParentHas(this.constructor, name, fn);
    if (!parent) return;

    var args = jQuery.makeArray(arguments);
    args.shift();
    var ret = parent.fn[name].apply(this, args);
    return ret;
};

mini.Observable = mini.Base.extend({
    _canFire: true,

    constructor: function (config) {
        mini.Base.call(this);
        this.events = {};

        this.applyConfig(config);
    },

    applyConfig: function (config) {
        config = config || {};
        for (var name in config) {
            var value = config[name];
            if (name.indexOf('on') == 0) {
                this.on(name.substr(2), value);
            } else {
                this[name] = value;
            }
        }
    },

    set: function (options) {
        if (typeof options == 'string' || !options) return this;

        options = jQuery.extend({}, options);

        for (var name in options) {
            if (name.toLowerCase().indexOf('on') == 0) {
                var fn = options[name];
                this.on(name.substr(2).toLowerCase(), fn);
                delete options[name];
            }
        }

        mini.Base.prototype.set.call(this, options);

        return this;
    },

    fireEvent: function (type, data) {
        return this.fire(type, data);
    },

    fire: function (type, data) {
        if (this._canFire == false) return;
        type = type.toLowerCase();
        var result;
        var handlers = this.events[type];
        if (handlers) {
            if (!data) data = {};
            data.source = data.sender = this;
            if (!data.type) {
                data.type = type;
            }
            for (var i = 0, l = handlers.length; i < l; i++) {
                var handler = handlers[i];
                if (handler) {
                    if (handler[0].apply(handler[1] || this, [data]) === false || data.cancel) {
                        result = false;

                        data.cancel = true;
                    }
                }
            }
        }
        return result;
    },

    on: function (type, fn, scope) {
        if (typeof fn == 'string') {
            var f = mini._getFunctoin(fn);
            if (!f) {
                var id = mini.newId('__str_');
                window[id] = fn;

                fn = new Function(
                    'e',
                    'var s = ' + id + ';var fn = mini._getFunctoin(s); if(fn) {fn.call(this, e)}else{eval(s);}'
                );
            } else {
                fn = f;
            }
        }

        if (typeof fn != 'function' || !type) return false;
        type = type.toLowerCase();
        var event = this.events[type];
        if (!event) {
            event = this.events[type] = [];
        }
        scope = scope || this;
        if (!this.findListener(type, fn, scope)) {
            event.push([fn, scope]);
        }
        return this;
    },

    off: function (type, fn, scope) {
        return this.un(type, fn, scope);
    },

    un: function (type, fn, scope) {
        if (typeof fn != 'function') return false;
        type = type.toLowerCase();
        var listeners = this.events[type];
        if (listeners) {
            scope = scope || this;
            var listener = this.findListener(type, fn, scope);
            if (listener) {
                mini.Array.remove(listeners, listener);
            }
        }
        return this;
    },

    hasListener: function (type) {
        return !!this.events[type];
    },

    findListener: function (type, fn, scope) {
        type = type.toLowerCase();
        scope = scope || this;
        var handlers = this.events[type];
        if (handlers) {
            for (var i = 0, l = handlers.length; i < l; i++) {
                var listener = handlers[i];
                if (listener[0] === fn && listener[1] === scope) return listener;
            }
        }
    }
});

mini.getClassProps = function (ctor) {
    if (!ctor._props) {
        var props = {};
        var parent = ctor;
        while (parent) {
            if (parent.fn) mini.applyIf(props, parent.fn.props);
            parent = parent.base;
        }
        ctor._props = props;
    }
    return ctor._props;
};

mini.getInstanceProps = function (instance) {
    var clsProps = mini.getClassProps(instance.constructor);
    var props = {};
    for (var name in clsProps) {
        var value = instance[name];
        if (value !== null && value !== undefined && value !== '') {
            props[name] = value;
        }
    }
    return props;
};

mini.Component = mini.Observable.extend({
    props: {
        id: null
    },

    idPrefix: 'mini-',
    destroyed: false,

    constructor: function (config) {
        mini.Observable.call(this, config);
        var props = mini.getInstanceProps(this);

        this.initComponent();

        this.set(props);
    },

    initComponent: function () {
        this.uid = mini.newId(this.idPrefix);
        this._id = this.uid;
        if (!this.id) {
            this.id = this.uid;
        }
        mini.reg(this);

        var destroy = this.destroy;
        this.destroy = function () {
            if (!this.destroyed) {
                destroy.call(this);
            }
        };
    },

    setId: function (id) {
        mini['unreg'](this);
        this.id = id;
        if (this.el) this.el.id = id;
        if (this._textEl) this._textEl.id = id + '$text';
        if (this._valueEl) this._valueEl.id = id + '$value';

        mini.reg(this);
    },

    destroy: function () {
        if (!this.destroyed) {
            delete mini.hooksMap[this.id];
            mini['unreg'](this);
            this.fire('destroy');
            this.destroyed = true;
        }
    }
});

mini.Control = mini.Component.extend({
    isControl: true,
    jsName: null,

    props: {
        width: '',
        height: '',

        visible: true,
        readOnly: false,
        enabled: true,

        tooltip: '',
        renderTo: null,

        name: '',
        allowAnim: true,
        defaultValue: null,
        value: null,
        dataField: ''
    },

    template: '',

    readOnlyCls: 'mini-readonly',
    disabledCls: 'mini-disabled',

    set: function (options) {
        this.callParent('set', options);
        this.invalidateLayout();
        this.requestUpdate();
        return this;
    },

    initComponent: function () {
        mini.Component.fn.initComponent.call(this);
        this.refs = {};
        this.initElement();
        this.el.uid = this.uid;
        this._initEvents();
        if (this.uiCls) this.addCls(this.uiCls);

        var doLayout = this.doLayout;
        this.doLayout = function () {
            if (!this.el) return;

            if (this._refreshTimeout) {
                this.refresh();
            }

            if (this._layoutTimeout) {
                mini.clearTimeout(this._layoutTimeout);
                this._layoutTimeout = null;
            }

            doLayout.call(this);
            mini.layoutChildren(this.el.children);
        };

        var refresh = this.refresh;
        this.refresh = function () {
            if (!this.el) return;

            if (this._refreshTimeout) {
                mini.clearTimeout(this._refreshTimeout);
                this._refreshTimeout = null;
            }

            refresh.call(this);
            this.invalidateLayout();

            this.fireEvent('refresh');
        };

        if (this.update) throw new Error('update method error');

        this.__render__ = this.render;
        this.render = this.__render;
    },

    __render: function (container, position) {
        mini.unqueueUpdate(this);
        if (!this.el) return;

        if (container) this.doRenderParent(container, position);

        if (this._updateTimeout) {
            mini.clearTimeout(this._updateTimeout);
            this._updateTimeout = null;
        }

        var hook = { cmp: mini.hookComponent, index: mini.hookIndex };
        mini.hookComponent = this;
        mini.hookIndex = 0;

        this._renderBinds();
        this.__render__.call(this);

        mini.hookComponent = hook.cmp;
        mini.hookIndex = hook.index;
    },

    _renderBinds: function () {
        if (this._updateFns) {
            $.each(this._updateFns, function (i, fn) {
                fn();
            });
        }
    },

    getTemplate: function () {
        return this.template.trim();
    },

    initElement: function () {
        var template = this.getTemplate();

        if (template) {
            this.el = jQuery(template)[0];
        } else {
            this._create();
        }
        mini._parseChildren(this.el.children, this);
        mini._parseContext(this.el, this);
    },

    _create: function () {
        this.el = document.createElement('div');
    },

    _initEvents: function () {},

    getForm: function () {
        if (!this.form) {
            this.form = new mini.Form(this.el);
        }
        return this.form;
    },

    getByName: function (name) {
        return mini.getByName(name, this);
    },

    within: function (e) {
        if (mini.isAncestor(this.el, e.target)) return true;
        return false;
    },

    setName: function (value) {
        this.name = value;
    },
    getName: function () {
        return this.name;
    },

    isAutoHeight: function () {
        var v = this.el.style.height;
        return v == 'auto' || v == '';
    },
    isAutoWidth: function () {
        var v = this.el.style.width;
        return v == 'auto' || v == '';
    },
    isFixedSize: function () {
        var width = this.width;
        var height = this.height;
        if (parseInt(width) + 'px' == width && parseInt(height) + 'px' == height) return true;
        return false;
    },

    updateRenderTo: function (value) {
        if (value) this.render(value);
    },

    doRenderParent: function (parent, position) {
        if (typeof parent === 'string') {
            if (parent == '#body') parent = document.body;
            else parent = mini.byId(parent);
        }
        if (!parent) return;
        if (!position) position = 'append';
        position = position.toLowerCase();

        if (position == 'before') {
            jQuery(parent).before(this.el);
        } else if (position == 'preend') {
            jQuery(parent).preend(this.el);
        } else if (position == 'after') {
            jQuery(parent).after(this.el);
        } else {
            parent.appendChild(this.el);
        }

        this.el.id = this.id;

        this.invalidateLayout();
    },

    getEl: function () {
        return this.el;
    },
    setJsName: function (value) {
        this.jsName = value;
        window[value] = this;
    },
    getJsName: function () {
        return this.jsName;
    },
    setTooltip: function (value) {
        this.tooltip = value;
        this.el.title = value;
    },
    setWidth: function (value) {
        if (parseInt(value) == value) value += 'px';
        this.width = value;
        this.el.style.width = value;
        this.invalidateLayout();
    },
    getWidth: function (content) {
        var w = content ? jQuery(this.el).width() : jQuery(this.el).outerWidth();
        w = parseInt(w);
        if (content && this._borderEl) {
            var b2 = mini.getBorders(this._borderEl);
            w = w - b2.left - b2.right;
        }
        return w;
    },
    setHeight: function (value) {
        if (parseInt(value) == value) value += 'px';
        this.height = value;
        this.el.style.height = value;
        this.invalidateLayout();
    },
    getHeight: function (content) {
        var h = content ? jQuery(this.el).height() : jQuery(this.el).outerHeight();
        h = parseInt(h);
        if (content && this._borderEl) {
            var b2 = mini.getBorders(this._borderEl);
            h = h - b2.top - b2.bottom;
        }
        return h;
    },
    getBox: function () {
        return mini.getBox(this.el);
    },
    setBorderStyle: function (value) {
        var el = this._borderEl || this.el;
        mini.setStyle(el, value);
        this.invalidateLayout();
    },

    setStyle: function (value) {
        this.style = value;
        mini.setStyle(this.el, value);

        this.width = this.el.style.width;
        this.height = this.el.style.height;

        this.invalidateLayout();
    },

    setCls: function (cls) {
        this.addCls(cls);
    },

    addCls: function (cls) {
        mini.addClass(this.el, cls);
    },
    removeCls: function (cls) {
        mini.removeClass(this.el, cls);
    },
    _doReadOnly: function () {
        if (this.readOnly) {
            this.addCls(this.readOnlyCls);
        } else {
            this.removeCls(this.readOnlyCls);
        }
    },
    updateReadOnly: function (value) {
        this._doReadOnly();
    },

    getParent: function (uiCls) {
        var doc = document;
        var p = this.el.parentNode;
        while (p != doc && p != null) {
            var pcontrol = mini.get(p);
            if (pcontrol) {
                if (!mini.isControl(pcontrol)) return null;
                if (!uiCls || pcontrol.uiCls == uiCls) return pcontrol;
            }
            p = p.parentNode;
        }
        return null;
    },
    isReadOnly: function () {
        if (this.readOnly || !this.enabled) return true;
        var p = this.getParent();
        if (p) return p.isReadOnly();
        return false;
    },
    isDisabled: function () {
        return this.enabled == false;
    },
    updateEnabled: function (value) {
        if (value) {
            this.removeCls(this.disabledCls);
        } else {
            this.addCls(this.disabledCls);
        }
        this._doReadOnly();
    },

    enable: function () {
        this.setEnabled(true);
    },
    disable: function () {
        this.setEnabled(false);
    },
    _displayStyle: '',
    updateVisible: function (value) {
        if (this.el) {
            this.el.style.display = value ? this._displayStyle : 'none';
            if (value) this.invalidateLayout();
        }
    },

    show: function () {
        this.setVisible(true);
    },
    hide: function () {
        this.setVisible(false);
    },
    isDisplay: function (ignoresFn) {
        if (mini.WindowVisible == false) return false;

        var doc = document.body;
        var p = this.el;
        while (1) {
            if (p == null || !p.style) return false;
            if (p && p.style && p.style.display == 'none') {
                if (ignoresFn) {
                    if (ignoresFn(p) !== true) return false;
                } else return false;
            }
            if (p == doc) return true;

            p = p.parentNode;
        }
        return true;
    },

    _destroyChildren: function () {
        if (this.el) {
            var cs = mini.getChildControls(this);
            for (var i = 0, l = cs.length; i < l; i++) {
                var control = cs[i];
                if (control.destroyed !== true) {
                    control.destroy();
                }
            }
        }
    },
    destroy: function () {
        if (this.destroyed !== true) {
            this._destroyChildren();
        }

        if (this.el) {
            mini.clearEvent(this.el);

            if (mini._destroying !== true) {
                var p = this.el.parentNode;
                if (p) p.removeChild(this.el);
            }
        }
        this._borderEl = null;
        this.el = null;
        mini['unreg'](this);
        this.destroyed = true;
        this.fire('destroy');
    },

    focus: function () {
        try {
            var me = this;

            me.el.focus();
        } catch (e) {}
    },
    blur: function () {
        try {
            var me = this;

            me.el.blur();
        } catch (e) {}
    },

    _getMaskWrapEl: function () {
        return this.el;
    },
    mask: function (options) {
        if (typeof options == 'string') options = { html: options };
        options = options || {};
        options.el = this._getMaskWrapEl();
        if (!options.cls) options.cls = this._maskCls;
        mini.mask(options);
    },
    unmask: function () {
        mini.unmask(this._getMaskWrapEl());
    },
    _maskCls: 'mini-mask-loading',
    loadingMsg: 'Loading...',
    loading: function (msg) {
        this.mask(msg || this.loadingMsg);
    },
    setLoadingMsg: function (value) {
        this.loadingMsg = value;
    },
    getLoadingMsg: function () {
        return this.loadingMsg;
    },

    _getContextMenu: function (value) {
        var ui = value;
        if (typeof value == 'string') {
            ui = mini.get(value);
            if (!ui) {
                mini.parse(value);
                ui = mini.get(value);
            }
        } else if (mini.isArray(value)) {
            ui = {
                type: 'menu',
                items: value
            };
        } else if (!mini.isControl(value)) {
            ui = mini.create(value);
        }
        return ui;
    },
    __OnHtmlContextMenu: function (e) {
        var ev = {
            popupEl: this.el,
            htmlEvent: e,
            cancel: false
        };
        this.contextMenu.fire('BeforeOpen', ev);
        if (ev.cancel == true) return;
        this.contextMenu.fire('opening', ev);
        if (ev.cancel == true) return;
        this.contextMenu.showAtPos(e.pageX, e.pageY);
        this.contextMenu.fire('Open', ev);
        return false;
    },
    contextMenu: null,
    setContextMenu: function (value) {
        var ui = this._getContextMenu(value);
        if (!ui) return;
        if (this.contextMenu !== ui) {
            this.contextMenu = ui;
            this.contextMenu.owner = this;
            mini.on(this.el, 'contextmenu', this.__OnHtmlContextMenu, this);
        }
    },
    getContextMenu: function () {
        return this.contextMenu;
    },

    _afterApply: function (el) {},

    requestUpdate: function () {
        mini.requestUpdate(this);
    },

    render: function () {},

    updateProps: function (el, props) {
        if (mini.hookComponent != this) {
            throw new Error('sync must called in render');
        }

        if (arguments.length == 1) {
            var options = el;
            for (var name in options) {
                this.updateProps(name, options[name]);
            }
        } else {
            if (typeof el == 'string') {
                if (this.refs[el]) el = this.refs[el];
                else el = this.getByName(el);
            }
            mini.updateByHook(el, props);
        }
    },

    updateItems: function (options) {},

    invalidate: function () {
        var me = this;
        if (!me._refreshTimeout) {
            me._refreshTimeout = mini.defer(function () {
                me.refresh();
            });
        }
    },
    refresh: function () {},

    invalidateLayout: function () {
        var me = this;
        if (!me._layoutTimeout) {
            me._layoutTimeout = mini.defer(function () {
                me.doLayout();
            });
        }
    },

    doLayout: function () {},

    _allowUpdate: true,
    beginUpdate: function () {
        this._allowUpdate = false;
    },
    endUpdate: function () {
        this._allowUpdate = true;
        this.doUpdate();
    },
    doUpdate: function () {},

    getAttrs: function (el) {
        var attrs = mini.parseConfig(el, this.constructor);

        var cls = el.className;
        if (cls) attrs.cls = cls;

        if (el.value) attrs.value = el.value;
        mini._ParseString(el, attrs, [
            'id',
            'name',
            'width',
            'height',
            'borderStyle',
            'value',
            'defaultValue',
            'contextMenu',
            'tooltip',
            'ondestroy',
            'data-options',
            'dataField'
        ]);

        mini._ParseBool(el, attrs, ['visible', 'enabled', 'readOnly']);

        if (el.readOnly && el.readOnly != 'false') attrs.readOnly = true;

        var style = el.style.cssText;
        if (style) {
            attrs.style = style;
        }

        if (isIE9) {
            var bg = el.style.background;
            if (bg) {
                if (!attrs.style) attrs.style = '';
                attrs.style += ';background:' + bg;
            }
        }
        if (this.style) {
            if (attrs.style) attrs.style = this.style + ';' + attrs.style;
            else attrs.style = this.style;
        }
        if (this.borderStyle) {
            if (attrs.borderStyle) attrs.borderStyle = this.borderStyle + ';' + attrs.borderStyle;
            else attrs.borderStyle = this.borderStyle;
        }

        var ts = mini._attrs;
        if (ts) {
            for (var i = 0, l = ts.length; i < l; i++) {
                var t = ts[i];
                var name = t[0];
                var type = t[1];
                if (!type) type = 'string';
                if (type == 'string') mini._ParseString(el, attrs, [name]);
                else if (type == 'bool') mini._ParseBool(el, attrs, [name]);
                else if (type == 'int') mini._ParseInt(el, attrs, [name]);
            }
        }

        var options = attrs['data-options'];
        if (options) {
            options = eval('(' + options + ')');
            if (options) {
                mini.copyTo(attrs, options);
            }
        }

        return attrs;
    }
});

mini._attrs = null;
mini.regHtmlAttr = function (attr, type) {
    if (!attr) return;
    if (!type) type = 'string';
    if (!mini._attrs) mini._attrs = [];
    mini._attrs.push([attr, type]);
};

mini.Control.parseConfig = function (el) {
    var ui = new this();
    var config = ui.getAttrs(el);
    return config;
};

mini.parseConfig = function (el, ctor) {
    var config = {};

    var props = mini.getClassProps(ctor);

    var context = mini.__getElementContext(el);

    var attrs = [].concat.apply([], el.attributes);
    for (var i = 0, l = attrs.length; i < l; i++) {
        var attr = attrs[i],
            name = mini.toCamelCase(attr.name),
            value = attr.value;

        if (name == 'ref' || name.indexOf('@') == 0 || name.indexOf(':') == 0 || name.indexOf('v-') == 0) {
            if (!config.bind) config.bind = {};
            config.bind[name] = value;
            continue;
        }

        if (name.indexOf('on') == 0) {
            config[name] = value;
        } else {
            if (name == 'config' || name == 'class') {
                value = mini._parseValue(value, context);
                config[name] = value;
            } else {
                var propName = mini.__getClassPropName(ctor, name);
                if (propName) {
                    value = mini._parseValue(value, context);
                    config[propName] = value;
                }
            }
        }
    }

    if (config.config) {
        mini.applyIf(config, config.config);
        delete config.config;
    }
    if (config['class']) {
        if (!config.cls) config.cls = config['class'];
        else config.cls = config['class'] + ' ' + config.cls;
        delete config['class'];
    }

    var children = [].concat.apply([], el.children);
    for (var i = 0, l = children.length; i < l; i++) {
        var node = children[i];
        var tagName = mini.toCamelCase(node.nodeName);

        var property = $(node).attr('property');
        if (property) tagName = property;

        if (tagName in props) {
            var parseName = 'parse' + tagName[0].toUpperCase() + tagName.substr(1);
            var parseFn = ctor[parseName];
            if (parseFn) {
                config[tagName] = parseFn(node);
            } else {
                if (property) {
                    config[tagName] = node;
                } else {
                    config[tagName] = mini.getChildNodes(node, false);
                }
            }
            mini.removeNode(node);
        }
    }

    if (!config.type && ctor.fn.type) config.type = ctor.fn.type;

    return config;
};

mini.__getClassPropName = function (ctor, name) {
    name = name.toLowerCase();
    var props = ctor._lowerProps;
    if (!props) {
        props = ctor._lowerProps = {};
        for (var key in ctor._props) {
            props[key.toLowerCase()] = key;
        }
    }
    return props[name];
};

mini.toCamelCase = function (str) {
    var sb = str.toLowerCase().split('-');
    var s = sb[0];
    for (var i = 1, l = sb.length; i < l; i++) {
        s += sb[i][0].toUpperCase() + sb[i].substr(1);
    }
    return s;
};

mini._parseValue = function (value, context) {
    if (!context) context = window;

    value = jQuery.trim(value);
    if (value == 'true') value = true;
    else if (value == 'false') value = false;
    else {
        var n = parseFloat(value);
        if (typeof n == 'number' && String(n) == value) value = n;
        else {
            if (
                (value[0] == '[' && value[value.length - 1] == ']') ||
                (value[0] == '{' && value[value.length - 1] == '}')
            ) {
                try {
                    var fn = new Function('_c', 'with(_c){return ' + value + '}');
                    value = fn.call(context, context);
                } catch (ex) {
                    console.error(ex);
                    value = null;
                }
            }
        }
    }
    return value;
};

mini.Widget = mini.Control.extend({
    _clearBorder: false
});

mini.ValidatorBase = mini.Control.extend({
    props: {
        required: false,
        requiredErrorText: 'This field is required.',
        errorText: '',
        errorMode: 'icon',
        validateOnChanged: true,
        validateOnLeave: true
    },

    requiredCls: 'mini-required',
    errorCls: 'mini-error',
    invalidCls: 'mini-invalid',

    _IsValid: true,

    _tryValidate: function () {
        if (this._tryValidateTimer) clearTimeout(this._tryValidateTimer);
        var me = this;
        this._tryValidateTimer = setTimeout(function () {
            me.validate();
        }, 30);
    },
    validate: function () {
        if (this.enabled == false) {
            this.setIsValid(true);
            return true;
        }
        var e = {
            value: this.getValue(),
            errorText: '',
            isValid: true
        };

        if (this.required) {
            if (mini.isNull(e.value) || String(e.value).trim() === '') {
                e.isValid = false;
                e.errorText = this.requiredErrorText;
            }
        }

        this.fire('validation', e);

        this.errorText = e.errorText;
        this.setIsValid(e.isValid);
        return this.isValid();
    },
    isValid: function () {
        return this._IsValid;
    },
    setIsValid: function (value) {
        this._IsValid = value;
        this.doUpdateValid();
    },
    getIsValid: function () {
        return this._IsValid;
    },
    setValidateOnChanged: function (value) {
        this.validateOnChanged = value;
    },
    getValidateOnChanged: function (value) {
        return this.validateOnChanged;
    },
    setValidateOnLeave: function (value) {
        this.validateOnLeave = value;
    },
    getValidateOnLeave: function (value) {
        return this.validateOnLeave;
    },

    setErrorMode: function (value) {
        if (!value) value = 'none';
        this.errorMode = value.toLowerCase();
        if (this._IsValid == false) this.doUpdateValid();
    },
    getErrorMode: function () {
        return this.errorMode;
    },
    setErrorText: function (value) {
        this.errorText = value;
        if (this._IsValid == false) this.doUpdateValid();
    },
    getErrorText: function () {
        return this.errorText;
    },
    setRequired: function (value) {
        this.required = value;
        if (this.required) {
            this.addCls(this.requiredCls);
        } else {
            this.removeCls(this.requiredCls);
        }
    },

    setRequiredErrorText: function (value) {
        this.requiredErrorText = value;
    },

    errorIconEl: null,
    getErrorIconEl: function () {
        return this._errorIconEl;
    },
    _RemoveErrorIcon: function () {},
    doUpdateValid: function () {
        var me = this;
        this._doUpdateValidTimer = setTimeout(function () {
            me.__doUpdateValid();
        }, 1);
    },
    __doUpdateValid: function () {
        if (!this.el) return;
        this.removeCls(this.errorCls);
        this.removeCls(this.invalidCls);
        this.el.title = '';
        if (this._IsValid == false) {
            switch (this.errorMode) {
                case 'icon':
                    this.addCls(this.errorCls);
                    var icon = this.getErrorIconEl();
                    if (icon) icon.title = this.errorText;
                    break;
                case 'border':
                    this.addCls(this.invalidCls);
                    this.el.title = this.errorText;
                default:
                    this._RemoveErrorIcon();
                    break;
            }
        } else {
            this._RemoveErrorIcon();
        }
        this.doLayout();
    },
    _OnValueChanged: function () {
        if (this.validateOnChanged) {
            this._tryValidate();
        }
        this.fire('valuechanged', { value: this.getValue() });

        this.fire('change', { value: this.getValue() });
    },
    onValueChanged: function (fn, scope) {
        this.on('valuechanged', fn, scope);
    },
    onValidation: function (fn, scope) {
        this.on('validation', fn, scope);
    },
    getAttrs: function (el) {
        var attrs = mini.ValidatorBase.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['onvaluechanged', 'onvalidation', 'requiredErrorText', 'errorMode']);

        mini._ParseBool(el, attrs, ['validateOnChanged', 'validateOnLeave']);

        var required = el.getAttribute('required');
        if (!required) required = el.required;
        if (!required) {
            var o = el.attributes['required'];
            if (o) {
                required = o.value == 'null' ? null : 'true';
            }
        }
        if (required) {
            attrs.required = required != 'false' ? true : false;
        }

        return attrs;
    }
});

mini.ListControl = mini.ValidatorBase.extend({
    type: 'list',
    tag: 'mini-list',

    props: {
        defaultValue: '',
        value: '',
        valueField: 'id',
        textField: 'text',
        delimiter: ',',

        data: null,
        url: '',
        multiSelect: false
    },

    itemCls: 'mini-list-item',
    itemHoverCls: 'mini-list-item-hover',
    itemSelectedCls: 'mini-list-item-selected',

    initComponent: function () {
        this.data = this.data || [];
        this._selecteds = [];

        this.callParent('initComponent');
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        kv = jQuery.extend({}, kv);

        var value = kv.value;
        delete kv.value;
        var url = kv.url;
        delete kv.url;
        var data = kv.data;
        delete kv.data;

        this.callParent('set', kv);

        if (!mini.isNull(data)) {
            this.setData(data);
        }
        if (!mini.isNull(url)) {
            this.setUrl(url);
        }
        if (!mini.isNull(value)) {
            this.setValue(value);
        }

        return this;
    },

    _create: function () {},
    _initEvents: function () {
        mini._BindEvents(function () {
            mini_onOne(this.el, 'click', this.__OnClick, this);
            mini_onOne(this.el, 'dblclick', this.__OnDblClick, this);

            mini_onOne(this.el, 'mousedown', this.__OnMouseDown, this);
            mini_onOne(this.el, 'mouseup', this.__OnMouseUp, this);
            mini_onOne(this.el, 'mousemove', this.__OnMouseMove, this);
            mini_onOne(this.el, 'mouseover', this.__OnMouseOver, this);
            mini_onOne(this.el, 'mouseout', this.__OnMouseOut, this);

            mini_onOne(this.el, 'keydown', this.__OnKeyDown, this);
            mini_onOne(this.el, 'keyup', this.__OnKeyUp, this);

            mini_onOne(this.el, 'contextmenu', this.__OnContextMenu, this);
        }, this);
    },
    destroy: function (removeEl) {
        if (this.el) {
            this.el.onclick = null;
            this.el.ondblclick = null;
            this.el.onmousedown = null;
            this.el.onmouseup = null;
            this.el.onmousemove = null;
            this.el.onmouseover = null;
            this.el.onmouseout = null;
            this.el.onkeydown = null;
            this.el.onkeyup = null;
            this.el.oncontextmenu = null;
        }
        mini.ListControl.superclass.destroy.call(this, removeEl);
    },

    name: '',
    setName: function (value) {
        this.name = value;
        if (this._valueEl) mini.setAttr(this._valueEl, 'name', this.name);
    },

    getItemByEvent: function (event) {
        var domItem = mini.findParent(event.target, this.itemCls);
        if (domItem) {
            var index = parseInt(mini.getAttr(domItem, 'index'));

            return this.data[index];
        }
    },
    addItemCls: function (item, cls) {
        var itemEl = this.getItemEl(item);
        if (itemEl) mini.addClass(itemEl, cls);
    },
    removeItemCls: function (item, cls) {
        var itemEl = this.getItemEl(item);
        if (itemEl) mini.removeClass(itemEl, cls);
    },
    getItemEl: function (item) {
        item = this.getItem(item);
        var index = this.data.indexOf(item);
        var id = this._createItemId(index);
        return document.getElementById(id);
    },
    _focusItem: function (item, view) {
        item = this.getItem(item);
        if (!item) return;
        var dom = this.getItemEl(item);
        if (view && dom) {
            this.scrollIntoView(item);
        }
        if (this._focusedItem == item) {
            if (dom) mini.addClass(dom, this.itemHoverCls);
            return;
        }
        this._blurItem();
        this._focusedItem = item;
        if (dom) mini.addClass(dom, this.itemHoverCls);
    },
    _blurItem: function () {
        if (!this._focusedItem) return;

        try {
            var dom = this.getItemEl(this._focusedItem);
            if (dom) {
                mini.removeClass(dom, this.itemHoverCls);
            }
        } catch (e) {}
        this._focusedItem = null;
    },
    getFocusedItem: function () {
        return this._focusedItem;
    },
    getFocusedIndex: function () {
        return this.data.indexOf(this._focusedItem);
    },
    _scrollViewEl: null,
    scrollIntoView: function (item) {
        try {
            var itemEl = this.getItemEl(item);
            var _scrollViewEl = this._scrollViewEl || this.el;
            mini.scrollIntoView(itemEl, _scrollViewEl, false);
        } catch (e) {}
    },

    getItem: function (item) {
        if (typeof item == 'object') return item;
        if (typeof item == 'number') return this.data[item];
        return this.findItems(item)[0];
    },
    getCount: function () {
        return this.data.length;
    },
    indexOf: function (item) {
        return this.data.indexOf(item);
    },
    getAt: function (index) {
        return this.data[index];
    },
    updateItem: function (item, options) {
        item = this.getItem(item);
        if (!item) return;
        mini.copyTo(item, options);
        this.doUpdate();
    },

    ajaxType: '',
    setAjaxType: function (value) {
        this.ajaxType = value;
    },
    getAjaxType: function () {
        return this.ajaxType;
    },

    load: function (data) {
        if (typeof data == 'string') this.setUrl(data);
        else this.setData(data);
    },
    loadData: function (data) {
        this.setData(data);
    },
    setData: function (data) {
        if (typeof data == 'string') {
            data = eval(data);
        }
        if (!mini.isArray(data)) data = [];
        this.data = data;

        this._selected = null;
        this._selecteds = [];

        this.doUpdate();

        if (this.value != '') {
            this.deselectAll();
            var records = this.findItems(this.value);
            this.selects(records);
        }
    },
    getData: function () {
        return this.data.clone();
    },
    setUrl: function (url) {
        this.url = url;
        if (url) this._doLoad({});
    },

    _doLoad: function (params) {
        try {
            var url = eval(this.url);
            if (url != undefined) {
                this.url = url;
            }
        } catch (e) {}

        var e = {
            url: this.url,
            async: false,
            type: this.ajaxType ? this.ajaxType : mini.ListControl.ajaxType,
            params: params,
            data: params,
            cache: false,
            cancel: false
        };
        this.fire('beforeload', e);
        if (e.data != e.params && e.params != params) {
            e.data = e.params;
        }
        if (e.cancel == true) return;

        var sf = this;
        var url = e.url;
        mini.copyTo(e, {
            success: function (text) {
                var data = null;
                try {
                    data = mini.decode(text);
                } catch (ex) {
                    data = [];
                    if (mini_debugger == true) {
                        alert(url + '\njson is error.');
                    }
                }
                if (sf.dataField) {
                    data = mini._getMap(sf.dataField, data);
                }
                if (!data) data = [];
                var ex = { data: data, cancel: false };
                sf.fire('preload', ex);
                if (ex.cancel == true) return;

                sf.setData(ex.data);

                sf.fire('load');

                setTimeout(function () {
                    sf.doLayout();
                }, 100);
            },
            error: function (jqXHR, textStatus, errorThrown) {
                var e = {
                    xmlHttp: jqXHR,
                    errorMsg: jqXHR.responseText,
                    errorCode: jqXHR.status
                };
                if (mini_debugger == true) {
                    alert(url + '\n' + e.errorCode + '\n' + e.errorMsg);
                }

                sf.fire('loaderror', e);
            }
        });

        this._ajaxer = mini.ajax(e);
    },
    setValue: function (value) {
        if (mini.isNull(value)) value = '';
        if (this.value !== value) {
            this.deselectAll();

            this.value = value;
            if (this._valueEl) this._valueEl.value = value;

            var records = this.findItems(this.value);
            this.selects(records);
        }
    },
    getValue: function () {
        return this.value;
    },
    getFormValue: function () {
        return this.value;
    },
    setValueField: function (valueField) {
        this.valueField = valueField;
    },
    getValueField: function () {
        return this.valueField;
    },
    setTextField: function (value) {
        this.textField = value;
    },
    getTextField: function () {
        return this.textField;
    },

    getItemValue: function (item) {
        return String(mini._getMap(this.valueField, item));
    },
    getItemText: function (item) {
        var t = mini._getMap(this.textField, item);
        return mini.isNull(t) ? '' : String(t);
    },
    getValueAndText: function (records) {
        if (mini.isNull(records)) records = [];
        if (!mini.isArray(records)) {
            records = this.findItems(records);
        }
        var values = [];
        var texts = [];
        for (var i = 0, l = records.length; i < l; i++) {
            var record = records[i];
            if (record) {
                values.push(this.getItemValue(record));
                texts.push(this.getItemText(record));
            }
        }
        return [values.join(this.delimiter), texts.join(this.delimiter)];
    },
    findItems: function (value) {
        if (mini.isNull(value) || value === '') return [];
        if (typeof value == 'function') {
            var fn = value;
            var items = [];
            var data = this.data;
            for (var j = 0, k = data.length; j < k; j++) {
                var record = data[j];
                if (fn(record, j) === true) {
                    items.push(record);
                }
            }
            return items;
        }

        var values = String(value).split(this.delimiter);

        var data = this.data;
        var valueRecords = {};
        for (var j = 0, k = data.length; j < k; j++) {
            var record = data[j];
            var v = record[this.valueField];
            valueRecords[v] = record;
        }

        var records = [];
        for (var i = 0, l = values.length; i < l; i++) {
            var v = values[i];
            var record = valueRecords[v];
            if (record) {
                records.push(record);
            }
        }
        return records;
    },

    removeAll: function () {
        var items = this.getData();
        this.removeItems(items);
    },
    addItems: function (items, index) {
        if (!mini.isArray(items)) return;
        if (mini.isNull(index)) index = this.data.length;
        this.data.insertRange(index, items);
        this.doUpdate();
    },
    addItem: function (item, index) {
        if (!item) return;
        if (this.data.indexOf(item) != -1) return;
        if (mini.isNull(index)) index = this.data.length;
        this.data.insert(index, item);
        this.doUpdate();
    },
    removeItems: function (items) {
        if (!mini.isArray(items)) return;
        mini.Array.removeRange(this.data, items);

        this._checkSelecteds();
        this.doUpdate();
    },
    removeItem: function (item) {
        var index = this.data.indexOf(item);
        if (index != -1) {
            this.data.removeAt(index);
            this._checkSelecteds();
            this.doUpdate();
        }
    },
    moveItem: function (item, index) {
        if (!item || !mini.isNumber(index)) return;

        if (index < 0) index = 0;
        if (index > this.data.length) index = this.data.length;
        this.data.remove(item);

        this.data.insert(index, item);
        this.doUpdate();
    },

    _selected: null,
    _selecteds: [],

    _checkSelecteds: function () {
        for (var i = this._selecteds.length - 1; i >= 0; i--) {
            var record = this._selecteds[i];
            if (this.data.indexOf(record) == -1) {
                this._selecteds.removeAt(i);
            }
        }
        var vts = this.getValueAndText(this._selecteds);
        this.value = vts[0];
        if (this._valueEl) this._valueEl.value = this.value;
    },
    setMultiSelect: function (value) {
        this.multiSelect = value;
    },
    getMultiSelect: function () {
        return this.multiSelect;
    },
    isSelected: function (record) {
        if (!record) return false;
        return this._selecteds.indexOf(record) != -1;
    },
    getSelecteds: function () {
        var arr = this._selecteds.clone();
        var me = this;
        mini.sort(arr, function (a, b) {
            var index1 = me.indexOf(a);
            var index2 = me.indexOf(b);
            if (index1 > index2) return 1;
            if (index1 < index2) return -1;
            return 0;
        });
        return arr;
    },
    setSelected: function (record) {
        if (record) {
            this._selected = record;
            this.select(record);
        }
    },
    getSelected: function () {
        return this._selected;
    },
    select: function (record) {
        record = this.getItem(record);
        if (!record) return;
        if (this.isSelected(record)) return;

        this.selects([record]);
    },
    deselect: function (record) {
        record = this.getItem(record);
        if (!record) return;
        if (!this.isSelected(record)) return;
        this.deselects([record]);
    },
    selectAll: function () {
        var data = this.data.clone();
        this.selects(data);
    },
    deselectAll: function () {
        this.deselects(this._selecteds);
    },
    clearSelect: function () {
        this.deselectAll();
    },
    selects: function (records) {
        if (!records || records.length == 0) return;
        records = records.clone();
        for (var i = 0, l = records.length; i < l; i++) {
            var record = records[i];
            if (!this.isSelected(record)) {
                this._selecteds.push(record);
            }
        }
        var me = this;
        setTimeout(function () {
            me._doSelects();
        }, 1);
    },
    deselects: function (records) {
        if (!records || records.length == 0) return;
        records = records.clone();
        for (var i = records.length - 1; i >= 0; i--) {
            var record = records[i];
            if (this.isSelected(record)) {
                this._selecteds.remove(record);
            }
        }

        var me = this;
        setTimeout(function () {
            me._doSelects();
        }, 1);
    },
    _doSelects: function () {
        var vts = this.getValueAndText(this._selecteds);
        this.value = vts[0];
        if (this._valueEl) this._valueEl.value = this.value;

        for (var i = 0, l = this.data.length; i < l; i++) {
            var record = this.data[i];
            var select = this.isSelected(record);
            if (select) {
                this.addItemCls(record, this.itemSelectedCls);
            } else {
                this.removeItemCls(record, this.itemSelectedCls);
            }
            var index = this.data.indexOf(record);
            var id = this._createCheckId(index);
            var checkbox = document.getElementById(id);
            if (checkbox) checkbox.checked = !!select;
        }
    },
    _OnSelectionChanged: function (records, select) {
        var vts = this.getValueAndText(this._selecteds);
        this.value = vts[0];
        if (this._valueEl) this._valueEl.value = this.value;

        var e = {
            selecteds: this.getSelecteds(),
            selected: this.getSelected(),
            value: this.getValue()
        };
        this.fire('SelectionChanged', e);
    },
    _createCheckId: function (index) {
        return this.uid + '_ck_' + index;
    },
    _createItemId: function (index) {
        return this.uid + '_' + index;
    },

    __OnClick: function (e) {
        this._fireEvent(e, 'Click');
    },
    __OnDblClick: function (e) {
        this._fireEvent(e, 'Dblclick');
    },
    __OnMouseDown: function (e) {
        this._fireEvent(e, 'MouseDown');
    },
    __OnMouseUp: function (e) {
        this._fireEvent(e, 'MouseUp');
    },
    __OnMouseMove: function (e) {
        this._fireEvent(e, 'MouseMove');
    },
    __OnMouseOver: function (e) {
        this._fireEvent(e, 'MouseOver');
    },
    __OnMouseOut: function (e) {
        this._fireEvent(e, 'MouseOut');
    },
    __OnKeyDown: function (e) {
        this._fireEvent(e, 'KeyDown');
    },
    __OnKeyUp: function (e) {
        this._fireEvent(e, 'KeyUp');
    },
    __OnContextMenu: function (e) {
        this._fireEvent(e, 'ContextMenu');
    },
    _fireEvent: function (e, name) {
        if (!this.enabled) return;

        var item = this.getItemByEvent(e);
        if (!item) return;
        var fn = this['_OnItem' + name];
        if (fn) {
            fn.call(this, item, e);
        } else {
            var eve = {
                item: item,
                htmlEvent: e
            };
            this.fire('item' + name, eve);
        }
    },
    _OnItemClick: function (item, e) {
        if (this.isReadOnly() || this.enabled == false || item.enabled === false) {
            e.preventDefault();
            return;
        }

        var value = this.getValue();

        if (this.multiSelect) {
            if (this.isSelected(item)) {
                this.deselect(item);
                if (this._selected == item) {
                    this._selected = null;
                }
            } else {
                this.select(item);
                this._selected = item;
            }
            this._OnSelectionChanged();
        } else {
            if (!this.isSelected(item)) {
                this.deselectAll();
                this.select(item);
                this._selected = item;
                this._OnSelectionChanged();
            }
        }

        if (value != this.getValue()) {
            this._OnValueChanged();
        }

        var e = {
            item: item,
            htmlEvent: e
        };
        this.fire('itemclick', e);
    },
    _blurOnOut: true,
    _OnItemMouseOut: function (item, e) {
        mini.repaint(this.el);
        if (!this.enabled) return;
        if (this._blurOnOut) {
            this._blurItem();
        }
        var e = {
            item: item,
            htmlEvent: e
        };
        this.fire('itemmouseout', e);
    },
    _OnItemMouseMove: function (item, e) {
        mini.repaint(this.el);
        if (!this.enabled || item.enabled === false) return;

        this._focusItem(item);
        var e = {
            item: item,
            htmlEvent: e
        };
        this.fire('itemmousemove', e);
    },
    onItemClick: function (fn, scope) {
        this.on('itemclick', fn, scope);
    },
    onItemMouseDown: function (fn, scope) {
        this.on('itemmousedown', fn, scope);
    },
    onBeforeLoad: function (fn, scope) {
        this.on('beforeload', fn, scope);
    },
    onLoad: function (fn, scope) {
        this.on('load', fn, scope);
    },
    onLoadError: function (fn, scope) {
        this.on('loaderror', fn, scope);
    },
    onPreLoad: function (fn, scope) {
        this.on('preload', fn, scope);
    },

    getAttrs: function (el) {
        var attrs = mini.ListControl.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'url',
            'data',
            'value',
            'textField',
            'valueField',
            'onitemclick',
            'onitemmousemove',
            'onselectionchanged',
            'onitemdblclick',
            'onbeforeload',
            'onload',
            'onloaderror',
            'ondataload',
            'ajaxType'
        ]);
        mini._ParseBool(el, attrs, ['multiSelect']);

        var valueField = attrs.valueField || this.valueField;
        var textField = attrs.textField || this.textField;
        if (el.nodeName.toLowerCase() == 'select') {
            var data = [];
            for (var i = 0, l = el.length; i < l; i++) {
                var op = el.options[i];
                var o = {};
                o[textField] = op.text;
                o[valueField] = op.value;

                data.push(o);
            }
            if (data.length > 0) {
                attrs.data = data;
            }
        }

        return attrs;
    }
});

mini.ListControl.ajaxType = 'get';

__mini_setControls = function (controls, contentEl, scope) {
    contentEl = jQuery(contentEl || this._contentEl)[0];
    scope = scope || this;
    if (!controls) controls = [];
    if (!mini.isArray(controls)) controls = [controls];

    var changed = false;
    for (var i = 0, l = controls.length; i < l; i++) {
        var c = controls[i];
        if (typeof c == 'string') {
            if (c.indexOf('#') == 0) c = mini.byId(c);
        } else if (mini.isElement(c)) {
        } else {
            c = mini.getAndCreate(c);
            c = c.el;
        }
        if (!c) continue;

        mini.append(contentEl, c);
        changed = true;
    }

    if (changed) {
        mini._parseChildren(contentEl.childNodes, scope.context || scope);

        scope.invalidateLayout();
    }
    return scope;
};

mini.updateContent = function (el, value, scope) {
    return __mini_setControls(value, el, scope);
};

mini.Container = mini.Control.extend({
    props: {
        content: null
    },

    initComponent: function () {
        this.callParent('initComponent');
        this._contentEl = this.el;

        this.bodyEl = this.bodyEl || this._bodyEl || this._contentEl;
    },

    setContent: function (value) {
        this.content = value;
        if (value) {
            mini.updateContent(this.getBodyEl(), value, this);
        }
    },

    getContentEl: function () {
        return this._contentEl;
    },
    getBodyEl: function () {
        return this._contentEl;
    },
    getAttrs: function (el) {
        var attrs = mini.Container.superclass.getAttrs.call(this, el);

        attrs.content = mini.getChildNodes(el, false);

        return attrs;
    }
});

mini.DataBinding = function () {
    this._bindFields = [];
    this._bindForms = [];
    mini.DataBinding.superclass.constructor.call(this);
};
mini.extend(mini.DataBinding, mini.Component, {
    bindField: function (control, source, field, mode, convert) {
        control = mini.get(control);
        source = mini.get(source);
        if (!control || !source || !field) return;
        var bind = { control: control, source: source, field: field, convert: convert, mode: mode };
        this._bindFields.push(bind);

        source.on('currentchanged', this.__OnCurrentChanged, this);
        control.on('valuechanged', this.__OnValueChanged, this);
    },
    bindForm: function (form, source, mode, convert) {
        form = mini.byId(form);
        source = mini.get(source);
        if (!form || !source) return;

        var form = new mini.Form(form);
        var controls = form.getFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            this.bindField(control, source, control.getName(), mode, convert);
        }
    },

    __OnCurrentChanged: function (e) {
        if (this._doSetting) return;
        this._doSetting = true;

        var source = e.sender;
        var record = e.record;

        for (var i = 0, l = this._bindFields.length; i < l; i++) {
            var bind = this._bindFields[i];
            if (bind.source != source) continue;

            var control = bind.control;
            var field = bind.field;
            if (control.setValue) {
                if (record) {
                    var value = record[field];
                    control.setValue(value);
                } else {
                    control.setValue('');
                }
            }

            if (control.setText && control.textName) {
                if (record) {
                    control.setText(record[control.textName]);
                } else {
                    control.setText('');
                }
            }
        }

        var me = this;
        setTimeout(function () {
            me._doSetting = false;
        }, 10);
    },
    __OnValueChanged: function (e) {
        if (this._doSetting) return;
        this._doSetting = true;

        var control = e.sender;
        var value = control.getValue();

        for (var i = 0, l = this._bindFields.length; i < l; i++) {
            var bind = this._bindFields[i];

            if (bind.control != control || bind.mode === false) continue;
            var source = bind.source;
            var current = source.getCurrent();
            if (!current) continue;

            var obj = {};
            obj[bind.field] = value;

            if (control.getText && control.textName) {
                obj[control.textName] = control.getText();
            }

            source.updateRow(current, obj);
        }

        var me = this;
        setTimeout(function () {
            me._doSetting = false;
        }, 10);
    }
});
mini.regClass(mini.DataBinding, 'databinding');

mini.DataSet = function () {
    this._sources = {};
    this._data = {};
    this._links = [];

    this._originals = {};

    mini.DataSet.superclass.constructor.call(this);
};
mini.extend(mini.DataSet, mini.Component, {
    add: function (name, listControl) {
        if (!name || !listControl) return;
        this._sources[name] = listControl;
        this._data[name] = [];

        listControl.autoCreateNewID = true;
        listControl._originalIdField = listControl.getIdField();
        listControl._clearOriginals = false;

        listControl.on('addrow', this.__OnRowChanged, this);
        listControl.on('updaterow', this.__OnRowChanged, this);
        listControl.on('deleterow', this.__OnRowChanged, this);
        listControl.on('removerow', this.__OnRowChanged, this);
        listControl.on('preload', this.__OnDataPreLoad, this);

        listControl.on('selectionchanged', this.__OnDataSelectionChanged, this);
    },
    addLink: function (name, childName, parentField) {
        if (!name || !childName || !parentField) return;
        if (!this._sources[name] || !this._sources[childName]) return;

        var link = {
            parentName: name,
            childName: childName,
            parentField: parentField
        };
        this._links.push(link);
    },
    clearData: function () {
        this._data = {};
        this._originals = {};
        for (var name in this._sources) {
            this._data = [];
        }
    },
    getData: function () {
        return this._data;
    },
    _getNameByListControl: function (listControl) {
        for (var name in this._sources) {
            var c = this._sources[name];
            if (c == listControl) return name;
        }
    },
    _getRecord: function (name, record, idField) {
        var rows = this._data[name];
        if (!rows) return false;
        for (var i = 0, l = rows.length; i < l; i++) {
            var row = rows[i];
            if (row[idField] == record[idField]) return row;
        }
        return null;
    },

    __OnRowChanged: function (e) {
        var type = e.type;
        var record = e.record;
        var name = this._getNameByListControl(e.sender);
        var oldRow = this._getRecord(name, record, e.sender.getIdField());

        var rows = this._data[name];
        if (oldRow) {
            var rows = this._data[name];
            rows.remove(oldRow);
        }

        if (type == 'removerow' && record._state == 'added') {
        } else {
            rows.push(record);
        }

        this._originals[name] = e.sender._originals;

        if (record._state == 'added') {
            var parentSource = this._getParentSource(e.sender);
            if (parentSource) {
                var current = parentSource.getSelected();
                if (current) {
                    record._parentId = current[parentSource.getIdField()];
                } else {
                    rows.remove(record);
                }
            }
        }
    },
    __OnDataPreLoad: function (e) {
        var source = e.sender;
        var name = this._getNameByListControl(source);
        var idField = e.sender.getIdField();

        var rows = this._data[name];
        var maps = {};
        for (var i = 0, l = rows.length; i < l; i++) {
            var row = rows[i];
            maps[row[idField]] = row;
        }

        var ors = this._originals[name];
        if (ors) {
            source._originals = ors;
        }

        var nowData = e.data || [];
        for (var i = 0, l = nowData.length; i < l; i++) {
            var row = nowData[i];
            var old = maps[row[idField]];
            if (old) {
                delete old._uid;
                mini.copyTo(row, old);
            }
        }

        var parentSource = this._getParentSource(source);
        if (source.getPageIndex && source.getPageIndex() == 0) {
            var adds = [];
            for (var i = 0, l = rows.length; i < l; i++) {
                var row = rows[i];
                if (row._state == 'added') {
                    if (parentSource) {
                        var current = parentSource.getSelected();
                        if (current && current[parentSource.getIdField()] == row._parentId) {
                            adds.push(row);
                        }
                    } else {
                        adds.push(row);
                    }
                }
            }
            adds.reverse();
            nowData.insertRange(0, adds);
        }

        var removes = [];
        for (var i = nowData.length - 1; i >= 0; i--) {
            var row = nowData[i];
            var old = maps[row[idField]];
            if (old && old._state == 'removed') {
                nowData.removeAt(i);
                removes.push(old);
            }
        }
    },

    _getParentSource: function (source) {
        var childName = this._getNameByListControl(source);
        for (var i = 0, l = this._links.length; i < l; i++) {
            var link = this._links[i];
            if (link.childName == childName) {
                return this._sources[link.parentName];
            }
        }
    },
    _getLinks: function (source) {
        var name = this._getNameByListControl(source);
        var links = [];
        for (var i = 0, l = this._links.length; i < l; i++) {
            var link = this._links[i];
            if (link.parentName == name) {
                links.push(link);
            }
        }
        return links;
    },
    __OnDataSelectionChanged: function (e) {
        var grid1 = e.sender;
        var record = grid1.getSelected();

        var links = this._getLinks(grid1);
        for (var i = 0, l = links.length; i < l; i++) {
            var link = links[i];
            var grid2 = this._sources[link.childName];

            if (record) {
                var args = {};
                args[link.parentField] = record[grid1.getIdField()];
                grid2.load(args);
            } else {
                grid2.loadData([]);
            }
        }
    }
});
mini.regClass(mini.DataSet, 'dataset');
mini.Include = function () {
    mini.Include.superclass.constructor.call(this);
};
mini.extend(mini.Include, mini.Control, {
    url: '',

    uiCls: 'mini-include',
    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-include';
    },
    _initEvents: function () {},

    setUrl: function (value) {
        this.url = value;
        mini.update({
            url: this.url,
            el: this.el,
            async: this.async
        });

        this.doLayout();
    },
    getUrl: function (value) {
        return this.url;
    },

    getAttrs: function (el) {
        var attrs = mini.Include.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['url']);

        return attrs;
    }
});
mini.regClass(mini.Include, 'include');

mini.Button = mini.Control.extend({
    type: 'button',
    tag: 'mini-button',

    props: {
        text: '',
        iconCls: '',
        iconStyle: '',
        iconPosition: 'left',
        plain: false,
        checkOnClick: false,
        checked: false,
        groupName: '',
        href: '',
        target: '',
        arrowCls: '',
        tabIndex: 0
    },

    plainCls: 'mini-button-plain',
    hoverCls: 'mini-button-hover',
    pressedCls: 'mini-button-pressed',
    checkedCls: 'mini-button-checked',
    disabledCls: 'mini-button-disabled',

    _create: function () {
        this.el = document.createElement('a');

        this.el.className = 'mini-button';
        this.el.hideFocus = true;
    },

    _initEvents: function () {
        mini._BindEvents(function () {
            mini_onOne(this.el, 'mousedown', this.__OnMouseDown, this);
            mini_onOne(this.el, 'click', this.__OnClick, this);
        }, this);

        mini.on(this.el, 'keydown', this.onKeyDown, this);
    },
    destroy: function (removeEl) {
        if (this.el) {
            this.el.onclick = null;
            this.el.onmousedown = null;
        }
        if (this.menu) this.menu.owner = null;
        this.menu = null;
        mini.Button.superclass.destroy.call(this, removeEl);
    },

    refresh: function () {
        var cls = '',
            text = this.text;

        if (this.iconCls && text) {
            cls = ' mini-button-icon ' + this.iconCls;
        } else if (this.iconCls && text === '') {
            cls = ' mini-button-iconOnly ' + this.iconCls;
            text = '&nbsp;';
        } else {
        }

        mini.toggleClass(this.el, 'mini-button-arrow-only', !!(this.arrowCls && !text && !this.iconCls));

        if (text == '') text = '&nbsp;';
        var s = '<span class="mini-button-text ' + cls + '">' + text + '</span>';
        if (this.arrowCls) {
            s = s + '<span class="mini-button-arrow ' + this.arrowCls + '"></span>';
        }
        this.el.innerHTML = s;
    },

    setHref: function (value) {
        this.href = value;
        this.el.href = value ? value : 'javascript:void(0)';
        var el = this.el;
        if (value) {
            setTimeout(function () {
                el.onclick = null;
            }, 100);
        }
    },

    updateTarget: function (value) {
        this.el.target = value;
    },

    updateText: function (value) {
        this.invalidate();
    },

    updateIconCls: function (value) {
        this.invalidate();
    },

    updateIconStyle: function (value) {
        this.invalidate();
    },

    updateIconPosition: function (value) {
        this.invalidate();
    },

    updatePlain: function (value) {
        if (value) this.addCls(this.plainCls);
        else this.removeCls(this.plainCls);
    },

    setChecked: function (value) {
        var fire = this.checked != value;
        this.checked = value;
        if (value) this.addCls(this.checkedCls);
        else this.removeCls(this.checkedCls);
        if (fire) {
            this.fire('CheckedChanged');
        }
    },

    updateTabIndex: function (value) {
        this.el.tabIndex = value;
    },

    doClick: function () {
        this.__OnClick(null);
    },

    onKeyDown: function (e) {
        if (e.keyCode == mini.Keys.Enter) {
            this.__OnClick(e);
        }
    },

    __OnClick: function (e) {
        if (!this.href) {
            e.preventDefault();
        }
        if (this.readOnly || this.enabled == false) return;
        this.focus();
        if (this.checkOnClick) {
            if (this.groupName) {
                var groupName = this.groupName;
                var buttons = mini.findControls(function (control) {
                    if (control.type == 'button' && control.groupName == groupName) return true;
                });
                if (buttons.length > 0) {
                    for (var i = 0, l = buttons.length; i < l; i++) {
                        var button = buttons[i];
                        if (button != this) button.setChecked(false);
                    }
                    this.setChecked(true);
                } else {
                    this.setChecked(!this.checked);
                }
            } else {
                this.setChecked(!this.checked);
            }
        }

        if (this.menu) {
            if (this.menu.visible) {
                this.hideMenu();
            } else {
                this.showMenu();
            }
        }

        this.fire('click', {
            htmlEvent: e
        });
    },

    getReferenceEl: function () {
        return this.el;
    },

    showMenu: function () {
        if (this.menu) {
            this.menu.showAtEl(this.getReferenceEl());
        }
    },

    hideMenu: function () {
        if (this.menu) {
            this.menu.hide();
        }
    },

    __OnMouseDown: function (e) {
        if (this.isReadOnly()) return;

        this.addCls(this.pressedCls);
        mini.on(document, 'mouseup', this.__OnDocMouseUp, this);
    },
    __OnDocMouseUp: function (e) {
        this.removeCls(this.pressedCls);
        mini.un(document, 'mouseup', this.__OnDocMouseUp, this);
    },
    onClick: function (fn, scope) {
        this.on('click', fn, scope);
    },

    getAttrs: function (el) {
        var attrs = mini.Button.superclass.getAttrs.call(this, el);

        attrs.text = el.innerHTML;
        mini._ParseString(el, attrs, [
            'text',
            'href',
            'iconCls',
            'iconStyle',
            'iconPosition',
            'groupName',
            'menu',
            'onclick',
            'oncheckedchanged',
            'target'
        ]);
        mini._ParseBool(el, attrs, ['plain', 'checkOnClick', 'checked']);
        return attrs;
    }
});

mini.MenuButton = mini.Button.extend({
    type: 'menubutton',
    tag: 'mini-menubutton',
    arrowCls: 'mini-button-menu',

    setMenu: function (value) {
        if (mini.isArray(value)) {
            value = {
                type: 'menu',
                items: value
            };
        }
        if (typeof value == 'string') {
            var el = mini.byId(value);
            if (!el) return;
            mini.parse(value);
            value = mini.get(value);
        }

        if (this.menu !== value) {
            this.menu = mini.getAndCreate(value);
            this.menu.setPopupEl(this.getReferenceEl());
            this.menu.setPopupCls('mini-button-popup');
            this.menu.setShowAction('none');
            this.menu.setHideAction('outerclick');
            this.menu.setXAlign('left');
            this.menu.setYAlign('below');
            this.menu.hide();
            this.menu.owner = this;
        }
    },
    setEnabled: function (value) {
        this.callParent('setEnabled', value);

        jQuery(this.el).attr('allowPopup', !!value);
    }
});

mini.SplitButton = mini.Control.extend({
    type: 'splitbutton',
    tag: 'mini-splitbutton',
    props: {
        text: '',
        iconCls: '',
        plain: false,
        handler: null,
        menu: null,
        arrowHandler: null
    },
    template:
        '<div @mouseenter="onMouseEnter" @mouseleave="onMouseLeave"><mini-button @click="handleClick" ref="button" iconCls="icon-new">新建</mini-button><mini-menubutton ref="arrow" @click="handleArrowClick" @menuhide="onMenuHide"></mini-menubutton></div>',

    render: function () {
        this.updateProps(this.refs.button, {
            text: this.text,
            iconCls: this.iconCls,
            plain: this.plain,
            handler: this.handler
        });

        this.updateProps(this.refs.arrow, {
            plain: this.plain,
            handler: this.arrowHandler
        });
    },

    updateMenu: function (value) {
        this.refs.arrow.setMenu(value);
    },

    handleClick: function (e) {
        this.fireEvent('click', e);
    },

    handleArrowClick: function (e) {
        this.fireEvent('arrowclick', e);
    },

    onMouseEnter: function (event) {
        if (this.isDisabled()) return;
        this.refs.button.setPlain(false);
        this.refs.arrow.setPlain(false);
    },

    onMouseLeave: function (event) {
        if (this.isDisabled()) return;

        this.setPlain(this.plain);
    }
});

mini.Calendar = mini.Control.extend({
    type: 'calendar',
    tag: 'mini-calendar',

    props: {
        width: 220,
        height: 160,
        viewDate: null,
        multiSelect: false,
        firstDayOfWeek: 0,
        todayText: 'Today',
        clearText: 'Clear',
        okText: 'OK',
        cancelText: 'Cancel',
        format: 'MMM, yyyy',
        timeFormat: 'H:mm',
        showTime: false,
        currentTime: true,
        rows: 1,
        columns: 1,
        headerCls: '',
        bodyCls: '',
        footerCls: '',
        showHeader: true,
        showFooter: true,
        showWeekNumber: false,
        showDaysHeader: true,
        showMonthButtons: true,
        showYearButtons: true,
        showTodayButton: true,
        showClearButton: true,
        showOkButton: false
    },

    _clearBorder: false,
    _selectedDate: '',
    _selectedDates: null,
    _todayCls: 'mini-calendar-today',
    _weekendCls: 'mini-calendar-weekend',
    _otherMonthCls: 'mini-calendar-othermonth',
    _selectedDateCls: 'mini-calendar-selected',
    daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],

    initComponent: function () {
        this.viewDate = this.viewDate || new Date();
        this._selectedDates = [];
        this.callParent('initComponent');
    },

    isWeekend: function (date) {
        var day = date?.getDay();
        return day == 0 || day == 6;
    },
    getFirstDateOfMonth: function (date) {
        var date = new Date(date?.getFullYear(), date?.getMonth(), 1);

        return mini.getWeekStartDate(date, this.firstDayOfWeek);
    },
    getShortWeek: function (week) {
        return this.daysShort[week];
    },

    _create: function () {
        var s = '<tr style="width:100%;"><td style="width:100%;"></td></tr>';
        s +=
            '<tr ><td><div class="mini-calendar-footer">' +
            '<span style="display:inline-block;"><input name="time" class="mini-timespinner" style="width:80px" format="' +
            this.timeFormat +
            '"/>' +
            '<span class="mini-calendar-footerSpace"></span></span>' +
            '<span class="mini-calendar-tadayButton">' +
            this.todayText +
            '</span>' +
            '<span class="mini-calendar-footerSpace"></span>' +
            '<span class="mini-calendar-clearButton">' +
            this.clearText +
            '</span>' +
            '<span class="mini-calendar-okButton">' +
            this.okText +
            '</span>' +
            '<a href="#" class="mini-calendar-focus" style="position:absolute;left:-10px;top:-10px;width:0px;height:0px;outline:none" hideFocus></a>' +
            '</div></td></tr>';

        var html = '<table class="mini-calendar" cellpadding="0" cellspacing="0">' + s + '</table>';

        var d = document.createElement('div');
        d.innerHTML = html;
        this.el = d.firstChild;

        var trs = this.el.getElementsByTagName('tr');
        var tds = this.el.getElementsByTagName('td');

        this._innerEl = tds[0];
        this._footerEl = mini.byClass('mini-calendar-footer', this.el);

        this.timeWrapEl = this._footerEl.childNodes[0];
        this.todayButtonEl = this._footerEl.childNodes[1];
        this.footerSpaceEl = this._footerEl.childNodes[2];
        this.closeButtonEl = this._footerEl.childNodes[3];
        this.okButtonEl = this._footerEl.childNodes[4];

        this._focusEl = this._footerEl.lastChild;

        mini._parseChildren(this._footerEl.children);
        this.timeSpinner = this.getByName('time');
        this.invalidate();
    },
    focus: function () {
        try {
            this._focusEl.focus();
        } catch (e) {}
    },
    destroy: function () {
        this._innerEl =
            this._footerEl =
            this.timeWrapEl =
            this.todayButtonEl =
            this.footerSpaceEl =
            this.closeButtonEl =
                null;

        mini.Calendar.superclass.destroy.call(this);
    },
    _initEvents: function () {
        if (this.timeSpinner) this.timeSpinner.on('valuechanged', this.__OnTimeChanged, this);
        mini._BindEvents(function () {
            mini.on(this.el, 'click', this.__OnClick, this);
            mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
            mini.on(this.el, 'keydown', this.__OnKeyDown, this);
        }, this);
    },
    getDateEl: function (date) {
        if (!date) return null;
        var id = this.uid + '_' + mini.clearTime(date)?.getTime();
        return document.getElementById(id);
    },
    within: function (e) {
        if (mini.isAncestor(this.el, e.target)) return true;
        if (this.menuEl && mini.isAncestor(this.menuEl, e.target)) return true;
        return false;
    },

    setShowHeader: function (value) {
        this.showHeader = value;
        this.invalidate();
    },
    getShowHeader: function () {
        return this.showHeader;
    },
    setShowFooter: function (value) {
        this.showFooter = value;
        this.invalidate();
    },
    getShowFooter: function () {
        return this.showFooter;
    },
    setShowWeekNumber: function (value) {
        this.showWeekNumber = value;
        this.invalidate();
    },
    getShowWeekNumber: function () {
        return this.showWeekNumber;
    },
    setShowDaysHeader: function (value) {
        this.showDaysHeader = value;
        this.invalidate();
    },
    getShowDaysHeader: function () {
        return this.showDaysHeader;
    },
    setShowMonthButtons: function (value) {
        this.showMonthButtons = value;
        this.invalidate();
    },
    getShowMonthButtons: function () {
        return this.showMonthButtons;
    },
    setShowYearButtons: function (value) {
        this.showYearButtons = value;
        this.invalidate();
    },
    getShowYearButtons: function () {
        return this.showYearButtons;
    },
    setShowTodayButton: function (value) {
        this.showTodayButton = value;
        this.todayButtonEl.style.display = this.showTodayButton ? '' : 'none';
        this.invalidate();
    },
    getShowTodayButton: function () {
        return this.showTodayButton;
    },
    setShowClearButton: function (value) {
        this.showClearButton = value;
        this.closeButtonEl.style.display = this.showClearButton ? '' : 'none';
        this.invalidate();
    },
    getShowClearButton: function () {
        return this.showClearButton;
    },
    setShowOkButton: function (value) {
        this.showOkButton = value;
        this.okButtonEl.style.display = this.showOkButton ? '' : 'none';
        this.invalidate();
    },
    getShowOkButton: function () {
        return this.showOkButton;
    },

    setViewDate: function (value) {
        value = mini.parseDate(value);
        if (!value) value = new Date();
        if (mini.isDate(value)) value = new Date(value?.getTime());
        this.viewDate = value;
        this.invalidate();
    },
    getViewDate: function () {
        return this.viewDate;
    },
    setSelectedDate: function (value) {
        value = mini.parseDate(value);
        if (!mini.isDate(value)) value = '';
        else value = new Date(value?.getTime());

        var dateEl = this.getDateEl(this._selectedDate);
        if (dateEl) mini.removeClass(dateEl, this._selectedDateCls);

        this._selectedDate = value;
        if (this._selectedDate) this._selectedDate = mini.cloneDate(this._selectedDate);

        var dateEl = this.getDateEl(this._selectedDate);
        if (dateEl) mini.addClass(dateEl, this._selectedDateCls);

        this.fire('datechanged');
    },
    setSelectedDates: function (value) {
        if (!mini.isArray(value)) value = [];
        this._selectedDates = value;
        this.invalidate();
    },
    getSelectedDate: function () {
        return this._selectedDate ? this._selectedDate : '';
    },
    setTime: function (time) {
        this.timeSpinner.setValue(time);
    },
    getTime: function () {
        return this.timeSpinner.getFormValue();
    },
    setValue: function (value) {
        this.setSelectedDate(value);
        if (!value) {
            value = new Date();
        }
        this.setTime(value);
    },
    getValue: function () {
        var d = this._selectedDate;
        if (d) {
            d = mini.clearTime(d);
            if (this.showTime) {
                var d2 = this.timeSpinner.getValue();
                d?.setHours(d2?.getHours());
                d?.setMinutes(d2?.getMinutes());
                d?.setSeconds(d2?.getSeconds());
            }
        }
        return d ? d : '';
    },
    getFormValue: function () {
        var d = this.getValue();
        if (d) return mini.formatDate(d, 'yyyy-MM-dd HH:mm:ss');
        return '';
    },
    isSelectedDate: function (date) {
        if (!date || !this._selectedDate) return false;
        return mini.clearTime(date)?.getTime() == mini.clearTime(this._selectedDate)?.getTime();
    },
    setMultiSelect: function (value) {
        this.multiSelect = value;
        this.invalidate();
    },
    getMultiSelect: function () {
        return this.multiSelect;
    },
    setRows: function (value) {
        if (isNaN(value)) return;
        if (value < 1) value = 1;
        this.rows = value;
        this.invalidate();
    },
    getRows: function () {
        return this.rows;
    },
    setColumns: function (value) {
        if (isNaN(value)) return;
        if (value < 1) value = 1;
        this.columns = value;
        this.invalidate();
    },
    getColumns: function () {
        return this.columns;
    },
    setShowTime: function (value) {
        if (this.showTime != value) {
            this.showTime = value;
            this.timeWrapEl.style.display = this.showTime ? '' : 'none';
            this.invalidate();
        }
    },
    getShowTime: function () {
        return this.showTime;
    },
    setTimeFormat: function (value) {
        if (this.timeFormat != value) {
            this.timeSpinner.setFormat(value);
            this.timeFormat = this.timeSpinner.format;
        }
    },
    getTimeFormat: function () {
        return this.timeFormat;
    },
    doLayout: function () {
        this.timeWrapEl.style.display = this.showTime ? '' : 'none';
        this.todayButtonEl.style.display = this.showTodayButton ? '' : 'none';
        this.closeButtonEl.style.display = this.showClearButton ? '' : 'none';

        this.okButtonEl.style.display = this.showOkButton ? '' : 'none';
        this.footerSpaceEl.style.display = this.showClearButton && this.showTodayButton ? '' : 'none';

        this._footerEl.style.display = this.showFooter ? '' : 'none';

        var views = this._innerEl.firstChild;
        if (views) {
            var autoHeight = this.isAutoHeight();
            if (!autoHeight) {
                views.parentNode.style.height = '100px';
                h = jQuery(this.el).height();

                h -= jQuery(this._footerEl).outerHeight();

                views.parentNode.style.height = h + 'px';
            } else {
                views.parentNode.style.height = '';
            }
        }
    },

    refresh: function () {
        var viewDate = new Date(this.viewDate?.getTime());
        var isOne = this.rows == 1 && this.columns == 1;
        var h = 100 / this.rows;
        var s = '<table class="mini-calendar-views" border="0" cellpadding="0" cellspacing="0">';
        for (var i = 0, l = this.rows; i < l; i++) {
            s += '<tr >';
            for (var j = 0, k = this.columns; j < k; j++) {
                s += '<td style="height:' + h + '%">';

                s += this._CreateView(viewDate, i, j);

                s += '</td>';

                viewDate = new Date(viewDate?.getFullYear(), viewDate?.getMonth() + 1, 1);
            }
            s += '</tr>';
        }

        s += '</table>';
        this._innerEl.innerHTML = s;
    },

    _CreateView: function (viewDate, row, column) {
        var month = viewDate?.getMonth();
        var date = this.getFirstDateOfMonth(viewDate);
        var firstDateOfWeek = new Date(date?.getTime());
        var todayTime = mini.clearTime(new Date())?.getTime();
        var selectedTime = this.value ? mini.clearTime(this.value)?.getTime() : -1;

        var multiView = this.rows > 1 || this.columns > 1;

        var s = '';
        s += '<table class="mini-calendar-view" border="0" cellpadding="0" cellspacing="0">';

        if (this.showHeader) {
            s += '<tr ><td colSpan="10" class="mini-calendar-header"><div class="mini-calendar-headerInner">';
            if (row == 0 && column == 0) {
                s += '<div class="mini-calendar-prev">';
                if (this.showYearButtons) s += '<span class="mini-calendar-yearPrev"></span>';
                if (this.showMonthButtons) s += '<span class="mini-calendar-monthPrev"></span>';
                s += '</div>';
            }
            if (row == 0 && column == this.columns - 1) {
                s += '<div class="mini-calendar-next">';
                if (this.showMonthButtons) s += '<span class="mini-calendar-monthNext"></span>';
                if (this.showYearButtons) s += '<span class="mini-calendar-yearNext"></span>';
                s += '</div>';
            }
            s += '<span class="mini-calendar-title">' + mini.formatDate(viewDate, this.format);
            +'</span>';
            s += '</div></td></tr>';
        }

        if (this.showDaysHeader) {
            s += '<tr class="mini-calendar-daysheader"><td class="mini-calendar-space"></td>';
            if (this.showWeekNumber) {
                s += '<td sclass="mini-calendar-weeknumber"></td>';
            }

            for (var j = this.firstDayOfWeek, k = j + 7; j < k; j++) {
                var name = this.getShortWeek(j);
                s += '<td yAlign="middle">';
                s += name;
                s += '</td>';
                date = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate() + 1);
            }
            s += '<td class="mini-calendar-space"></td></tr>';
        }

        date = firstDateOfWeek;
        for (var i = 0; i <= 5; i++) {
            s += '<tr class="mini-calendar-days"><td class="mini-calendar-space"></td>';
            if (this.showWeekNumber) {
                var num = mini.getWeek(date?.getFullYear(), date?.getMonth() + 1, date?.getDate());
                if (String(num).length == 1) num = '0' + num;
                s += '<td class="mini-calendar-weeknumber" yAlign="middle">' + num + '</td>';
            }
            for (var j = this.firstDayOfWeek, k = j + 7; j < k; j++) {
                var weekend = this.isWeekend(date);
                var clearTime = mini.clearTime(date)?.getTime();
                var isToday = clearTime == todayTime;
                var isSelected = this.isSelectedDate(date);

                if (month != date?.getMonth() && multiView) {
                    clearTime = -1;
                }

                var e = this._OnDrawDate(date);

                s += '<td yAlign="middle" id="';
                s += this.uid + '_' + clearTime;
                s += '" class="mini-calendar-date ';
                if (weekend) {
                    s += ' mini-calendar-weekend ';
                }
                if (e.allowSelect == false) {
                    s += ' mini-calendar-disabled ';
                }

                if (e.dateCls) {
                    s += ' ' + e.dateCls;
                }

                if (month != date?.getMonth() && multiView) {
                } else {
                    if (isSelected) {
                        s += ' ' + this._selectedDateCls + ' ';
                    }
                    if (isToday) {
                        s += ' mini-calendar-today ';
                    }
                }
                if (month != date?.getMonth()) {
                    s += ' mini-calendar-othermonth ';
                }
                s += '">';

                if (month != date?.getMonth() && multiView) {
                } else {
                    s += e.dateHtml;
                }
                s += '</td>';

                date = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate() + 1);
            }
            s += '<td class="mini-calendar-space"></td></tr>';
        }
        s += '<tr class="mini-calendar-bottom" colSpan="10"><td ></td></tr>';

        s += '</table>';
        return s;
    },
    _OnDrawDate: function (date) {
        var e = {
            date: date,
            dateCls: '',
            dateStyle: '',
            dateHtml: date?.getDate(),
            allowSelect: true
        };
        this.fire('drawdate', e);
        return e;
    },
    _OnDateClick: function (date, action) {
        var e = { date: date, action: action };
        this.fire('dateclick', e);

        this._OnValueChanged();
    },

    menuEl: null,
    menuYear: null,
    menuSelectMonth: null,
    menuSelectYear: null,
    showMenu: function (el) {
        if (!el) return;
        this.hideMenu();

        this.menuYear = parseInt(this.viewDate?.getFullYear() / 10) * 10;
        this._menuselectMonth = this.viewDate?.getMonth();
        this._menuselectYear = this.viewDate?.getFullYear();

        var s = '<div class="mini-calendar-menu"></div>';
        this.menuEl = mini.append(document.body, s);
        this.updateMenu(this.viewDate);

        var box = this.getBox();

        if (this.el.style.borderWidth == '0px') {
        }

        box.width += 1;
        box.height += 1;
        mini.setBox(this.menuEl, box);

        mini.on(this.menuEl, 'click', this.__OnMenuClick, this);
        mini.on(document, 'mousedown', this.__OnBodyMenuMouseDown, this);
    },
    hideMenu: function () {
        if (this.menuEl) {
            mini.un(this.menuEl, 'click', this.__OnMenuClick, this);
            mini.un(document, 'mousedown', this.__OnBodyMenuMouseDown, this);
            jQuery(this.menuEl).remove();
            this.menuEl = null;
        }
    },
    updateMenu: function () {
        var s = '<div class="mini-calendar-menu-months">';
        for (var i = 0, l = 12; i < l; i++) {
            var text = mini.getShortMonth(i);
            var cls = '';
            if (this._menuselectMonth == i) cls = 'mini-calendar-menu-selected';
            s +=
                '<a id="' +
                i +
                '" class="mini-calendar-menu-month ' +
                cls +
                '" href="javascript:void(0);" hideFocus onclick="return false">' +
                text +
                '</a>';
        }
        s += '<div style="clear:both;"></div></div>';

        s += '<div class="mini-calendar-menu-years">';
        for (var i = this.menuYear, l = this.menuYear + 10; i < l; i++) {
            var text = i;
            var cls = '';
            if (this._menuselectYear == i) cls = 'mini-calendar-menu-selected';
            s +=
                '<a id="' +
                i +
                '" class="mini-calendar-menu-year ' +
                cls +
                '" href="javascript:void(0);" hideFocus onclick="return false">' +
                text +
                '</a>';
        }
        s +=
            '<div class="mini-calendar-menu-prevYear"></div><div class="mini-calendar-menu-nextYear"></div><div style="clear:both;"></div></div>';

        s +=
            '<div class="mini-calendar-footer">' +
            '<span class="mini-calendar-okButton">' +
            this.okText +
            '</span>' +
            '<span class="mini-calendar-footerSpace"></span>' +
            '<span class="mini-calendar-cancelButton">' +
            this.cancelText +
            '</span>' +
            '</div><div style="clear:both;"></div>';

        this.menuEl.innerHTML = s;
    },
    __OnMenuClick: function (e) {
        var t = e.target;
        var monthEl = mini.findParent(t, 'mini-calendar-menu-month');
        var yearEl = mini.findParent(t, 'mini-calendar-menu-year');
        if (monthEl) {
            this._menuselectMonth = parseInt(monthEl.id);
            this.updateMenu();
        } else if (yearEl) {
            this._menuselectYear = parseInt(yearEl.id);
            this.updateMenu();
        } else if (mini.findParent(t, 'mini-calendar-menu-prevYear')) {
            this.menuYear = this.menuYear - 1;
            this.menuYear = parseInt(this.menuYear / 10) * 10;
            this.updateMenu();
        } else if (mini.findParent(t, 'mini-calendar-menu-nextYear')) {
            this.menuYear = this.menuYear + 11;
            this.menuYear = parseInt(this.menuYear / 10) * 10;
            this.updateMenu();
        } else if (mini.findParent(t, 'mini-calendar-okButton')) {
            var date = new Date(this._menuselectYear, this._menuselectMonth, 1);
            this.setViewDate(date);
            this.hideMenu();
        } else if (mini.findParent(t, 'mini-calendar-cancelButton')) {
            this.hideMenu();
        }
    },
    __OnBodyMenuMouseDown: function (e) {
        if (!mini.findParent(e.target, 'mini-calendar-menu')) {
            this.hideMenu();
        }
    },

    __OnClick: function (e) {
        var viewDate = this.viewDate;
        if (this.enabled == false) return;
        var t = e.target;
        var titleEl = mini.findParent(e.target, 'mini-calendar-title');

        if (mini.findParent(t, 'mini-calendar-monthNext')) {
            viewDate?.setDate(1);
            viewDate?.setMonth(viewDate?.getMonth() + 1);
            this.setViewDate(viewDate);
        } else if (mini.findParent(t, 'mini-calendar-yearNext')) {
            viewDate?.setFullYear(viewDate?.getFullYear() + 1);
            this.setViewDate(viewDate);
        } else if (mini.findParent(t, 'mini-calendar-monthPrev')) {
            viewDate?.setDate(1);
            viewDate?.setMonth(viewDate?.getMonth() - 1);
            this.setViewDate(viewDate);
        } else if (mini.findParent(t, 'mini-calendar-yearPrev')) {
            viewDate?.setFullYear(viewDate?.getFullYear() - 1);
            this.setViewDate(viewDate);
        } else if (mini.findParent(t, 'mini-calendar-tadayButton')) {
            var d = new Date();
            this.setViewDate(d);
            this.setSelectedDate(d);
            if (this.currentTime) {
                var td = new Date();
                this.setTime(td);
            }
            this._OnDateClick(d, 'today');
        } else if (mini.findParent(t, 'mini-calendar-clearButton')) {
            this.setSelectedDate(null);
            this.setTime(null);
            this._OnDateClick(null, 'clear');
        } else if (mini.findParent(t, 'mini-calendar-okButton')) {
            this._OnDateClick(null, 'ok');
        } else if (titleEl) {
            this.showMenu(titleEl);
        }

        var dateEl = mini.findParent(e.target, 'mini-calendar-date');

        if (dateEl && !mini.hasClass(dateEl, 'mini-calendar-disabled')) {
            var ids = dateEl.id.split('_');
            var time = parseInt(ids[ids.length - 1]);
            if (time == -1) return;
            var date = new Date(time);

            this._OnDateClick(date);
        }
    },
    __OnMouseDown: function (e) {
        if (this.enabled == false) return;
        var dateEl = mini.findParent(e.target, 'mini-calendar-date');
        if (dateEl && !mini.hasClass(dateEl, 'mini-calendar-disabled')) {
            var ids = dateEl.id.split('_');
            var time = parseInt(ids[ids.length - 1]);
            if (time == -1) return;
            var date = new Date(time);
            this.setSelectedDate(date);
        }
    },
    __OnTimeChanged: function (e) {
        this.fire('timechanged');
        this._OnValueChanged();
    },

    __OnKeyDown: function (e) {
        if (this.enabled == false) return;

        var date = this.getSelectedDate();
        if (!date) date = new Date(this.viewDate?.getTime());
        switch (e.keyCode) {
            case 27:
                break;
            case 13:
                break;
            case 37:
                date = mini.addDate(date, -1, 'D');
                break;
            case 38:
                date = mini.addDate(date, -7, 'D');
                break;
            case 39:
                date = mini.addDate(date, 1, 'D');
                break;
            case 40:
                date = mini.addDate(date, 7, 'D');
                break;
            default:
                break;
        }
        var me = this;

        if (date?.getMonth() != me.viewDate?.getMonth()) {
            me.setViewDate(mini.cloneDate(date));
            me.focus();
        }

        var dateEl = this.getDateEl(date);
        if (dateEl && mini.hasClass(dateEl, 'mini-calendar-disabled')) {
            return;
        }

        me.setSelectedDate(date);

        if (e.keyCode == 37 || e.keyCode == 38 || e.keyCode == 39 || e.keyCode == 40) {
            e.preventDefault();
        }
    },

    _OnValueChanged: function () {
        this.fire('valuechanged');
    },

    getAttrs: function (el) {
        var attrs = mini.Calendar.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'viewDate',
            'rows',
            'columns',
            'ondateclick',
            'ondrawdate',
            'ondatechanged',
            'timeFormat',
            'ontimechanged',
            'onvaluechanged'
        ]);
        mini._ParseBool(el, attrs, [
            'multiSelect',
            'showHeader',
            'showFooter',
            'showWeekNumber',
            'showDaysHeader',
            'showMonthButtons',
            'showYearButtons',
            'showTodayButton',
            'showClearButton',
            'showTime',
            'showOkButton'
        ]);

        return attrs;
    }
});
mini.regClass(mini.Calendar, 'calendar');

mini.Field = mini.ValidatorBase.extend({
    formField: true,

    props: {
        defaultValue: null,
        value: null,
        label: ''
    },

    set: function (options) {
        options = mini.apply({}, options);

        var value = options.value;
        delete options.value;
        var text = options.text;
        delete options.text;

        this.callParent('set', options);

        if (value !== undefined) {
            this.setValue(value);
        }
        if (text !== undefined) {
            if (this.setText) this.setText(text);
            else this.text = text;
        }

        return this;
    }
});
mini.TextBox = mini.Field.extend({
    type: 'textbox',
    tag: 'mini-textbox',

    props: {
        name: '',
        selectOnFocus: false,
        minWidth: 10,
        minHeight: 15,
        maxLength: 5000,
        emptyText: '',
        text: '',
        value: '',
        defaultValue: '',

        height: 22
    },

    emptyCls: 'mini-textbox-empty',
    focusCls: 'mini-textbox-focus',
    disabledCls: 'mini-textbox-disabled',
    inputType: 'text',

    _create: function () {
        var html = '<input  type="' + this.inputType + '" class="mini-textbox-input" autocomplete="off"/>';
        if (this.inputType == 'textarea') {
            html = '<textarea  class="mini-textbox-input" autocomplete="off"/></textarea>';
        }
        html = '<span class="mini-textbox-border">' + html + '</span>';
        html += '<input type="hidden"/>';

        this.el = document.createElement('span');
        this.el.className = 'mini-textbox';
        this.el.innerHTML = html;
        this._borderEl = this.el.firstChild;
        this._textEl = this._borderEl.firstChild;
        this._valueEl = this._borderEl.lastChild;

        this._doEmpty();
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini_onOne(this._textEl, 'drop', this.__OnDropText, this);
            mini_onOne(this._textEl, 'change', this.__OnInputTextChanged, this);
            mini_onOne(this._textEl, 'focus', this.__OnFocus, this);
            mini_onOne(this.el, 'mousedown', this.__OnMouseDown, this);

            var v = this.value;
            this.value = null;
            this.setValue(v);
        }, this);
        this.on('validation', this.__OnValidation, this);
    },
    _inputEventsInited: false,
    _initInputEvents: function () {
        if (this._inputEventsInited) return;
        this._inputEventsInited = true;

        mini.on(this._textEl, 'blur', this.__OnBlur, this);
        mini.on(this._textEl, 'keydown', this.__OnInputKeyDown, this);
        mini.on(this._textEl, 'keyup', this.__OnInputKeyUp, this);
        mini.on(this._textEl, 'keypress', this.__OnInputKeyPress, this);
    },
    destroy: function (removeEl) {
        if (this.el) {
            this.el.onmousedown = null;
        }
        if (this._textEl) {
            this._textEl.ondrop = null;
            this._textEl.onchange = null;
            this._textEl.onfocus = null;

            mini.clearEvent(this._textEl);
            this._textEl = null;
        }
        if (this._valueEl) {
            mini.clearEvent(this._valueEl);
            this._valueEl = null;
        }
        mini.TextBox.superclass.destroy.call(this, removeEl);
    },

    doLayout: function () {},

    setHeight: function (value) {
        if (parseInt(value) == value) value += 'px';
        this.height = value;
        if (this.inputType == 'textarea') {
            this.el.style.height = value;
            this.doLayout();
        }
    },
    setName: function (value) {
        if (this.name != value) {
            this.name = value;

            if (this._valueEl) mini.setAttr(this._valueEl, 'name', this.name);
        }
    },
    setValue: function (value) {
        if (value === null || value === undefined) value = '';
        value = String(value);
        if (value.length > this.maxLength) {
            value = value.substring(0, this.maxLength);
        }

        if (this.value !== value) {
            this.value = value;
            this._valueEl.value = this._textEl.value = value;
            this._doEmpty();
        }
    },
    getValue: function () {
        return this.value;
    },
    getFormValue: function () {
        value = this.value;
        if (value === null || value === undefined) value = '';
        return String(value);
    },
    updateAllowInput: function (value) {
        this.updateStatus();
    },
    getAllowInput: function () {
        return this.allowInput;
    },
    _placeholdered: false,
    _doEmpty: function () {
        this._textEl.placeholder = this.emptyText;
        if (this.emptyText) {
            mini._placeholder(this._textEl);
        }
    },
    updateEmptyText: function (value) {
        this._doEmpty();
    },
    getEmptyText: function () {
        return this.emptyText;
    },
    setMaxLength: function (value) {
        this.maxLength = value;

        mini.setAttr(this._textEl, 'maxLength', value);

        if (this.inputType == 'textarea' && mini.isIE) {
            mini.on(this._textEl, 'keypress', this.__OnMaxLengthKeyUp, this);
        }
    },
    __OnMaxLengthKeyUp: function (e) {
        if (this._textEl.value.length >= this.maxLength) {
            e.preventDefault();
        }
    },

    updateReadOnly: function (value) {
        this.updateStatus();
    },
    updateEnabled: function (value) {
        this.updateStatus();
    },
    updateStatus: function () {
        if (this.enabled) {
            this.removeCls(this.disabledCls);
        } else {
            this.addCls(this.disabledCls);
        }
        if (this.isReadOnly() || this.allowInput == false) {
            this._textEl.readOnly = true;
            mini.addClass(this.el, 'mini-textbox-readOnly');
        } else {
            this._textEl.readOnly = false;
            mini.removeClass(this.el, 'mini-textbox-readOnly');
        }
        if (this.required) {
            this.addCls(this.requiredCls);
        } else {
            this.removeCls(this.requiredCls);
        }

        if (this.enabled) {
            this._textEl.disabled = false;
        } else {
            this._textEl.disabled = true;
        }
    },
    focus: function () {
        try {
            this._textEl.focus();
        } catch (e) {}
    },
    blur: function () {
        try {
            this._textEl.blur();
        } catch (e) {}
    },
    selectText: function () {
        var me = this;
        function doSelect() {
            try {
                me._textEl.select();
            } catch (ex) {}
        }
        doSelect();
        setTimeout(function () {
            doSelect();
        }, 30);
    },
    getTextEl: function () {
        return this._textEl;
    },
    getInputText: function () {
        return this._textEl.value;
    },
    setSelectOnFocus: function (value) {
        this.selectOnFocus = value;
    },
    getSelectOnFocus: function (value) {
        return this.selectOnFocus;
    },

    _errorIconEl: null,
    getErrorIconEl: function () {
        if (!this._errorIconEl) {
            this._errorIconEl = mini.append(this.el, '<span class="mini-errorIcon"></span>');
        }
        return this._errorIconEl;
    },
    _RemoveErrorIcon: function () {
        if (this._errorIconEl) {
            var el = this._errorIconEl;
            jQuery(el).remove();
        }
        this._errorIconEl = null;
    },

    __OnMouseDown: function (e) {
        var sf = this;
        if (!mini.isAncestor(this._textEl, e.target)) {
            setTimeout(function () {
                sf.focus();
                mini.selectRange(sf._textEl, 1000, 1000);
            }, 1);
        } else {
            setTimeout(function () {
                try {
                    sf._textEl.focus();
                } catch (ex) {}
            }, 1);
        }
    },
    __OnInputTextChanged: function (e, valid) {
        var value = this.value;
        this.setValue(this._textEl.value);

        if (value !== this.getValue() || valid === true) {
            this._OnValueChanged();
        }
    },
    __OnDropText: function (e) {
        var me = this;
        setTimeout(function () {
            me.__OnInputTextChanged(e);
        }, 0);
    },
    __OnInputKeyDown: function (e) {
        var ex = { htmlEvent: e };
        this.fire('keydown', ex);

        if (e.keyCode == 8 && (this.isReadOnly() || this.allowInput == false)) {
            return false;
        }
        if (e.keyCode == 13 || e.keyCode == 9) {
            if (this.inputType == 'textarea' && e.keyCode == 13) {
            } else {
                this.__OnInputTextChanged(null, true);
                if (e.keyCode == 13) {
                    var me = this;

                    me.fire('enter', ex);
                }
            }
        }
        if (e.keyCode == 27) {
            e.preventDefault();
        }
    },
    __OnInputKeyUp: function (e) {
        this.fire('keyup', { htmlEvent: e });
    },
    __OnInputKeyPress: function (e) {
        this.fire('keypress', { htmlEvent: e });
    },
    __OnFocus: function (e) {
        this.updateStatus();

        if (this.isReadOnly()) {
            return;
        }
        this._focused = true;
        this.addCls(this.focusCls);
        this._initInputEvents();

        if (this.selectOnFocus) {
            this.selectText();
        }

        this.fire('focus', { htmlEvent: e });
    },
    __OnBlur: function (e) {
        this._focused = false;
        var sf = this;
        setTimeout(function () {
            if (sf._focused == false) {
                sf.removeCls(sf.focusCls);
            }
        }, 2);

        this.fire('blur', { htmlEvent: e });

        if (this.validateOnLeave) {
            this._tryValidate();
        }
    },
    inputStyle: '',
    setInputStyle: function (value) {
        this.inputStyle = value;
        mini.setStyle(this._textEl, value);
    },

    getAttrs: function (el) {
        var attrs = mini.TextBox.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        mini._ParseString(el, attrs, [
            'value',
            'text',
            'emptyText',
            'inputStyle',
            'onenter',
            'onkeydown',
            'onkeyup',
            'onkeypress',
            'maxLengthErrorText',
            'minLengthErrorText',
            'onfocus',
            'onblur',

            'vtype',
            'emailErrorText',
            'urlErrorText',
            'floatErrorText',
            'intErrorText',
            'dateErrorText',
            'minErrorText',
            'maxErrorText',
            'rangeLengthErrorText',
            'rangeErrorText',
            'rangeCharErrorText'
        ]);
        mini._ParseBool(el, attrs, ['allowInput', 'selectOnFocus']);
        mini._ParseInt(el, attrs, ['maxLength', 'minLength', 'minHeight', 'minWidth']);

        return attrs;
    },

    vtype: '',
    setVtype: function (value) {
        this.vtype = value;
    },
    getVtype: function () {
        return this.vtype;
    },
    __OnValidation: function (e) {
        if (e.isValid == false) return;
        mini._ValidateVType(this.vtype, e.value, e, this);
    },
    setEmailErrorText: function (value) {
        this.emailErrorText = value;
    },
    getEmailErrorText: function () {
        return this.emailErrorText;
    },
    setUrlErrorText: function (value) {
        this.urlErrorText = value;
    },
    getUrlErrorText: function () {
        return this.urlErrorText;
    },
    setFloatErrorText: function (value) {
        this.floatErrorText = value;
    },
    getFloatErrorText: function () {
        return this.floatErrorText;
    },
    setIntErrorText: function (value) {
        this.intErrorText = value;
    },
    getIntErrorText: function () {
        return this.intErrorText;
    },
    setDateErrorText: function (value) {
        this.dateErrorText = value;
    },
    getDateErrorText: function () {
        return this.dateErrorText;
    },
    setMaxLengthErrorText: function (value) {
        this.maxLengthErrorText = value;
    },
    getMaxLengthErrorText: function () {
        return this.maxLengthErrorText;
    },
    setMinLengthErrorText: function (value) {
        this.minLengthErrorText = value;
    },
    getMinLengthErrorText: function () {
        return this.minLengthErrorText;
    },
    setMaxErrorText: function (value) {
        this.maxErrorText = value;
    },
    getMaxErrorText: function () {
        return this.maxErrorText;
    },
    setMinErrorText: function (value) {
        this.minErrorText = value;
    },
    getMinErrorText: function () {
        return this.minErrorText;
    },
    setRangeLengthErrorText: function (value) {
        this.rangeLengthErrorText = value;
    },
    getRangeLengthErrorText: function () {
        return this.rangeLengthErrorText;
    },
    setRangeCharErrorText: function (value) {
        this.rangeCharErrorText = value;
    },
    getRangeCharErrorText: function () {
        return this.rangeCharErrorText;
    },
    setRangeErrorText: function (value) {
        this.rangeErrorText = value;
    },
    getRangeErrorText: function () {
        return this.rangeErrorText;
    }
});

mini.Password = mini.TextBox.extend({
    uiCls: 'mini-password',
    inputType: 'password',
    setEmptyText: function (value) {
        this.emptyText = '';
    }
});
mini.regClass(mini.Password, 'password');

mini.TextArea = mini.TextBox.extend({
    maxLength: 10000000,

    height: '',
    minHeight: 50,
    inputType: 'textarea',
    uiCls: 'mini-textarea',
    doLayout: function () {
        mini.TextArea.superclass.doLayout.call(this);

        var h = mini.getHeight(this.el);

        mini.setHeight(this._borderEl, h);

        h -= 2;
        if (h < 0) h = 0;
        this._textEl.style.height = h + 'px';
    }
});
mini.regClass(mini.TextArea, 'textarea');

mini.CheckBox = mini.Control.extend({
    type: 'checkbox',
    tag: 'mini-checkbox',

    formField: true,
    _clearText: false,

    props: {
        checked: false,
        value: false,

        text: '',
        defaultValue: false,

        trueValue: true,
        falseValue: false
    },

    _create: function () {
        var ckid = this.uid + '_check';
        this.el = document.createElement('span');
        this.el.className = 'mini-checkbox';
        this.el.innerHTML =
            '<input id="' +
            ckid +
            '" name="' +
            this.id +
            '" type="checkbox" class="mini-checkbox-check"><label for="' +
            ckid +
            '" onclick="return false;">' +
            this.text +
            '</label>';

        this._checkEl = this.el.firstChild;
        this._labelEl = this.el.lastChild;
    },
    destroy: function (removeEl) {
        if (this._checkEl) {
            this._checkEl.onmouseup = null;
            this._checkEl.onclick = null;
            this._checkEl = null;
        }
        mini.CheckBox.superclass.destroy.call(this, removeEl);
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini.on(this.el, 'click', this.__onClick, this);

            this._checkEl.onmouseup = function () {
                return false;
            };
            var sf = this;
            this._checkEl.onclick = function () {
                if (sf.isReadOnly()) return false;
            };
        }, this);
    },
    setName: function (value) {
        this.name = value;
        mini.setAttr(this._checkEl, 'name', this.name);
    },
    setText: function (value) {
        if (this.text !== value) {
            this.text = value;

            this._labelEl.innerHTML = value;
        }
    },
    getText: function () {
        return this.text;
    },
    setChecked: function (value) {
        if (value === true) value = true;
        else if (value == this.trueValue) value = true;
        else if (value == 'true') value = true;
        else if (value === 1) value = true;
        else if (value == 'Y') value = true;
        else value = false;

        if (this.checked !== value) {
            this.checked = !!value;
            this._checkEl.checked = this.checked;

            this.value = this.getValue();
        }
    },
    getChecked: function () {
        return this.checked;
    },
    setValue: function (value) {
        if (this.checked != value) {
            this.setChecked(value);
            this.value = this.getValue();
        }
    },
    getValue: function () {
        return this.checked == true ? this.trueValue : this.falseValue;
    },
    getFormValue: function () {
        return this.getValue();
    },
    setTrueValue: function (value) {
        this._checkEl.value = value;
        this.trueValue = value;
    },
    getTrueValue: function () {
        return this.trueValue;
    },
    setFalseValue: function (value) {
        this.falseValue = value;
    },
    getFalseValue: function () {
        return this.falseValue;
    },

    __onClick: function (e) {
        if (this.isReadOnly()) return;

        this.setChecked(!this.checked);

        this.fire('checkedchanged', { checked: this.checked });
        this.fire('valuechanged', { value: this.getValue() });
        this.fire('change', { value: this.getValue() });

        this.fire('click', e, this);
    },

    getAttrs: function (el) {
        var attrs = mini.CheckBox.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        mini._ParseString(el, attrs, ['text', 'oncheckedchanged', 'onclick', 'onvaluechanged']);

        mini._ParseBool(el, attrs, ['enabled']);

        var checked = mini.getAttr(el, 'checked');

        if (checked) {
            attrs.checked = checked == 'true' || checked == 'checked' ? true : false;
        }

        var trueValue = jq.attr('trueValue');
        if (trueValue) {
            attrs.trueValue = trueValue;
            trueValue = parseInt(trueValue);
            if (!isNaN(trueValue)) {
                attrs.trueValue = trueValue;
            }
        }
        var falseValue = jq.attr('falseValue');
        if (falseValue) {
            attrs.falseValue = falseValue;
            falseValue = parseInt(falseValue);
            if (!isNaN(falseValue)) {
                attrs.falseValue = falseValue;
            }
        }

        if (!attrs.text && el.innerHTML) {
            attrs.text = el.innerHTML;
        }

        return attrs;
    }
});

mini.ButtonEdit = mini.Field.extend({
    type: 'buttonedit',
    tag: 'mini-buttonedit',

    props: {
        name: '',
        textName: '',
        selectOnFocus: false,
        showClose: false,
        emptyText: '',
        defaultValue: '',
        value: '',
        text: '',
        maxLength: 1000,
        minLength: 0,

        height: 21,
        inputAsValue: false,
        editable: true,
        allowInput: true
    },

    noInputCls: 'mini-buttonedit-noInput',
    readOnlyCls: 'mini-buttonedit-readOnly',
    disabledCls: 'mini-buttonedit-disabled',
    emptyCls: 'mini-buttonedit-empty',
    focusCls: 'mini-buttonedit-focus',

    buttonCls: 'mini-buttonedit-button',
    buttonHoverCls: 'mini-buttonedit-button-hover',
    buttonPressedCls: 'mini-buttonedit-button-pressed',
    closeCls: 'mini-buttonedit-close',

    initComponent: function () {
        this.callParent('initComponent');

        var isReadOnly = this.isReadOnly();
        if (isReadOnly || this.allowInput == false) {
            this._textEl.readOnly = true;
        }
        if (this.enabled == false) {
            this.addCls(this.disabledCls);
        }
        if (isReadOnly) {
            this.addCls(this.readOnlyCls);
        }
        if (this.required) {
            this.addCls(this.requiredCls);
        }
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var value = kv.value;
        delete kv.value;
        var text = kv.text;
        delete kv.text;

        this._allowUpdate = !(kv.enabled == false || kv.allowInput == false || kv.readOnly);

        this.callParent('set', kv);

        if (this._allowUpdate === false) {
            this._allowUpdate = true;
            this.doUpdate();
        }

        if (!mini.isNull(text)) {
            this.setText(text);
        }
        if (!mini.isNull(value)) {
            this.setValue(value);
        }

        if (kv.editable != null && kv.allowInput == null) {
            this.setAllowInput(kv.editable);
        }

        return this;
    },

    _getButtonsHTML: function () {
        var s = '<span class="mini-buttonedit-close"></span>' + this._getButtonHtml();
        return '<span class="mini-buttonedit-buttons">' + s + '</span>';
    },
    _getButtonHtml: function () {
        var hover = '';
        return '<span class="mini-buttonedit-button" ' + hover + '><span class="mini-buttonedit-icon"></span></span>';
    },
    _create: function () {
        this.el = document.createElement('span');
        this.el.className = 'mini-buttonedit';

        var s = this._getButtonsHTML();
        this.el.innerHTML =
            '<span class="mini-buttonedit-border"><input type="input" class="mini-buttonedit-input" autocomplete="off"/>' +
            s +
            '</span><input name="' +
            this.name +
            '" type="hidden"/>';

        this._borderEl = this.el.firstChild;
        this._textEl = this._borderEl.firstChild;
        this._valueEl = this.el.lastChild;

        this._buttonsEl = this._borderEl.lastChild;
        this._buttonEl = this._buttonsEl.lastChild;
        this._closeEl = this._buttonEl.previousSibling;

        this._doEmpty();
    },
    destroy: function (removeEl) {
        if (this.el) {
            this.el.onmousedown = null;
            this.el.onmousewheel = null;
            this.el.onmouseover = null;
            this.el.onmouseout = null;
        }
        if (this._textEl) {
            this._textEl.onchange = null;
            this._textEl.onfocus = null;

            mini.clearEvent(this._textEl);

            this._textEl = null;
        }
        mini.ButtonEdit.superclass.destroy.call(this, removeEl);
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini_onOne(this.el, 'mousedown', this.__OnMouseDown, this);
            mini_onOne(this._textEl, 'focus', this.__OnFocus, this);
            mini_onOne(this._textEl, 'change', this.__OnInputTextChanged, this);

            var me = this;
            var jq = jQuery('.mini-buttonedit-button', this.el);
            jq.on('mouseenter', function (event) {
                $(this).addClass(me.buttonHoverCls);
            });
            jq.on('mouseleave', function (event) {
                $(this).removeClass(me.buttonHoverCls);
            });

            var v = this.text;
            this.text = null;
            this.setText(v);
        }, this);
    },
    _inputEventsInited: false,
    _initInputEvents: function () {
        if (this._inputEventsInited) return;
        this._inputEventsInited = true;

        mini.on(this.el, 'click', this.__OnClick, this);
        mini.on(this._textEl, 'blur', this.__OnBlur, this);
        mini.on(this._textEl, 'keydown', this.__OnInputKeyDown, this);
        mini.on(this._textEl, 'keyup', this.__OnInputKeyUp, this);
        mini.on(this._textEl, 'keypress', this.__OnInputKeyPress, this);
    },
    _buttonWidth: 20,
    _closeWidth: 20,
    _doInputLayout: function (doLayout) {
        if (this._closeEl) {
            this._closeEl.style.display = this.showClose ? 'inline-block' : 'none';
        }
        var w = this._buttonsEl.offsetWidth + 2;
        if (w == 2) {
            this._noLayout = true;
        } else {
            this._noLayout = false;
        }
        this._borderEl.style['paddingRight'] = w + 'px';
        if (doLayout !== false) {
            this.doLayout();
        }
    },
    doLayout: function () {
        if (this._noLayout) {
            this._doInputLayout(false);
        }
    },
    setHeight: function (value) {
        if (parseInt(value) == value) value += 'px';
        this.height = value;
    },
    focus: function () {
        try {
            this._textEl.focus();
            var sf = this;
            setTimeout(function () {
                if (sf._focused) {
                    sf._textEl.focus();
                }
            }, 10);
        } catch (e) {}
    },
    blur: function () {
        try {
            this._textEl.blur();
        } catch (e) {}
    },
    selectText: function () {
        this._textEl.select();
    },

    getTextEl: function () {
        return this._textEl;
    },
    setName: function (value) {
        this.name = value;

        if (this._valueEl) mini.setAttr(this._valueEl, 'name', this.name);
    },
    setText: function (value) {
        if (value === null || value === undefined) value = '';
        var fire = this.text !== value;
        this.text = value;
        this._textEl.value = value;
        this._doEmpty();
    },
    getText: function () {
        var text = this._textEl.value;
        return text;
    },

    setValue: function (value) {
        if (value === null || value === undefined) value = '';
        var fire = this.value !== value;
        this.value = value;
        this._valueEl.value = this.getFormValue();
    },
    getValue: function () {
        return this.value;
    },
    getFormValue: function () {
        value = this.value;
        if (value === null || value === undefined) value = '';
        return String(value);
    },

    _doEmpty: function () {
        this._textEl.placeholder = this.emptyText;
        if (this.emptyText) {
            mini._placeholder(this._textEl);
        }
    },
    setEmptyText: function (value) {
        if (this.emptyText != value) {
            this.emptyText = value;
            this._doEmpty();
        }
    },
    getEmptyText: function () {
        return this.emptyText;
    },

    setMaxLength: function (value) {
        value = parseInt(value);
        if (isNaN(value)) return;
        this.maxLength = value;
        this._textEl.maxLength = value;
    },
    getMaxLength: function () {
        return this.maxLength;
    },
    setMinLength: function (value) {
        value = parseInt(value);
        if (isNaN(value)) return;
        this.minLength = value;
    },
    getMinLength: function () {
        return this.minLength;
    },

    _doReadOnly: function () {
        var readOnly = this.isReadOnly();
        if (readOnly || this.allowInput == false) {
            this._textEl.readOnly = true;
        } else {
            this._textEl.readOnly = false;
        }
        if (readOnly) {
            this.addCls(this.readOnlyCls);
        } else {
            this.removeCls(this.readOnlyCls);
        }
        if (this.allowInput) {
            this.removeCls(this.noInputCls);
        } else {
            this.addCls(this.noInputCls);
        }

        if (this.enabled) {
            this._textEl.disabled = false;
        } else {
            this._textEl.disabled = true;
        }
    },
    updateAllowInput: function (value) {
        this._doReadOnly();
    },

    _errorIconEl: null,
    getErrorIconEl: function () {
        if (!this._errorIconEl) {
            this._errorIconEl = mini.append(this.el, '<span class="mini-errorIcon"></span>');
        }
        return this._errorIconEl;
    },
    _RemoveErrorIcon: function () {
        if (this._errorIconEl) {
            var el = this._errorIconEl;
            jQuery(el).remove();
        }
        this._errorIconEl = null;
    },

    __OnClick: function (e) {
        if (this.isReadOnly() || this.enabled == false) return;

        if (!mini.isAncestor(this._borderEl, e.target)) return;

        var t = new Date();

        if (mini.isAncestor(this._buttonEl, e.target)) {
            this._OnButtonClick(e);
        }
        if (mini.findParent(e.target, this.closeCls)) {
            this.fire('closeclick', { htmlEvent: e });
        }
    },
    __OnMouseDown: function (e) {
        if (this.isReadOnly() || this.enabled == false) return;

        if (!mini.isAncestor(this._borderEl, e.target)) return;

        if (!mini.isAncestor(this._textEl, e.target)) {
            this._clickTarget = e.target;
            var sf = this;
            setTimeout(function () {
                sf.focus();
                mini.selectRange(sf._textEl, 1000, 1000);
            }, 1);
            if (mini.isAncestor(this._buttonEl, e.target)) {
                var up = mini.findParent(e.target, 'mini-buttonedit-up');
                var down = mini.findParent(e.target, 'mini-buttonedit-down');
                if (up) {
                    mini.addClass(up, this.buttonPressedCls);
                    this._OnButtonMouseDown(e, 'up');
                } else if (down) {
                    mini.addClass(down, this.buttonPressedCls);
                    this._OnButtonMouseDown(e, 'down');
                } else {
                    mini.addClass(this._buttonEl, this.buttonPressedCls);
                    this._OnButtonMouseDown(e);
                }
                mini.on(document, 'mouseup', this.__OnDocMouseUp, this);
            }
        }
    },
    __OnDocMouseUp: function (e) {
        this._clickTarget = null;

        var me = this;
        setTimeout(function () {
            var doms = me._buttonEl.getElementsByTagName('*');
            for (var i = 0, l = doms.length; i < l; i++) {
                mini.removeClass(doms[i], me.buttonPressedCls);
            }
            mini.removeClass(me._buttonEl, me.buttonPressedCls);
            mini.removeClass(me.el, me._pressedCls);
        }, 80);
        mini.un(document, 'mouseup', this.__OnDocMouseUp, this);
    },
    __OnFocus: function (e) {
        this.doUpdate();
        this._initInputEvents();
        if (this.isReadOnly()) return;

        this._focused = true;
        this.addCls(this.focusCls);

        if (this.selectOnFocus) {
            this.selectText();
        }
        this.fire('focus', { htmlEvent: e });
    },
    __doFocusCls: function () {
        if (this._focused == false) {
            this.removeCls(this.focusCls);
        }
    },

    __fireBlur: function (e) {
        this._focused = false;
        var sf = this;

        function f() {
            sf.__doFocusCls();
        }
        setTimeout(function () {
            f.call(sf);
        }, 2);

        this.fire('blur', { htmlEvent: e });
    },
    __OnBlur: function (e) {
        this._focused = false;
        var me = this;
        setTimeout(function () {
            me.__fireBlur(e);
        }, 10);
    },
    __OnInputKeyDown: function (e) {
        var ex = { htmlEvent: e };
        this.fire('keydown', ex);
        if (e.keyCode == 8 && (this.isReadOnly() || this.allowInput == false)) {
            return false;
        }
        if (e.keyCode == 13 || e.keyCode == 9) {
            var sf = this;
            sf.__OnInputTextChanged(null);
            if (e.keyCode == 13) {
                var me = this;

                me.fire('enter', ex);
            }
        }
        if (e.keyCode == 27) {
            e.preventDefault();
        }
    },
    __OnInputTextChanged: function () {
        var v = this._textEl.value;
        if (v == this.text) return;

        var value = this.getValue();

        this.setValue(v);
        if (value !== this.getFormValue()) {
            this._OnValueChanged();
        }
    },
    __OnInputKeyUp: function (e) {
        this.fire('keyup', { htmlEvent: e });
    },
    __OnInputKeyPress: function (e) {
        this.fire('keypress', { htmlEvent: e });
    },

    _OnButtonClick: function (htmlEvent) {
        var e = {
            htmlEvent: htmlEvent,
            cancel: false
        };
        this.fire('beforebuttonclick', e);
        if (e.cancel == true) return;

        this.fire('buttonclick', e);
    },
    _OnButtonMouseDown: function (htmlEvent, spinType) {
        this.focus();
        this.addCls(this.focusCls);

        this.fire('buttonmousedown', {
            htmlEvent: htmlEvent,
            spinType: spinType
        });
    },

    onButtonClick: function (fn, scope) {
        this.on('buttonclick', fn, scope);
    },
    onButtonMouseDown: function (fn, scope) {
        this.on('buttonmousedown', fn, scope);
    },
    onTextChanged: function (fn, scope) {
        this.on('textchanged', fn, scope);
    },

    setTextName: function (value) {
        this.textName = value;
        if (this._textEl) mini.setAttr(this._textEl, 'name', this.textName);
    },
    getTextName: function () {
        return this.textName;
    },

    setSelectOnFocus: function (value) {
        this.selectOnFocus = value;
    },
    getSelectOnFocus: function (value) {
        return this.selectOnFocus;
    },
    setShowClose: function (value) {
        this.showClose = value;
        this._doInputLayout();
    },
    getShowClose: function (value) {
        return this.showClose;
    },
    inputStyle: '',
    setInputStyle: function (value) {
        this.inputStyle = value;
        mini.setStyle(this._textEl, value);
    },

    getAttrs: function (el) {
        var attrs = mini.ButtonEdit.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        mini._ParseString(el, attrs, [
            'value',
            'text',
            'textName',
            'emptyText',
            'inputStyle',
            'defaultText',
            'onenter',
            'onkeydown',
            'onkeyup',
            'onkeypress',
            'onbuttonclick',
            'onbuttonmousedown',
            'ontextchanged',
            'onfocus',
            'onblur',
            'oncloseclick'
        ]);
        mini._ParseBool(el, attrs, ['allowInput', 'inputAsValue', 'selectOnFocus', 'showClose']);
        mini._ParseInt(el, attrs, ['maxLength', 'minLength']);

        return attrs;
    }
});
mini.regClass(mini.ButtonEdit, 'buttonedit');
mini.PopupEdit = mini.ButtonEdit.extend({
    uiCls: 'mini-popupedit',

    popup: null,

    popupCls: 'mini-buttonedit-popup',

    hoverCls: 'mini-buttonedit-hover',
    pressedCls: 'mini-buttonedit-pressed',

    initComponent: function () {
        this.callParent('initComponent');
        this._createPopup();
        this.el.className += ' mini-popupedit';
    },

    _destroyPopup: true,
    destroy: function (removeEl) {
        if (this.isShowPopup()) {
            this.hidePopup();
        }
        if (this.popup) {
            if (this._destroyPopup) {
                this.popup.destroy();
            }
            this.popup = null;
        }
        if (this._popupInner) {
            this._popupInner.owner = null;
            this._popupInner = null;
        }
        mini.PopupEdit.superclass.destroy.call(this, removeEl);
    },
    _initEvents: function () {
        mini.PopupEdit.superclass._initEvents.call(this);

        mini._BindEvents(function () {
            mini_onOne(this.el, 'mouseover', this.__OnMouseOver, this);
            mini_onOne(this.el, 'mouseout', this.__OnMouseOut, this);
        }, this);
    },
    _initButtons: function () {
        this.buttons = [];

        var button = this.createButton({
            cls: 'mini-buttonedit-popup',
            iconCls: 'mini-buttonedit-icons-popup',
            name: 'popup'
        });
        this.buttons.push(button);
    },
    __OnBlur: function (e) {
        this._focused = false;
        if (this._clickTarget && mini.isAncestor(this.el, this._clickTarget)) return;
        if (this.isShowPopup()) return;
        mini.PopupEdit.superclass.__OnBlur.call(this, e);
    },
    __OnMouseOver: function (e) {
        if (this.isReadOnly() || this.allowInput) return;
        if (mini.findParent(e.target, 'mini-buttonedit-border')) {
            this.addCls(this.hoverCls);
        }
    },
    __OnMouseOut: function (e) {
        if (this.isReadOnly() || this.allowInput) return;
        this.removeCls(this.hoverCls);
    },
    __OnMouseDown: function (e) {
        if (this.isReadOnly()) return;
        mini.PopupEdit.superclass.__OnMouseDown.call(this, e);
        if (this.allowInput == false && mini.findParent(e.target, 'mini-buttonedit-border')) {
            mini.addClass(this.el, this.pressedCls);

            mini.on(document, 'mouseup', this.__OnDocMouseUp, this);
        }
    },
    __OnInputKeyDown: function (e) {
        this.fire('keydown', { htmlEvent: e });
        if (e.keyCode == 8 && (this.isReadOnly() || this.allowInput == false)) {
            return false;
        }
        if (e.keyCode == 9) {
            this.hidePopup();
            return;
        }
        if (e.keyCode == 27) {
            this.hidePopup();
            return;
        }
        if (e.keyCode == 13) {
            this.fire('enter');
        }

        if (this.isShowPopup()) {
            if (e.keyCode == 13 || e.keyCode == 27) {
                e.stopPropagation();
            }
        }
    },

    within: function (e) {
        if (mini.isAncestor(this.el, e.target)) return true;
        if (this.popup.within(e)) return true;
        return false;
    },

    popupWidth: '100%',
    popupMinWidth: 50,
    popupMaxWidth: 2000,

    popupHeight: '',
    popupMinHeight: 30,
    popupMaxHeight: 2000,

    setPopup: function (value) {
        if (!value) return;

        if (typeof value == 'string') {
            mini.parse(value);
            value = mini.get(value);
        }
        var p = mini.getAndCreate(value);
        if (!p) return;
        p.setVisible(false);

        this._popupInner = p;

        p.owner = this;

        p.on('beforebuttonclick', this.__OnPopupButtonClick, this);
    },

    getPopup: function () {
        if (!this.popup) {
            this._createPopup();
        }
        return this.popup;
    },
    _createPopup: function () {
        this.popup = new mini.Popup();
        this.popup.setShowAction('none');
        this.popup.setHideAction('outerclick');
        this.popup.setPopupEl(this.el);

        this.popup.on('BeforeClose', this.__OnPopupBeforeClose, this);
        mini.on(this.popup.el, 'keydown', this.__OnPopupKeyDown, this);
    },
    __OnPopupBeforeClose: function (e) {
        if (this.within(e.htmlEvent)) e.cancel = true;
    },
    __OnPopupKeyDown: function (e) {},
    showPopup: function () {
        var ex = { cancel: false };
        this.fire('beforeshowpopup', ex);
        if (ex.cancel == true) return;

        var popup = this.getPopup();

        this._syncShowPopup();

        popup.on('Close', this.__OnPopupHide, this);

        this.fire('showpopup');
    },
    doLayout: function () {
        mini.PopupEdit.superclass.doLayout.call(this);
        if (this.isShowPopup()) {
        }
    },
    _syncShowPopup: function () {
        var popup = this.getPopup();

        if (this._popupInner && this._popupInner.el.parentNode != this.popup._contentEl) {
            this.popup._contentEl.appendChild(this._popupInner.el);
            this._popupInner.setVisible(true);
        }

        var box = this.getBox();

        var w = this.popupWidth;
        if (this.popupWidth == '100%') w = box.width;

        popup.setWidth(w);

        var h = parseInt(this.popupHeight);

        if (!isNaN(h)) {
            popup.setHeight(h);
        } else {
            popup.setHeight('auto');
        }

        popup.setMinWidth(this.popupMinWidth);
        popup.setMinHeight(this.popupMinHeight);
        popup.setMaxWidth(this.popupMaxWidth);
        popup.setMaxHeight(this.popupMaxHeight);

        popup.showAtEl(this.el, {
            xAlign: 'left',
            yAlign: 'below',
            outYAlign: 'above',
            outXAlign: 'right',
            popupCls: this.popupCls
        });
    },
    __OnPopupHide: function (e) {
        this.__doFocusCls();
        this.fire('hidepopup');
    },
    hidePopup: function () {
        if (this.isShowPopup()) {
            var popup = this.getPopup();
            popup.close();
        }
    },
    isShowPopup: function () {
        if (this.popup && this.popup.isDisplay()) return true;
        else return false;
    },

    setPopupWidth: function (value) {
        this.popupWidth = value;
    },
    setPopupMaxWidth: function (value) {
        this.popupMaxWidth = value;
    },
    setPopupMinWidth: function (value) {
        this.popupMinWidth = value;
    },
    getPopupWidth: function (value) {
        return this.popupWidth;
    },
    getPopupMaxWidth: function (value) {
        return this.popupMaxWidth;
    },
    getPopupMinWidth: function (value) {
        return this.popupMinWidth;
    },
    setPopupHeight: function (value) {
        this.popupHeight = value;
    },
    setPopupMaxHeight: function (value) {
        this.popupMaxHeight = value;
    },
    setPopupMinHeight: function (value) {
        this.popupMinHeight = value;
    },
    getPopupHeight: function (value) {
        return this.popupHeight;
    },
    getPopupMaxHeight: function (value) {
        return this.popupMaxHeight;
    },
    getPopupMinHeight: function (value) {
        return this.popupMinHeight;
    },
    __OnClick: function (e) {
        if (this.isReadOnly()) return;

        if (mini.isAncestor(this._buttonEl, e.target)) {
            this._OnButtonClick(e);
        }
        if (mini.findParent(e.target, this._closeCls)) {
            if (this.isShowPopup()) {
                this.hidePopup();
            }
            this.fire('closeclick', { htmlEvent: e });
            return;
        }
        if (this.allowInput == false || mini.isAncestor(this._buttonEl, e.target)) {
            if (this.isShowPopup()) {
                this.hidePopup();
            } else {
                var sf = this;
                setTimeout(function () {
                    sf.showPopup();
                }, 1);
            }
        }
    },
    __OnPopupButtonClick: function (e) {
        if (e.name == 'close') this.hidePopup();
        e.cancel = true;
    },

    ajaxType: '',
    setAjaxType: function (value) {
        this.ajaxType = value;
        var source = this._listbox || this.tree;
        if (source) source.setAjaxType(value);
    },
    getAjaxType: function () {
        return this.ajaxType;
    },

    getAttrs: function (el) {
        var attrs = mini.PopupEdit.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'popupWidth',
            'popupHeight',
            'popup',
            'onshowpopup',
            'onhidepopup',
            'onbeforeshowpopup',
            'ajaxType'
        ]);
        mini._ParseInt(el, attrs, ['popupMinWidth', 'popupMaxWidth', 'popupMinHeight', 'popupMaxHeight']);

        return attrs;
    }
});
mini.regClass(mini.PopupEdit, 'popupedit');
mini.ComboBox = mini.PopupEdit.extend({
    type: 'combobox',
    tag: 'mini-combobox',

    props: {
        text: '',
        value: '',
        valueField: 'id',
        textField: 'text',
        delimiter: ',',
        multiSelect: false,
        data: null,
        url: '',
        columns: null,
        allowInput: false,
        valueFromSelect: false,
        showNullItem: false,
        popupMaxHeight: 200,
        virtual: false
    },

    initComponent: function () {
        this.data = this.data || [];
        this.columns = this.columns || [];

        this.callParent('initComponent');

        var me = this;
        if (isFirefox) {
            this._textEl.oninput = function () {
                me._tryQuery();
            };
        }
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var value = kv.value;
        delete kv.value;
        var url = kv.url;
        delete kv.url;
        var data = kv.data;
        delete kv.data;

        this.callParent('set', kv);

        if (!mini.isNull(data)) {
            this.setData(data);
            kv.data = data;
        }
        if (!mini.isNull(url)) {
            this.setUrl(url);
            kv.url = url;
        }
        if (!mini.isNull(value)) {
            this.setValue(value);
            kv.value = value;
        }

        return this;
    },

    _createPopup: function () {
        mini.ComboBox.superclass._createPopup.call(this);

        this._listbox = new mini.ListBox();

        this._listbox.setBorderStyle('border:0;');
        this._listbox.setStyle('width:100%;height:auto;');
        this._listbox.render(this.popup._contentEl);

        this._listbox.on('itemclick', this.__OnItemClick, this);
        this._listbox.on('drawcell', this.__OnItemDrawCell, this);

        var me = this;
        this._listbox.on(
            'beforeload',
            function (e) {
                me.fire('beforeload', e);
            },
            this
        );
        this._listbox.on(
            'load',
            function (e) {
                me.fire('load', e);
            },
            this
        );
        this._listbox.on(
            'loaderror',
            function (e) {
                me.fire('loaderror', e);
            },
            this
        );
    },
    showPopup: function () {
        var ex = { cancel: false };
        this.fire('beforeshowpopup', ex);
        if (ex.cancel == true) return;

        this._listbox.setHeight('auto');
        mini.ComboBox.superclass.showPopup.call(this);
        var h = this.popup.el.style.height;
        if (h == '' || h == 'auto') {
            this._listbox.setHeight('auto');
        } else {
            this._listbox.setHeight('100%');
        }

        this._listbox.setValue(this.value);

        if (this.virtual) {
            var me = this;
            setTimeout(function () {
                me._listbox.refreshItems();
            }, 10);
        }
    },
    select: function (item) {
        this._listbox.deselectAll();
        item = this.getItem(item);
        if (item) {
            this._listbox.select(item);
            this.__OnItemClick({ item: item });
        }
    },
    getItem: function (item) {
        return typeof item == 'object' ? item : this.data[item];
    },
    indexOf: function (item) {
        return this.data.indexOf(item);
    },
    getAt: function (index) {
        return this.data[index];
    },
    load: function (data) {
        if (typeof data == 'string') {
            this.setUrl(data);
        } else {
            this.setData(data);
        }
    },
    _eval: function (_) {
        return eval('(' + _ + ')');
    },
    setData: function (data) {
        if (typeof data == 'string') {
            data = this._eval(data);
        }
        if (!mini.isArray(data)) data = [];
        this._listbox.setData(data);
        this.data = this._listbox.data;

        var vts = this._listbox.getValueAndText(this.value);
        this.text = this._textEl.value = vts[1];
    },
    getData: function () {
        return this.data;
    },
    setUrl: function (url) {
        if (!url) return;

        this.getPopup();

        this._listbox.setUrl(url);
        this.url = this._listbox.url;
        this.data = this._listbox.data;

        var vts = this._listbox.getValueAndText(this.value);
        this.text = this._textEl.value = vts[1];
    },
    getUrl: function () {
        return this.url;
    },
    setValueField: function (valueField) {
        this.valueField = valueField;
        if (this._listbox) {
            this._listbox.setValueField(valueField);
        }
    },
    getValueField: function () {
        return this.valueField;
    },
    setTextField: function (value) {
        if (this._listbox) this._listbox.setTextField(value);
        this.textField = value;
    },
    getTextField: function () {
        return this.textField;
    },
    setDisplayField: function (value) {
        this.setTextField(value);
    },
    setDataField: function (value) {
        if (this._listbox) this._listbox.setDataField(value);
        this.dataField = value;
    },
    setValue: function (value) {
        if (this.value !== value) {
            var vts = this._listbox.getValueAndText(value);

            this.value = value;

            this._valueEl.value = this.value;
            this.text = this._textEl.value = vts[1];

            this._doEmpty();
        } else {
            var vts = this._listbox.getValueAndText(value);
            this.text = this._textEl.value = vts[1];
        }
    },
    setMultiSelect: function (value) {
        if (this.multiSelect != value) {
            this.multiSelect = value;
            if (this._listbox) {
                this._listbox.setMultiSelect(value);
                this._listbox.setShowCheckBox(value);
            }
        }
    },
    getMultiSelect: function () {
        return this.multiSelect;
    },
    setColumns: function (value) {
        if (!mini.isArray(value)) value = [];
        this.columns = value;
        this._listbox.setColumns(value);
    },
    getColumns: function () {
        return this.columns;
    },
    setShowNullItem: function (value) {
        if (this.showNullItem != value) {
            this.showNullItem = value;
            this._listbox.setShowNullItem(value);
        }
    },

    getVirtual: function () {
        return this.virtual;
    },
    setVirtual: function (value) {
        if (this.virtual != value) {
            this.virtual = value;
            this._listbox.setVirtual(value);
        }
    },
    getShowNullItem: function () {
        return this.showNullItem;
    },
    setNullItemText: function (value) {
        if (this.nullItemText != value) {
            this.nullItemText = value;
            this._listbox.setNullItemText(value);
        }
    },
    getNullItemText: function () {
        return this.nullItemText;
    },
    setValueFromSelect: function (value) {
        this.valueFromSelect = value;
    },
    getValueFromSelect: function () {
        return this.valueFromSelect;
    },

    _OnValueChanged: function () {
        if (this.validateOnChanged) {
            this._tryValidate();
        }
        var value = this.getValue();
        var selecteds = this.getSelecteds();
        var selected = selecteds[0];
        var sf = this;

        var e = { value: value, selecteds: selecteds, selected: selected };

        sf.fire('valuechanged', e);

        sf.fire('change', e);
    },
    getSelecteds: function () {
        return this._listbox.findItems(this.value);
    },
    getSelected: function () {
        return this.getSelecteds()[0];
    },
    __OnItemDrawCell: function (e) {
        this.fire('drawcell', e);
    },
    __OnItemClick: function (e) {
        var ev = { item: e.item, cancel: false };

        this.fire('beforeitemclick', ev);
        if (ev.cancel) return;

        var items = this._listbox.getSelecteds();

        var vts = this._listbox.getValueAndText(items);

        var value = this.getValue();
        this.setValue(vts[0]);
        this.setText(vts[1]);
        if (e) {
            if (value != this.getValue()) {
                var sf = this;
                setTimeout(function () {
                    sf._OnValueChanged();
                }, 1);
            }

            if (!this.multiSelect) {
                this.hidePopup();
            }

            this.focus();

            this.fire('itemclick', { item: e.item });
        }
    },
    __OnInputKeyDown: function (e, userOldText) {
        var ex = { htmlEvent: e };
        this.fire('keydown', ex);

        if (e.keyCode == 8 && (this.isReadOnly() || this.allowInput == false)) {
            return false;
        }

        if (e.keyCode == 9) {
            this.hidePopup();
            return;
        }

        if (this.isReadOnly()) return;

        switch (e.keyCode) {
            case 27:
                e.preventDefault();
                if (this.isShowPopup()) {
                    e.stopPropagation();
                }

                this.hidePopup();
                break;
            case mini.Keys.Space:
                if (this.isShowPopup() && this.multiSelect) {
                    e.preventDefault();
                    e.stopPropagation();

                    var index = this._listbox.getFocusedIndex();
                    if (index != -1) {
                        var item = this._listbox.getAt(index);

                        var ev = { item: item, cancel: false };
                        this.fire('beforeitemclick', ev);
                        if (ev.cancel == false) {
                            if (this._listbox.isSelected(item)) {
                                this._listbox.deselect(item);
                            } else {
                                this._listbox.select(item);
                            }

                            var items = this._listbox.getSelecteds();
                            var vts = this._listbox.getValueAndText(items);
                            this.setValue(vts[0]);
                            this.setText(vts[1]);
                            this._OnValueChanged();
                        }
                    }
                }
                break;
            case 13:
                if (this.isShowPopup()) {
                    e.preventDefault();
                    e.stopPropagation();

                    var index = this._listbox.getFocusedIndex();
                    if (index != -1) {
                        var item = this._listbox.getAt(index);

                        var ev = { item: item, cancel: false };
                        this.fire('beforeitemclick', ev);
                        if (ev.cancel == false) {
                            if (this.multiSelect) {
                                this._listbox.select(item);
                            } else {
                                this._listbox.deselectAll();
                                this._listbox.select(item);
                            }
                            var items = this._listbox.getSelecteds();
                            var vts = this._listbox.getValueAndText(items);
                            this.setValue(vts[0]);
                            this.setText(vts[1]);
                            this._OnValueChanged();
                        }
                    }
                    this.hidePopup();
                } else {
                    this.fire('enter', ex);
                }
                break;
            case 37:
                break;
            case 38:
                e.preventDefault();
                var index = this._listbox.getFocusedIndex();
                if (index == -1) {
                    index = 0;

                    var item = this._listbox.findItems(this.value)[0];
                    if (item) {
                        index = this._listbox.indexOf(item);
                    }
                }
                if (this.isShowPopup()) {
                    index -= 1;
                    if (index < 0) index = 0;
                    this._listbox._focusItem(index, true);
                }
                break;
            case 39:
                break;
            case 40:
                e.preventDefault();
                var index = this._listbox.getFocusedIndex();
                if (index == -1) {
                    index = 0;

                    var item = this._listbox.findItems(this.value)[0];
                    if (item) {
                        index = this._listbox.indexOf(item);
                    }
                }
                if (this.isShowPopup()) {
                    index += 1;
                    if (index > this._listbox.getCount() - 1) index = this._listbox.getCount() - 1;
                    this._listbox._focusItem(index, true);
                } else {
                    this.showPopup();

                    this._listbox._focusItem(index, true);
                }
                break;
            default:
                this._tryQuery(this._textEl.value);
                break;
        }
    },
    __OnInputKeyUp: function (e) {
        this.fire('keyup', { htmlEvent: e });
    },
    __OnInputKeyPress: function (e) {
        this.fire('keypress', { htmlEvent: e });
    },
    _tryQuery: function (oldText) {
        var sf = this;
        setTimeout(function () {
            var text = sf._textEl.value;
            if (text != oldText) {
                sf._doQuery(text);
            }
        }, 10);
    },
    itemFilter: function (item, value) {
        var text = mini._getMap(this.textField, item);
        if (typeof text == 'string') {
            text = text.toUpperCase();
            value = value.toUpperCase();
            if (text.indexOf(value) != -1) {
                return true;
            }
        }
        return false;
    },
    _doQuery: function (key) {
        // if (this.multiSelect == true) return;
        var view = [];
        for (var i = 0, l = this.data.length; i < l; i++) {
            var o = this.data[i];

            o.hide = !this.itemFilter(o, key);
            view.push(o);
        }
        this._listbox.setData(view);
        this._filtered = true;
        if (key !== '' || this.isShowPopup()) {
            this.showPopup();

            var index = 0;

            if (this._listbox.getShowNullItem()) index = 1;
            var me = this;

            me._listbox._focusItem(index, true);
        }
    },
    __OnPopupHide: function (e) {
        if (this._filtered) {
            this._filtered = false;
            if (this._listbox.el) {
                this._listbox.setData(this.data);
            }
        }
        this.__doFocusCls();
        this.fire('hidepopup');
    },

    findItems: function (value) {
        return this._listbox.findItems(value);
    },

    findItemByText: function (text) {
        var data = this.getData();
        for (var i = 0, l = data.length; i < l; i++) {
            var item = data[i];
            var itemText = item[this.textField];
            if (itemText == text) {
                return item;
            }
        }
        return null;
    },

    __OnInputTextChanged: function (e) {
        if (this.isShowPopup()) return;
        if (this.multiSelect == false) {
            var text = this._textEl.value;

            var data = this.getData();
            var selected = null;
            for (var i = 0, l = data.length; i < l; i++) {
                var item = data[i];
                var itemText = item[this.textField];
                if (itemText == text) {
                    selected = item;
                    break;
                }
            }
            if (selected) {
                this._listbox.setValue(selected ? selected[this.valueField] : '');

                var v = this._listbox.getValue();
                var vts = this._listbox.getValueAndText(v);

                var value = this.getValue();
                this.setValue(v);
                this.setText(vts[1]);
            } else {
                if (this.valueFromSelect) {
                    this.setValue('');
                    this.setText('');
                } else {
                    this.setValue(text);
                    this.setText(text);
                }
            }
            if (value != this.getValue()) {
                var sf = this;

                sf._OnValueChanged();
            }
        }
    },

    getAttrs: function (el) {
        var ctor = this.constructor;
        ctor.parseColumns = function (el) {
            return mini._ParseColumns(el);
        };

        var attrs = mini.ComboBox.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'url',
            'data',
            'textField',
            'valueField',
            'displayField',
            'nullItemText',
            'pinyinField',
            'delimiter',
            'ondrawcell',
            'onbeforeload',
            'onpreload',
            'onload',
            'onloaderror',
            'onitemclick',
            'onbeforeitemclick'
        ]);
        mini._ParseBool(el, attrs, [
            'multiSelect',
            'showNullItem',
            'valueFromSelect',
            'valueInCheckOrder',
            'clearOnLoad',
            'autoFilter',
            'autoFocusItem'
        ]);

        if (attrs.displayField) attrs.textField = attrs.displayField;

        var valueField = attrs.valueField || this.valueField;
        var textField = attrs.textField || this.textField;
        if (el.nodeName.toLowerCase() == 'select') {
            var data = [];
            for (var i = 0, l = el.length; i < l; i++) {
                var op = el.options[i];
                var o = {};
                o[textField] = op.text;
                o[valueField] = op.value;

                data.push(o);
            }
            if (data.length > 0) {
                attrs.data = data;
            }
        } else {
        }

        return attrs;
    }
});
mini.regClass(mini.ComboBox, 'combobox');
mini.DatePicker = mini.PopupEdit.extend({
    type: 'datepicker',
    tag: 'mini-datepicker',

    props: {
        format: 'yyyy-MM-dd',

        maxDate: null,
        minDate: null,

        popupWidth: '',

        viewDate: new Date(),
        showTime: false,
        timeFormat: 'H:mm',

        showTodayButton: true,
        showClearButton: true,
        showOkButton: false
    },

    _getCalendar: function () {
        if (!mini.DatePicker._Calendar) {
            var calendar = (mini.DatePicker._Calendar = new mini.Calendar());

            calendar.setStyle('border:0;');
        }
        return mini.DatePicker._Calendar;
    },
    destroy: function () {
        $(this._calendar.el).detach();
        this._calendar = null;

        mini.DatePicker.superclass.destroy.call(this);
    },
    _createPopup: function () {
        mini.DatePicker.superclass._createPopup.call(this);

        this._calendar = this._getCalendar();
    },
    showPopup: function () {
        var ex = { cancel: false };
        this.fire('beforeshowpopup', ex);
        if (ex.cancel == true) return;

        if (this._calendar.el.parentNode != this.popup._contentEl) {
            this._calendar.render(this.popup._contentEl);
        }

        this._calendar.set({
            showTime: this.showTime,
            timeFormat: this.timeFormat,
            showClearButton: this.showClearButton,
            showTodayButton: this.showTodayButton,
            showOkButton: this.showOkButton
        });

        this._calendar.setValue(this.value);

        if (this.value) {
            this._calendar.setViewDate(this.value);
        } else {
            this._calendar.setViewDate(this.viewDate);
        }

        function doUpdate() {
            if (this._calendar._target) {
                var obj = this._calendar._target;
                this._calendar.un('timechanged', obj.__OnTimeChanged, obj);
                this._calendar.un('dateclick', obj.__OnDateClick, obj);
                this._calendar.un('drawdate', obj.__OnDrawDate, obj);
            }
            this._calendar.on('timechanged', this.__OnTimeChanged, this);
            this._calendar.on('dateclick', this.__OnDateClick, this);
            this._calendar.on('drawdate', this.__OnDrawDate, this);

            this._calendar.doLayout();

            this._calendar.focus();

            this._calendar._target = this;
        }

        var me = this;
        doUpdate.call(me);

        mini.DatePicker.superclass.showPopup.call(this);
    },
    hidePopup: function () {
        mini.DatePicker.superclass.hidePopup.call(this);

        this._calendar.un('timechanged', this.__OnTimeChanged, this);
        this._calendar.un('dateclick', this.__OnDateClick, this);
        this._calendar.un('drawdate', this.__OnDrawDate, this);
    },
    within: function (e) {
        if (mini.isAncestor(this.el, e.target)) return true;
        if (this._calendar.within(e)) return true;
        return false;
    },
    __OnPopupKeyDown: function (e) {
        if (e.keyCode == 13) {
            this.__OnDateClick();
        }
        if (e.keyCode == 27) {
            this.hidePopup();
            this.focus();
        }
    },
    __OnDrawDate: function (e) {
        var date = e.date;
        var maxDate = mini.parseDate(this.maxDate);
        var minDate = mini.parseDate(this.minDate);
        if (mini.isDate(maxDate)) {
            if (date?.getTime() > maxDate?.getTime()) {
                e.allowSelect = false;
            }
        }
        if (mini.isDate(minDate)) {
            if (date?.getTime() < minDate?.getTime()) {
                e.allowSelect = false;
            }
        }

        this.fire('drawdate', e);
    },
    __OnDateClick: function (e) {
        if (this.showOkButton && e.action != 'ok') return;

        var date = this._calendar.getValue();
        var value = this.getFormValue('U');

        if (this.value && date) {
            date?.setHours(this.value?.getHours());
            date?.setMinutes(this.value?.getMinutes());
            date?.setSeconds(this.value?.getSeconds());
        }

        this.setValue(date);

        if (value !== this.getFormValue('U')) {
            this._OnValueChanged();
        }

        this.focus();

        this.hidePopup();
    },
    __OnTimeChanged: function (e) {
        if (this.showOkButton) return;
        var date = this._calendar.getValue();
        this.setValue(date);
        this._OnValueChanged();
    },
    setFormat: function (value) {
        if (typeof value != 'string') return;
        if (this.format != value) {
            this.format = value;
            this._textEl.value = this._valueEl.value = this.getFormValue();
        }
    },
    getFormat: function () {
        return this.format;
    },

    valueFormat: '',
    setValueFormat: function (value) {
        if (typeof value != 'string') return;
        this.valueFormat = value;
    },
    getValueFormat: function () {
        return this.valueFormat;
    },

    nullValue: null,
    setNullValue: function (value) {
        if (value == 'null') value = null;
        this.nullValue = value;
    },
    getNullValue: function () {
        return this.nullValue;
    },

    maxDate: new Date(2100, 0, 1),

    setValue: function (value) {
        value = mini.parseDate(value);
        if (mini.isNull(value)) value = '';
        if (mini.isDate(value)) value = new Date(value?.getTime());
        if (this.value != value) {
            if (value && value > this.maxDate) value = new Date(this.maxDate?.getTime());
            this.value = value;
            this.text = this._textEl.value = this._valueEl.value = this.getFormValue();
        }
    },
    getValue: function () {
        if (!mini.isDate(this.value)) return this.nullValue;

        var v = this.value;
        if (this.valueFormat) {
            v = mini.formatDate(v, this.valueFormat);
        }
        return v;
    },
    getFormValue: function (format) {
        if (!mini.isDate(this.value)) return '';
        format = format || this.format;
        return mini.formatDate(this.value, format);
    },
    setViewDate: function (value) {
        value = mini.parseDate(value);
        if (!mini.isDate(value)) return;
        this.viewDate = value;
    },
    getViewDate: function () {
        return this._calendar.getViewDate();
    },
    setShowTime: function (value) {
        if (this.showTime != value) {
            this.showTime = value;
        }
    },
    getShowTime: function () {
        return this.showTime;
    },
    setTimeFormat: function (value) {
        if (this.timeFormat != value) {
            this.timeFormat = value;
        }
    },
    getTimeFormat: function () {
        return this.timeFormat;
    },
    setShowTodayButton: function (value) {
        this.showTodayButton = value;
    },
    getShowTodayButton: function () {
        return this.showTodayButton;
    },
    setShowClearButton: function (value) {
        this.showClearButton = value;
    },
    getShowClearButton: function () {
        return this.showClearButton;
    },
    setShowOkButton: function (value) {
        this.showOkButton = value;
    },
    getShowOkButton: function () {
        return this.showOkButton;
    },

    setMaxDate: function (value) {
        this.maxDate = value;
    },
    getMaxDate: function () {
        return this.maxDate;
    },
    setMinDate: function (value) {
        this.minDate = value;
    },
    getMinDate: function () {
        return this.minDate;
    },

    parseValue: function (v) {
        return mini.parseDate(v);
    },

    __OnInputTextChanged: function (e) {
        var v = jQuery.trim(this._textEl.value);

        var d = this.parseValue(v);

        if (!d || isNaN(d) || d?.getFullYear() == 1970) {
            d = null;
        }

        var value = this.getFormValue('U');

        this.setValue(d);
        if (d == null) this._textEl.value = '';

        if (value !== this.getFormValue('U')) {
            this._OnValueChanged();
        }
    },
    __OnInputKeyDown: function (e) {
        var ex = { htmlEvent: e };
        this.fire('keydown', ex);
        if (e.keyCode == 8 && (this.isReadOnly() || this.allowInput == false)) {
            return false;
        }

        if (e.keyCode == 9) {
            this.hidePopup();
            return;
        }

        if (this.isReadOnly()) return;

        switch (e.keyCode) {
            case 27:
                e.preventDefault();
                if (this.isShowPopup()) {
                    e.stopPropagation();
                }

                this.hidePopup();
                break;
            case 9:
            case 13:
                if (this.isShowPopup()) {
                    e.preventDefault();
                    e.stopPropagation();

                    this.hidePopup();
                } else {
                    this.__OnInputTextChanged(null);
                    var me = this;
                    setTimeout(function () {
                        me.fire('enter', ex);
                    }, 10);
                }
                break;
            case 37:
                break;
            case 38:
                e.preventDefault();
                break;
            case 39:
                break;
            case 40:
                e.preventDefault();
                this.showPopup();
                break;
            default:
                break;
        }
    },

    getAttrs: function (el) {
        var attrs = mini.DatePicker.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'format',
            'viewDate',
            'timeFormat',
            'ondrawdate',
            'minDate',
            'maxDate',
            'valueFormat',
            'nullValue'
        ]);
        mini._ParseBool(el, attrs, ['showTime', 'showTodayButton', 'showClearButton', 'showOkButton']);

        return attrs;
    }
});

mini.regClass(mini.DatePicker, 'datepicker');
mini.Spinner = mini.ButtonEdit.extend({
    type: 'spinner',
    tag: 'mini-spinner',

    props: {
        value: 0,
        minValue: 0,
        maxValue: 100,
        increment: 1,
        decimalPlaces: 0,
        changeOnMousewheel: true,
        allowLimitValue: true,
        allowLoopValue: false,
        allowNull: false
    },

    initComponent: function () {
        if (this.value < this.minValue) {
            this.setValue(this.minValue);
        }
        this.callParent('initComponent');
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var value = kv.value;
        delete kv.value;

        mini.Spinner.superclass.set.call(this, kv);

        if (!mini.isNull(value)) {
            this.setValue(value);
        }

        return this;
    },

    uiCls: 'mini-spinner',
    _getButtonHtml: function () {
        var hover = '';
        return (
            '<span class="mini-buttonedit-button" ' +
            hover +
            '><span class="mini-buttonedit-up"><span></span></span><span class="mini-buttonedit-down"><span></span></span></span>'
        );
    },

    _initEvents: function () {
        mini.Spinner.superclass._initEvents.call(this);

        mini._BindEvents(function () {
            this.on('buttonmousedown', this.__OnButtonMouseDown, this);
            mini.on(this.el, 'mousewheel', this.__OnMousewheel, this);

            var me = this;
            var jq = jQuery('.mini-buttonedit-button', this.el);
            jq.on('mouseenter', function (event) {
                $(this).addClass(me.buttonHoverCls);
            });
            jq.on('mouseleave', function (event) {
                $(this).removeClass(me.buttonHoverCls);
            });
        }, this);
    },

    _ValueLimit: function () {
        if (this.allowLimitValue == false) return;
        if (this.minValue > this.maxValue) {
            this.maxValue = this.minValue + 100;
        }
        if (this.value < this.minValue) {
            this.setValue(this.minValue);
        }
        if (this.value > this.maxValue) {
            this.setValue(this.maxValue);
        }
    },
    getFormValue: function () {
        var v = this.value;
        v = parseFloat(v);
        if (isNaN(v)) v = 0;
        var s = String(v).split('.');
        var s1 = s[0],
            s2 = s[1];
        if (!s2) s2 = '';
        if (this.decimalPlaces > 0 && String(s2).length > 0) {
            for (var i = s2.length, l = this.decimalPlaces; i < l; i++) {
                s2 += '0';
            }
            s2 = '.' + s2;
        }
        return s1 + s2;
    },
    setValue: function (value) {
        value = parseFloat(value);
        if (isNaN(value)) value = this.defaultValue;
        value = parseFloat(value);

        value = parseFloat(value.toFixed(this.decimalPlaces));
        if (isNaN(value)) value = 0;
        if (this.value != value) {
            this.value = value;
            this._ValueLimit();
            this._valueEl.value = this.value;
            this.text = this._textEl.value = this.getFormValue();
        } else {
            this.text = this._textEl.value = this.getFormValue();
        }
    },
    setMaxValue: function (value) {
        value = parseFloat(value);
        if (isNaN(value)) return;
        value = parseFloat(value.toFixed(this.decimalPlaces));
        if (this.maxValue != value) {
            this.maxValue = value;
            this._ValueLimit();
        }
    },
    getMaxValue: function (value) {
        return this.maxValue;
    },
    setMinValue: function (value) {
        value = parseFloat(value);
        if (isNaN(value)) return;
        value = parseFloat(value.toFixed(this.decimalPlaces));
        if (this.minValue != value) {
            this.minValue = value;
            this._ValueLimit();
        }
    },
    getMinValue: function (value) {
        return this.minValue;
    },
    setIncrement: function (value) {
        value = parseFloat(value);
        if (isNaN(value)) return;
        if (this.increment != value) {
            this.increment = value;
        }
    },
    getIncrement: function (value) {
        return this.increment;
    },
    setDecimalPlaces: function (value) {
        value = parseInt(value);
        if (isNaN(value) || value < 0) return;
        this.decimalPlaces = value;
    },
    getDecimalPlaces: function (value) {
        return this.decimalPlaces;
    },
    setChangeOnMousewheel: function (value) {
        this.changeOnMousewheel = value;
    },
    getChangeOnMousewheel: function (value) {
        return this.changeOnMousewheel;
    },
    setAllowLimitValue: function (value) {
        this.allowLimitValue = value;
    },
    getAllowLimitValue: function (value) {
        return this.allowLimitValue;
    },

    _SpinTimer: null,
    _StartSpin: function (Increment, time, count) {
        this._StopSpin();

        this.setValue(this.value + Increment);

        var sf = this;
        var sourceCount = count;
        var now = new Date();
        this._SpinTimer = setInterval(function () {
            sf.setValue(sf.value + Increment);
            sf._OnValueChanged();

            count--;
            if (count == 0 && time > 50) {
                sf._StartSpin(Increment, time - 100, sourceCount + 3);
            }

            var now2 = new Date();
            if (now2 - now > 500) sf._StopSpin();
            now = now2;
        }, time);
        mini.on(document, 'mouseup', this._OnDocumentMouseUp, this);
    },
    _StopSpin: function () {
        clearInterval(this._SpinTimer);
        this._SpinTimer = null;
    },
    __OnButtonMouseDown: function (e) {
        this._DownValue = this.getValue();

        this.__OnInputTextChanged();

        if (e.spinType == 'up') {
            this._StartSpin(this.increment, 230, 2);
        } else {
            this._StartSpin(-this.increment, 230, 2);
        }
    },
    __OnInputKeyDown: function (e) {
        mini.Spinner.superclass.__OnInputKeyDown.call(this, e);

        var KEY = mini.Keyboard;

        switch (e.keyCode) {
            case KEY.Top:
                this.setValue(this.value + this.increment);
                this._OnValueChanged();
                break;
            case KEY.Bottom:
                this.setValue(this.value - this.increment);
                this._OnValueChanged();
                break;
        }
    },

    __OnMousewheel: function (e) {
        if (this.isReadOnly()) return;
        if (this.changeOnMousewheel == false) return;

        var wheelDelta = e.wheelDelta || e.originalEvent.wheelDelta || e.originalEvent.detail;

        var increment = this.increment;
        if (wheelDelta > 0) increment = -increment;
        this.setValue(this.value + increment);
        this._OnValueChanged();

        return false;
    },
    _OnDocumentMouseUp: function (e) {
        this._StopSpin();
        mini.un(document, 'mouseup', this._OnDocumentMouseUp, this);

        if (this._DownValue != this.getValue()) {
            this._OnValueChanged();
        }
    },

    __OnInputTextChanged: function (e) {
        var _value = this.getValue();

        var value = parseFloat(this._textEl.value);
        this.setValue(value);

        if (_value != this.getValue()) {
            this._OnValueChanged();
        }
    },

    getAttrs: function (el) {
        var attrs = mini.Spinner.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['minValue', 'maxValue', 'increment', 'decimalPlaces', 'changeOnMousewheel']);
        mini._ParseBool(el, attrs, ['allowLimitValue']);

        return attrs;
    }
});
mini.regClass(mini.Spinner, 'spinner');
mini.Hidden = mini.Control.extend({
    type: 'hidden',
    tag: 'mini-hidden',
    formField: true,
    _clearBorder: false,

    props: {
        value: ''
    },

    _create: function () {
        this.el = document.createElement('input');
        this.el.type = 'hidden';
        this.el.className = 'mini-hidden';
    },
    setName: function (value) {
        this.name = value;
        this.el.name = value;
    },
    setValue: function (value) {
        if (value === null || value === undefined) value = '';
        this.value = value;
        if (mini.isDate(value)) {
            var y = value?.getFullYear();
            var m = value?.getMonth() + 1;
            var d = value?.getDate();
            m = m < 10 ? '0' + m : m;
            d = d < 10 ? '0' + d : d;
            this.el.value = y + '-' + m + '-' + d;
        } else {
            this.el.value = value;
        }
    },
    getValue: function () {
        return this.value;
    },
    getFormValue: function () {
        return this.el.value;
    }
});

mini.regClass(mini.Hidden, 'hidden');

mini.Popup = mini.Container.extend({
    type: 'mini-popup',
    tag: 'mini-popup',

    initComponent: function () {
        this.callParent('initComponent');
        this.setVisible(false);
        this.setAllowDrag(this.allowDrag);
        this.setAllowResize(this.allowResize);
    },

    _create: function () {
        var el = (this.el = document.createElement('div'));
        this.el.className = 'mini-popup';
        this._contentEl = this.el;
    },

    _initEvents: function () {
        mini._BindEvents(function () {
            mini_onOne(this.el, 'mouseover', this.__OnMouseOver, this);
        }, this);
    },
    doLayout: function () {
        mini.Popup.superclass.doLayout.call(this);
    },
    destroy: function (removeEl) {
        if (this.el) {
            this.el.onmouseover = null;
        }

        mini.un(document, 'mousedown', this.__OnBodyMouseDown, this);
        mini.un(window, 'resize', this.__OnWindowResize, this);
        if (this._modalEl) {
            jQuery(this._modalEl).remove();
            this._modalEl = null;
        }
        if (this.shadowEl) {
            jQuery(this.shadowEl).remove();
            this.shadowEl = null;
        }

        mini.Popup.superclass.destroy.call(this, removeEl);
    },
    setWidth: function (value) {
        if (parseInt(value) == value) value += 'px';
        this.width = value;

        if (value.indexOf('px') != -1) {
            mini.setWidth(this.el, value);
        } else {
            this.el.style.width = value;
        }
        this.invalidateLayout();
    },
    setHeight: function (value) {
        if (parseInt(value) == value) value += 'px';
        this.height = value;
        if (value.indexOf('px') != -1) {
            mini.setHeight(this.el, value);
        } else {
            this.el.style.height = value;
        }
        this.invalidateLayout();
    },
    setBody: function (value) {
        if (!value) return;
        if (!mini.isArray(value)) value = [value];
        for (var i = 0, l = value.length; i < l; i++) {
            mini.append(this._contentEl, value[i]);
        }
    },
    getAttrs: function (el) {
        var attrs = mini.Popup.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'popupEl',
            'popupCls',
            'showAction',
            'hideAction',
            'xAlign',
            'yAlign',
            'modalStyle',
            'onbeforeopen',
            'open',
            'onbeforeclose',
            'onclose'
        ]);
        mini._ParseBool(el, attrs, ['showModal', 'showShadow', 'allowDrag', 'allowResize']);
        mini._ParseInt(el, attrs, [
            'showDelay',
            'hideDelay',
            'xOffset',
            'yOffset',
            'minWidth',
            'minHeight',
            'maxWidth',
            'maxHeight'
        ]);
        var cs = mini.getChildNodes(el, true);
        attrs.body = cs;
        return attrs;
    }
});
mini.regClass(mini.Popup, 'popup');

mini.Popup_prototype = {
    isPopup: false,

    popupEl: null,
    popupCls: '',

    showAction: 'mouseover',
    hideAction: 'outerclick',
    showDelay: 300,
    hideDelay: 500,

    xAlign: 'left',
    yAlign: 'below',
    xOffset: 0,
    yOffset: 0,

    minWidth: 50,
    minHeight: 25,
    maxWidth: 2000,
    maxHeight: 2000,

    showModal: false,
    showShadow: true,

    modalStyle: 'opacity:0.2',

    _dragCls: 'mini-popup-drag',
    _resizeCls: 'mini-popup-resize',
    allowDrag: false,
    allowResize: false,

    _unbindPopupEl: function () {
        if (!this.popupEl) return;
        mini.un(this.popupEl, 'click', this.__OnLeftClick, this);
        mini.un(this.popupEl, 'contextmenu', this.__OnRightClick, this);
        mini.un(this.popupEl, 'mouseover', this.__OnMouseOver, this);
    },
    _bindPopupEl: function () {
        if (!this.popupEl) return;
        mini.on(this.popupEl, 'click', this.__OnLeftClick, this);
        mini.on(this.popupEl, 'contextmenu', this.__OnRightClick, this);
        mini.on(this.popupEl, 'mouseover', this.__OnMouseOver, this);
    },
    doShow: function (e) {
        var ev = {
            popupEl: this.popupEl,
            htmlEvent: e,
            cancel: false
        };

        this.fire('BeforeOpen', ev);
        if (ev.cancel == true) return;

        this.fire('opening', ev);
        if (ev.cancel == true) return;

        if (!this.popupEl) {
            this.show();
        } else {
            var options = {};
            if (e) options.xy = [e.pageX, e.pageY];
            this.showAtEl(this.popupEl, options);
        }
    },
    doHide: function (e) {
        var ev = {
            popupEl: this.popupEl,
            htmlEvent: e,
            cancel: false
        };
        this.fire('BeforeClose', ev);
        if (ev.cancel == true) return;
        this.close();
    },

    show: function (left, top) {
        this.showAtPos(left, top);
    },
    showAtPos: function (x, y) {
        if (!this.el.parentElement) {
            this.render(document.body);
        }

        if (!x) x = 'center';
        if (!y) y = 'middle';

        this.el.style.position = 'absolute';
        this.el.style.left = '-2000px';
        this.el.style.top = '-2000px';
        this.el.style.display = '';

        this._measureSize();

        var vbox = mini.getViewportBox();
        var box = mini.getBox(this.el);

        if (x == 'left') x = 0;
        if (x == 'center') x = vbox.width / 2 - box.width / 2;
        if (x == 'right') x = vbox.width - box.width;

        if (y == 'top') y = 0;
        if (y == 'middle') y = vbox.y + vbox.height / 2 - box.height / 2;
        if (y == 'bottom') y = vbox.height - box.height;

        if (x + box.width > vbox.right) x = vbox.right - box.width;
        if (y + box.height > vbox.bottom) y = vbox.bottom - box.height - 20;

        this._Show(x, y);
    },
    _doModal: function () {
        jQuery(this._modalEl).remove();
        if (!this.showModal) return;
        if (this.visible == false) return;

        var dd = document.documentElement;
        var scrollWidth = parseInt(Math.max(document.body.scrollWidth, dd ? dd.scrollWidth : 0));
        var scrollHeight = parseInt(Math.max(document.body.scrollHeight, dd ? dd.scrollHeight : 0));

        var vbox = mini.getViewportBox();
        var height = vbox.height;
        if (height < scrollHeight) height = scrollHeight;

        var width = vbox.width;
        if (width < scrollWidth) width = scrollWidth;

        this._modalEl = mini.append(document.body, '<div class="mini-modal"></div>');
        this._modalEl.style.height = height + 'px';
        this._modalEl.style.width = width + 'px';
        this._modalEl.style.zIndex = mini.getStyle(this.el, 'zIndex') - 1;
        mini.setStyle(this._modalEl, this.modalStyle);
    },

    _measureSize: function () {
        this.el.style.display = '';
        var box = mini.getBox(this.el);

        if (box.width > this.maxWidth) {
            mini.setWidth(this.el, this.maxWidth);
            box = mini.getBox(this.el);
        }
        if (box.height > this.maxHeight) {
            mini.setHeight(this.el, this.maxHeight);
            box = mini.getBox(this.el);
        }
        if (box.width < this.minWidth) {
            mini.setWidth(this.el, this.minWidth);
            box = mini.getBox(this.el);
        }
        if (box.height < this.minHeight) {
            mini.setHeight(this.el, this.minHeight);
            box = mini.getBox(this.el);
        }
    },
    showAtEl: function (el, options) {
        el = mini.byId(el);
        if (!el) return;

        if (!this.el.parentElement) {
            this.render(document.body);
        }

        var c = {
            xAlign: this.xAlign,
            yAlign: this.yAlign,
            xOffset: this.xOffset,
            yOffset: this.yOffset,
            popupCls: this.popupCls
        };
        mini.copyTo(c, options);

        mini.addClass(el, c.popupCls);
        el.popupCls = c.popupCls;
        this._popupEl = el;

        this.el.style.position = 'absolute';
        this.el.style.left = '-2000px';
        this.el.style.top = '-2000px';
        this.el.style.display = '';

        this.doLayout();
        this._measureSize();

        var vbox = mini.getViewportBox();
        var box = mini.getBox(this.el);
        var pbox = mini.getBox(el);
        var xy = c.xy;
        var h = c.xAlign,
            v = c.yAlign;

        var x = vbox.width / 2 - box.width / 2,
            y = 0;
        if (xy) {
            x = xy[0];
            y = xy[1];
        }

        switch (c.xAlign) {
            case 'outleft':
                x = pbox.x - box.width;
                break;
            case 'left':
                x = pbox.x;
                break;
            case 'center':
                x = pbox.x + pbox.width / 2 - box.width / 2;
                break;
            case 'right':
                x = pbox.right - box.width;
                break;
            case 'outright':
                x = pbox.right;
                break;
            default:
                break;
        }

        switch (c.yAlign) {
            case 'above':
                y = pbox.y - box.height;
                break;
            case 'top':
                y = pbox.y;
                break;
            case 'middle':
                y = pbox.y + pbox.height / 2 - box.height / 2;
                break;
            case 'bottom':
                y = pbox.bottom - box.height;
                break;
            case 'below':
                y = pbox.bottom;
                break;
            default:
                break;
        }
        x = parseInt(x);
        y = parseInt(y);

        if (c.outYAlign || c.outXAlign) {
            if (c.outYAlign == 'above') {
                if (y + box.height > vbox.bottom) {
                    var top = pbox.y - vbox.y;
                    var bottom = vbox.bottom - pbox.bottom;
                    if (top > bottom) {
                        y = pbox.y - box.height;
                    }
                }
            }
            if (c.outYAlign == 'below') {
                if (y + box.height > vbox.bottom) {
                    var top = pbox.y - vbox.y;
                    var bottom = vbox.bottom - pbox.bottom;
                    if (top > bottom) {
                        y = pbox.y - box.height;
                    }
                }
            }
            if (c.outXAlign == 'outleft') {
                if (x + box.width > vbox.right) {
                    var left = pbox.x - vbox.x;
                    var right = vbox.right - pbox.right;
                    if (left > right) {
                        x = pbox.x - box.width;
                    }
                }
            }
            if (c.outXAlign == 'right') {
                if (x + box.width > vbox.right) {
                    x = pbox.right - box.width;
                }
            }

            if (c.alwaysView) {
                if (y < 0) y = 0;

                if (y + box.height > vbox.bottom) y = vbox.bottom - box.height;

                if (x < 0) x = 0;

                if (x + box.width > vbox.right) x = vbox.right - box.width;
            }

            this._Show(x, y);
        } else {
            this.showAtPos(x + c.xOffset, y + c.yOffset);
        }
    },
    _Show: function (x, y) {
        this.el.style.display = '';
        this.el.style.zIndex = mini.getMaxZIndex();

        mini.setX(this.el, x);
        mini.setY(this.el, y);

        this.setVisible(true);

        if (this.hideAction == 'mouseout') {
            mini.on(document, 'mousemove', this.__OnBodyMouseMove, this);
        }
        var sf = this;

        this._doModal();

        mini.layoutIFrames(this.el);

        this.isPopup = true;

        mini.on(document, 'mousedown', this.__OnBodyMouseDown, this);
        mini.on(window, 'resize', this.__OnWindowResize, this);

        this.fire('Open');
    },
    open: function () {
        this.show();
    },
    close: function () {
        this.hide();
    },
    hide: function () {
        if (!this.el) return;
        if (this.popupEl) mini.removeClass(this.popupEl, this.popupEl.popupCls);
        if (this._popupEl) mini.removeClass(this._popupEl, this._popupEl.popupCls);
        this._popupEl = null;
        jQuery(this._modalEl).remove();

        if (this.shadowEl) this.shadowEl.style.display = 'none';
        mini.un(document, 'mousemove', this.__OnBodyMouseMove, this);
        mini.un(document, 'mousedown', this.__OnBodyMouseDown, this);
        mini.un(window, 'resize', this.__OnWindowResize, this);

        this.setVisible(false);

        this.isPopup = false;

        this.fire('Close');
    },

    setPopupEl: function (el) {
        el = mini.byId(el);
        if (!el) return;
        this._unbindPopupEl();
        this.popupEl = el;
        this._bindPopupEl();
    },

    setPopupCls: function (value) {
        this.popupCls = value;
    },
    setShowAction: function (value) {
        this.showAction = value;
    },
    setHideAction: function (value) {
        this.hideAction = value;
    },
    setShowDelay: function (value) {
        this.showDelay = value;
    },
    setHideDelay: function (value) {
        this.hideDelay = value;
    },

    setXAlign: function (value) {
        this.xAlign = value;
    },
    setYAlign: function (value) {
        this.yAlign = value;
    },
    setxOffset: function (value) {
        value = parseInt(value);
        if (isNaN(value)) value = 0;
        this.xOffset = value;
    },
    setyOffset: function (value) {
        value = parseInt(value);
        if (isNaN(value)) value = 0;
        this.yOffset = value;
    },

    setShowModal: function (value) {
        this.showModal = value;
    },
    setShowShadow: function (value) {
        this.showShadow = value;
    },

    setMinWidth: function (value) {
        if (isNaN(value)) return;
        this.minWidth = value;
    },
    setMinHeight: function (value) {
        if (isNaN(value)) return;
        this.minHeight = value;
    },
    setMaxWidth: function (value) {
        if (isNaN(value)) return;
        this.maxWidth = value;
    },
    setMaxHeight: function (value) {
        if (isNaN(value)) return;
        this.maxHeight = value;
    },

    setAllowDrag: function (value) {
        this.allowDrag = value;
        mini.removeClass(this.el, this._dragCls);
        if (value) {
            mini.addClass(this.el, this._dragCls);
        }
    },
    setAllowResize: function (value) {
        this.allowResize = value;
        mini.removeClass(this.el, this._resizeCls);
        if (value) {
            mini.addClass(this.el, this._resizeCls);
        }
    },

    __OnLeftClick: function (e) {
        if (this._inAniming) return;
        if (this.showAction != 'leftclick') return;
        var allowPopup = jQuery(this.popupEl).attr('allowPopup');
        if (String(allowPopup) == 'false') return;
        this.doShow(e);
    },
    __OnRightClick: function (e) {
        if (this._inAniming) return;
        if (this.showAction != 'rightclick') return;
        var allowPopup = jQuery(this.popupEl).attr('allowPopup');
        if (String(allowPopup) == 'false') return;

        e.preventDefault();
        this.doShow(e);
    },
    __OnMouseOver: function (e) {
        if (this._inAniming) return;
        if (this.showAction != 'mouseover') return;
        var allowPopup = jQuery(this.popupEl).attr('allowPopup');
        if (String(allowPopup) == 'false') return;

        clearTimeout(this._hideTimer);
        this._hideTimer = null;

        if (this.isPopup) return;

        var sf = this;
        this._showTimer = setTimeout(function () {
            sf.doShow(e);
        }, this.showDelay);
    },
    __OnBodyMouseMove: function (e) {
        if (this.hideAction != 'mouseout') return;
        this._tryHide(e);
    },

    __OnBodyMouseDown: function (e) {
        if (this.hideAction != 'outerclick') return;
        if (!this.isPopup) return;

        if (this.within(e) || (this.popupEl && mini.isAncestor(this.popupEl, e.target))) {
        } else {
            this.doHide(e);
        }
    },
    _tryHide: function (e) {
        if (mini.isAncestor(this.el, e.target) || (this.popupEl && mini.isAncestor(this.popupEl, e.target))) {
        } else {
            clearTimeout(this._showTimer);
            this._showTimer = null;
            if (this._hideTimer) return;

            var sf = this;
            this._hideTimer = setTimeout(function () {
                sf.doHide(e);
            }, this.hideDelay);
        }
    },
    __OnWindowResize: function (e) {
        if (this.isDisplay() && !mini.isIE6) {
            this._doModal();
        }
    },
    within: function (e) {
        if (mini.isAncestor(this.el, e.target)) return true;
        var controls = mini.getChildControls(this);

        for (var i = 0, l = controls.length; i < l; i++) {
            var c = controls[i];

            if (c.within(e)) return true;
        }

        return false;
    }
};

mini.copyTo(mini.Popup.prototype, mini.Popup_prototype);
mini.ListBox = mini.ListControl.extend({
    type: 'listbox',
    tag: 'mini-listbox',

    formField: true,

    props: {
        width: 200,
        columns: null,
        columnWidth: 80,

        showNullItem: false,
        nullItemText: '',

        showEmpty: false,
        emptyText: '',

        showCheckBox: false,
        showAllCheckBox: true,
        multiSelect: false,

        showColumns: true,
        virtual: false
    },

    itemCls: 'mini-listbox-item',
    itemHoverCls: 'mini-listbox-item-hover',
    itemSelectedCls: 'mini-listbox-item-selected',

    initElement: function () {
        var el = (this.el = document.createElement('div'));
        this.el.className = 'mini-listbox';

        this.el.innerHTML =
            '<div class="mini-listbox-border"><div class="mini-listbox-header"></div><div class="mini-listbox-view"></div><input type="hidden"/></div><div class="mini-errorIcon"></div>';

        this._borderEl = this.el.firstChild;
        this._headerEl = this._borderEl.firstChild;
        this._viewEl = this._borderEl.childNodes[1];
        this._valueEl = this._borderEl.childNodes[2];

        this._errorIconEl = this.el.lastChild;

        this._scrollViewEl = this._viewEl;
    },

    _initEvents: function () {
        mini.ListBox.superclass._initEvents.call(this);
        mini._BindEvents(function () {
            mini_onOne(this._viewEl, 'scroll', this.__OnScroll, this);
        }, this);
    },
    destroy: function (removeEl) {
        if (this._viewEl) {
            this._viewEl.onscroll = null;
            mini.clearEvent(this._viewEl);

            this._viewEl = null;
        }
        this._borderEl = null;
        this._headerEl = null;
        this._viewEl = null;
        this._valueEl = null;
        mini.ListBox.superclass.destroy.call(this, removeEl);
    },
    setColumns: function (value) {
        if (!mini.isArray(value)) value = [];
        this.columns = value;

        for (var i = 0, l = this.columns.length; i < l; i++) {
            var column = this.columns[i];

            if (column.type) {
                if (!mini.isNull(column.header) && typeof column.header !== 'function') {
                    if (column.header.trim() == '') {
                        delete column.header;
                    }
                }
                var col = mini._getColumn(column.type);
                if (col) {
                    var _column = mini.copyTo({}, column);
                    mini.copyTo(column, col);
                    mini.copyTo(column, _column);
                }
            }

            var width = parseInt(column.width);
            if (mini.isNumber(width) && String(width) == column.width) column.width = width + 'px';
            if (mini.isNull(column.width)) column.width = this.columnWidth + 'px';
        }

        this.doUpdate();
    },
    getColumns: function () {
        return this.columns;
    },

    createItems: function (items, start) {
        start = start || 0;
        var itemHeight = this.getItemHeight();
        var hasColumns = this.columns && this.columns.length > 0;
        var sb = [];
        for (var i = 0, l = items.length; i < l; i++) {
            var item = items[i];

            var rowClsIndex = -1;
            var rowCls = ' ';
            var rowStyleIndex = -1;
            var rowStyle = ' ';

            sb[sb.length] = '<tr id="';
            sb[sb.length] = this._createItemId(i + start);
            sb[sb.length] = '" index="';
            sb[sb.length] = i + start;
            sb[sb.length] = '" class="mini-listbox-item ';

            if (item.enabled === false) {
                sb[sb.length] = ' mini-disabled ';
            }

            rowClsIndex = sb.length;
            sb[sb.length] = rowCls;
            sb[sb.length] = '" style="';

            if (this.virtual) {
                sb[sb.length] = 'height:' + itemHeight + 'px;';
            }

            if (item.hide === true) {
                sb[sb.length] = 'display: none;';
            }

            rowStyleIndex = sb.length;
            sb[sb.length] = rowStyle;
            sb[sb.length] = '">';

            var ckid = this._createCheckId(i);
            var ckName = this.name;
            var ckValue = this.getItemValue(item);

            var disable = '';
            if (item.enabled === false) {
                disable = 'disabled';
            }
            sb[sb.length] =
                '<td class="mini-listbox-checkbox"><input ' + disable + ' id="' + ckid + '" type="checkbox" ></td>';

            if (hasColumns) {
                for (var j = 0, k = this.columns.length; j < k; j++) {
                    var column = this.columns[j];

                    var e = this._OnDrawCell(item, i, column);

                    var w = column.width;
                    if (typeof w == 'number') w = w + 'px';

                    sb[sb.length] = '<td class="';
                    if (e.cellCls) sb[sb.length] = e.cellCls;
                    sb[sb.length] = '" style="';
                    if (e.cellStyle) sb[sb.length] = e.cellStyle + ';';
                    if (w) {
                        sb[sb.length] = 'width:' + w + ';';
                    }
                    if (column.align) {
                        sb[sb.length] = 'text-align:' + column.align + ';';
                    }
                    sb[sb.length] = '">';
                    sb[sb.length] = e.cellHtml;
                    sb[sb.length] = '</td>';

                    if (e.rowCls) rowCls = e.rowCls;
                    if (e.rowStyle) rowStyle = e.rowStyle;
                }
            } else {
                var e = this._OnDrawCell(item, i, null);
                sb[sb.length] = '<td class="';
                if (e.cellCls) sb[sb.length] = e.cellCls;
                sb[sb.length] = '" style="';
                if (e.cellStyle) sb[sb.length] = e.cellStyle;
                sb[sb.length] = '">';
                sb[sb.length] = e.cellHtml;
                sb[sb.length] = '</td>';

                if (e.rowCls) rowCls = e.rowCls;
                if (e.rowStyle) rowStyle = e.rowStyle;
            }

            sb[rowClsIndex] = rowCls;
            sb[rowStyleIndex] = rowStyle;

            sb[sb.length] = '</tr>';
        }
        return sb.join('');
    },

    createTable: function (items, start) {
        var sb = [];
        sb[sb.length] = '<table class="mini-listbox-items" cellspacing="0" cellpadding="0">';

        if (this.showEmpty && items.length == 0) {
            sb[sb.length] = '<tr><td colspan="20">' + this.emptyText + '</td></tr>';
        } else {
            this._doNullItem();
            sb.push(this.createItems(items, start));
        }
        sb[sb.length] = '</table>';
        return sb.join('');
    },

    doUpdate: function () {
        if (this._allowUpdate === false) return;
        var hasColumns = this.columns && this.columns.length > 0;
        if (hasColumns) {
            mini.addClass(this.el, 'mini-listbox-showColumns');
        } else {
            mini.removeClass(this.el, 'mini-listbox-showColumns');
        }
        this._headerEl.style.display = hasColumns ? '' : 'none';

        var sb = [];
        if (hasColumns && this.showColumns) {
            sb[sb.length] = '<table class="mini-listbox-headerInner" cellspacing="0" cellpadding="0"><tr>';
            var ckAllId = this.uid + '_ck_all';
            sb[sb.length] = '<td class="mini-listbox-checkbox"><input type="checkbox" id="' + ckAllId + '"></td>';
            for (var j = 0, k = this.columns.length; j < k; j++) {
                var column = this.columns[j];
                var header = column.header;
                if (mini.isNull(header)) header = '&nbsp;';

                var w = column.width;
                if (mini.isNumber(w)) w = w + 'px';

                sb[sb.length] = '<td class="';
                if (column.headerCls) sb[sb.length] = column.headerCls;
                sb[sb.length] = '" style="';
                if (column.headerStyle) sb[sb.length] = column.headerStyle + ';';
                if (w) {
                    sb[sb.length] = 'width:' + w + ';';
                }
                if (column.headerAlign) {
                    sb[sb.length] = 'text-align:' + column.headerAlign + ';';
                }
                sb[sb.length] = '">';
                sb[sb.length] = header;
                sb[sb.length] = '</td>';
            }
            sb[sb.length] = '</tr></table>';
        }
        this._headerEl.innerHTML = sb.join('');

        var data = this.data;
        if (this.virtual) data = [];
        var html = this.createTable(data);

        var innerHTML = html;

        if (this.virtual) {
            if (!this._verticalEl) {
                this._viewEl.innerHTML = '';
                mini.addClass(this.el, 'mini-listbox-virtual');
                this._vbarEl = jQuery(
                    '<div class="mini-scroll-vbar"><div class="mini-scroll-content"></div></div>'
                ).appendTo(this._viewEl)[0];
                this._bodyEl = jQuery('<div class="mini-listbox-body"></div>').appendTo(this._viewEl)[0];

                mini.on(this._vbarEl, 'scroll', this._onVScroll, this);

                var me = this;
                jQuery(this.el).on('mousewheel DOMMouseScroll', function (event) {
                    var delta = event.originalEvent.wheelDelta;
                    if (!delta) delta = -event.originalEvent.detail;
                    delta = delta > 0 ? 1 : -1;

                    me._vbarEl.scrollTop -= delta * 40;
                });
            }
        } else {
            this._viewEl.innerHTML = innerHTML;
        }

        this._doSelects();

        this.doLayout();

        if (this.virtual) {
            this.refreshItems();
        }
    },

    _onVScroll: function (event) {
        var me = this;
        if (!this._vscrollTimeout) {
            this._vscrollTimeout = setTimeout(function () {
                me._vscrollTimeout = null;
                me.refreshItems();
            }, 50);
        } else {
        }
    },

    getViewRange: function () {
        var range = {
            topRow: 0,
            bottomRow: 20,
            topOffset: 0
        };

        var scrollTop = this._vbarEl.scrollTop;
        var bodyHeight = this._bodyEl.offsetHeight;
        var itemHeight = this.getItemHeight();

        range.topRow = parseInt(scrollTop / itemHeight);
        range.topOffset = range.topRow * itemHeight - scrollTop;
        range.bottomRow = parseInt((scrollTop + bodyHeight) / itemHeight) + 1;

        return range;
    },

    refreshItems: function () {
        var range = this.getViewRange();
        var items = [];

        for (var i = range.topRow, l = range.bottomRow; i < l; i++) {
            var item = this.data[i];
            if (!item) break;
            items.push(item);
        }

        var html = this.createTable(items, range.topRow);
        this._bodyEl.innerHTML = html;

        this._bodyEl.firstChild.style.top = range.topOffset + 'px';
    },

    getItemHeight: function () {
        return 23;
    },

    doLayout: function () {
        if (this.columns && this.columns.length > 0) {
            mini.addClass(this.el, 'mini-listbox-showcolumns');
        } else {
            mini.removeClass(this.el, 'mini-listbox-showcolumns');
        }
        if (this.showCheckBox) {
            mini.removeClass(this.el, 'mini-listbox-hideCheckBox');
        } else {
            mini.addClass(this.el, 'mini-listbox-hideCheckBox');
        }

        var ckAllId = this.uid + '_ck_all';
        var ck = document.getElementById(ckAllId);
        if (ck) ck.style.display = this.showAllCheckBox ? '' : 'none';

        var autoHeight = this.isAutoHeight();

        h = this.getHeight(true);

        w = this.getWidth(true);
        var elWidth = w;

        var viewEl = this._viewEl;

        viewEl.style.width = w + 'px';

        if (!autoHeight) {
            var h2 = mini.getHeight(this._headerEl);
            h = h - h2;
            viewEl.style.height = h + 'px';
        } else {
            viewEl.style.height = 'auto';
        }

        if (isIE) {
            var table1 = this._headerEl.firstChild,
                table2 = this._viewEl.firstChild;
            if (this._viewEl.offsetHeight >= this._viewEl.scrollHeight) {
                table2.style.width = '100%';
                if (table1) table1.style.width = '100%';
            } else {
                var w = parseInt(table2.parentNode.offsetWidth - 17) + 'px';
                table2.style.width = w;
                if (table1) table1.style.width = w;
            }
        }

        var outHeight = this._viewEl.offsetHeight < this._viewEl.scrollHeight;

        if (this.virtual) {
            var scrollHeight = this.data.length * this.getItemHeight();
            this._vbarEl.firstChild.style.height = scrollHeight + 'px';
            this._bodyEl.style.right = this.getScrollbarSize() + 'px';
            outHeight = true;
        }

        if (outHeight) {
            this._headerEl.style.width = elWidth - this.getScrollbarSize() + 'px';
        } else {
            this._headerEl.style.width = '100%';
        }
    },

    getScrollbarSize: function () {
        return 17;
    },

    setShowCheckBox: function (value) {
        this.showCheckBox = value;
        this.doLayout();
    },
    getShowCheckBox: function () {
        return this.showCheckBox;
    },
    setShowAllCheckBox: function (value) {
        this.showAllCheckBox = value;
        this.doLayout();
    },
    getShowAllCheckBox: function () {
        return this.showAllCheckBox;
    },
    setShowColumns: function (value) {
        this.showColumns = value;

        this.doUpdate();
    },
    getShowColumns: function () {
        return this.showColumns;
    },
    setShowNullItem: function (value) {
        if (this.showNullItem != value) {
            this.showNullItem = value;

            this._doNullItem();

            this.doUpdate();
        }
    },
    getShowNullItem: function () {
        return this.showNullItem;
    },

    setNullItemText: function (value) {
        if (this.nullItemText != value) {
            this.nullItemText = value;

            this._doNullItem();

            this.doUpdate();
        }
    },
    getNullItemText: function () {
        return this.nullItemText;
    },
    getVirtual: function () {
        return this.virtual;
    },
    setVirtual: function (value) {
        this.virtual = value;
    },
    _doNullItem: function () {
        for (var i = 0, l = this.data.length; i < l; i++) {
            var item = this.data[i];
            if (item.__NullItem) {
                this.data.removeAt(i);
                break;
            }
        }
        if (this.showNullItem) {
            var item = { __NullItem: true };
            item[this.textField] = '';
            item[this.valueField] = '';
            this.data.insert(0, item);
        }
    },

    _OnDrawCell: function (record, index, column) {
        var value = column ? record[column.field] : this.getItemText(record);
        var e = {
            sender: this,
            index: index,
            rowIndex: index,
            record: record,
            item: record,
            column: column,
            field: column ? column.field : null,
            value: value,
            cellHtml: value,
            rowCls: null,
            cellCls: column ? column.cellCls || '' : '',
            rowStyle: null,
            cellStyle: column ? column.cellStyle || '' : ''
        };

        var hasColumns = this.columns && this.columns.length > 0;
        if (!hasColumns) {
            if (index == 0 && this.showNullItem) {
                e.cellHtml = this.nullItemText;
            }
        }

        if (e.autoEscape == true) {
            e.cellHtml = mini.htmlEncode(e.cellHtml);
        }

        if (column) {
            if (column.dateFormat) {
                if (mini.isDate(e.value)) e.cellHtml = mini.formatDate(value, column.dateFormat);
                else e.cellHtml = value;
            }
            var renderer = column.renderer;
            if (renderer) {
                fn = typeof renderer == 'function' ? renderer : window[renderer];
                if (fn) {
                    e.cellHtml = fn.call(column, e);
                }
            }
        }

        this.fire('drawcell', e);

        if (e.cellHtml === null || e.cellHtml === undefined || e.cellHtml === '') e.cellHtml = '&nbsp;';

        return e;
    },
    __OnScroll: function (e) {
        this._headerEl.scrollLeft = this._viewEl.scrollLeft;
    },
    __OnClick: function (e) {
        var ckAllId = this.uid + '_ck_all';
        if (e.target.id == ckAllId) {
            var ck = document.getElementById(ckAllId);
            if (ck) {
                var checked = ck.checked;

                var value = this.getValue();

                if (checked) {
                    this.selectAll();
                } else {
                    this.deselectAll();
                }
                this._OnSelectionChanged();

                if (value != this.getValue()) {
                    this._OnValueChanged();

                    this.fire('itemclick', { htmlEvent: e });
                }
            }
            return;
        }
        this._fireEvent(e, 'Click');
    },

    getAttrs: function (el) {
        var ctor = this.constructor;
        ctor.parseColumns = function (el) {
            return mini._ParseColumns(el);
        };

        var attrs = mini.ListBox.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['nullItemText', 'ondrawcell']);
        mini._ParseBool(el, attrs, ['showCheckBox', 'showAllCheckBox', 'showNullItem']);

        return attrs;
    }
});
mini.regClass(mini.ListBox, 'listbox');
mini.CheckBoxList = mini.ListControl.extend({
    type: 'checkboxlist',
    tag: 'mini-checkboxlist',
    formField: true,

    props: {
        multiSelect: true,
        repeatItems: 0,
        repeatLayout: 'none',
        repeatDirection: 'horizontal'
    },

    itemCls: 'mini-checkboxlist-item',
    itemHoverCls: 'mini-checkboxlist-item-hover',
    itemSelectedCls: 'mini-checkboxlist-item-selected',
    tableCls: 'mini-checkboxlist-table',
    tdCls: 'mini-checkboxlist-td',
    checkType: 'checkbox',

    _create: function () {
        var el = (this.el = document.createElement('div'));
        this.el.className = this.uiCls;

        this.el.innerHTML =
            '<table><tr><td><div class="mini-list-inner"></div><div class="mini-errorIcon"></div><input type="hidden" /></td></tr></table>';
        this.cellEl = this.el.firstChild.rows[0].cells[0];
        this._innerEl = this.cellEl.firstChild;
        this._valueEl = this.cellEl.lastChild;
        this._errorIconEl = this.cellEl.childNodes[1];
    },

    _getRepeatTable: function () {
        var table = [];
        if (this.repeatItems > 0) {
            if (this.repeatDirection == 'horizontal') {
                var row = [];
                for (var i = 0, l = this.data.length; i < l; i++) {
                    var item = this.data[i];
                    if (row.length == this.repeatItems) {
                        table.push(row);
                        row = [];
                    }
                    row.push(item);
                }
                table.push(row);
            } else {
                var len = this.repeatItems > this.data.length ? this.data.length : this.repeatItems;
                for (var i = 0, l = len; i < l; i++) {
                    table.push([]);
                }
                for (var i = 0, l = this.data.length; i < l; i++) {
                    var item = this.data[i];
                    var index = i % this.repeatItems;
                    table[index].push(item);
                }
            }
        } else {
            table = [this.data.clone()];
        }
        return table;
    },
    doUpdate: function () {
        var data = this.data;
        var s = '';

        for (var i = 0, l = data.length; i < l; i++) {
            var item = data[i];
            item._i = i;
        }

        if (this.repeatLayout == 'flow') {
            var table = this._getRepeatTable();
            for (var i = 0, l = table.length; i < l; i++) {
                var row = table[i];
                for (var j = 0, k = row.length; j < k; j++) {
                    var item = row[j];
                    s += this._createItemHtml(item, item._i);
                }
                if (i != l - 1) {
                    s += '<br/>';
                }
            }
        } else if (this.repeatLayout == 'table') {
            var table = this._getRepeatTable();
            s += '<table class="' + this.tableCls + '" cellpadding="0" cellspacing="1">';
            for (var i = 0, l = table.length; i < l; i++) {
                var row = table[i];
                s += '<tr>';
                for (var j = 0, k = row.length; j < k; j++) {
                    var item = row[j];
                    s += '<td class="' + this.tdCls + '">';
                    s += this._createItemHtml(item, item._i);
                    s += '</td>';
                }
                s += '</tr>';
            }
            s += '</table>';
        } else {
            for (var i = 0, l = data.length; i < l; i++) {
                var item = data[i];
                s += this._createItemHtml(item, i);
            }
        }
        this._innerEl.innerHTML = s;

        for (var i = 0, l = data.length; i < l; i++) {
            var item = data[i];
            delete item._i;
        }
    },
    _createItemHtml: function (item, index) {
        var e = this._OnDrawItem(item, index);
        var id = this._createItemId(index);
        var ckId = this._createCheckId(index);
        var ckValue = this.getItemValue(item);

        var disable = '';

        var s = '<div id="' + id + '" index="' + index + '" class="' + this.itemCls + ' ';
        if (item.enabled === false) {
            s += ' mini-disabled ';
            disable = 'disabled';
        }

        var onclick = 'onclick="return false"';
        if (isChrome) {
            onclick = 'onmousedown="this._checked = this.checked;" onclick="this.checked = this._checked"';
        }
        s +=
            e.itemCls +
            '" style="' +
            e.itemStyle +
            '"><input ' +
            onclick +
            ' ' +
            disable +
            ' value="' +
            ckValue +
            '" id="' +
            ckId +
            '" type="' +
            this.checkType +
            '" /><label for="' +
            ckId +
            '" onclick="return false;">';
        s += e.itemHtml + '</label></div>';
        return s;
    },
    _OnDrawItem: function (item, index) {
        var value = this.getItemText(item);
        var e = {
            index: index,
            item: item,
            itemHtml: value,
            itemCls: '',
            itemStyle: ''
        };
        this.fire('drawitem', e);

        if (e.itemHtml === null || e.itemHtml === undefined) e.itemHtml = '';

        return e;
    },

    setRepeatItems: function (value) {
        value = parseInt(value);
        if (isNaN(value)) value = 0;
        if (this.repeatItems != value) {
            this.repeatItems = value;
            this.doUpdate();
        }
    },
    getRepeatItems: function () {
        return this.repeatItems;
    },
    setRepeatLayout: function (value) {
        if (value != 'flow' && value != 'table') value = 'none';
        if (this.repeatLayout != value) {
            this.repeatLayout = value;
            this.doUpdate();
        }
    },
    getRepeatLayout: function () {
        return this.repeatLayout;
    },
    setRepeatDirection: function (value) {
        if (value != 'vertical') value = 'horizontal';
        if (this.repeatDirection != value) {
            this.repeatDirection = value;
            this.doUpdate();
        }
    },
    getRepeatDirection: function () {
        return this.repeatDirection;
    },

    getAttrs: function (el) {
        var attrs = mini.CheckBoxList.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        mini._ParseString(el, attrs, ['ondrawitem']);

        var repeatItems = parseInt(jq.attr('repeatItems'));
        if (!isNaN(repeatItems)) {
            attrs.repeatItems = repeatItems;
        }
        var repeatLayout = jq.attr('repeatLayout');
        if (repeatLayout) {
            attrs.repeatLayout = repeatLayout;
        }
        var repeatDirection = jq.attr('repeatDirection');
        if (repeatDirection) {
            attrs.repeatDirection = repeatDirection;
        }
        return attrs;
    }
});
mini.regClass(mini.CheckBoxList, 'checkboxlist');
mini.RadioButtonList = mini.CheckBoxList.extend({
    multiSelect: false,

    itemCls: 'mini-radiobuttonlist-item',
    itemHoverCls: 'mini-radiobuttonlist-item-hover',
    itemSelectedCls: 'mini-radiobuttonlist-item-selected',

    tableCls: 'mini-radiobuttonlist-table',
    tdCls: 'mini-radiobuttonlist-td',
    checkType: 'radio',

    uiCls: 'mini-radiobuttonlist'
});
mini.regClass(mini.RadioButtonList, 'radiobuttonlist');
mini.TreeSelect = mini.PopupEdit.extend({
    type: 'treeselect',
    tag: 'mini-treeselect',

    props: {
        valueFromSelect: false,

        text: '',
        value: '',

        autoCheckParent: false,
        expandOnLoad: false,

        valueField: 'id',
        textField: 'text',
        nodesField: 'children',
        delimiter: ',',

        multiSelect: false,
        data: null,
        url: '',

        allowInput: false,

        showTreeIcon: false,
        showTreeLines: true,

        resultAsTree: false,
        parentField: 'pid',
        checkRecursive: false,

        showFolderCheckBox: false,

        popupHeight: 200,
        popupWidth: '100%',
        popupMaxHeight: 250,
        popupMinWidth: 100
    },

    initComponent: function () {
        this.data = this.data || [];
        this.callParent('initComponent');
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var value = kv.value;
        delete kv.value;
        var text = kv.text;
        delete kv.text;
        var url = kv.url;
        delete kv.url;
        var data = kv.data;
        delete kv.data;

        this.callParent('set', kv);

        if (!mini.isNull(data)) {
            this.setData(data);
        }
        if (!mini.isNull(url)) {
            this.setUrl(url);
        }
        if (!mini.isNull(value)) {
            this.setValue(value);
        }
        if (!mini.isNull(text)) {
            this.setText(text);
        }
        return this;
    },

    _createPopup: function () {
        mini.TreeSelect.superclass._createPopup.call(this);

        this.tree = new mini.Tree();
        this.tree.setShowTreeIcon(true);
        this.tree.setStyle('border:0;width:100%;height:100%;');
        this.tree.setResultAsTree(this.resultAsTree);
        this.tree.render(this.popup._contentEl);
        this.tree.setCheckRecursive(this.checkRecursive);
        this.tree.setShowFolderCheckBox(this.showFolderCheckBox);

        this.tree.on('nodeclick', this.__OnNodeClick, this);
        this.tree.on('nodecheck', this.__OnCheckedChanged, this);
        this.tree.on('expand', this.__OnTreeExpand, this);
        this.tree.on('collapse', this.__OnTreeCollapse, this);
        this.tree.on('beforenodecheck', this.__OnTreeBeforeNodeCheck, this);
        this.tree.on('beforenodeselect', this.__OnTreeBeforeNodeSelect, this);
        this.tree.on('drawnode', this.__OnDrawNode, this);
        this.tree.allowAnim = false;

        var me = this;
        this.tree.on(
            'beforeload',
            function (e) {
                me.fire('beforeload', e);
            },
            this
        );
        this.tree.on(
            'load',
            function (e) {
                me.fire('load', e);
            },
            this
        );
        this.tree.on(
            'loaderror',
            function (e) {
                me.fire('loaderror', e);
            },
            this
        );
    },
    __OnDrawNode: function (e) {
        this.fire('drawnode', e);
    },
    __OnTreeBeforeNodeCheck: function (e) {
        e.tree = e.sender;
        this.fire('beforenodecheck', e);
    },
    __OnTreeBeforeNodeSelect: function (e) {
        e.tree = e.sender;
        this.fire('beforenodeselect', e);
    },
    __OnTreeExpand: function (e) {},
    __OnTreeCollapse: function (e) {},
    getSelectedNode: function () {
        return this.tree.getSelectedNode();
    },
    getCheckedNodes: function (hasParent) {
        return this.tree.getCheckedNodes(hasParent);
    },
    getSelectedNodes: function () {
        return this.tree.getSelectedNodes();
    },
    getParentNode: function (node) {
        return this.tree.getParentNode(node);
    },
    getChildNodes: function (node) {
        return this.tree.getChildNodes(node);
    },

    showPopup: function () {
        var ex = { cancel: false };
        this.fire('beforeshowpopup', ex);
        if (ex.cancel == true) return;

        mini.TreeSelect.superclass.showPopup.call(this);

        this.tree.setValue(this.value);
    },

    __OnPopupHide: function (e) {
        this.__doFocusCls();
        this.tree.clearFilter();
        this.fire('hidepopup');
    },
    getItem: function (item) {
        return typeof item == 'object' ? item : this.data[item];
    },
    indexOf: function (item) {
        return this.data.indexOf(item);
    },
    getAt: function (index) {
        return this.data[index];
    },
    loadList: function (list, idField, parentField) {
        this.tree.loadList(list, idField, parentField);
        this.data = this.tree.getData();
    },
    getList: function () {
        return this.tree.getList();
    },
    load: function (data) {
        this.tree.load(data);
    },
    _eval: function (_) {
        return eval('(' + _ + ')');
    },
    setData: function (data) {
        if (typeof data == 'string') {
            data = this._eval(data);
        }
        if (!mini.isArray(data)) data = [];
        this.tree.setData(data);
        this.data = this.tree.data;
    },
    getData: function () {
        return this.data;
    },
    setUrl: function (url) {
        if (!url) return;
        this.getPopup();

        this.tree.setUrl(url);
        this.url = this.tree.url;
    },
    getUrl: function () {
        return this.url;
    },
    setTextField: function (value) {
        if (this.tree) this.tree.setTextField(value);
        this.textField = value;
    },
    getTextField: function () {
        return this.textField;
    },
    setNodesField: function (value) {
        if (this.tree) this.tree.setNodesField(value);
        this.nodesField = value;
    },
    getNodesField: function () {
        return this.nodesField;
    },

    setValue: function (value) {
        var vts = this.tree.getValueAndText(value);
        if (vts[1] == '' && !this.valueFromSelect) {
            vts[0] = value;
            vts[1] = value;
        }
        this.value = value;

        this._valueEl.value = value;

        this.text = this._textEl.value = vts[1];

        this._doEmpty();

        this.tree.value = this.value;
    },
    setMultiSelect: function (value) {
        if (this.multiSelect != value) {
            this.multiSelect = value;
            this.tree.setShowCheckBox(value);
            this.tree.setAllowSelect(!value);
            this.tree.setEnableHotTrack(!value);
        }
    },
    getMultiSelect: function () {
        return this.multiSelect;
    },
    __OnNodeClick: function (e) {
        if (this.multiSelect) return;

        var node = this.tree.getSelectedNode();
        var v = this.tree.getItemValue(node);

        var value = this.getValue();
        this.setValue(v);
        if (value != this.getValue()) {
            this._OnValueChanged();
        }

        this.hidePopup();
        this.focus();

        this.fire('nodeclick', { node: e.node });
    },
    __OnCheckedChanged: function (e) {
        if (!this.multiSelect) return;
        var v = this.tree.getValue();

        var value = this.getValue();
        this.setValue(v);
        if (value != this.getValue()) {
            this._OnValueChanged();
        }
        this.focus();
    },

    __OnInputKeyDown: function (e) {
        var ex = { htmlEvent: e };
        this.fire('keydown', ex);
        if (e.keyCode == 8 && (this.isReadOnly() || this.allowInput == false)) {
            return false;
        }

        if (e.keyCode == 9) {
            this.hidePopup();
            return;
        }

        if (this.isReadOnly()) return;

        switch (e.keyCode) {
            case 27:
                if (this.isShowPopup()) {
                    e.stopPropagation();
                }

                this.hidePopup();
                break;
            case 13:
                var me = this;
                setTimeout(function () {
                    me.fire('enter', ex);
                }, 10);
                break;
            case 37:
                break;
            case 38:
                e.preventDefault();
                break;
            case 39:
                break;
            case 40:
                e.preventDefault();
                this.showPopup();
                break;
            default:
                var me = this;
                setTimeout(function () {
                    me._doQuery();
                }, 10);
                break;
        }
    },
    _doQuery: function () {
        var field = this.textField;
        var value = this._textEl.value.toLowerCase();
        this.tree.filter(function (node) {
            var text = String(node[field] ? node[field] : '').toLowerCase();
            if (text.indexOf(value) != -1) {
                return true;
            } else return false;
        });
        this.tree.expandAll();
        this.showPopup();
    },

    setCheckRecursive: function (value) {
        this.checkRecursive = value;
        if (this.tree) this.tree.setCheckRecursive(value);
    },
    getCheckRecursive: function () {
        return this.checkRecursive;
    },
    setResultAsTree: function (value) {
        this.resultAsTree = value;
        if (this.tree) this.tree.setResultAsTree(value);
    },
    getResultAsTree: function () {
        return this.resultAsTree;
    },
    setParentField: function (value) {
        this.parentField = value;
        if (this.tree) this.tree.setParentField(value);
    },
    getParentField: function () {
        return this.parentField;
    },
    setValueField: function (valueField) {
        if (this.tree) this.tree.setIdField(valueField);
        this.valueField = valueField;
    },
    getValueField: function () {
        return this.valueField;
    },
    setShowTreeIcon: function (value) {
        this.showTreeIcon = value;
        if (this.tree) this.tree.setShowTreeIcon(value);
    },
    getShowTreeIcon: function () {
        return this.showTreeIcon;
    },
    setShowTreeLines: function (value) {
        this.showTreeLines = value;
        if (this.tree) this.tree.setShowTreeLines(value);
    },
    getShowTreeLines: function () {
        return this.showTreeLines;
    },
    setShowFolderCheckBox: function (value) {
        this.showFolderCheckBox = value;
        if (this.tree) this.tree.setShowFolderCheckBox(value);
    },
    getShowFolderCheckBox: function () {
        return this.showFolderCheckBox;
    },
    setAutoCheckParent: function (value) {
        this.autoCheckParent = value;
        if (this.tree) this.tree.setAutoCheckParent(value);
    },
    getAutoCheckParent: function () {
        return this.autoCheckParent;
    },
    setExpandOnLoad: function (value) {
        this.expandOnLoad = value;
        if (this.tree) this.tree.setExpandOnLoad(value);
    },
    getExpandOnLoad: function () {
        return this.expandOnLoad;
    },
    setValueFromSelect: function (value) {
        this.valueFromSelect = value;
    },
    getValueFromSelect: function () {
        return this.valueFromSelect;
    },
    setDataField: function (value) {
        if (this.tree) this.tree.setDataField(value);
        this.dataField = value;
    },
    getAttrs: function (el) {
        var attrs = mini.ComboBox.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'url',
            'data',
            'textField',
            'valueField',
            'nodesField',
            'parentField',
            'onbeforenodecheck',
            'onbeforenodeselect',
            'expandOnLoad',
            'onnodeclick',
            'onbeforeload',
            'onload',
            'onloaderror',
            'ondrawnode'
        ]);
        mini._ParseBool(el, attrs, [
            'multiSelect',
            'resultAsTree',
            'checkRecursive',
            'showTreeIcon',
            'showTreeLines',
            'showFolderCheckBox',
            'autoCheckParent',
            'valueFromSelect'
        ]);

        if (attrs.expandOnLoad) {
            var level = parseInt(attrs.expandOnLoad);
            if (mini.isNumber(level)) {
                attrs.expandOnLoad = level;
            } else {
                attrs.expandOnLoad = attrs.expandOnLoad == 'true' ? true : false;
            }
        }

        return attrs;
    }
});
mini.regClass(mini.TreeSelect, 'TreeSelect');
mini.TimeSpinner = mini.ButtonEdit.extend({
    type: 'timespinner',
    tag: 'mini-timespinner',

    props: {
        value: '00:00:00',
        format: 'H:mm:ss'
    },

    _getButtonHtml: function () {
        var hover =
            'onmouseover="mini.addClass(this, \'' +
            this._buttonHoverCls +
            '\');" ' +
            'onmouseout="mini.removeClass(this, \'' +
            this._buttonHoverCls +
            '\');"';
        return (
            '<span class="mini-buttonedit-button" ' +
            hover +
            '><span class="mini-buttonedit-up"><span></span></span><span class="mini-buttonedit-down"><span></span></span></span>'
        );
    },
    _initEvents: function () {
        mini.TimeSpinner.superclass._initEvents.call(this);

        mini._BindEvents(function () {
            this.on('buttonmousedown', this.__OnButtonMouseDown, this);
            mini.on(this.el, 'mousewheel', this.__OnMousewheel, this);
            mini.on(this._textEl, 'keydown', this.__OnKeyDown, this);
        }, this);
    },
    setFormat: function (value) {
        if (typeof value != 'string') return;
        var formats = ['H:mm:ss', 'HH:mm:ss', 'H:mm', 'HH:mm', 'H', 'HH', 'mm:ss'];

        if (this.format != value) {
            this.format = value;
            this.text = this._textEl.value = this.getFormattedValue();
        }
    },
    getFormat: function () {
        return this.format;
    },
    setValue: function (value) {
        value = mini.parseTime(value, this.format);
        if (!value) value = mini.parseTime('00:00:00', this.format);

        if (mini.isDate(value)) value = new Date(value?.getTime());

        if (mini.formatDate(this.value, 'H:mm:ss') != mini.formatDate(value, 'H:mm:ss')) {
            this.value = value;
            this.text = this._textEl.value = this.getFormattedValue();
            this._valueEl.value = this.getFormValue();
        }
    },
    getValue: function () {
        return this.value == null ? null : new Date(this.value?.getTime());
    },
    getFormValue: function () {
        if (!this.value) return '';
        return mini.formatDate(this.value, 'H:mm:ss');
    },
    getFormattedValue: function () {
        if (!this.value) return '';
        return mini.formatDate(this.value, this.format);
    },
    _ChangeValue: function (Increment, timeType) {
        var value = this.getValue();
        if (value) {
            switch (timeType) {
                case 'hours':
                    var hours = value?.getHours() + Increment;
                    if (hours > 23) hours = 23;
                    if (hours < 0) hours = 0;
                    value?.setHours(hours);
                    break;
                case 'minutes':
                    var minutes = value?.getMinutes() + Increment;
                    if (minutes > 59) minutes = 59;
                    if (minutes < 0) minutes = 0;
                    value?.setMinutes(minutes);
                    break;
                case 'seconds':
                    var seconds = value?.getSeconds() + Increment;
                    if (seconds > 59) seconds = 59;
                    if (seconds < 0) seconds = 0;
                    value?.setSeconds(seconds);
                    break;
            }
        } else {
            value = '00:00:00';
        }

        this.setValue(value);
    },

    _SpinTimer: null,
    _StartSpin: function (Increment, time, count) {
        this._StopSpin();

        this._ChangeValue(Increment, this._timeType);

        var sf = this;
        var sourceCount = count;
        var now = new Date();
        this._SpinTimer = setInterval(function () {
            sf._ChangeValue(Increment, sf._timeType);

            count--;
            if (count == 0 && time > 50) {
                sf._StartSpin(Increment, time - 100, sourceCount + 3);
            }

            var now2 = new Date();
            if (now2 - now > 500) sf._StopSpin();
            now = now2;
        }, time);
        mini.on(document, 'mouseup', this._OnDocumentMouseUp, this);
    },
    _StopSpin: function () {
        clearInterval(this._SpinTimer);
        this._SpinTimer = null;
    },
    __OnButtonMouseDown: function (e) {
        this._DownValue = this.getFormValue();
        this._timeType = 'hours';
        if (e.spinType == 'up') {
            this._StartSpin(1, 230, 2);
        } else {
            this._StartSpin(-1, 230, 2);
        }
    },

    _OnDocumentMouseUp: function (e) {
        this._StopSpin();
        mini.un(document, 'mouseup', this._OnDocumentMouseUp, this);

        if (this._DownValue != this.getFormValue()) {
            this._OnValueChanged();
        }
    },
    __OnInputTextChanged: function (e) {
        var _value = this.getFormValue();

        this.setValue(this._textEl.value);

        if (_value != this.getFormValue()) {
            this._OnValueChanged();
        }
    },

    getAttrs: function (el) {
        var attrs = mini.TimeSpinner.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['format']);

        return attrs;
    }
});
mini.regClass(mini.TimeSpinner, 'timespinner');
mini.HtmlFile = mini.ButtonEdit.extend({
    type: 'htmlfile',
    tag: 'mini-htmlfile',

    props: {
        width: 180,
        buttonText: '浏览...',
        imitType: '',

        limitTypeErrorText: '上传文件格式为：',
        allowInput: false,
        readOnly: true
    },
    _buttonWidth: 56,
    _cellSpacing: 0,

    initComponent: function () {
        this.callParent('initComponent');
        this.on('validation', this.__OnValidation, this);
    },

    _create: function () {
        mini.HtmlFile.superclass._create.call(this);

        this._fileEl = mini.append(
            this.el,
            '<input type="file" hideFocus class="mini-htmlfile-file" name="' + this.name + '" ContentEditable=false/>'
        );
        mini.on(this._borderEl, 'mousemove', this.__OnMouseMove, this);
        mini.on(this._fileEl, 'change', this.__OnFileChange, this);
    },
    _getButtonHtml: function () {
        var hover =
            'onmouseover="mini.addClass(this, \'' +
            this._buttonHoverCls +
            '\');" ' +
            'onmouseout="mini.removeClass(this, \'' +
            this._buttonHoverCls +
            '\');"';
        return '<span class="mini-buttonedit-button" ' + hover + '>' + this.buttonText + '</span>';
    },
    __OnFileChange: function (e) {
        this.value = this._textEl.value = this._fileEl.value;
        this._OnValueChanged();

        e = { htmlEvent: e };
        this.fire('fileselect', e);
    },
    __OnMouseMove: function (e) {
        var x = e.pageX,
            y = e.pageY;
        var box = mini.getBox(this.el);

        x = x - box.x - 5;
        y = y - box.y - 5;

        if (this.enabled == false) {
            x = -20;
            y = -20;
        }
        this._fileEl.style.display = '';
        this._fileEl.style.left = x + 'px';
        this._fileEl.style.top = y + 'px';
    },
    __OnValidation: function (e) {
        if (!this.limitType) return;

        var vs = e.value.split('.');
        var fileType = '*.' + vs[vs.length - 1];
        var types = this.limitType.split(';');

        if (types.length > 0 && types.indexOf(fileType) == -1) {
            e.errorText = this.limitTypeErrorText + this.limitType;
            e.isValid = false;
        }
    },
    setName: function (value) {
        this.name = value;
        mini.setAttr(this._fileEl, 'name', this.name);
    },
    getValue: function () {
        return this._textEl.value;
    },

    setButtonText: function (value) {
        this.buttonText = value;
    },
    getButtonText: function () {
        return this.buttonText;
    },
    setLimitType: function (value) {
        this.limitType = value;
    },
    getLimitType: function () {
        return this.limitType;
    },

    getAttrs: function (el) {
        var attrs = mini.HtmlFile.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['limitType', 'buttonText', 'limitTypeErrorText']);

        return attrs;
    }
});
mini.regClass(mini.HtmlFile, 'htmlfile');
mini.FileUpload = mini.ButtonEdit.extend({
    type: 'fileupload',
    tag: 'mini-fileupload',

    props: {
        width: 180,
        buttonText: '浏览...',
        limitTypeErrorText: '上传文件格式为：',
        readOnly: true,
        limitSize: '',
        limitType: '',
        typesDescription: '上传文件格式',
        uploadLimit: 0,
        queueLimit: '',
        flashUrl: '',
        uploadUrl: '',
        postParam: null,
        uploadOnSelect: false
    },

    _buttonWidth: 56,
    _cellSpacing: 0,

    initComponent: function () {
        this.postParam = this.postParam || {};
        this.callParent('initComponent');
        this.on('validation', this.__OnValidation, this);
    },

    _create: function () {
        mini.FileUpload.superclass._create.call(this);

        mini.addClass(this.el, 'mini-htmlfile');

        this._uploadId = this.uid + '$button_placeholder';
        this._fileEl = mini.append(this.el, '<span id="' + this._uploadId + '"></span>');
        this.uploadEl = this._fileEl;

        mini.on(this._borderEl, 'mousemove', this.__OnMouseMove, this);
    },
    _getButtonHtml: function () {
        var hover =
            'onmouseover="mini.addClass(this, \'' +
            this._buttonHoverCls +
            '\');" ' +
            'onmouseout="mini.removeClass(this, \'' +
            this._buttonHoverCls +
            '\');"';
        return '<span class="mini-buttonedit-button" ' + hover + '>' + this.buttonText + '</span>';
    },
    destroy: function (removeEl) {
        if (this._innerEl) {
            mini.clearEvent(this._innerEl);

            this._innerEl = null;
        }
        mini.FileUpload.superclass.destroy.call(this, removeEl);
    },
    __OnMouseMove: function (evt) {
        if (this.enabled == false) return;
        var sf = this;
        if (!this.swfUpload) {
            var upload = new SWFUpload({
                file_post_name: this.name,
                upload_url: sf.uploadUrl,
                flash_url: sf.flashUrl,

                file_size_limit: sf.limitSize,
                file_types: sf.limitType,
                file_types_description: sf.typesDescription,
                file_upload_limit: parseInt(sf.uploadLimit),
                file_queue_limit: sf.queueLimit,

                file_queued_handler: mini.createDelegate(this.__on_file_queued, this),

                upload_error_handler: mini.createDelegate(this.__on_upload_error, this),
                upload_success_handler: mini.createDelegate(this.__on_upload_success, this),
                upload_complete_handler: mini.createDelegate(this.__on_upload_complete, this),

                button_placeholder_id: this._uploadId,
                button_width: 1000,
                button_height: 50,
                button_window_mode: 'transparent',

                debug: false
            });
            upload.flashReady();
            this.swfUpload = upload;

            var el = this.swfUpload.movieElement;
            el.style.zIndex = 1000;
            el.style.position = 'absolute';
            el.style.left = '0px';
            el.style.top = '0px';
            el.style.width = '100%';
            el.style.height = '50px';
        } else {
        }
    },
    addPostParam: function (value) {
        mini.copyTo(this.postParam, value);
    },
    setPostParam: function (value) {
        this.addPostParam(value);
    },
    getPostParam: function () {
        return this.postParam;
    },
    setLimitType: function (value) {
        this.limitType = value;
    },
    getLimitType: function () {
        return this.limitType;
    },
    setTypesDescription: function (str) {
        this.typesDescription = str;
    },
    getTypesDescription: function () {
        return this.typesDescription;
    },
    setButtonText: function (value) {
        this.buttonText = value;
        this._buttonEl.innerHTML = value;
    },
    getButtonText: function () {
        return this.buttonText;
    },

    setUploadLimit: function (value) {
        this.uploadLimit = value;
    },

    setQueueLimit: function (value) {
        this.queueLimit = value;
    },
    setFlashUrl: function (value) {
        this.flashUrl = value;
    },

    setUploadUrl: function (value) {
        if (this.swfUpload) {
            this.swfUpload.setUploadURL(value);
        }
        this.uploadUrl = value;
    },

    setName: function (value) {
        this.name = value;
    },

    startUpload: function (params) {
        var e = { cancel: false };
        this.fire('beforeupload', e);
        if (e.cancel == true) return;
        if (this.swfUpload) {
            this.swfUpload.setPostParams(this.postParam);
            this.swfUpload.startUpload();
        }
    },

    __on_file_queued: function (file) {
        var e = { file: file };

        if (this.uploadOnSelect) {
            this.startUpload();
        }
        this.setText(file.name);

        this.fire('fileselect', e);
    },
    __on_upload_success: function (file, serverData) {
        var e = { file: file, serverData: serverData };
        this.fire('uploadsuccess', e);
    },
    __on_upload_error: function (file) {
        var e = { file: file };

        this.fire('uploaderror', e);
    },
    __on_upload_complete: function (e) {
        this.fire('uploadcomplete', e);
    },
    __fileError: function () {},

    getAttrs: function (el) {
        var attrs = mini.FileUpload.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'limitType',
            'limitSize',
            'flashUrl',
            'uploadUrl',
            'uploadLimit',
            'buttonText',
            'onuploadsuccess',
            'onuploaderror',
            'onuploadcomplete',
            'onfileselect'
        ]);

        mini._ParseBool(el, attrs, ['uploadOnSelect']);

        return attrs;
    }
});
mini.regClass(mini.FileUpload, 'fileupload');

mini.Lookup = mini.PopupEdit.extend({
    type: 'lookup',
    tag: 'mini-lookup',

    props: {
        allowInput: true,
        valueField: 'id',
        textField: 'text',
        delimiter: ',',
        multiSelect: false,
        data: null,
        grid: null
    },

    _destroyPopup: false,

    initComponent: function () {
        this.data = this.data || [];
        this.callParent('initComponent');
        mini.on(this._textEl, 'mouseup', this.__OnMouseUp, this);
        this.on('showpopup', this.__OnShowPopup, this);
    },

    destroy: function (removeEl) {
        if (this.grid) {
            this.grid.un('rowclick', this.__OnGridRowClickChanged, this);
            this.grid.un('load', this.__OnGridLoad, this);
            this.grid = null;
        }
        mini.Lookup.superclass.destroy.call(this, removeEl);
    },
    setMultiSelect: function (value) {
        this.multiSelect = value;

        if (this.grid) this.grid.setMultiSelect(value);
    },
    setGrid: function (value) {
        if (typeof value == 'string') {
            mini.parse(value);
            value = mini.get(value);
        }
        this.grid = mini.getAndCreate(value);
        if (this.grid) {
            this.grid.setMultiSelect(this.multiSelect);
            this.grid.setCheckSelectOnLoad(false);
            this.grid.on('rowclick', this.__OnGridRowClickChanged, this);
            this.grid.on('load', this.__OnGridLoad, this);
            this.grid.on('checkall', this.__OnGridRowClickChanged, this);
        }
    },
    getGrid: function () {
        return this.grid;
    },
    setValueField: function (valueField) {
        this.valueField = valueField;
    },
    getValueField: function () {
        return this.valueField;
    },
    setTextField: function (value) {
        this.textField = value;
    },
    getTextField: function () {
        return this.textField;
    },
    deselectAll: function () {
        this.data = [];
        this.setValue('');
        this.setText('');
        if (this.grid) this.grid.deselectAll();
    },

    getItemValue: function (item) {
        return String(item[this.valueField]);
    },
    getItemText: function (item) {
        var t = item[this.textField];
        return mini.isNull(t) ? '' : String(t);
    },
    getValueAndText: function (records) {
        if (mini.isNull(records)) records = [];

        var values = [];
        var texts = [];
        for (var i = 0, l = records.length; i < l; i++) {
            var record = records[i];
            if (record) {
                values.push(this.getItemValue(record));
                texts.push(this.getItemText(record));
            }
        }
        return [values.join(this.delimiter), texts.join(this.delimiter)];
    },
    _createData: function () {
        this.value = mini.isNull(this.value) ? '' : String(this.value);
        this.text = mini.isNull(this.text) ? '' : String(this.text);

        var data = [];
        var values = this.value.split(this.delimiter);
        var texts = this.text.split(this.delimiter);
        var len = values.length;

        if (this.value) {
            for (var i = 0, l = len; i < l; i++) {
                var row = {};
                var id = values[i];
                var text = texts[i];
                row[this.valueField] = id ? id : '';
                row[this.textField] = text ? text : '';
                data.push(row);
            }
        }
        this.data = data;
    },
    _getValueMaps: function (rows) {
        var vs = {};
        for (var i = 0, l = rows.length; i < l; i++) {
            var row = rows[i];
            var id = row[this.valueField];
            vs[id] = row;
        }
        return vs;
    },
    setValue: function (value) {
        mini.Lookup.superclass.setValue.call(this, value);
        this._createData();
    },
    setText: function (value) {
        mini.Lookup.superclass.setText.call(this, value);
        this._createData();
    },
    __OnGridRowClickChanged: function (e) {
        var rows = this._getValueMaps(this.grid.getData());
        var sels = this._getValueMaps(this.grid.getSelecteds());
        var vs = this._getValueMaps(this.data);
        if (this.multiSelect == false) {
            vs = {};
            this.data = [];
        }

        var removes = {};
        for (var id in vs) {
            var o = vs[id];
            if (rows[id]) {
                if (sels[id]) {
                } else {
                    removes[id] = o;
                }
            }
        }
        for (var i = this.data.length - 1; i >= 0; i--) {
            var o = this.data[i];
            var id = o[this.valueField];
            if (removes[id]) this.data.removeAt(i);
        }

        for (var id in sels) {
            var o = sels[id];
            if (!vs[id]) this.data.push(o);
        }

        var vts = this.getValueAndText(this.data);

        this.setValue(vts[0]);
        this.setText(vts[1]);

        this._OnValueChanged();
    },
    __OnGridLoad: function (e) {
        this.__OnShowPopup(e);
    },
    __OnShowPopup: function (e) {
        var vsb = String(this.value).split(this.delimiter);
        var vs = {};
        for (var i = 0, l = vsb.length; i < l; i++) {
            var v = vsb[i];
            vs[v] = 1;
        }

        var rows = this.grid.getData();

        var sels = [];
        for (var i = 0, l = rows.length; i < l; i++) {
            var row = rows[i];
            var id = row[this.valueField];
            if (vs[id]) sels.push(row);
        }

        this.grid.selects(sels);
    },

    doUpdate: function () {
        mini.Lookup.superclass.doUpdate.call(this);
        this._textEl.readOnly = true;
        this.el.style.cursor = 'default';
    },
    __OnInputKeyDown: function (e) {
        mini.Lookup.superclass.__OnInputKeyDown.call(this, e);

        switch (e.keyCode) {
            case 46:
            case 8:
                break;
            case 37:
                break;
            case 39:
                break;
        }
    },
    __OnMouseUp: function (e) {
        if (this.isReadOnly()) return;

        var rg = mini.getSelectRange(this._textEl);
        var start = rg[0],
            end = rg[1];

        var index = this._findTextIndex(start);
    },
    _findTextIndex: function (rgIndex) {
        var index = -1;
        if (this.text == '') return index;

        var texts = String(this.text).split(this.delimiter);
        var len = 0;
        for (var i = 0, l = texts.length; i < l; i++) {
            var text = texts[i];
            if (len < rgIndex && rgIndex <= len + text.length) {
                index = i;
                break;
            }
            len = len + text.length + 1;
        }
        return index;
    },

    getAttrs: function (el) {
        var attrs = mini.Lookup.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['grid', 'valueField', 'textField']);
        mini._ParseBool(el, attrs, ['multiSelect']);

        return attrs;
    }
});

mini.regClass(mini.Lookup, 'lookup');

mini.TextBoxList = mini.Field.extend({
    type: 'textboxlist',
    tag: 'mini-textboxlist',

    props: {
        value: '',
        text: '',
        valueField: 'id',
        textField: 'text',

        url: '',
        delay: 150,

        allowInput: true,

        editIndex: 0,
        textName: ''
    },

    focusCls: 'mini-textboxlist-focus',
    itemHoverClass: 'mini-textboxlist-item-hover',
    itemSelectedClass: 'mini-textboxlist-item-selected',
    closeHoverClass: 'mini-textboxlist-close-hover',

    initComponent: function () {
        this.data = this.data || [];
        this.callParent('initComponent');
        this.doUpdate();
    },

    setTextName: function (value) {
        this.textName = value;
    },
    getTextName: function () {
        return this.textName;
    },

    _create: function () {
        var html =
            '<table class="mini-textboxlist" cellpadding="0" cellspacing="0"><tr ><td class="mini-textboxlist-border"><ul></ul><a href="#"></a><input type="hidden"/></td></tr></table>';
        var d = document.createElement('div');
        d.innerHTML = html;
        this.el = d.firstChild;

        var td = this.el.getElementsByTagName('td')[0];
        this.ulEl = td.firstChild;
        this._valueEl = td.lastChild;
        this.focusEl = td.childNodes[1];
    },
    destroy: function (removeEl) {
        if (this.isShowPopup) {
            this.hidePopup();
        }
        mini.un(document, 'mousedown', this.__OnDocMouseDown, this);
        mini.TextBoxList.superclass.destroy.call(this, removeEl);
    },
    _initEvents: function () {
        mini.TextBoxList.superclass._initEvents.call(this);

        mini.on(this.el, 'mousemove', this.__OnMouseMove, this);
        mini.on(this.el, 'mouseout', this.__OnMouseOut, this);
        mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
        mini.on(this.el, 'click', this.__OnClick, this);
        mini.on(this.el, 'keydown', this.__OnKeyDown, this);

        mini.on(document, 'mousedown', this.__OnDocMouseDown, this);
    },
    __OnDocMouseDown: function (e) {
        if (this.isReadOnly()) return;
        if (this.isShowPopup) {
            if (!mini.isAncestor(this.popup.el, e.target)) {
                this.hidePopup();
            }
        }
        if (this._focused) {
            if (this.within(e) == false) {
                this.select(null, false);
                this.showInput(false);

                this.removeCls(this.focusCls);
                this._focused = false;
            }
        }
    },

    errorIconEl: null,
    getErrorIconEl: function () {
        if (!this._errorIconEl) {
            var tr = this.el.rows[0];
            var td = tr.insertCell(1);
            td.style.cssText = 'width:18px;vertical-align:top;';
            td.innerHTML = '<div class="mini-errorIcon"></div>';
            this._errorIconEl = td.firstChild;
        }
        return this._errorIconEl;
    },
    _RemoveErrorIcon: function () {
        if (this._errorIconEl) {
            jQuery(this._errorIconEl.parentNode).remove();
        }
        this._errorIconEl = null;
    },

    doLayout: function () {
        mini.TextBoxList.superclass.doLayout.call(this);

        if (this.isReadOnly() || this.allowInput == false) {
            this.inputEl.readOnly = true;
        } else {
            this.inputEl.readOnly = false;
        }
    },
    doUpdate: function () {
        if (this._ValueChangeTimer) clearInterval(this._ValueChangeTimer);
        if (this.inputEl) mini.un(this.inputEl, 'keydown', this.__OnInputKeyDown, this);

        var sb = [];
        var id = this.uid;
        for (var i = 0, l = this.data.length; i < l; i++) {
            var o = this.data[i];
            var li_id = id + '_text_' + i;
            var text = mini._getMap(this.textField, o);
            if (mini.isNull(text)) text = '';
            sb[sb.length] = '<li id="' + li_id + '" class="mini-textboxlist-item">';
            sb[sb.length] = text;
            sb[sb.length] = '<span class="mini-textboxlist-close"></span></li>';
        }
        var inputid = id + '_input';
        sb[sb.length] =
            '<li id="' +
            inputid +
            '" class="mini-textboxlist-inputLi"><input class="mini-textboxlist-input" type="text" autocomplete="off"></li>';

        this.ulEl.innerHTML = sb.join('');

        this.editIndex = this.data.length;
        if (this.editIndex < 0) this.editIndex = 0;

        this.inputLi = this.ulEl.lastChild;
        this.inputEl = this.inputLi.firstChild;

        mini.on(this.inputEl, 'keydown', this.__OnInputKeyDown, this);

        var sf = this;
        this.inputEl.onkeyup = function () {
            sf._syncInputSize();
        };

        sf._ValueChangeTimer = null;
        sf._LastInputText = sf.inputEl.value;
        this.inputEl.onfocus = function () {
            sf._ValueChangeTimer = setInterval(function () {
                if (sf._LastInputText != sf.inputEl.value) {
                    sf._startQuery();
                    sf._LastInputText = sf.inputEl.value;
                }
            }, 10);

            sf.addCls(sf.focusCls);
            sf._focused = true;

            sf.fire('focus');
        };
        this.inputEl.onblur = function () {
            clearInterval(sf._ValueChangeTimer);

            sf.fire('blur');
        };
    },
    getItemByEvent: function (event) {
        var domItem = mini.findParent(event.target, 'mini-textboxlist-item');
        if (domItem) {
            var ids = domItem.id.split('_');
            var id = ids[ids.length - 1];
            return this.data[id];
        }
    },
    getItem: function (id) {
        if (typeof id == 'number') return this.data[id];
        if (typeof id == 'object') return id;
    },
    getItemEl: function (o) {
        var index = this.data.indexOf(o);
        var li_id = this.uid + '_text_' + index;
        return document.getElementById(li_id);
    },
    hoverItem: function (item, e) {
        if (this.isReadOnly() || this.enabled == false) return;
        this.blurItem();
        var li = this.getItemEl(item);
        mini.addClass(li, this.itemHoverClass);

        if (e && mini.hasClass(e.target, 'mini-textboxlist-close')) {
            mini.addClass(e.target, this.closeHoverClass);
        }
    },
    blurItem: function () {
        var len = this.data.length;
        for (var i = 0, l = len; i < l; i++) {
            var o = this.data[i];

            var li = this.getItemEl(o);
            if (li) {
                mini.removeClass(li, this.itemHoverClass);

                mini.removeClass(li.lastChild, this.closeHoverClass);
            }
        }
    },
    showInput: function (index) {
        this.select(null);

        if (mini.isNumber(index)) {
            this.editIndex = index;
        } else {
            this.editIndex = this.data.length;
        }
        if (this.editIndex < 0) this.editIndex = 0;
        if (this.editIndex > this.data.length) this.editIndex = this.data.length;

        var inputLi = this.inputLi;
        inputLi.style.display = 'block';

        if (mini.isNumber(index) && index < this.data.length) {
            var item = this.data[index];
            var itemEl = this.getItemEl(item);
            jQuery(itemEl).before(inputLi);
        } else {
            this.ulEl.appendChild(inputLi);
        }
        if (index !== false) {
            setTimeout(function () {
                try {
                    inputLi.firstChild.focus();
                    mini.selectRange(inputLi.firstChild, 100);
                } catch (e) {}
            }, 10);
        } else {
            this.lastInputText = '';
            this.inputEl.value = '';
        }
        return inputLi;
    },
    select: function (item) {
        item = this.getItem(item);
        if (this._selected) {
            var itemEl = this.getItemEl(this._selected);
            mini.removeClass(itemEl, this.itemSelectedClass);
        }
        this._selected = item;

        if (this._selected) {
            var itemEl = this.getItemEl(this._selected);
            mini.addClass(itemEl, this.itemSelectedClass);
        }

        var sf = this;

        if (this._selected) {
            this.focusEl.focus();
            var me = this;
            setTimeout(function () {
                try {
                    me.focusEl.focus();
                } catch (ex) {}
            }, 50);
        }

        if (this._selected) {
            sf.addCls(sf.focusCls);
            sf._focused = true;
        }
    },

    _doInsertSelectValue: function () {
        var item = this._listbox.getSelected();
        var index = this.editIndex;

        if (item) {
            item = mini.clone(item);

            this.insertItem(index, item);
        }
    },
    insertItem: function (index, item) {
        this.data.insert(index, item);
        var text = this.getText();
        var value = this.getValue();

        this.setValue(value, false);
        this.setText(text, false);

        this._createData();

        this.doUpdate();

        this.showInput(index + 1);

        this._OnValueChanged();
    },
    removeItem: function (item) {
        if (!item) return;
        var itemEl = this.getItemEl(item);
        mini.removeNode(itemEl);

        this.data.remove(item);

        var text = this.getText();
        var value = this.getValue();

        this.setValue(value, false);
        this.setText(text, false);

        this._OnValueChanged();
    },
    _createData: function () {
        var texts = (this.text ? this.text : '').split(',');
        var values = (this.value ? this.value : '').split(',');

        if (values[0] == '') values = [];
        var len = values.length;
        this.data.length = len;

        for (var i = 0, l = len; i < l; i++) {
            var o = this.data[i];
            if (!o) {
                o = {};
                this.data[i] = o;
            }

            var text = !mini.isNull(texts[i]) ? texts[i] : '';
            var value = !mini.isNull(values[i]) ? values[i] : '';

            mini._setMap(this.textField, text, o);
            mini._setMap(this.valueField, value, o);
        }

        this.value = this.getValue();
        this.text = this.getText();
    },
    getInputText: function () {
        return this.inputEl ? this.inputEl.value : '';
    },
    getText: function () {
        var sb = [];
        for (var i = 0, l = this.data.length; i < l; i++) {
            var o = this.data[i];
            var name = mini._getMap(this.textField, o);
            if (mini.isNull(name)) name = '';
            name = name.replace(',', '，');
            sb.push(name);
        }
        return sb.join(',');
    },
    getValue: function () {
        var sb = [];
        for (var i = 0, l = this.data.length; i < l; i++) {
            var o = this.data[i];
            var v = mini._getMap(this.valueField, o);
            sb.push(v);
        }
        return sb.join(',');
    },

    setName: function (value) {
        if (this.name != value) {
            this.name = value;
            this._valueEl.name = value;
        }
    },
    setValue: function (value) {
        if (mini.isNull(value)) value = '';

        if (this.value != value) {
            this.value = value;
            this._valueEl.value = value;
            this._createData();
            this.doUpdate();
        }
    },
    setText: function (value) {
        if (mini.isNull(value)) value = '';
        if (this.text !== value) {
            this.text = value;
            this._createData();
            this.doUpdate();
        }
    },
    setValueField: function (value) {
        this.valueField = value;
        this._createData();
    },
    getValueField: function () {
        return this.valueField;
    },
    setTextField: function (value) {
        this.textField = value;
        this._createData();
    },
    getTextField: function () {
        return this.textField;
    },
    setAllowInput: function (value) {
        this.allowInput = value;
        this.doLayout();
    },
    getAllowInput: function () {
        return this.allowInput;
    },
    setUrl: function (value) {
        this.url = value;
    },
    getUrl: function () {
        return this.url;
    },
    setPopupHeight: function (value) {
        this.popupHeight = value;
    },
    getPopupHeight: function () {
        return this.popupHeight;
    },
    setPopupMinHeight: function (value) {
        this.popupMinHeight = value;
    },
    getPopupMinHeight: function () {
        return this.popupMinHeight;
    },
    setPopupMaxHeight: function (value) {
        this.popupMaxHeight = value;
    },
    getPopupMaxHeight: function () {
        return this.popupMaxHeight;
    },

    doQuery: function () {
        this._startQuery(true);
    },

    _syncInputSize: function () {
        if (this.isDisplay() == false) return;
        var text = this.getInputText();
        var size = mini.measureText(this.inputEl, text);
        var width = size.width > 20 ? size.width + 4 : 20;
        var elWidth = mini.getWidth(this.el, true);
        if (width > elWidth - 15) width = elWidth - 15;
        this.inputEl.style.width = width + 'px';
    },
    _startQuery: function (oldText) {
        var sf = this;

        setTimeout(function () {
            sf._syncInputSize();
        }, 1);

        this.showPopup('loading');

        this._stopQuery();

        this._loading = true;

        this.delayTimer = setTimeout(function () {
            var text = sf.inputEl.value;

            sf._doQuery();
        }, this.delay);
    },
    _doQuery: function () {
        if (this.isDisplay() == false) return;
        var text = this.getInputText();

        var sf = this;
        var dataSource = this._listbox.getData();
        var params = {
            value: this.getValue(),
            text: this.getText()
        };
        params[this.searchField] = text;

        var url = this.url;
        var fn = typeof url == 'function' ? url : window[url];
        if (typeof fn == 'function') {
            url = fn(this);
        }
        if (!url) return;

        var ajaxMethod = 'post';
        if (url) {
            if (url.indexOf('.txt') != -1 || url.indexOf('.json') != -1) {
                ajaxMethod = 'get';
            }
        }

        var e = {
            url: url,
            async: true,
            params: params,
            data: params,
            type: ajaxMethod,
            cache: false,
            cancel: false
        };
        this.fire('beforeload', e);
        if (e.data != e.params && e.params != params) {
            e.data = e.params;
        }
        if (e.cancel) return;

        mini.copyTo(e, {
            success: function (text) {
                var data = mini.decode(text);

                if (sf.dataField) {
                    data = mini._getMap(sf.dataField, data);
                }
                if (!data) data = [];

                sf._listbox.setData(data);
                sf.showPopup();
                sf._listbox._focusItem(0, true);
                sf.fire('load');
                sf._loading = false;

                if (sf._selectOnLoad) {
                    sf.__doSelectValue();
                    sf._selectOnLoad = null;
                }
            },
            error: function (jqXHR, textStatus, errorThrown) {
                sf.showPopup('error');
            }
        });

        sf._ajaxer = mini.ajax(e);
    },
    _stopQuery: function () {
        if (this.delayTimer) {
            clearTimeout(this.delayTimer);
            this.delayTimer = null;
        }
        if (this._ajaxer) {
            this._ajaxer.abort();
        }
        this._loading = false;
    },

    within: function (e) {
        if (mini.isAncestor(this.el, e.target)) return true;
        if (this.showPopup && this.popup && this.popup.within(e)) return true;
        return false;
    },

    popupLoadingText: "<span class='mini-textboxlist-popup-loading'>Loading...</span>",
    popupErrorText: "<span class='mini-textboxlist-popup-error'>Error</span>",
    popupEmptyText: "<span class='mini-textboxlist-popup-noresult'>No Result</span>",

    isShowPopup: false,
    popupHeight: '',
    popupMinHeight: 30,
    popupMaxHeight: 150,
    _createPopup: function () {
        if (!this.popup) {
            this.popup = new mini.ListBox();
            this.popup.addCls('mini-textboxlist-popup');
            this.popup.setStyle('position:absolute;left:0;top:0;');
            this.popup.showEmpty = true;
            this.popup.setValueField(this.valueField);
            this.popup.setTextField(this.textField);
            this.popup.render(document.body);

            this.popup.on(
                'itemclick',
                function (e) {
                    this.hidePopup();
                    this._doInsertSelectValue();
                },
                this
            );
        }
        this._listbox = this.popup;
        return this.popup;
    },
    showPopup: function (action) {
        if (this.isDisplay() == false) return;
        this.isShowPopup = true;

        var popup = this._createPopup();

        popup.el.style.zIndex = mini.getMaxZIndex();
        var control = this._listbox;
        control.emptyText = this.popupEmptyText;

        if (action == 'loading') {
            control.emptyText = this.popupLoadingText;
            this._listbox.setData([]);
        } else if (action == 'error') {
            control.emptyText = this.popupLoadingText;
            this._listbox.setData([]);
        }
        this._listbox.refresh();

        var box = this.getBox();
        var x = box.x,
            y = box.y + box.height;

        this.popup.el.style.display = 'block';
        mini.setXY(popup.el, -1000, -1000);
        this.popup.setWidth(box.width);

        this.popup.setHeight(this.popupHeight);

        if (this.popup.getHeight() < this.popupMinHeight) {
            this.popup.setHeight(this.popupMinHeight);
        }
        if (this.popup.getHeight() > this.popupMaxHeight) {
            this.popup.setHeight(this.popupMaxHeight);
        }
        mini.setXY(popup.el, x, y);

        var popupHeight = mini.getHeight(popup.el);
        var vbox = mini.getViewportBox();

        if (y + popupHeight > vbox.bottom) {
            mini.setY(popup.el, box.y - popupHeight);
        }
    },
    hidePopup: function () {
        this.isShowPopup = false;
        if (this.popup) this.popup.el.style.display = 'none';
    },

    __OnMouseMove: function (e) {
        if (this.enabled == false) return;
        var item = this.getItemByEvent(e);
        if (!item) {
            this.blurItem();
            return;
        }
        this.hoverItem(item, e);
    },
    __OnMouseOut: function (e) {
        this.blurItem();
    },
    __OnClick: function (e) {
        if (this.isReadOnly() || this.enabled == false) return;
        if (this.enabled == false) return;

        var item = this.getItemByEvent(e);
        if (!item) {
            if (mini.findParent(e.target, 'mini-textboxlist-input')) {
            } else {
                this.showInput();
            }
            return;
        }
        this.focusEl.focus();
        this.select(item);

        if (e && mini.hasClass(e.target, 'mini-textboxlist-close')) {
            this.removeItem(item);
        }
    },
    __OnKeyDown: function (e) {
        if (this.isReadOnly() || this.allowInput == false) return false;

        var index = this.data.indexOf(this._selected);

        var sf = this;
        function remove() {
            var item = sf.data[index];
            sf.removeItem(item);

            item = sf.data[index];
            if (!item) item = sf.data[index - 1];
            sf.select(item);
            if (!item) {
                sf.showInput();
            }
        }

        switch (e.keyCode) {
            case 8:
                e.preventDefault();
                remove();
                break;
            case 37:
            case 38:
                this.select(null);
                this.showInput(index);

                break;
            case 39:
            case 40:
                index += 1;
                this.select(null);
                this.showInput(index);

                break;
            case 46:
                remove();
                break;
        }
    },
    __doSelectValue: function () {
        var item = this._listbox.getFocusedItem();
        if (item) {
            this._listbox.setSelected(item);
        }

        this.lastInputText = this.text;
        this.hidePopup();

        this._doInsertSelectValue();
    },
    __OnInputKeyDown: function (e) {
        this._selectOnLoad = null;

        if (this.isReadOnly() || this.allowInput == false) return false;

        e.stopPropagation();

        if (this.isReadOnly() || this.allowInput == false) return;

        var range = mini.getSelectRange(this.inputEl);
        var start = range[0],
            end = range[1],
            textLen = this.inputEl.value.length;
        var isFirst = start == end && start == 0;
        var isLast = start == end && end == textLen;

        if (this.isReadOnly() || this.allowInput == false) {
            e.preventDefault();
        }
        if (e.keyCode == 9) {
            this.hidePopup();
            return;
        }
        if (e.keyCode == 16 || e.keyCode == 17 || e.keyCode == 18) return;

        switch (e.keyCode) {
            case 13:
                if (this.isShowPopup) {
                    e.preventDefault();

                    if (this._loading) {
                        this._selectOnLoad = true;
                        return;
                    }

                    this.__doSelectValue();
                }
                break;
            case 27:
                e.preventDefault();
                this.hidePopup();
                break;
            case 8:
                if (isFirst) {
                    e.preventDefault();
                }
            case 37:
                if (isFirst) {
                    if (this.isShowPopup) {
                        this.hidePopup();
                    } else {
                        if (this.editIndex > 0) {
                            var index = this.editIndex - 1;
                            if (index < 0) index = 0;
                            if (index >= this.data.length) index = this.data.length - 1;

                            this.showInput(false);
                            this.select(index);
                        }
                    }
                }
                break;
            case 39:
                if (isLast) {
                    if (this.isShowPopup) {
                        this.hidePopup();
                    } else {
                        if (this.editIndex <= this.data.length - 1) {
                            var index = this.editIndex;

                            this.showInput(false);
                            this.select(index);
                        }
                    }
                }
                break;
            case 38:
                e.preventDefault();
                if (this.isShowPopup) {
                    var index = -1;
                    var item = this._listbox.getFocusedItem();
                    if (item) index = this._listbox.indexOf(item);
                    index--;
                    if (index < 0) index = 0;
                    this._listbox._focusItem(index, true);
                }
                break;
            case 40:
                e.preventDefault();
                if (this.isShowPopup) {
                    var index = -1;
                    var item = this._listbox.getFocusedItem();
                    if (item) index = this._listbox.indexOf(item);
                    index++;
                    if (index < 0) index = 0;
                    if (index >= this._listbox.getCount()) index = this._listbox.getCount() - 1;
                    this._listbox._focusItem(index, true);
                } else {
                    this._startQuery(true);
                }
                break;
            default:
                break;
        }
    },

    focus: function () {
        try {
            this.inputEl.focus();
        } catch (e) {}
    },
    blur: function () {
        try {
            this.inputEl.blur();
        } catch (e) {}
    },
    searchField: 'key',
    setSearchField: function (value) {
        this.searchField = value;
    },
    getSearchField: function () {
        return this.searchField;
    },
    getAttrs: function (el) {
        var attrs = mini.TextBox.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        mini._ParseString(el, attrs, [
            'value',
            'text',
            'valueField',
            'textField',
            'url',
            'popupHeight',
            'textName',
            'onfocus',
            'onbeforeload',
            'onload',
            'searchField'
        ]);
        mini._ParseBool(el, attrs, ['allowInput']);

        mini._ParseInt(el, attrs, ['popupMinHeight', 'popupMaxHeight']);
        return attrs;
    }
});

mini.regClass(mini.TextBoxList, 'textboxlist');
mini.AutoComplete = mini.ComboBox.extend({
    type: 'autocomplete',
    tag: 'mini-autocomplete',

    props: {
        url: '',
        allowInput: true,
        delay: 150,
        searchField: 'key',
        minChars: 0
    },

    _buttonWidth: 0,

    initComponent: function () {
        this.callParent('initComponent');

        var sf = this;
        sf._ValueChangeTimer = null;

        this._textEl.onfocus = function () {
            sf._LastInputText = sf._textEl.value;
            sf._ValueChangeTimer = setInterval(function () {
                if (sf._LastInputText != sf._textEl.value) {
                    sf._tryQuery();
                    sf._LastInputText = sf._textEl.value;

                    if (sf._textEl.value == '' && sf.value != '') {
                        sf.setValue('');
                        sf._OnValueChanged();
                    }
                }
            }, 10);
        };
        this._textEl.onblur = function () {
            clearInterval(sf._ValueChangeTimer);
            if (!sf.isShowPopup()) {
                if (sf._LastInputText != sf._textEl.value) {
                    if (sf._textEl.value == '' && sf.value != '') {
                        sf.setValue('');
                        sf._OnValueChanged();
                    }
                }
            }
        };

        this._buttonEl.style.display = 'none';

        this._doInputLayout();
    },

    setUrl: function (value) {
        this.url = value;
    },
    setValue: function (value) {
        if (mini.isNull(value)) value = '';
        if (this.value != value) {
            this.value = value;
            this._valueEl.value = this.value;
        }
    },
    setText: function (value) {
        if (mini.isNull(value)) value = '';
        if (this.text != value) {
            this.text = value;
            this._LastInputText = value;
        }
        this._textEl.value = this.text;
    },

    setMinChars: function (value) {
        this.minChars = value;
    },
    getMinChars: function () {
        return this.minChars;
    },
    setSearchField: function (value) {
        this.searchField = value;
    },
    getSearchField: function () {
        return this.searchField;
    },

    popupLoadingText: "<span class='mini-textboxlist-popup-loading'>Loading...</span>",
    popupErrorText: "<span class='mini-textboxlist-popup-error'>Error</span>",
    popupEmptyText: "<span class='mini-textboxlist-popup-noresult'>No Result</span>",
    showPopup: function (action) {
        var popup = this.getPopup();
        var control = this._listbox;
        control.showEmpty = true;
        control.emptyText = this.popupEmptyText;
        if (action == 'loading') {
            control.emptyText = this.popupLoadingText;
            this._listbox.setData([]);
        } else if (action == 'error') {
            control.emptyText = this.popupLoadingText;
            this._listbox.setData([]);
        }
        this._listbox.doUpdate();

        mini.AutoComplete.superclass.showPopup.call(this);
    },

    __OnInputKeyDown: function (e) {
        var ex = { htmlEvent: e };
        this.fire('keydown', ex);
        if (e.keyCode == 8 && (this.isReadOnly() || this.allowInput == false)) {
            return false;
        }
        if (e.keyCode == 9) {
            this.hidePopup();
            return;
        }

        if (this.isReadOnly()) return;

        switch (e.keyCode) {
            case 27:
                if (this.isShowPopup()) {
                    e.stopPropagation();
                }

                this.hidePopup();
                break;
            case 13:
                if (this.isShowPopup()) {
                    e.preventDefault();
                    e.stopPropagation();

                    var index = this._listbox.getFocusedIndex();

                    if (index != -1) {
                        var item = this._listbox.getAt(index);
                        var vts = this._listbox.getValueAndText([item]);
                        var value = vts[0];

                        this.setText(vts[1]);

                        this.setValue(value, false);

                        this._OnValueChanged();

                        this.hidePopup();
                    }
                } else {
                    this.fire('enter', ex);
                }
                break;
            case 37:
                break;
            case 38:
                var index = this._listbox.getFocusedIndex();
                if (index == -1) {
                    index = 0;
                    if (!this.multiSelect) {
                        var item = this._listbox.findItems(this.value)[0];
                        if (item) {
                            index = this._listbox.indexOf(item);
                        }
                    }
                }
                if (this.isShowPopup()) {
                    if (!this.multiSelect) {
                        index -= 1;
                        if (index < 0) index = 0;
                        this._listbox._focusItem(index, true);
                    }
                }
                break;
            case 39:
                break;
            case 40:
                var index = this._listbox.getFocusedIndex();
                if (this.isShowPopup()) {
                    if (!this.multiSelect) {
                        index += 1;
                        if (index > this._listbox.getCount() - 1) index = this._listbox.getCount() - 1;
                        this._listbox._focusItem(index, true);
                    }
                } else {
                    this._tryQuery(this._textEl.value);
                }
                break;
            default:
                this._tryQuery(this._textEl.value);
                break;
        }
    },
    doQuery: function () {
        this._tryQuery();
    },
    _tryQuery: function (oldText) {
        var sf = this;
        if (this._queryTimer) {
            clearTimeout(this._queryTimer);
            this._queryTimer = null;
        }
        this._queryTimer = setTimeout(function () {
            var text = sf._textEl.value;

            sf._doQuery(text);
        }, this.delay);
        this.showPopup('loading');
    },
    _doQuery: function (key) {
        if (!this.url) return;
        if (this._ajaxer) {
            this._ajaxer.abort();
        }

        var url = this.url;
        var ajaxMethod = 'post';
        if (url) {
            if (url.indexOf('.txt') != -1 || url.indexOf('.json') != -1) {
                ajaxMethod = 'get';
            }
        }

        var params = {};
        params[this.searchField] = key;

        var e = {
            url: url,
            async: true,
            params: params,
            data: params,
            type: ajaxMethod,
            cache: false,
            cancel: false
        };
        this.fire('beforeload', e);
        if (e.data != e.params && e.params != params) {
            e.data = e.params;
        }
        if (e.cancel) return;

        var me = (sf = this);
        mini.copyTo(e, {
            success: function (text) {
                try {
                    var data = mini.decode(text);
                } catch (ex) {
                    throw new Error('autocomplete json is error');
                }
                if (sf.dataField) {
                    data = mini._getMap(sf.dataField, data);
                }
                if (!data) data = [];

                me._listbox.setData(data);
                me.showPopup();
                me._listbox._focusItem(0, true);
                me.data = data;
                me.fire('load', { data: data });
            },
            error: function (jqXHR, textStatus, errorThrown) {
                me.showPopup('error');
            }
        });

        this._ajaxer = mini.ajax(e);
    },

    getAttrs: function (el) {
        var attrs = mini.AutoComplete.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['searchField']);

        return attrs;
    }
});

mini.Form = function (el) {
    this.el = mini.byId(el);
    if (!this.el) throw new Error('form element not null');
    mini.Form.superclass.constructor.call(this);
};
mini.extend(mini.Form, mini.Component, {
    el: null,

    getFields: function () {
        if (!this.el) return [];
        var fields = [];

        function each(children) {
            for (var i = 0, l = children.length; i < l; i++) {
                var el = children[i];
                var field = mini.get(el);
                if (field && field.formField) {
                    fields.push(field);
                } else {
                    each(el.children);
                }
            }
        }
        each(this.el.children);

        return fields;
    },

    getFieldsMap: function () {
        var fields = this.getFields();
        var map = {};
        for (var i = 0, l = fields.length; i < l; i++) {
            var field = fields[i];
            if (field.name) map[field.name] = field;
        }
        return map;
    },

    getField: function (name) {
        if (!this.el) return null;

        var map = this.getFieldsMap();
        return map[name];
    },

    resetValues: function () {
        var fields = this.getFields();
        for (var i = 0, l = fields.length; i < l; i++) {
            var field = fields[i];
            if (field.resetValue) {
                field.resetValue();
            } else if (field.reset) {
                field.reset();
            } else {
                if (field.setValue) field.setValue(field.defaultValue);
                if (field.setText && field.defaultText != null) field.setText(field.defaultText);
            }
        }
    },

    clearValues: function () {
        var fields = this.getFields();
        for (var i = 0, l = fields.length; i < l; i++) {
            var field = fields[i];
            if (field.clearValue) {
                field.clearValue();
            } else if (field.clear) {
                field.clear();
            } else {
                if (field.setValue) field.setValue(null);
                if (field.setText) field.setText('');
            }
        }
    },

    setValues: function (values) {
        if (!values) values = {};
        var fields = this.getFields();
        for (var i = 0, l = fields.length; i < l; i++) {
            var field = fields[i];
            if (field.setValue && field.name) {
                var value = mini._getMap(field.name, values);
                field.setValue(value);
            }
            if (field.setText && field.textName) {
                var text = mini._getMap(field.textName, values);
                if (text !== undefined) field.setText(text);
            }
        }
    },

    getValues: function () {
        var values = {};
        var fields = this.getFields();
        for (var i = 0, l = fields.length; i < l; i++) {
            var field = fields[i];
            if (field.getValue && field.name) {
                mini._setMap(field.name, field.getValue(), values);
            }
            if (field.getText && field.textName) {
                mini._setMap(field.textName, field.getText(), values);
            }
        }
        return values;
    },

    getData: function (formatted, deep) {
        if (mini.isNull(deep)) deep = true;
        var valueFn = formatted ? 'getFormValue' : 'getValue';
        var controls = this.getFields();
        var data = {};
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            var fn = control[valueFn];
            if (!fn) continue;
            if (control.name) {
                if (deep == true) {
                    mini._setMap(control.name, fn.call(control), data);
                } else {
                    data[control.name] = fn.call(control);
                }
            }
            if (control.textName && control.getText) {
                if (deep == true) {
                    mini._setMap(control.textName, control.getText(), data);
                } else {
                    data[control.textName] = control.getText();
                }
            }
        }
        return data;
    },

    setData: function (options, all, deep) {
        if (mini.isNull(deep)) deep = true;
        if (typeof options != 'object') options = {};
        var map = this.getFieldsMap();
        for (var name in map) {
            var control = map[name];
            if (!control) continue;
            if (control.setValue) {
                var v = options[name];
                if (deep == true) {
                    v = mini._getMap(name, options);
                }
                if (v === undefined && all === false) continue;
                if (v === null) v = '';
                control.setValue(v);
            }
            if (control.setText && control.textName) {
                var text = options[control.textName];
                if (deep == true) {
                    text = mini._getMap(control.textName, options);
                }
                if (mini.isNull(text)) text = '';
                control.setText(text);
            }
        }
    },
    reset: function () {
        var controls = this.getFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            if (!control.setValue) continue;
            if (control.setText && control._clearText !== false) {
                var text = control.defaultText;
                if (mini.isNull(text)) text = '';
                control.setText(text);
            }
            control.setValue(control.defaultValue);
        }
        this.setIsValid(true);
    },
    clear: function () {
        var controls = this.getFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            if (!control.setValue) continue;
            if (control.setText && control._clearText !== false) {
                control.setText('');
            }
            control.setValue('');
        }
        this.setIsValid(true);
    },
    getValidateFields: function () {
        function isDisplay(control) {
            return control.isDisplay(function (p) {
                if (mini.hasClass(p, 'mini-tabs-body')) return true;
            });
        }

        var fields = [];
        var controls = this.getFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            if (!control.validate || !control.isDisplay) continue;
            if (isDisplay(control) && control.enabled) {
                fields.push(control);
            }
        }
        return fields;
    },
    validate: function (all) {
        var controls = this.getValidateFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            var succ = control.validate();
            if (succ == false && all === false) {
                break;
            }
        }
        return this.isValid();
    },
    isValid: function () {
        var controls = this.getValidateFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            if (control.isValid() == false) return false;
        }
        return true;
    },
    setIsValid: function (isValid) {
        var controls = this.getFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            if (!control.setIsValid) continue;
            control.setIsValid(isValid);
        }
    },
    getErrorTexts: function () {
        var errorTexts = [];
        var errors = this.getErrors();
        for (var i = 0, l = errors.length; i < l; i++) {
            var control = errors[i];
            errorTexts.push(control.errorText);
        }
        return errorTexts;
    },
    getErrors: function () {
        var errors = [];
        var controls = this.getFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            if (!control.isValid) continue;
            if (control.isValid() == false) {
                errors.push(control);
            }
        }
        return errors;
    },

    mask: function (options) {
        if (typeof options == 'string') options = { html: options };
        options = options || {};
        options.el = this.el;
        if (!options.cls) options.cls = this._maskCls;
        mini.mask(options);
    },
    unmask: function () {
        mini.unmask(this.el);
    },
    _maskCls: 'mini-mask-loading',
    loadingMsg: '数据加载中，请稍后...',
    loading: function (msg) {
        this.mask(msg || this.loadingMsg);
    },

    __OnValueChanged: function (e) {
        this._changed = true;
    },
    _changed: false,
    setChanged: function (value) {
        this._changed = value;

        var controls = this.getFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            control.on('valuechanged', this.__OnValueChanged, this);
        }
    },
    isChanged: function () {
        return this._changed;
    },

    setEnabled: function (value) {
        var controls = this.getFields();
        for (var i = 0, l = controls.length; i < l; i++) {
            var control = controls[i];
            control.setEnabled(value);
        }
    }
});

mini.Panel = mini.Container.extend({
    type: 'panel',
    tag: 'mini-panel',

    props: {
        width: 'auto',
        title: '',
        iconCls: '',
        iconStyle: '',
        allowResize: false,
        url: '',
        refreshOnExpand: false,
        maskOnLoad: true,
        showCollapseButton: false,
        showCloseButton: false,
        closeAction: 'display',
        showHeader: true,
        showToolbar: false,
        showFooter: false,
        toolbar: null,
        footer: null,
        headerCls: '',
        headerStyle: '',
        bodyCls: '',
        bodyStyle: '',
        footerCls: '',
        footerStyle: '',
        toolbarCls: '',
        toolbarStyle: '',
        toolbar: null,
        footer: null,
        minWidth: 180,
        minHeight: 100,
        maxWidth: 5000,
        maxHeight: 3000
    },

    initComponent: function () {
        this._initButtons();
        this.callParent('initComponent');

        this._contentEl = this._bodyEl;
        this._doVisibleEls();
        this._Resizer = new mini._Resizer(this);
        this._doTools();
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var toolbar = kv.toolbar;
        delete kv.toolbar;
        var footer = kv.footer;
        delete kv.footer;
        var url = kv.url;
        delete kv.url;

        this.callParent('set', kv);

        if (toolbar) {
            this.setToolbar(toolbar);
        }
        if (footer) {
            this.setFooter(footer);
        }
        if (url) {
            this.setUrl(url);
        }

        this.invalidateLayout();

        return this;
    },

    initElement: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-panel';

        var s =
            '<div class="mini-panel-border">' +
            '<div class="mini-panel-header" ><div class="mini-panel-header-inner" ><span class="mini-panel-icon"></span><div class="mini-panel-title" ></div><div class="mini-tools" ></div></div></div>' +
            '<div class="mini-panel-viewport">' +
            '<div class="mini-panel-toolbar"></div>' +
            '<div class="mini-panel-body" ></div>' +
            '<div class="mini-panel-footer"></div>' +
            '<div class="mini-resizer-trigger"></div>' +
            '</div>' +
            '</div>';
        this.el.innerHTML = s;

        this._borderEl = this.el.firstChild;
        this._headerEl = this._borderEl.firstChild;
        this._viewportEl = this._borderEl.lastChild;

        this._toolbarEl = mini.byClass('mini-panel-toolbar', this.el);
        this._bodyEl = mini.byClass('mini-panel-body', this.el);
        this._footerEl = mini.byClass('mini-panel-footer', this.el);
        this._resizeGridEl = mini.byClass('mini-resizer-trigger', this.el);

        var hi = mini.byClass('mini-panel-header-inner', this.el);
        this._iconEl = mini.byClass('mini-panel-icon', this.el);
        this._titleEl = mini.byClass('mini-panel-title', this.el);
        this._toolsEl = mini.byClass('mini-tools', this.el);

        mini.setStyle(this._bodyEl, this.bodyStyle);

        this._doTitle();
    },
    destroy: function (removeEl) {
        this._doRemoveIFrame();
        this._iframeEl = null;

        this._viewportEl = this._borderEl = this._bodyEl = this._footerEl = this._toolbarEl = null;
        this._toolsEl = this._titleEl = this._iconEl = this._resizeGridEl = null;
        mini.Panel.superclass.destroy.call(this, removeEl);
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini.on(this.el, 'click', this.__OnClick, this);
        }, this);
    },

    _doVisibleEls: function () {
        mini.toggleClass(this._headerEl, 'mini-hidden', !this.showHeader);
        mini.toggleClass(this._toolbarEl, 'mini-hidden', !this.showToolbar);
        mini.toggleClass(this._footerEl, 'mini-hidden', !this.showFooter);
    },
    doLayout: function () {
        var autoHeight = this.isAutoHeight();
        var autoWidth = this.isAutoWidth();

        var w = mini.getWidth(this._viewportEl, true);
        var elWidth = w;

        if (!autoHeight) {
            var bh = this.getBodyHeight(true) - 1;

            mini.setHeight(this._bodyEl, bh);
        } else {
            this._viewportEl.style.height = 'auto';
            this._bodyEl.style.height = 'auto';
        }

        this.fire('layout');
    },
    getViewportWidth: function (content) {
        return mini.getWidth(this._viewportEl, content);
    },
    getViewportHeight: function (content) {
        var h = this.getHeight(true) - this.getHeaderHeight() + 2;
        if (content) {
            var padding2 = mini.getPaddings(this._viewportEl);
            var border2 = mini.getBorders(this._viewportEl);
            var margin2 = mini.getMargins(this._viewportEl);
            if (jQuery.boxModel) {
                h = h - padding2.top - padding2.bottom - border2.top - border2.bottom;
            }
            h = h - margin2.top - margin2.bottom;
        }
        return h;
    },
    getBodyHeight: function (content) {
        var h = this.getViewportHeight();
        var h = h - this.getToolbarHeight() - this.getFooterHeight();
        if (content) {
            var padding = mini.getPaddings(this._viewportEl);
            var border = mini.getBorders(this._viewportEl);
            var margin = mini.getMargins(this._viewportEl);
            if (jQuery.boxModel) {
                h = h - padding.top - padding.bottom - border.top - border.bottom;
            }
            h = h - margin.top - margin.bottom;
        }

        if (h < 0) h = 0;
        return h;
    },
    getHeaderHeight: function () {
        var h = this.showHeader ? jQuery(this._headerEl).outerHeight() : 0;
        return h;
    },
    getToolbarHeight: function () {
        var h = this.showToolbar ? jQuery(this._toolbarEl).outerHeight() : 0;
        return h;
    },
    getFooterHeight: function () {
        var h = this.showFooter ? jQuery(this._footerEl).outerHeight() : 0;
        return h;
    },

    setHeaderStyle: function (value) {
        this.headerStyle = value;
        mini.setStyle(this._headerEl, value);
        this.invalidateLayout();
    },
    getHeaderStyle: function () {
        return this.headerStyle;
    },
    setBodyStyle: function (value) {
        this.bodyStyle = value;
        mini.setStyle(this._bodyEl, value);
        this.invalidateLayout();
    },
    getBodyStyle: function () {
        return this.bodyStyle;
    },
    setToolbarStyle: function (value) {
        this.toolbarStyle = value;
        mini.setStyle(this._toolbarEl, value);
        this.invalidateLayout();
    },
    getToolbarStyle: function () {
        return this.toolbarStyle;
    },
    setFooterStyle: function (value) {
        this.footerStyle = value;
        mini.setStyle(this._footerEl, value);

        this.invalidateLayout();
    },
    getFooterStyle: function () {
        return this.footerStyle;
    },
    setHeaderCls: function (cls) {
        jQuery(this._headerEl).removeClass(this.headerCls);
        jQuery(this._headerEl).addClass(cls);
        this.headerCls = cls;
        this.invalidateLayout();
    },
    getHeaderCls: function () {
        return this.headerCls;
    },
    setBodyCls: function (cls) {
        jQuery(this._bodyEl).removeClass(this.bodyCls);
        jQuery(this._bodyEl).addClass(cls);
        this.bodyCls = cls;
        this.invalidateLayout();
    },
    getBodyCls: function () {
        return this.bodyCls;
    },
    setToolbarCls: function (cls) {
        jQuery(this._toolbarEl).removeClass(this.toolbarCls);
        jQuery(this._toolbarEl).addClass(cls);
        this.toolbarCls = cls;
        this.invalidateLayout();
    },
    getToolbarCls: function () {
        return this.toolbarCls;
    },
    setFooterCls: function (cls) {
        jQuery(this._footerEl).removeClass(this.footerCls);
        jQuery(this._footerEl).addClass(cls);
        this.footerCls = cls;
        this.invalidateLayout();
    },
    getFooterCls: function () {
        return this.footerCls;
    },
    _doTitle: function () {
        this._titleEl.innerHTML = this.title;

        this._iconEl.style.display = this.iconCls || this.iconStyle ? 'inline' : 'none';
        this._iconEl.className = 'mini-panel-icon ' + this.iconCls;
        mini.setStyle(this._iconEl, this.iconStyle);
    },
    setTitle: function (value) {
        this.title = value;
        this._doTitle();
    },
    getTitle: function () {
        return this.title;
    },
    setIconCls: function (value) {
        this.iconCls = value;
        this._doTitle();
    },
    getIconCls: function () {
        return this.iconCls;
    },
    _doTools: function () {
        var s = '';
        for (var i = this.buttons.length - 1; i >= 0; i--) {
            var button = this.buttons[i];
            s +=
                '<span id="' +
                i +
                '" class="' +
                button.cls +
                ' ' +
                (button.enabled ? '' : 'mini-disabled') +
                '" style="' +
                button.style +
                ';' +
                (button.visible ? '' : 'display:none;') +
                '"></span>';
        }
        this._toolsEl.innerHTML = s;
    },
    setShowCloseButton: function (value) {
        this.showCloseButton = value;
        var button = this.getButton('close');
        button.visible = value;
        this._doTools();
    },
    getShowCloseButton: function () {
        return this.showCloseButton;
    },
    setCloseAction: function (value) {
        this.closeAction = value;
    },
    getCloseAction: function () {
        return this.closeAction;
    },
    setShowCollapseButton: function (value) {
        this.showCollapseButton = value;
        var button = this.getButton('collapse');
        button.visible = value;
        this._doTools();
    },
    getShowCollapseButton: function () {
        return this.showCollapseButton;
    },
    setShowHeader: function (value) {
        this.showHeader = value;
        this._doVisibleEls();
        this.invalidateLayout();
    },
    getShowHeader: function () {
        return this.showHeader;
    },
    setShowToolbar: function (value) {
        this.showToolbar = value;
        this._doVisibleEls();
        this.invalidateLayout();
    },
    getShowToolbar: function () {
        return this.showToolbar;
    },
    setShowFooter: function (value) {
        this.showFooter = value;
        this._doVisibleEls();
        this.invalidateLayout();
    },
    getShowFooter: function () {
        return this.showFooter;
    },

    __OnClick: function (e) {
        if (mini.isAncestor(this._headerEl, e.target)) {
            var toolsEl = mini.findParent(e.target, 'mini-tools');
            if (toolsEl) {
                var button = this.getButton(parseInt(e.target.id));
                if (button) {
                    this._OnButtonClick(button, e);
                }
            }
        }
    },
    _OnButtonClick: function (button, htmlEvent) {
        var e = {
            button: button,
            index: this.buttons.indexOf(button),
            name: button.name.toLowerCase(),
            htmlEvent: htmlEvent,
            cancel: false
        };
        this.fire('beforebuttonclick', e);

        try {
            if (e.name == 'close' && this.closeAction == 'destroy' && this._iframeEl && this._iframeEl.contentWindow) {
                var ret = true;
                if (this._iframeEl.contentWindow.CloseWindow) {
                    ret = this._iframeEl.contentWindow.CloseWindow('close');
                } else if (this._iframeEl.contentWindow.CloseOwnerWindow) {
                    ret = this._iframeEl.contentWindow.CloseOwnerWindow('close');
                }
                if (ret === false) {
                    e.cancel = true;
                }
            }
        } catch (ex) {}

        if (e.cancel == true) return e;

        this.fire('buttonclick', e);

        if (e.name == 'close') {
            this.close('close');
        }

        if (e.name == 'collapse') {
            this.toggle();
            if (this.refreshOnExpand && this.expanded && this.url) {
                this.reload();
            }
        }
        return e;
    },
    onButtonClick: function (fn, scope) {
        this.on('buttonclick', fn, scope);
    },

    closeHandler: null,
    close: function (action) {
        var e = { cancel: false, action: action };
        this.fire('beforeclose', e);
        if (e.cancel) return false;

        if (this.closeHandler) {
            if (this.closeHandler(action) === false) return false;
        }

        this.fire('close', e);
        if (this.closeAction == 'destroy') {
            this.__HideAction = 'close';
            this.destroy();
        } else {
            this.hide();
        }
    },

    _initButtons: function () {
        this.buttons = [];

        var close = this.createButton({ name: 'close', cls: 'mini-tools-close', visible: this.showCloseButton });
        this.buttons.push(close);

        var collapse = this.createButton({
            name: 'collapse',
            cls: 'mini-tools-collapse',
            visible: this.showCollapseButton
        });
        this.buttons.push(collapse);
    },
    createButton: function (options) {
        var button = mini.copyTo(
            {
                name: '',
                cls: '',
                style: '',
                visible: true,
                enabled: true,
                html: ''
            },
            options
        );
        return button;
    },
    addButton: function (button, index) {
        if (typeof button == 'string') {
            button = { iconCls: button };
        }
        button = this.createButton(button);
        if (typeof index != 'number') index = this.buttons.length;
        this.buttons.insert(index, button);
        this._doTools();
    },
    updateButton: function (index, options) {
        var button = this.getButton(index);
        if (!button) return;
        mini.copyTo(button, options);
        this._doTools();
    },
    removeButton: function (index) {
        var button = this.getButton(index);
        if (!button) return;
        this.buttons.remove(button);
        this._doTools();
    },
    getButton: function (index) {
        if (typeof index == 'number') {
            return this.buttons[index];
        } else {
            for (var i = 0, l = this.buttons.length; i < l; i++) {
                var button = this.buttons[i];
                if (button.name == index) return button;
            }
        }
    },

    set_bodyParent: function (value) {},
    setToolbar: function (value) {
        __mini_setControls(value, this._toolbarEl, this);
    },
    setFooter: function (value) {
        __mini_setControls(value, this._footerEl, this);
    },
    getHeaderEl: function () {
        return this._headerEl;
    },
    getToolbarEl: function () {
        return this._toolbarEl;
    },
    getBodyEl: function () {
        return this._bodyEl;
    },
    getFooterEl: function () {
        return this._footerEl;
    },
    getIFrameEl: function (index) {
        return this._iframeEl;
    },

    _getMaskWrapEl: function () {
        return this._bodyEl;
    },
    _doRemoveIFrame: function (removeAll) {
        if (this._iframeEl) {
            var iframe = this._iframeEl;

            iframe.src = '';
            try {
                iframe.contentWindow.document.write('');
                iframe.contentWindow.document.close();
            } catch (ex) {}
            if (iframe._ondestroy) iframe._ondestroy();

            try {
                this._iframeEl.parentNode.removeChild(this._iframeEl);
                this._iframeEl.removeNode(true);
            } catch (ex) {}
        }
        this._iframeEl = null;

        if (removeAll === true) {
            mini.removeChilds(this._bodyEl);
        }
    },
    _deferLoadingTime: 80,
    _doLoad: function () {
        this._doRemoveIFrame(true);

        var st = new Date();
        var sf = this;

        this.loadedUrl = this.url;
        if (this.maskOnLoad) this.loading();

        jQuery(this._bodyEl).css('overflow', 'hidden');

        var iframe = mini.createIFrame(this.url, function (_iframe, firstLoad) {
            var t = st - new Date() + sf._deferLoadingTime;

            if (t < 0) t = 0;
            setTimeout(function () {
                sf.unmask();
            }, t);

            try {
                sf._iframeEl.contentWindow.Owner = sf.Owner;
                sf._iframeEl.contentWindow.CloseOwnerWindow = function (action) {
                    sf.__HideAction = action;

                    var ret = true;
                    if (sf.__onDestroy) ret = sf.__onDestroy(action);
                    if (ret === false) {
                        return false;
                    }

                    var e = {
                        iframe: sf._iframeEl,
                        action: action
                    };

                    sf.fire('unload', e);

                    setTimeout(function () {
                        sf.destroy();
                    }, 10);
                };
            } catch (e) {}

            if (firstLoad) {
                if (sf.__onLoad) sf.__onLoad();

                var e = {
                    iframe: sf._iframeEl
                };

                sf.fire('load', e);
            }
        });
        this._bodyEl.appendChild(iframe);
        this._iframeEl = iframe;
    },

    load: function (url, onload, ondestroy) {
        this.setUrl(url, onload, ondestroy);
    },
    reload: function () {
        this.setUrl(this.url);
    },
    setUrl: function (value, onload, ondestroy) {
        this.url = value;
        this.__onLoad = onload;
        this.__onDestroy = ondestroy;
        if (this.expanded && this.url) {
            this._doLoad();
        }
    },
    getUrl: function () {
        return this.url;
    },
    setRefreshOnExpand: function (value) {
        this.refreshOnExpand = value;
    },
    getRefreshOnExpand: function () {
        return this.refreshOnExpand;
    },
    setMaskOnLoad: function (value) {
        this.maskOnLoad = value;
    },
    getMaskOnLoad: function (value) {
        return this.maskOnLoad;
    },
    setAllowResize: function (value) {
        this.allowResize = value;
        this._resizeGridEl.style.display = this.allowResize ? '' : 'none';
    },
    getAllowResize: function () {
        return this.allowResize;
    },

    expanded: true,
    setExpanded: function (value) {
        if (this.expanded != value) {
            this.expanded = value;
            if (this.expanded) {
                this.expand();
            } else {
                this.collapse();
            }
        }
    },
    toggle: function () {
        if (this.expanded) {
            this.collapse();
        } else {
            this.expand();
        }
    },
    collapse: function () {
        this.expanded = false;

        this._height = this.el.style.height;
        this.el.style.height = 'auto';
        this._viewportEl.style.display = 'none';

        mini.addClass(this.el, 'mini-panel-collapse');
        this.doLayout();
    },
    expand: function () {
        this.expanded = true;

        this.el.style.height = this._height;
        this._viewportEl.style.display = 'block';
        delete this._height;

        mini.removeClass(this.el, 'mini-panel-collapse');

        if (this.url && this.url != this.loadedUrl) {
            this._doLoad();
        }
        this.doLayout();
    },

    getAttrs: function (el) {
        var attrs = mini.Panel.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'title',
            'iconCls',
            'iconStyle',
            'headerCls',
            'headerStyle',
            'bodyCls',
            'bodyStyle',
            'footerCls',
            'footerStyle',
            'toolbarCls',
            'toolbarStyle',
            'footer',
            'toolbar',
            'url',
            'closeAction',
            'loadingMsg',
            'onbeforebuttonclick',
            'onbuttonclick',
            'onload'
        ]);
        mini._ParseBool(el, attrs, [
            'allowResize',
            'showCloseButton',
            'showHeader',
            'showToolbar',
            'showFooter',
            'showCollapseButton',
            'refreshOnExpand',
            'maskOnLoad',
            'expanded'
        ]);

        return attrs;
    }
});
mini.regClass(mini.Panel, 'panel');

mini.Window = mini.Panel.extend({
    type: 'window',
    tag: 'mini-window',

    props: {
        x: 0,
        y: 0,
        state: 'restore',
        visible: false,
        allowDrag: true,

        showCloseButton: true,
        showMaxButton: false,
        showMinButton: false,
        showCollapseButton: false,
        showModal: true,
        minWidth: 150,
        minHeight: 80,
        maxWidth: 2000,
        maxHeight: 2000
    },

    dragCls: 'mini-window-drag',
    resizeCls: 'mini-window-resize',

    initComponent: function () {
        this.callParent('initComponent');
        this.addCls('mini-window');
    },

    _create: function () {
        mini.Window.superclass._create.call(this);
    },
    _initButtons: function () {
        this.buttons = [];

        var close = this.createButton({ name: 'close', cls: 'mini-tools-close', visible: this.showCloseButton });
        this.buttons.push(close);

        var max = this.createButton({ name: 'max', cls: 'mini-tools-max', visible: this.showMaxButton });
        this.buttons.push(max);

        var min = this.createButton({ name: 'min', cls: 'mini-tools-min', visible: this.showMinButton });
        this.buttons.push(min);

        var collapse = this.createButton({
            name: 'collapse',
            cls: 'mini-tools-collapse',
            visible: this.showCollapseButton
        });
        this.buttons.push(collapse);
    },
    _initEvents: function () {
        mini.Window.superclass._initEvents.call(this);

        mini._BindEvents(function () {
            mini.on(this.el, 'mouseover', this.__OnMouseOver, this);
            mini.on(window, 'resize', this.__OnWindowResize, this);

            mini.on(this.el, 'mousedown', this.__OnWindowMouseDown, this);
        }, this);
    },
    doLayout: function () {
        if (this.state == 'max') {
            var vbox = this.getParentBox();
            this.el.style.left = '0px';
            this.el.style.top = '0px';
            mini.setSize(this.el, vbox.width, vbox.height);
        }

        mini.Window.superclass.doLayout.call(this);

        if (this.allowDrag) {
            mini.addClass(this.el, this.dragCls);
        }
        if (this.state == 'max') {
            this._resizeGridEl.style.display = 'none';
            mini.removeClass(this.el, this.dragCls);
        }

        this._doModal();
    },
    _doModal: function () {
        var show = this.showModal && this.isDisplay() && this.visible;
        if (!this._modalEl && this.showModal == false) return;

        if (!this._modalEl) {
            this._modalEl = mini.append(document.body, '<div class="mini-modal" style="display:none"></div>');
        }

        function resizeModal() {
            this._modalEl.style.zIndex = mini.getStyle(this.el, 'zIndex') - 1;
        }
        if (show) {
            this._modalEl.style.display = 'block';
            this._modalEl.style.zIndex = mini.getStyle(this.el, 'zIndex') - 1;
        } else {
            this._modalEl.style.display = 'none';
        }
    },
    getParentBox: function () {
        var vbox = mini.getViewportBox();
        var containerEl = this._containerEl || document.body;
        if (containerEl != document.body) {
            vbox = mini.getBox(containerEl);
        }
        return vbox;
    },

    setShowModal: function (value) {
        this.showModal = value;
    },
    getShowModal: function () {
        return this.showModal;
    },
    setMinWidth: function (value) {
        if (isNaN(value)) return;
        this.minWidth = value;
    },
    getMinWidth: function () {
        return this.minWidth;
    },
    setMinHeight: function (value) {
        if (isNaN(value)) return;
        this.minHeight = value;
    },
    getMinHeight: function () {
        return this.minHeight;
    },
    setMaxWidth: function (value) {
        if (isNaN(value)) return;
        this.maxWidth = value;
    },
    getMaxWidth: function () {
        return this.maxWidth;
    },
    setMaxHeight: function (value) {
        if (isNaN(value)) return;
        this.maxHeight = value;
    },
    getMaxHeight: function () {
        return this.maxHeight;
    },
    setAllowDrag: function (value) {
        this.allowDrag = value;
        mini.removeClass(this.el, this.dragCls);
        if (value) {
            mini.addClass(this.el, this.dragCls);
        }
    },
    getAllowDrag: function () {
        return this.allowDrag;
    },

    setShowMaxButton: function (value) {
        this.showMaxButton = value;
        var button = this.getButton('max');
        button.visible = value;
        this._doTools();
    },
    getShowMaxButton: function () {
        return this.showMaxButton;
    },
    setShowMinButton: function (value) {
        this.showMinButton = value;
        var button = this.getButton('min');
        button.visible = value;
        this._doTools();
    },
    getShowMinButton: function () {
        return this.showMinButton;
    },

    max: function () {
        this.state = 'max';
        this.show();

        var button = this.getButton('max');
        if (button) {
            button.cls = 'mini-tools-restore';
            this._doTools();
        }
    },
    restore: function () {
        this.state = 'restore';
        this.show(this.x, this.y);

        var button = this.getButton('max');
        if (button) {
            button.cls = 'mini-tools-max';
            this._doTools();
        }
    },
    containerEl: null,
    showAtPos: function (x, y, options) {
        this.show(x, y, options);
    },
    showInBody: true,
    setShowInBody: function (value) {
        this.showInBody = value;
    },
    getShowInBody: function () {
        return this.showInBody;
    },

    show: function (x, y, options) {
        this._allowLayout = false;

        var containerEl = this._containerEl || document.body;
        if (!this.el.parentElement || (this.el.parentNode != containerEl && this.showInBody)) {
            this.render(containerEl);
        }

        this.el.style.zIndex = mini.getMaxZIndex();

        this._doShow(x, y);

        this._allowLayout = true;
        this.setVisible(true);

        if (this.state != 'max') {
            var box = this.getBox();
            this.x = box.x;
            this.y = box.y;
        }

        try {
            this.el.focus();
        } catch (e) {}
    },
    hide: function () {
        this.setVisible(false);
        this._doModal();
    },
    getWidth: function () {
        this._headerEl.style.width = '50px';
        var width = mini.getWidth(this.el);
        this._headerEl.style.width = 'auto';
        return width;
    },
    getBox: function () {
        this._headerEl.style.width = '50px';
        this.el.style.display = '';
        var width = mini.getWidth(this.el);
        this._headerEl.style.width = 'auto';
        var box = mini.getBox(this.el);
        box.width = width;
        box.right = box.x + width;
        return box;
    },
    _measureSize: function () {
        var box = this.getBox();

        if (box.width > this.maxWidth) {
            mini.setWidth(this.el, this.maxWidth);
            box = this.getBox();
        }
        if (box.height > this.maxHeight) {
            mini.setHeight(this.el, this.maxHeight);
            box = this.getBox();
        }
        if (box.width < this.minWidth) {
            mini.setWidth(this.el, this.minWidth);
            box = this.getBox();
        }
        if (box.height < this.minHeight) {
            mini.setHeight(this.el, this.minHeight);
            box = this.getBox();
        }
    },
    _doShow: function (x, y) {
        var vbox = this.getParentBox();

        if (this.state == 'max') {
            if (!this._width) {
                var box = this.getBox();
                this._width = box.width;
                this._height = box.height;

                this.x = box.x;
                this.y = box.y;
            }
        } else {
            if (mini.isNull(x)) x = 'center';
            if (mini.isNull(y)) y = 'middle';

            this.el.style.position = 'absolute';
            this.el.style.left = '-2000px';
            this.el.style.top = '-2000px';
            this.el.style.display = '';

            if (this._width) {
                this.setWidth(this._width);
                this.setHeight(this._height);
            } else {
            }
            this._measureSize();

            var box = this.getBox();

            if (x == 'left') x = 0;
            if (x == 'center') x = vbox.width / 2 - box.width / 2;
            if (x == 'right') x = vbox.width - box.width;

            if (y == 'top') y = 0;
            if (y == 'middle') y = vbox.y + vbox.height / 2 - box.height / 2;
            if (y == 'bottom') y = vbox.height - box.height;

            if (x + box.width > vbox.right) x = vbox.right - box.width;
            if (y + box.height > vbox.bottom) y = vbox.bottom - box.height;
            if (x < 0) x = 0;
            if (y < 0) y = 0;

            this.el.style.display = '';

            mini.setX(this.el, x);
            mini.setY(this.el, y);

            this.el.style.left = x + 'px';
            this.el.style.top = y + 'px';
        }
        this.doLayout();
    },

    _OnButtonClick: function (button, htmlEvent) {
        var e = mini.Window.superclass._OnButtonClick.call(this, button, htmlEvent);
        if (e.cancel == true) return e;

        if (e.name == 'max') {
            if (this.state == 'max') {
                this.restore();
            } else {
                this.max();
            }
        }
        return e;
    },
    __OnWindowResize: function (e) {
        if (this.state == 'max') {
            this.doLayout();
        }
    },
    __OnWindowMouseDown: function (e) {
        var sf = this;

        if (e.button != mini.MouseButton.Left) return;
        if (
            this.state != 'max' &&
            this.allowDrag &&
            mini.isAncestor(this._headerEl, e.target) &&
            !mini.findParent(e.target, 'mini-tools')
        ) {
            var sf = this;
            var box = this.getBox();
            var drag = new mini.Drag({
                capture: false,
                onStart: function () {
                    sf._maskProxy = mini.append(document.body, '<div class="mini-resizer-mask"></div>');
                    sf._dragProxy = mini.append(document.body, '<div class="mini-drag-proxy"></div>');

                    sf.el.style.display = 'none';
                },
                onMove: function (drag) {
                    var x = drag.now[0] - drag.init[0],
                        y = drag.now[1] - drag.init[1];

                    x = box.x + x;
                    y = box.y + y;

                    var vbox = sf.getParentBox();

                    var right = x + box.width;
                    var bottom = y + box.height;
                    if (right > vbox.width) x = vbox.width - box.width;

                    if (x < 0) x = 0;
                    if (y < 0) y = 0;

                    sf.x = x;
                    sf.y = y;

                    var dbox = { x: x, y: y, width: box.width, height: box.height };

                    mini.setBox(sf._dragProxy, dbox);
                    this.moved = true;
                },
                onStop: function () {
                    sf.el.style.display = 'block';

                    if (this.moved) {
                        var box = mini.getBox(sf._dragProxy);

                        mini.setXY(sf.el, box.x, box.y);
                    }

                    jQuery(sf._maskProxy).remove();
                    sf._maskProxy = null;

                    jQuery(sf._dragProxy).remove();
                    sf._dragProxy = null;
                }
            });
            drag.start(e);
        }
    },
    destroy: function (removeEl) {
        mini.un(window, 'resize', this.__OnWindowResize, this);
        if (this._modalEl) {
            jQuery(this._modalEl).remove();
            this._modalEl = null;
        }
        if (this.shadowEl) {
            jQuery(this.shadowEl).remove();
            this.shadowEl = null;
        }
        mini.Window.superclass.destroy.call(this, removeEl);
    },
    getAttrs: function (el) {
        var attrs = mini.Window.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['modalStyle']);
        mini._ParseBool(el, attrs, [
            'showModal',
            'showShadow',
            'allowDrag',
            'allowResize',
            'showMaxButton',
            'showMinButton',
            'showInBody'
        ]);
        mini._ParseInt(el, attrs, ['minWidth', 'minHeight', 'maxWidth', 'maxHeight']);

        return attrs;
    },

    showAtEl: function (atEl, options) {
        atEl = mini.byId(atEl);
        if (!atEl) return;
        if (!this.el.parentElement || this.el.parentNode != document.body) {
            this.render(document.body);
        }

        var c = {
            xAlign: this.xAlign,
            yAlign: this.yAlign,
            xOffset: 0,
            yOffset: 0,
            popupCls: this.popupCls
        };
        mini.copyTo(c, options);

        this._popupEl = atEl;

        this.el.style.position = 'absolute';
        this.el.style.left = '-2000px';
        this.el.style.top = '-2000px';
        this.el.style.display = '';

        this.doLayout();
        this._measureSize();

        var vbox = mini.getViewportBox();
        var box = this.getBox();
        var pbox = mini.getBox(atEl);
        var xy = c.xy;
        var h = c.xAlign,
            v = c.yAlign;

        var x = vbox.width / 2 - box.width / 2,
            y = 0;
        if (xy) {
            x = xy[0];
            y = xy[1];
        }

        switch (c.xAlign) {
            case 'outleft':
                x = pbox.x - box.width;
                break;
            case 'left':
                x = pbox.x;
                break;
            case 'center':
                x = pbox.x + pbox.width / 2 - box.width / 2;
                break;
            case 'right':
                x = pbox.right - box.width;
                break;
            case 'outright':
                x = pbox.right;
                break;
            default:
                break;
        }

        switch (c.yAlign) {
            case 'above':
                y = pbox.y - box.height;
                break;
            case 'top':
                y = pbox.y;
                break;
            case 'middle':
                y = pbox.y + pbox.height / 2 - box.height / 2;
                break;
            case 'bottom':
                y = pbox.bottom - box.height;
                break;
            case 'below':
                y = pbox.bottom;
                break;
            default:
                break;
        }
        x = parseInt(x);
        y = parseInt(y);

        if (c.outYAlign || c.outXAlign) {
            if (c.outYAlign == 'above') {
                if (y + box.height > vbox.bottom) {
                    var top = pbox.y - vbox.y;
                    var bottom = vbox.bottom - pbox.bottom;
                    if (top > bottom) {
                        y = pbox.y - box.height;
                    }
                }
            }
            if (c.outXAlign == 'outleft') {
                if (x + box.width > vbox.right) {
                    var left = pbox.x - vbox.x;
                    var right = vbox.right - pbox.right;
                    if (left > right) {
                        x = pbox.x - box.width;
                    }
                }
            }
            if (c.outXAlign == 'right') {
                if (x + box.width > vbox.right) {
                    x = pbox.right - box.width;
                }
            }
            this._Show(x, y);
        } else {
            this.showAtPos(x + c.xOffset, y + c.yOffset);
        }
    }
});

mini.regClass(mini.Window, 'window');

mini.MessageBox = {
    alertTitle: '提醒',
    confirmTitle: '确认',
    prompTitle: '输入',
    prompMessage: '请输入内容：',
    buttonText: {
        ok: '确定',
        cancel: '取消',
        yes: '是',
        no: '否'
    },
    show: function (options) {
        options = mini.copyTo(
            {
                width: 'auto',
                height: 'auto',
                showModal: true,

                timeout: 0,

                minWidth: 150,
                maxWidth: 800,
                minHeight: 100,
                maxHeight: 350,

                showHeader: true,
                title: '',
                titleIcon: '',
                iconCls: '',
                iconStyle: '',
                message: '',
                html: '',

                spaceStyle: 'margin-right:15px',

                showCloseButton: true,
                buttons: null,
                buttonWidth: 58,
                callback: null
            },
            options
        );

        var callback = options.callback;

        var control = new mini.Window();

        control.setBodyStyle('overflow:hidden');
        control.setShowModal(options.showModal);
        control.setTitle(options.title || '');
        control.setIconCls(options.titleIcon);
        control.setShowHeader(options.showHeader);

        control.setShowCloseButton(options.showCloseButton);

        var id1 = control.uid + '$table',
            id2 = control.uid + '$content';

        var icon = '<div class="' + options.iconCls + '" style="' + options.iconStyle + '"></div>';
        var s =
            '<table class="mini-messagebox-table" id="' +
            id1 +
            '" style="" cellspacing="0" cellpadding="0"><tr><td>' +
            icon +
            '</td><td id="' +
            id2 +
            '" class="mini-messagebox-content-text">' +
            (options.message || '') +
            '</td></tr></table>';

        var ws = '<div class="mini-messagebox-content"></div>' + '<div class="mini-messagebox-buttons"></div>';
        control._bodyEl.innerHTML = ws;
        var contentEl = control._bodyEl.firstChild;
        if (options.html) {
            if (typeof options.html == 'string') {
                contentEl.innerHTML = options.html;
            } else if (mini.isElement(options.html)) {
                contentEl.appendChild(options.html);
            }
        } else {
            contentEl.innerHTML = s;
        }

        control._Buttons = [];

        var buttonsEl = control._bodyEl.lastChild;
        if (options.buttons && options.buttons.length > 0) {
            for (var i = 0, l = options.buttons.length; i < l; i++) {
                var button = options.buttons[i];
                var text = mini.MessageBox.buttonText[button];
                if (!text) text = button;

                var btn = new mini.Button();
                btn.setText(text);
                btn.setWidth(options.buttonWidth);
                btn.render(buttonsEl);
                btn.action = button;
                btn.on('click', function (e) {
                    var button = e.sender;
                    if (callback) callback(button.action);
                    mini.MessageBox.hide(control);
                });

                if (i != l - 1) {
                    btn.setStyle(options.spaceStyle);
                }

                control._Buttons.push(btn);
            }
        } else {
            buttonsEl.style.display = 'none';
        }

        control.setMinWidth(options.minWidth);
        control.setMinHeight(options.minHeight);
        control.setMaxWidth(options.maxWidth);
        control.setMaxHeight(options.maxHeight);
        control.setWidth(options.width);
        control.setHeight(options.height);

        control.show();

        var width = control.getWidth();
        control.setWidth(width);

        var height = control.getHeight();
        control.setHeight(height);

        var tb = document.getElementById(id1);
        if (tb) {
            tb.style.width = '100%';
        }
        var td = document.getElementById(id2);
        if (td) {
            td.style.width = '100%';
        }

        var firstButton = control._Buttons[0];
        if (firstButton) {
            firstButton.focus();
        } else {
            control.focus();
        }

        control.on('beforebuttonclick', function (e) {
            if (callback) callback('close');
            e.cancel = true;
            mini.MessageBox.hide(control);
        });
        mini.on(control.el, 'keydown', function (e) {});

        if (options.timeout) {
            setTimeout(function () {
                mini.MessageBox.hide(control);
            }, options.timeout);
        }

        return control;
    },
    hide: function (id) {
        if (!id) return;
        var control = typeof id == 'object' ? id : mini.getbyUID(id);
        if (!control) return;

        for (var i = 0, l = control._Buttons.length; i < l; i++) {
            var button = control._Buttons[i];
            button.destroy();
        }
        control._Buttons = null;

        control.destroy();
    },
    alert: function (message, title, callback) {
        return mini.MessageBox.show({
            minWidth: 250,
            title: title || mini.MessageBox.alertTitle,
            buttons: ['ok'],
            message: message,
            iconCls: 'mini-messagebox-warning',
            callback: callback
        });
    },
    confirm: function (message, title, callback) {
        return mini.MessageBox.show({
            minWidth: 250,
            title: title || mini.MessageBox.confirmTitle,
            buttons: ['ok', 'cancel'],
            message: message,
            iconCls: 'mini-messagebox-question',
            callback: callback
        });
    },
    prompt: function (message, title, callback, multi) {
        var id = 'prompt$' + new Date()?.getTime();
        var s = message || mini.MessageBox.promptMessage;
        if (multi) {
            s = s + '<br/><textarea id="' + id + '" style="width:200px;height:60px;margin-top:3px;"></textarea>';
        } else {
            s = s + '<br/><input id="' + id + '" type="text" style="width:200px;margin-top:3px;"/>';
        }
        var win = mini.MessageBox.show({
            title: title || mini.MessageBox.promptTitle,
            buttons: ['ok', 'cancel'],
            width: 250,
            html: '<div style="padding:5px;padding-left:10px;">' + s + '</div>',
            callback: function (action) {
                var input = document.getElementById(id);
                if (callback) callback(action, input.value);
            }
        });
        var input = document.getElementById(id);
        input.focus();

        win.input = input;
        return win;
    },
    loading: function (message, title) {
        return mini.MessageBox.show({
            minHeight: 50,
            title: title,
            showCloseButton: false,
            message: message,
            iconCls: 'mini-messagebox-waiting'
        });
    }
};
mini.alert = mini.MessageBox.alert;
mini.confirm = mini.MessageBox.confirm;
mini.prompt = mini.MessageBox.prompt;
mini.loading = mini.MessageBox.loading;
mini.showMessageBox = mini.MessageBox.show;
mini.hideMessageBox = mini.MessageBox.hide;

mini.Splitter = mini.Control.extend({
    props: {
        width: 300,
        height: 180,

        vertical: false,
        allowSplitMove: true,

        pane1: null,
        pane2: null,

        showHandleButton: true,
        handlerStyle: '',
        handlerCls: '',

        handlerSize: 5
    },

    uiCls: 'mini-splitter',

    initComponent: function () {
        this._initPanes();
        this.callParent('initComponent');
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-splitter';
        this.el.innerHTML =
            '<div class="mini-splitter-border"><div id="1" class="mini-splitter-pane mini-splitter-pane1"></div><div id="2" class="mini-splitter-pane mini-splitter-pane2"></div><div class="mini-splitter-handler"></div></div>';

        this._borderEl = this.el.firstChild;
        this._pane1El = this._borderEl.firstChild;
        this._pane2El = this._borderEl.childNodes[1];
        this._handlerEl = this._borderEl.lastChild;
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini.on(this.el, 'click', this.__OnClick, this);
            mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
        }, this);
    },
    _initPanes: function () {
        this.pane1 = {
            id: '',
            index: 1,
            minSize: 30,
            maxSize: 1000000,
            size: '',
            showCollapseButton: false,
            cls: '',
            style: '',
            visible: true,
            expanded: true
        };
        this.pane2 = mini.copyTo({}, this.pane1);
        this.pane2.index = 2;
    },

    doLayout: function () {
        this._handlerEl.style.cursor = this.allowSplitMove ? '' : 'default';

        mini.removeClass(this.el, 'mini-splitter-vertical');
        if (this.vertical) {
            mini.addClass(this.el, 'mini-splitter-vertical');
        }

        mini.removeClass(this._pane1El, 'mini-splitter-pane1-vertical');
        mini.removeClass(this._pane2El, 'mini-splitter-pane2-vertical');
        if (this.vertical) {
            mini.addClass(this._pane1El, 'mini-splitter-pane1-vertical');
            mini.addClass(this._pane2El, 'mini-splitter-pane2-vertical');
        }

        mini.removeClass(this._handlerEl, 'mini-splitter-handler-vertical');
        if (this.vertical) {
            mini.addClass(this._handlerEl, 'mini-splitter-handler-vertical');
        }

        var h = this.getHeight();
        var w = this.getWidth();

        if (w < 0) w = 0;
        if (h < 0) h = 0;
        this._borderEl.style.width = w + 'px';
        this._borderEl.style.height = h + 'px';
        if (this.vertical) {
            this._borderEl.style.height = '100%';
        } else {
            this._borderEl.style.width = '100%';
        }

        var p1 = this._pane1El,
            p2 = this._pane2El;
        var jqP1 = jQuery(p1),
            jqP2 = jQuery(p2);

        p1.style.display = p2.style.display = this._handlerEl.style.display = '';

        var hSize = this.handlerSize;

        this.pane1.size = String(this.pane1.size);
        this.pane2.size = String(this.pane2.size);

        var p1SIZE = parseFloat(this.pane1.size),
            p2SIZE = parseFloat(this.pane2.size);

        var p1Null = isNaN(p1SIZE),
            p2Null = isNaN(p2SIZE);
        var p1Percent = !isNaN(p1SIZE) && this.pane1.size.indexOf('%') != -1;
        var p2Percent = !isNaN(p2SIZE) && this.pane2.size.indexOf('%') != -1;
        var p1Number = !p1Null && !p1Percent;
        var p2Number = !p2Null && !p2Percent;

        var size = this.vertical ? h - this.handlerSize : w - this.handlerSize;
        var p1Size = (p2Size = 0);

        if (p1Null || p2Null) {
            if (p1Null && p2Null) {
                p1Size = parseInt(size / 2);
                p2Size = size - p1Size;
            } else if (p1Number) {
                p1Size = p1SIZE;
                p2Size = size - p1Size;
            } else if (p1Percent) {
                p1Size = parseInt((size * p1SIZE) / 100);
                p2Size = size - p1Size;
            } else if (p2Number) {
                p2Size = p2SIZE;
                p1Size = size - p2Size;
            } else if (p2Percent) {
                p2Size = parseInt((size * p2SIZE) / 100);
                p1Size = size - p2Size;
            }
        } else if (p1Percent && p2Number) {
            p2Size = p2SIZE;
            p1Size = size - p2Size;
        } else if (p1Number && p2Percent) {
            p1Size = p1SIZE;
            p2Size = size - p1Size;
        } else {
            var all = p1SIZE + p2SIZE;
            p1Size = parseInt((size * p1SIZE) / all);
            p2Size = size - p1Size;
        }

        if (p1Size > this.pane1.maxSize) {
            p1Size = this.pane1.maxSize;
            p2Size = size - p1Size;
        }
        if (p2Size > this.pane2.maxSize) {
            p2Size = this.pane2.maxSize;
            p1Size = size - p2Size;
        }

        if (p1Size < this.pane1.minSize) {
            p1Size = this.pane1.minSize;
            p2Size = size - p1Size;
        }
        if (p2Size < this.pane2.minSize) {
            p2Size = this.pane2.minSize;
            p1Size = size - p2Size;
        }

        if (this.pane1.expanded == false) {
            p2Size = size;
            p1Size = 0;
            p1.style.display = 'none';
        } else if (this.pane2.expanded == false) {
            p1Size = size;
            p2Size = 0;
            p2.style.display = 'none';
        }

        if (this.pane1.visible == false) {
            p2Size = size + hSize;
            p1Size = hSize = 0;
            p1.style.display = 'none';
            this._handlerEl.style.display = 'none';
        } else if (this.pane2.visible == false) {
            p1Size = size + hSize;
            p2Size = hSize = 0;
            p2.style.display = 'none';
            this._handlerEl.style.display = 'none';
        }

        if (this.vertical) {
            mini.setWidth(p1, w);
            mini.setWidth(p2, w);

            mini.setHeight(p1, p1Size);
            mini.setHeight(p2, p2Size);

            p2.style.top = p1Size + hSize + 'px';

            this._handlerEl.style.left = '0px';
            this._handlerEl.style.top = p1Size + 'px';
            mini.setWidth(this._handlerEl, w);
            mini.setHeight(this._handlerEl, this.handlerSize);

            p1.style.left = '0px';
            p2.style.left = '0px';
        } else {
            mini.setWidth(p1, p1Size);
            mini.setWidth(p2, p2Size);

            mini.setHeight(p1, h);
            mini.setHeight(p2, h);
            p2.style.left = p1Size + hSize + 'px';

            this._handlerEl.style.top = '0px';
            this._handlerEl.style.left = p1Size + 'px';
            mini.setWidth(this._handlerEl, this.handlerSize);
            mini.setHeight(this._handlerEl, h);

            p1.style.top = '0px';
            p2.style.top = '0px';
        }

        var s = '<div class="mini-splitter-handler-buttons">';

        if (!this.pane1.expanded || !this.pane2.expanded) {
            if (!this.pane1.expanded) {
                if (this.pane1.showCollapseButton) {
                    s += '<a id="1" class="mini-splitter-pane2-button"></a>';
                }
            } else {
                if (this.pane2.showCollapseButton) {
                    s += '<a id="2" class="mini-splitter-pane1-button"></a>';
                }
            }
        } else {
            if (this.pane1.showCollapseButton) {
                s += '<a id="1" class="mini-splitter-pane1-button"></a>';
            }
            if (this.allowSplitMove) {
                if (!this.pane1.showCollapseButton && !this.pane2.showCollapseButton) {
                    s += '<span class="mini-splitter-resize-button"></span>';
                }
            }
            if (this.pane2.showCollapseButton) {
                s += '<a id="2" class="mini-splitter-pane2-button"></a>';
            }
        }
        s += '</div>';
        this._handlerEl.innerHTML = s;
        var buttons = this._handlerEl.firstChild;
        buttons.style.display = this.showHandleButton ? '' : 'none';
        var box = mini.getBox(buttons);
        if (this.vertical) {
            buttons.style.marginLeft = -box.width / 2 + 'px';
        } else {
            buttons.style.marginTop = -box.height / 2 + 'px';
        }

        if (!this.pane1.visible || !this.pane2.visible || !this.pane1.expanded || !this.pane2.expanded) {
            mini.addClass(this._handlerEl, 'mini-splitter-nodrag');
        } else {
            mini.removeClass(this._handlerEl, 'mini-splitter-nodrag');
        }
    },

    getPaneBox: function (index) {
        var el = this.getPaneEl(index);
        if (!el) return null;
        return mini.getBox(el);
    },
    getPane: function (index) {
        if (index == 1) return this.pane1;
        else if (index == 2) return this.pane2;
        return index;
    },

    setPanes: function (panes) {
        if (!mini.isArray(panes)) return;
        for (var i = 0; i < 2; i++) {
            var p = panes[i];
            this.updatePane(i + 1, p);
        }
    },
    setPaneControls: function (index, value) {
        var pane = this.getPane(index);
        if (!pane) return;
        var el = this.getPaneEl(index);
        __mini_setControls(value, el, this);
    },
    getPaneEl: function (index) {
        if (index == 1) return this._pane1El;
        return this._pane2El;
    },
    updatePane: function (index, options) {
        var pane = this.getPane(index);
        if (!pane) return;
        mini.copyTo(pane, options);

        var el = this.getPaneEl(index);

        var cs = pane.body;
        delete pane.body;
        if (cs) {
            if (!mini.isArray(cs)) cs = [cs];
            for (var i = 0, l = cs.length; i < l; i++) {
                mini.append(el, cs[i]);
            }
        }

        if (pane.bodyParent) {
            var p = pane.bodyParent;
            while (p.firstChild) {
                el.appendChild(p.firstChild);
            }
        }
        delete pane.bodyParent;

        el.id = pane.id;

        mini.setStyle(el, pane.style);
        mini.addClass(el, pane['class']);

        if (pane.controls) {
            var index = pane == this.pane1 ? 1 : 2;
            this.setPaneControls(index, pane.controls);
            delete pane.controls;
        }

        this.invalidateLayout();
    },
    setShowHandleButton: function (value) {
        this.showHandleButton = value;
        this.invalidateLayout();
    },
    getShowHandleButton: function (value) {
        return this.showHandleButton;
    },
    setVertical: function (value) {
        this.vertical = value;
        this.invalidateLayout();
    },
    getVertical: function () {
        return this.vertical;
    },
    expandPane: function (index) {
        var pane = this.getPane(index);
        if (!pane) return;
        pane.expanded = true;
        this.invalidateLayout();
        var e = { pane: pane, paneIndex: this.pane1 == pane ? 1 : 2 };
        this.fire('expand', e);
    },
    collapsePane: function (index) {
        var pane = this.getPane(index);
        if (!pane) return;
        pane.expanded = false;
        var pane2 = pane == this.pane1 ? this.pane2 : this.pane1;
        if (pane2.expanded == false) {
            pane2.expanded = true;
            pane2.visible = true;
        }
        this.invalidateLayout();

        var e = { pane: pane, paneIndex: this.pane1 == pane ? 1 : 2 };
        this.fire('collapse', e);
    },
    togglePane: function (index) {
        var pane = this.getPane(index);
        if (!pane) return;
        if (pane.expanded) {
            this.collapsePane(pane);
        } else {
            this.expandPane(pane);
        }
    },
    showPane: function (index) {
        var pane = this.getPane(index);
        if (!pane) return;
        pane.visible = true;
        this.invalidateLayout();
    },
    hidePane: function (index) {
        var pane = this.getPane(index);
        if (!pane) return;
        pane.visible = false;
        var pane2 = pane == this.pane1 ? this.pane2 : this.pane1;
        if (pane2.visible == false) {
            pane2.expanded = true;
            pane2.visible = true;
        }
        this.invalidateLayout();
    },
    setAllowSplitMove: function (value) {
        this.allowSplitMove = value;
        this.invalidateLayout();
    },

    setHandlerSize: function (value) {
        this.handlerSize = value;
        this.invalidateLayout();
    },

    __OnClick: function (e) {
        var t = e.target;
        if (!mini.isAncestor(this._handlerEl, t)) return;
        var index = parseInt(t.id);
        var pane = this.getPane(index);

        var e = { pane: pane, paneIndex: index, cancel: false };
        if (pane.expanded) {
            this.fire('beforecollapse', e);
        } else {
            this.fire('beforeexpand', e);
        }
        if (e.cancel == true) return;

        if (t.className == 'mini-splitter-pane1-button') {
            this.togglePane(index);
        } else if (t.className == 'mini-splitter-pane2-button') {
            this.togglePane(index);
        }
    },
    _OnButtonClick: function (pane, htmlEvent) {
        this.fire('buttonclick', {
            pane: pane,
            index: this.pane1 == pane ? 1 : 2,
            htmlEvent: htmlEvent
        });
    },
    onButtonClick: function (fn, scope) {
        this.on('buttonclick', fn, scope);
    },

    __OnMouseDown: function (e) {
        var t = e.target;
        if (!this.allowSplitMove) return;
        if (!this.pane1.visible || !this.pane2.visible || !this.pane1.expanded || !this.pane2.expanded) {
            return;
        }
        if (mini.isAncestor(this._handlerEl, t)) {
            if (t.className == 'mini-splitter-pane1-button' || t.className == 'mini-splitter-pane2-button') {
            } else {
                var drag = this._getDrag();
                drag.start(e);
            }
        }
    },
    _getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                capture: true,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    },
    _OnDragStart: function (drag) {
        this.handlerBox = mini.getBox(this._handlerEl);

        this._maskProxy = mini.append(document.body, '<div class="mini-resizer-mask"></div>');

        this._dragProxy = mini.append(document.body, '<div class="mini-proxy"></div>');
        this._dragProxy.style.cursor = this.vertical ? 'n-resize' : 'w-resize';

        this.elBox = mini.getBox(this._borderEl, true);
        mini.setBox(this._dragProxy, this.handlerBox);
    },
    _OnDragMove: function (drag) {
        if (!this.handlerBox) return;
        if (!this.elBox) this.elBox = mini.getBox(this._borderEl, true);
        var w = this.elBox.width,
            h = this.elBox.height;
        var hSize = this.handlerSize;
        var size = this.vertical ? h - this.handlerSize : w - this.handlerSize;
        var p1Min = this.pane1.minSize,
            p1Max = this.pane1.maxSize;
        var p2Min = this.pane2.minSize,
            p2Max = this.pane2.maxSize;

        if (this.vertical == true) {
            var yOffset = drag.now[1] - drag.init[1];
            var y = this.handlerBox.y + yOffset;

            if (y - this.elBox.y > p1Max) y = this.elBox.y + p1Max;
            if (y + this.handlerBox.height < this.elBox.bottom - p2Max) {
                y = this.elBox.bottom - p2Max - this.handlerBox.height;
            }

            if (y - this.elBox.y < p1Min) y = this.elBox.y + p1Min;
            if (y + this.handlerBox.height > this.elBox.bottom - p2Min) {
                y = this.elBox.bottom - p2Min - this.handlerBox.height;
            }
            mini.setY(this._dragProxy, y);
        } else {
            var xOffset = drag.now[0] - drag.init[0];
            var x = this.handlerBox.x + xOffset;

            if (x - this.elBox.x > p1Max) x = this.elBox.x + p1Max;
            if (x + this.handlerBox.width < this.elBox.right - p2Max) {
                x = this.elBox.right - p2Max - this.handlerBox.width;
            }

            if (x - this.elBox.x < p1Min) x = this.elBox.x + p1Min;
            if (x + this.handlerBox.width > this.elBox.right - p2Min) {
                x = this.elBox.right - p2Min - this.handlerBox.width;
            }

            mini.setX(this._dragProxy, x);
        }
    },
    _OnDragStop: function (drag) {
        var w = this.elBox.width,
            h = this.elBox.height;
        var hSize = this.handlerSize;

        var p1SIZE = parseFloat(this.pane1.size),
            p2SIZE = parseFloat(this.pane2.size);

        var p1Null = isNaN(p1SIZE),
            p2Null = isNaN(p2SIZE);
        var p1Percent = !isNaN(p1SIZE) && this.pane1.size.indexOf('%') != -1;
        var p2Percent = !isNaN(p2SIZE) && this.pane2.size.indexOf('%') != -1;
        var p1Number = !p1Null && !p1Percent;
        var p2Number = !p2Null && !p2Percent;

        var size = this.vertical ? h - this.handlerSize : w - this.handlerSize;

        var box = mini.getBox(this._dragProxy);
        var p1Size = box.x - this.elBox.x,
            p2Size = size - p1Size;
        if (this.vertical) {
            p1Size = box.y - this.elBox.y;
            p2Size = size - p1Size;
        }

        if (p1Null || p2Null) {
            if (p1Null && p2Null) {
                p1SIZE = parseFloat((p1Size / size) * 100).toFixed(1);
                this.pane1.size = p1SIZE + '%';
            } else if (p1Number) {
                p1SIZE = p1Size;
                this.pane1.size = p1SIZE;
            } else if (p1Percent) {
                p1SIZE = parseFloat((p1Size / size) * 100).toFixed(1);
                this.pane1.size = p1SIZE + '%';
            } else if (p2Number) {
                p2SIZE = p2Size;
                this.pane2.size = p2SIZE;
            } else if (p2Percent) {
                p2SIZE = parseFloat((p2Size / size) * 100).toFixed(1);
                this.pane2.size = p2SIZE + '%';
            }
        } else if (p1Percent && p2Number) {
            this.pane2.size = p2Size;
        } else if (p1Number && p2Percent) {
            this.pane1.size = p1Size;
        } else {
            this.pane1.size = parseFloat((p1Size / size) * 100).toFixed(1);
            this.pane2.size = 100 - this.pane1.size;
        }

        jQuery(this._dragProxy).remove();
        jQuery(this._maskProxy).remove();

        this._maskProxy = null;
        this._dragProxy = null;
        this.elBox = this.handlerBox = null;

        this.invalidateLayout();

        this.fire('resize');
    },

    getAttrs: function (el) {
        var attrs = mini.Splitter.superclass.getAttrs.call(this, el);

        mini._ParseBool(el, attrs, ['allowSplitMove', 'vertical', 'showHandleButton', 'onresize']);
        mini._ParseInt(el, attrs, ['handlerSize']);

        var panes = [];

        var nodes = mini.getChildNodes(el);
        for (var i = 0, l = 2; i < l; i++) {
            var node = nodes[i];
            var g = jQuery(node);

            var o = {};
            panes.push(o);
            if (!node) continue;
            o.style = node.style.cssText;
            mini._ParseString(node, o, ['cls', 'size', 'id', 'class']);
            mini._ParseBool(node, o, ['visible', 'expanded', 'showCollapseButton']);
            mini._ParseInt(node, o, ['minSize', 'maxSize', 'handlerSize']);

            o.bodyParent = node;
        }
        attrs.panes = panes;

        return attrs;
    }
});
mini.regClass(mini.Splitter, 'splitter');
mini.Tabs = mini.Control.extend({
    type: 'tabs',
    tag: 'mini-tabs',

    props: {
        activeIndex: -1,
        tabAlign: 'left',
        tabPosition: 'top',
        showBody: true,

        nameField: 'name',
        titleField: 'title',
        urlField: 'url',

        url: '',
        maskOnLoad: true,

        plain: true,

        bodyStyle: ''
    },

    tabHoverCls: 'mini-tab-hover',
    tabActiveCls: 'mini-tab-active',

    initComponent: function () {
        this._initTabs();
        this.callParent('initComponent');
    },

    set: function (obj) {
        if (typeof obj == 'string') {
            return this;
        }

        var _allowLayout = this._allowLayout;
        this._allowLayout = false;

        var activeIndex = obj.activeIndex;
        delete obj.activeIndex;

        var url = obj.url;
        delete obj.url;

        this.callParent('set', obj);

        if (url) {
            this.setUrl(url);
        }
        if (mini.isNumber(activeIndex)) {
            this.setActiveIndex(activeIndex);
        }

        this._allowLayout = _allowLayout;
        this.doLayout();

        return this;
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-tabs';

        var s =
            '<table class="mini-tabs-table" cellspacing="0" cellpadding="0"><tr style="width:100%;">' +
            '<td></td>' +
            '<td style="text-align:left;vertical-align:top;width:100%;"><div class="mini-tabs-bodys"></div></td>' +
            '<td></td>' +
            '</tr></table>';
        this.el.innerHTML = s;
        this._tableEl = this.el.firstChild;

        var tds = this.el.getElementsByTagName('td');
        this._td1El = tds[0];
        this._td2El = tds[1];
        this._td3El = tds[2];

        this._bodyEl = this._td2El.firstChild;
        this._borderEl = this._bodyEl;
        this.doUpdate();
    },
    destroy: function (removeEl) {
        this._tableEl = this._td1El = this._td2El = this._td3El = null;
        this._bodyEl = this._borderEl = this.headerEl = null;
        this.tabs = [];
        mini.Tabs.superclass.destroy.call(this, removeEl);
    },

    _doClearElement: function () {
        mini.removeClass(this._td1El, 'mini-tabs-header');
        mini.removeClass(this._td3El, 'mini-tabs-header');
        this._td1El.innerHTML = '';
        this._td3El.innerHTML = '';

        mini.removeChilds(this._td2El, this._bodyEl);
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
            mini.on(this.el, 'click', this.__OnClick, this);
            mini.on(this.el, 'mouseover', this.__OnMouseOver, this);
            mini.on(this.el, 'mouseout', this.__OnMouseOut, this);
        }, this);
    },

    _initTabs: function () {
        this.tabs = [];
    },
    _TabID: 1,

    createTab: function (options) {
        var tab = mini.copyTo(
            {
                _id: this._TabID++,
                name: '',
                title: '',

                newLine: false,

                iconCls: '',
                iconStyle: '',
                headerCls: '',
                headerStyle: '',
                bodyCls: '',
                bodyStyle: '',

                visible: true,
                enabled: true,
                showCloseButton: false,
                active: false,

                url: '',
                loaded: false,
                refreshOnClick: false
            },
            options
        );
        if (options) {
            options = mini.copyTo(options, tab);
            tab = options;
        }
        return tab;
    },

    _doLoad: function () {
        var tabs = mini.getData(this.url);

        if (this.dataField) {
            tabs = mini._getMap(this.dataField, tabs);
        }
        if (!tabs) tabs = [];

        this.setTabs(tabs);
        this.fire('load');
    },

    load: function (url) {
        if (typeof url == 'string') {
            this.setUrl(url);
        } else {
            this.setTabs(url);
        }
    },
    setUrl: function (value) {
        this.url = value;

        if (value) {
            this._doLoad();
        }
    },
    getUrl: function () {
        return this.url;
    },

    setNameField: function (value) {
        this.nameField = value;
    },
    getNameField: function () {
        return this.nameField;
    },
    setTitleField: function (value) {
        this.titleField = value;
    },
    getTitleField: function () {
        return this.titleField;
    },
    setUrlField: function (value) {
        this.urlField = value;
    },
    getUrlField: function () {
        return this.urlField;
    },
    setTabControls: function (tab, value) {
        var tab = this.getTab(tab);
        if (!tab) return;
        var el = this.getTabBodyEl(tab);
        __mini_setControls(value, el, this);
    },
    setTabs: function (tabs) {
        if (!mini.isArray(tabs)) return;
        this.beginUpdate();

        this.removeAll();

        for (var i = 0, l = tabs.length; i < l; i++) {
            var tab = tabs[i];
            tab.title = mini._getMap(this.titleField, tab);
            tab.url = mini._getMap(this.urlField, tab);
            tab.name = mini._getMap(this.nameField, tab);
        }

        for (var i = 0, l = tabs.length; i < l; i++) {
            this.addTab(tabs[i]);
        }
        this.setActiveIndex(0);
        this.endUpdate();
    },
    getTabs: function () {
        return this.tabs;
    },
    removeAll: function (butTabs) {
        var activeTab = this.getActiveTab();
        if (mini.isNull(butTabs)) butTabs = [];
        if (!mini.isArray(butTabs)) {
            butTabs = [butTabs];
        }
        for (var i = butTabs.length - 1; i >= 0; i--) {
            var t = this.getTab(butTabs[i]);
            if (!t) butTabs.removeAt(i);
            else butTabs[i] = t;
        }

        var olds = this.tabs;
        for (var i = olds.length - 1; i >= 0; i--) {
            var tab = olds[i];
            if (butTabs.indexOf(tab) == -1) {
                this.removeTab(tab);
            }
        }
        var butTab = butTabs[0];
        if (activeTab != this.getActiveTab()) {
            if (butTab) this.activeTab(butTab);
        }
    },
    addTab: function (tab, index) {
        if (typeof tab == 'string') {
            tab = { title: tab };
        }
        tab = this.createTab(tab);
        if (!tab.name) tab.name = '';

        if (typeof index != 'number') index = this.tabs.length;
        this.tabs.insert(index, tab);

        var bodyId = this._createTabBodyId(tab);
        var s =
            '<div id="' +
            bodyId +
            '" class="mini-tabs-body ' +
            tab.bodyCls +
            '" style="' +
            tab.bodyStyle +
            ';display:none;"></div>';
        mini.append(this._bodyEl, s);

        var el = this.getTabBodyEl(tab);

        var cs = tab.body;
        delete tab.body;
        if (cs) {
            if (!mini.isArray(cs)) cs = [cs];
            for (var i = 0, l = cs.length; i < l; i++) {
                mini.append(el, cs[i]);
            }
        }

        if (tab.bodyParent) {
            var p = tab.bodyParent;
            while (p.firstChild) {
                el.appendChild(p.firstChild);
            }
        }
        delete tab.bodyParent;

        if (tab.controls) {
            this.setTabControls(tab, tab.controls);
            delete tab.controls;
        }

        this.doUpdate();
        return tab;
    },
    removeTab: function (tab) {
        tab = this.getTab(tab);
        if (!tab || this.tabs.indexOf(tab) == -1) return;

        var acTab = this.getActiveTab();

        var isActive = tab == acTab;

        var autoActive = this._OnTabDestroy(tab);

        this.tabs.remove(tab);

        this._doRemoveIFrame(tab);

        var el = this.getTabBodyEl(tab);
        if (el) this._bodyEl.removeChild(el);

        if (autoActive && isActive) {
            for (var i = this.activeIndex; i >= 0; i--) {
                var tab = this.getTab(i);
                if (tab && tab.enabled && tab.visible) {
                    this.activeIndex = i;
                    break;
                }
            }
            this.doUpdate();
            this.setActiveIndex(this.activeIndex);
            this.fire('activechanged');
        } else {
            this.activeIndex = this.tabs.indexOf(acTab);
            this.doUpdate();
        }
        return tab;
    },
    moveTab: function (tab, index) {
        tab = this.getTab(tab);
        if (!tab) return;

        var t = this.tabs[index];
        if (!t || t == tab) return;
        this.tabs.remove(tab);
        var index = this.tabs.indexOf(t);
        this.tabs.insert(index, tab);
        this.doUpdate();
    },
    updateTab: function (tab, options) {
        tab = this.getTab(tab);
        if (!tab) return;
        mini.copyTo(tab, options);
        this.doUpdate();
    },

    _getMaskWrapEl: function () {
        return this._bodyEl;
    },
    _doRemoveIFrame: function (tab, removeAll) {
        if (tab._iframeEl && tab._iframeEl.parentNode) {
            tab._iframeEl.src = '';
            try {
                iframe.contentWindow.document.write('');
                iframe.contentWindow.document.close();
            } catch (ex) {}
            if (tab._iframeEl._ondestroy) tab._iframeEl._ondestroy();
            try {
                tab._iframeEl.parentNode.removeChild(tab._iframeEl);
                tab._iframeEl.removeNode(true);
            } catch (ex) {}
        }
        tab._iframeEl = null;
        tab.loadedUrl = null;

        if (removeAll === true) {
            var bodyEl = this.getTabBodyEl(tab);
            if (bodyEl) {
                var cs = mini.getChildNodes(bodyEl, true);
                for (var i = 0, l = cs.length; i < l; i++) {
                    var d = cs[i];
                    if (d && d.parentNode) d.parentNode.removeChild(d);
                }
            }
        }
    },
    _deferLoadingTime: 180,
    _cancelLoadTabs: function (tab) {
        var tabs = this.tabs;
        for (var i = 0, l = tabs.length; i < l; i++) {
            var t = tabs[i];
            if (t != tab) {
                if (t._loading && t._iframeEl) {
                    t._loading = false;
                    this._doRemoveIFrame(t, true);
                }
            }
        }
        this._loading = false;
        this.unmask();
    },
    _doLoadTab: function (tab) {
        if (!tab) return;
        var bodyEl = this.getTabBodyEl(tab);
        if (!bodyEl) return;

        this._cancelLoadTabs();

        this._doRemoveIFrame(tab, true);

        this._loading = true;
        tab._loading = true;

        this.unmask();
        if (this.maskOnLoad) this.loading();
        var st = new Date();

        var sf = this;

        sf.isLoading = true;

        var iframe = mini.createIFrame(tab.url, function (_iframe, firstLoad) {
            try {
                tab._iframeEl.contentWindow.Owner = window;
                tab._iframeEl.contentWindow.CloseOwnerWindow = function (action) {
                    tab.removeAction = action;

                    var ret = true;
                    if (tab.ondestroy) {
                        if (typeof tab.ondestroy == 'string') {
                            tab.ondestroy = window[tab.ondestroy];
                        }
                        if (tab.ondestroy) {
                            ret = tab.ondestroy.call(this, e);
                        }
                    }
                    if (ret === false) {
                        return false;
                    }

                    setTimeout(function () {
                        sf.removeTab(tab);
                    }, 10);
                };
            } catch (e) {}

            if (tab._loading != true) return;
            var t = st - new Date() + sf._deferLoadingTime;

            tab._loading = false;
            tab.loadedUrl = tab.url;

            if (t < 0) t = 0;
            setTimeout(function () {
                sf.unmask();
                sf.doLayout();
                sf.isLoading = false;
            }, t);

            if (firstLoad) {
                var e = {
                    sender: sf,
                    tab: tab,
                    index: sf.tabs.indexOf(tab),
                    name: tab.name,
                    iframe: tab._iframeEl
                };
                if (tab.onload) {
                    if (typeof tab.onload == 'string') {
                        tab.onload = window[tab.onload];
                    }
                    if (tab.onload) {
                        tab.onload.call(sf, e);
                    }
                }
            }

            sf.fire('tabload', e);
        });
        setTimeout(function () {
            if (tab._iframeEl == iframe) {
                bodyEl.appendChild(iframe);
            }
        }, 1);
        tab._iframeEl = iframe;
    },
    _OnTabDestroy: function (tab) {
        var e = {
            sender: this,
            tab: tab,
            index: this.tabs.indexOf(tab),
            name: tab.name,
            iframe: tab._iframeEl,
            autoActive: true
        };
        this.fire('tabdestroy', e);
        return e.autoActive;
    },
    loadTab: function (url, tab, onload, ondestroy) {
        if (!url) return;
        tab = this.getTab(tab);
        if (!tab) tab = this.getActiveTab();
        if (!tab) return;

        var el = this.getTabBodyEl(tab);
        if (el) {
            mini.addClass(el, 'mini-tabs-hideOverflow');
        }

        tab.url = url;
        delete tab.loadedUrl;

        if (onload) tab.onload = onload;
        if (ondestroy) tab.ondestroy = ondestroy;

        var me = this;
        clearTimeout(this._loadTabTimer);
        this._loadTabTimer = null;
        this._loadTabTimer = setTimeout(function () {
            me._doLoadTab(tab);
        }, 1);
    },
    reloadTab: function (tab) {
        tab = this.getTab(tab);
        if (!tab) tab = this.getActiveTab();
        if (!tab) return;
        this.loadTab(tab.url, tab);
    },

    getTabRows: function () {
        var rows = [];
        var row = [];
        for (var i = 0, l = this.tabs.length; i < l; i++) {
            var tab = this.tabs[i];
            if (i != 0 && tab.newLine) {
                rows.push(row);
                row = [];
            }
            row.push(tab);
        }
        rows.push(row);
        return rows;
    },
    doUpdate: function () {
        if (this._allowUpdate === false) return;

        mini.removeClass(this.el, 'mini-tabs-position-left');
        mini.removeClass(this.el, 'mini-tabs-position-top');
        mini.removeClass(this.el, 'mini-tabs-position-right');
        mini.removeClass(this.el, 'mini-tabs-position-bottom');

        if (this.tabPosition == 'bottom') {
            mini.addClass(this.el, 'mini-tabs-position-bottom');
            this._doUpdateBottom();
        } else if (this.tabPosition == 'right') {
            mini.addClass(this.el, 'mini-tabs-position-right');
            this._doUpdateRight();
        } else if (this.tabPosition == 'left') {
            mini.addClass(this.el, 'mini-tabs-position-left');
            this._doUpdateLeft();
        } else {
            mini.addClass(this.el, 'mini-tabs-position-top');
            this._doUpdateTop();
        }

        this.doLayout();

        this.setActiveIndex(this.activeIndex, false);
    },
    _handleIFrameOverflow: function () {
        var bodyEl = this.getTabBodyEl(this.activeIndex);
        if (bodyEl) {
            mini.removeClass(bodyEl, 'mini-tabs-hideOverflow');
            var dom = mini.getChildNodes(bodyEl)[0];

            if (dom && dom.tagName && dom.tagName.toUpperCase() == 'IFRAME') {
                mini.addClass(bodyEl, 'mini-tabs-hideOverflow');
            }
        }
    },
    doLayout: function () {
        this._handleIFrameOverflow();

        var autoHeight = this.isAutoHeight();

        h = this.getHeight(true);

        w = this.getWidth() - 1;
        var elHeight = h;
        var elWidth = w;

        if (this.showBody) {
            this._bodyEl.style.display = '';
        } else {
            this._bodyEl.style.display = 'none';
        }

        if (this.plain) {
            mini.addClass(this.el, 'mini-tabs-plain');
        } else {
            mini.removeClass(this.el, 'mini-tabs-plain');
        }

        if (!autoHeight && this.showBody) {
            var headerHeight = jQuery(this._headerEl).outerHeight();
            var headerWidth = jQuery(this._headerEl).outerWidth();
            if (this.tabPosition == 'top') {
                headerHeight = jQuery(this._headerEl.parentNode).outerHeight();
            }

            if (this.tabPosition == 'left' || this.tabPosition == 'right') {
                w = w - headerWidth;
            } else {
                h = h - headerHeight;
            }

            margin = mini.getMargins(this._bodyEl);

            h = h - margin.top - margin.bottom;
            w = w - margin.left - margin.right;

            if (h < 0) h = 0;
            if (w < 0) w = 0;

            this._bodyEl.style.width = w + 'px';
            this._bodyEl.style.height = h + 'px';

            if (this.tabPosition == 'left' || this.tabPosition == 'right') {
                var tr = this._headerEl.getElementsByTagName('tr')[0];
                var tds = tr.childNodes;
                var trs = tds[0].getElementsByTagName('tr');

                var first = (last = all = 0);
                for (var i = 0, l = trs.length; i < l; i++) {
                    var tr = trs[i];
                    var trH = jQuery(tr).outerHeight();
                    all += trH;
                    if (i == 0) first = trH;
                    if (i == l - 1) last = trH;
                }

                switch (this.tabAlign) {
                    case 'center':
                        var halfH = parseInt((elHeight - (all - first - last)) / 2);
                        for (var i = 0, l = tds.length; i < l; i++) {
                            tds[i].firstChild.style.height = elHeight + 'px';
                            var tb = tds[i].firstChild;
                            var trs = tb.getElementsByTagName('tr');
                            var tr1 = trs[0],
                                tr2 = trs[trs.length - 1];
                            tr1.style.height = halfH + 'px';
                            tr2.style.height = halfH + 'px';
                        }
                        break;
                    case 'right':
                        for (var i = 0, l = tds.length; i < l; i++) {
                            var tb = tds[i].firstChild;
                            var trs = tb.getElementsByTagName('tr');
                            var tr = trs[0];

                            var size = elHeight - (all - first);
                            if (size >= 0) {
                                tr.style.height = size + 'px';
                            }
                        }
                        break;
                    case 'fit':
                        for (var i = 0, l = tds.length; i < l; i++) {
                            tds[i].firstChild.style.height = elHeight + 'px';
                        }
                        break;
                    default:
                        for (var i = 0, l = tds.length; i < l; i++) {
                            var tb = tds[i].firstChild;
                            var trs = tb.getElementsByTagName('tr');
                            var tr = trs[trs.length - 1];
                            var size = elHeight - (all - last);
                            if (size >= 0) {
                                tr.style.height = size + 'px';
                            }
                        }
                        break;
                }
            }
        } else {
            this._bodyEl.style.width = 'auto';
            this._bodyEl.style.height = 'auto';
        }

        var tabBodyEl = this.getTabBodyEl(this.activeIndex);
        if (tabBodyEl) {
            if (!autoHeight && this.showBody) {
                var h = mini.getHeight(this._bodyEl, true);

                tabBodyEl.style.height = h + 'px';
            } else {
                tabBodyEl.style.height = 'auto';
            }
        }

        switch (this.tabPosition) {
            case 'bottom':
                var hds = this._headerEl.childNodes;
                for (var i = 0, l = hds.length; i < l; i++) {
                    var tb = hds[i];
                    mini.removeClass(tb, 'mini-tabs-header2');
                    if (l > 1 && i != 0) {
                        mini.addClass(tb, 'mini-tabs-header2');
                    }
                }
                break;
            case 'left':
                var tds = this._headerEl.firstChild.rows[0].cells;
                for (var i = 0, l = tds.length; i < l; i++) {
                    var td = tds[i];
                    mini.removeClass(td, 'mini-tabs-header2');
                    if (l > 1 && i == 0) {
                        mini.addClass(td, 'mini-tabs-header2');
                    }
                }
                break;
            case 'right':
                var tds = this._headerEl.firstChild.rows[0].cells;
                for (var i = 0, l = tds.length; i < l; i++) {
                    var td = tds[i];
                    mini.removeClass(td, 'mini-tabs-header2');
                    if (l > 1 && i != 0) {
                        mini.addClass(td, 'mini-tabs-header2');
                    }
                }
                break;
            default:
                var hds = this._headerEl.childNodes;
                for (var i = 0, l = hds.length; i < l; i++) {
                    var tb = hds[i];
                    mini.removeClass(tb, 'mini-tabs-header2');
                    if (l > 1 && i == 0) {
                        mini.addClass(tb, 'mini-tabs-header2');
                    }
                }
                break;
        }

        mini.removeClass(this.el, 'mini-tabs-scroll');
        if (this.tabPosition == 'top') {
            mini.setWidth(this._headerEl, elWidth);
            if (this._headerEl.offsetWidth < this._headerEl.scrollWidth) {
                mini.setWidth(this._headerEl, elWidth - 60);
                mini.addClass(this.el, 'mini-tabs-scroll');
            }
            if (isIE && !jQuery.boxModel) {
                this._leftButtonEl.style.left = '-26px';
            }
        }

        this._doScrollButton();

        mini.layout(this._bodyEl);

        this.fire('layout');
    },

    setTabAlign: function (value) {
        this.tabAlign = value;
        this.doUpdate();
    },
    setTabPosition: function (value) {
        this.tabPosition = value;
        this.doUpdate();
    },

    getTab: function (index) {
        if (typeof index == 'object') return index;
        if (typeof index == 'number') {
            return this.tabs[index];
        } else {
            for (var i = 0, l = this.tabs.length; i < l; i++) {
                var tab = this.tabs[i];
                if (tab.name == index) return tab;
            }
        }
    },
    getHeaderEl: function () {
        return this._headerEl;
    },
    getBodyEl: function () {
        return this._bodyEl;
    },
    getTabEl: function (index) {
        var tab = this.getTab(index);
        if (!tab) return null;
        var id = this._createTabId(tab);
        var cs = this.el.getElementsByTagName('*');
        for (var i = 0, l = cs.length; i < l; i++) {
            var el = cs[i];
            if (el.id == id) return el;
        }
        return null;
    },
    getTabBodyEl: function (index) {
        var tab = this.getTab(index);
        if (!tab) return null;
        var id = this._createTabBodyId(tab);
        var cs = this._bodyEl.childNodes;
        for (var i = 0, l = cs.length; i < l; i++) {
            var el = cs[i];
            if (el.id == id) return el;
        }
        return null;
    },
    getTabIFrameEl: function (index) {
        var tab = this.getTab(index);
        if (!tab) return null;
        return tab._iframeEl;
    },
    _createTabId: function (tab) {
        return this.uid + '_' + tab._id;
    },
    _createTabBodyId: function (tab) {
        return this.uid + '_body_' + tab._id;
    },
    _doScrollButton: function () {
        if (this.tabPosition == 'top') {
            mini.removeClass(this._leftButtonEl, 'mini-disabled');
            mini.removeClass(this._rightButtonEl, 'mini-disabled');
            if (this._headerEl.scrollLeft == 0) {
                mini.addClass(this._leftButtonEl, 'mini-disabled');
            }
            var tabEl = this.getTabEl(this.tabs.length - 1);
            if (tabEl) {
                var tabBox = mini.getBox(tabEl);
                var scrollBox = mini.getBox(this._headerEl);
                if (tabBox.right <= scrollBox.right) {
                    mini.addClass(this._rightButtonEl, 'mini-disabled');
                }
            }
        }
    },

    setActiveIndex: function (value, load) {
        var tab = this.getTab(value);

        var acTab = this.getTab(this.activeIndex);

        var fire = tab != acTab;

        var el = this.getTabBodyEl(this.activeIndex);
        if (el) el.style.display = 'none';
        if (tab) {
            this.activeIndex = this.tabs.indexOf(tab);
        } else {
            this.activeIndex = -1;
        }
        var el = this.getTabBodyEl(this.activeIndex);
        if (el) el.style.display = '';

        var el = this.getTabEl(acTab);
        if (el) mini.removeClass(el, this.tabActiveCls);

        var el = this.getTabEl(tab);
        if (el) mini.addClass(el, this.tabActiveCls);

        if (el && fire) {
            if (this.tabPosition == 'bottom') {
                var tb = mini.findParent(el, 'mini-tabs-header');
                if (tb) {
                    jQuery(this._headerEl).prepend(tb);
                }
            } else if (this.tabPosition == 'left') {
                var td = mini.findParent(el, 'mini-tabs-header').parentNode;
                if (td) {
                    td.parentNode.appendChild(td);
                }
            } else if (this.tabPosition == 'right') {
                var td = mini.findParent(el, 'mini-tabs-header').parentNode;
                if (td) {
                    jQuery(td.parentNode).prepend(td);
                }
            } else {
                var tb = mini.findParent(el, 'mini-tabs-header');
                if (tb) {
                    this._headerEl.appendChild(tb);
                }
            }
            var scrollLeft = this._headerEl.scrollLeft;
            this.doLayout();

            var rows = this.getTabRows();
            if (rows.length > 1) {
            } else {
                if (this.tabPosition == 'top') {
                    this._headerEl.scrollLeft = scrollLeft;
                    var tabEl = this.getTabEl(this.activeIndex);
                    if (tabEl) {
                        var sf = this;
                        var tabBox = mini.getBox(tabEl);
                        var scrollBox = mini.getBox(sf._headerEl);

                        if (tabBox.x < scrollBox.x) {
                            sf._headerEl.scrollLeft -= scrollBox.x - tabBox.x;
                        } else if (tabBox.right > scrollBox.right) {
                            sf._headerEl.scrollLeft += tabBox.right - scrollBox.right;
                        }
                    }
                }
                this._doScrollButton();
            }

            for (var i = 0, l = this.tabs.length; i < l; i++) {
                var tabEl = this.getTabEl(this.tabs[i]);
                if (tabEl) {
                    mini.removeClass(tabEl, this.tabHoverCls);
                }
            }
        }
        var me = this;
        if (fire) {
            var e = {
                tab: tab,
                index: this.tabs.indexOf(tab),
                name: tab ? tab.name : ''
            };

            setTimeout(function () {
                me.fire('ActiveChanged', e);

                me.fire('tabchange', e);
            }, 1);
        }

        this._cancelLoadTabs(tab);
        if (load !== false) {
            if (tab && tab.url && !tab.loadedUrl) {
                var me = this;

                me.loadTab(tab.url, tab);
            }
        }

        try {
            mini.layoutIFrames(me.el);
        } catch (e) {}
    },
    getActiveIndex: function () {
        return this.activeIndex;
    },
    activeTab: function (tab) {
        this.setActiveIndex(tab);
    },
    getActiveTab: function () {
        return this.getTab(this.activeIndex);
    },
    getActiveIndex: function () {
        return this.activeIndex;
    },
    _tryActiveTab: function (tab) {
        tab = this.getTab(tab);
        if (!tab) return;
        var index = this.tabs.indexOf(tab);
        if (this.activeIndex == index) return;
        var e = {
            tab: tab,
            index: index,
            name: tab.name,
            cancel: false
        };
        this.fire('BeforeActiveChanged', e);
        if (e.cancel == false) {
            this.activeTab(tab);
        }
    },
    setShowBody: function (value) {
        if (this.showBody != value) {
            this.showBody = value;
            this.doLayout();
        }
    },
    getShowBody: function () {
        return this.showBody;
    },
    setBodyStyle: function (value) {
        this.bodyStyle = value;
        mini.setStyle(this._bodyEl, value);
        this.doLayout();
    },
    getBodyStyle: function () {
        return this.bodyStyle;
    },
    setMaskOnLoad: function (value) {
        this.maskOnLoad = value;
    },
    getMaskOnLoad: function () {
        return this.maskOnLoad;
    },
    setPlain: function (value) {
        this.plain = value;
        this.doLayout();
    },
    getPlain: function () {
        return this.plain;
    },

    getTabByEvent: function (e) {
        return this._getTabByEvent(e);
    },
    _getTabByEvent: function (e) {
        var el = mini.findParent(e.target, 'mini-tab');
        if (!el) return null;
        var ids = el.id.split('_');
        if (ids[0] != this.uid) return null;
        var index = parseInt(jQuery(el).attr('index'));
        return this.getTab(index);
    },
    __OnClick: function (e) {
        var tab = this._getTabByEvent(e);
        if (!tab) return;
        if (tab.enabled) {
            var me = this;
            setTimeout(function () {
                if (mini.findParent(e.target, 'mini-tab-close')) {
                    me._OnCloseButtonClick(tab, e);
                } else {
                    var loadedUrl = tab.loadedUrl;
                    me._tryActiveTab(tab);
                    if (tab.refreshOnClick && tab.url == loadedUrl) {
                        me.reloadTab(tab);
                    }
                }
            }, 10);
        }
    },
    hoverTab: null,
    __OnMouseOver: function (e) {
        var tab = this._getTabByEvent(e);
        if (tab && tab.enabled) {
            var tabEl = this.getTabEl(tab);
            mini.addClass(tabEl, this.tabHoverCls);
            this.hoverTab = tab;
        }
    },
    __OnMouseOut: function (e) {
        if (this.hoverTab) {
            var tabEl = this.getTabEl(this.hoverTab);
            mini.removeClass(tabEl, this.tabHoverCls);
        }
        this.hoverTab = null;
    },
    __OnMouseDown: function (e) {
        clearInterval(this._scrollTimer);
        if (this.tabPosition == 'top') {
            var sf = this;
            var count = 0,
                num = 10;
            if (e.target == this._leftButtonEl) {
                this._scrollTimer = setInterval(function () {
                    sf._headerEl.scrollLeft -= num;
                    count++;
                    if (count > 5) num = 18;
                    if (count > 10) num = 25;
                    sf._doScrollButton();
                }, 25);
            } else if (e.target == this._rightButtonEl) {
                this._scrollTimer = setInterval(function () {
                    sf._headerEl.scrollLeft += num;
                    count++;
                    if (count > 5) num = 18;
                    if (count > 10) num = 25;
                    sf._doScrollButton();
                }, 25);
            }
            mini.on(document, 'mouseup', this.__OnDocMouseUp, this);
        }
    },
    __OnDocMouseUp: function (e) {
        clearInterval(this._scrollTimer);
        this._scrollTimer = null;
        mini.un(document, 'mouseup', this.__OnDocMouseUp, this);
    },

    _doUpdateTop: function () {
        var isTop = this.tabPosition == 'top';

        var s = '';
        if (isTop) {
            s += '<div class="mini-tabs-scrollCt">';
            s +=
                '<a class="mini-tabs-leftButton" href="javascript:void(0)" hideFocus onclick="return false"></a><a class="mini-tabs-rightButton" href="javascript:void(0)" hideFocus onclick="return false"></a>';
        }
        s += '<div class="mini-tabs-headers">';
        var rows = this.getTabRows();
        for (var j = 0, k = rows.length; j < k; j++) {
            var tabs = rows[j];
            var cls = '';
            s +=
                '<table class="mini-tabs-header" cellspacing="0" cellpadding="0"><tr><td class="mini-tabs-space mini-tabs-firstSpace"><div></div></td>';
            for (var i = 0, l = tabs.length; i < l; i++) {
                var tab = tabs[i];
                var id = this._createTabId(tab);
                if (!tab.visible) continue;
                var index = this.tabs.indexOf(tab);
                var cls = tab.headerCls || '';
                if (tab.enabled == false) {
                    cls += ' mini-disabled';
                }
                s +=
                    '<td id="' +
                    id +
                    '" index="' +
                    index +
                    '"  class="mini-tab ' +
                    cls +
                    '" style="' +
                    tab.headerStyle +
                    '">';
                if (tab.iconCls || tab.iconStyle) {
                    s += '<span class="mini-tab-icon ' + tab.iconCls + '" style="' + tab.iconStyle + '"></span>';
                }
                s += '<span class="mini-tab-text">' + tab.title + '</span>';
                if (tab.showCloseButton) {
                    var ms = '';
                    if (tab.enabled) {
                        ms =
                            'onmouseover="mini.addClass(this, \'mini-tab-close-hover\')" onmouseout="mini.removeClass(this, \'mini-tab-close-hover\')"';
                    }
                    s += '<span class="mini-tab-close" ' + ms + '></span>';
                }
                s += '</td>';
                if (i != l - 1) {
                    s += '<td class="mini-tabs-space2"><div></div></td>';
                }
            }
            s += '<td class="mini-tabs-space mini-tabs-lastSpace" ><div></div></td></tr></table>';
        }
        if (isTop) s += '</div>';
        s += '</div>';

        this._doClearElement();

        mini.prepend(this._td2El, s);

        var td = this._td2El;
        this._headerEl = td.firstChild.lastChild;
        if (isTop) {
            this._leftButtonEl = this._headerEl.parentNode.firstChild;
            this._rightButtonEl = this._headerEl.parentNode.childNodes[1];
        }

        switch (this.tabAlign) {
            case 'center':
                var hds = this._headerEl.childNodes;
                for (var i = 0, l = hds.length; i < l; i++) {
                    var tb = hds[i];
                    var tds = tb.getElementsByTagName('td');
                    tds[0].style.width = '50%';
                    tds[tds.length - 1].style.width = '50%';
                }
                break;
            case 'right':
                var hds = this._headerEl.childNodes;
                for (var i = 0, l = hds.length; i < l; i++) {
                    var tb = hds[i];
                    var tds = tb.getElementsByTagName('td');
                    tds[0].style.width = '100%';
                }
                break;
            case 'fit':
                break;
            default:
                var hds = this._headerEl.childNodes;
                for (var i = 0, l = hds.length; i < l; i++) {
                    var tb = hds[i];
                    var tds = tb.getElementsByTagName('td');
                    tds[tds.length - 1].style.width = '100%';
                }
                break;
        }
    },
    _doUpdateBottom: function () {
        this._doUpdateTop();
        var td = this._td2El;

        mini.append(td, td.firstChild);
        this._headerEl = td.lastChild;
    },
    _doUpdateLeft: function () {
        var s = '<table cellspacing="0" cellpadding="0"><tr>';
        var rows = this.getTabRows();
        for (var j = 0, k = rows.length; j < k; j++) {
            var tabs = rows[j];

            var cls = '';
            if (k > 1 && j != k - 1) {
                cls = 'mini-tabs-header2';
            }
            s += '<td class="' + cls + '"><table class="mini-tabs-header" cellspacing="0" cellpadding="0">';
            s += '<tr ><td class="mini-tabs-space mini-tabs-firstSpace" ><div></div></td></tr>';

            for (var i = 0, l = tabs.length; i < l; i++) {
                var tab = tabs[i];
                var id = this._createTabId(tab);
                if (!tab.visible) continue;

                var index = this.tabs.indexOf(tab);

                var cls = tab.headerCls || '';
                if (tab.enabled == false) {
                    cls += ' mini-disabled';
                }
                s +=
                    '<tr><td id="' +
                    id +
                    '" index="' +
                    index +
                    '"  class="mini-tab ' +
                    cls +
                    '" style="' +
                    tab.headerStyle +
                    '">';
                if (tab.iconCls || tab.iconStyle) {
                    s += '<span class="mini-tab-icon ' + tab.iconCls + '" style="' + tab.iconStyle + '"></span>';
                }
                s += '<span class="mini-tab-text">' + tab.title + '</span>';
                if (tab.showCloseButton) {
                    var ms = '';
                    if (tab.enabled) {
                        ms =
                            'onmouseover="mini.addClass(this, \'mini-tab-close-hover\')" onmouseout="mini.removeClass(this, \'mini-tab-close-hover\')"';
                    }
                    s += '<span class="mini-tab-close" ' + ms + '></span>';
                }
                s += '</td></tr>';

                if (i != l - 1) {
                    s += '<tr><td class="mini-tabs-space2"><div></div></td></tr>';
                }
            }

            s += '<tr ><td class="mini-tabs-space mini-tabs-lastSpace" ><div></div></td></tr>';
            s += '</table></td>';
        }

        s += '</tr ></table>';

        this._doClearElement();
        mini.addClass(this._td1El, 'mini-tabs-header');
        mini.append(this._td1El, s);
        this._headerEl = this._td1El;
    },
    _doUpdateRight: function () {
        this._doUpdateLeft();

        mini.removeClass(this._td1El, 'mini-tabs-header');
        mini.removeClass(this._td3El, 'mini-tabs-header');
        mini.append(this._td3El, this._td1El.firstChild);
        this._headerEl = this._td3El;
    },

    _OnCloseButtonClick: function (tab, htmlEvent) {
        var e = {
            tab: tab,
            index: this.tabs.indexOf(tab),
            name: tab.name.toLowerCase(),
            htmlEvent: htmlEvent,
            cancel: false
        };

        this.fire('beforecloseclick', e);

        if (e.cancel == true) return;

        try {
            if (tab._iframeEl && tab._iframeEl.contentWindow) {
                var ret = true;
                if (tab._iframeEl.contentWindow.CloseWindow) {
                    ret = tab._iframeEl.contentWindow.CloseWindow('close');
                } else if (tab._iframeEl.contentWindow.CloseOwnerWindow) {
                    ret = tab._iframeEl.contentWindow.CloseOwnerWindow('close');
                }
                if (ret === false) {
                    e.cancel = true;
                }
            }
        } catch (ex) {}

        if (e.cancel == true) return;

        tab.removeAction = 'close';
        this.removeTab(tab);
        this.fire('closeclick', e);
    },
    onBeforeCloseClick: function (fn, scope) {
        this.on('beforecloseclick', fn, scope);
    },
    onCloseClick: function (fn, scope) {
        this.on('closeclick', fn, scope);
    },
    onActiveChanged: function (fn, scope) {
        this.on('activechanged', fn, scope);
    },

    getAttrs: function (el) {
        var attrs = mini.Tabs.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'tabAlign',
            'tabPosition',
            'bodyStyle',
            'onactivechanged',
            'onbeforeactivechanged',
            'url',
            'ontabload',
            'ontabdestroy',
            'onbeforecloseclick',
            'oncloseclick',
            'titleField',
            'urlField',
            'nameField',
            'loadingMsg'
        ]);
        mini._ParseBool(el, attrs, ['allowAnim', 'showBody', 'maskOnLoad', 'plain']);
        mini._ParseInt(el, attrs, ['activeIndex']);

        var tabs = [];
        var nodes = mini.getChildNodes(el);
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];

            var o = {};
            tabs.push(o);

            o.style = node.style.cssText;
            mini._ParseString(node, o, [
                'name',
                'title',
                'url',
                'cls',
                'iconCls',
                'iconStyle',
                'headerCls',
                'headerStyle',
                'bodyCls',
                'bodyStyle',
                'onload',
                'ondestroy',
                'data-options'
            ]);
            mini._ParseBool(node, o, ['newLine', 'visible', 'enabled', 'showCloseButton', 'refreshOnClick']);

            o.bodyParent = node;

            var options = o['data-options'];
            if (options) {
                options = eval('(' + options + ')');
                if (options) {
                    mini.copyTo(o, options);
                }
            }
        }
        attrs.tabs = tabs;

        return attrs;
    }
});
mini.regClass(mini.Tabs, 'tabs');
mini.Fit = function () {
    mini.Fit.superclass.constructor.call(this);
};
mini.extend(mini.Fit, mini.Container, {
    style: '',
    _clearBorder: false,

    uiCls: 'mini-fit',
    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-fit';
        this._bodyEl = this.el;
    },
    _initEvents: function () {},
    isFixedSize: function () {
        return false;
    },
    doLayout: function () {
        var parentNode = this.el.parentNode;
        var childNodes = mini.getChildNodes(parentNode);
        if (parentNode == document.body) {
            this.el.style.height = '0px';
        }

        var height = mini.getHeight(parentNode, true);

        for (var i = 0, l = childNodes.length; i < l; i++) {
            var node = childNodes[i];
            var tagName = node.tagName ? node.tagName.toLowerCase() : '';
            if (node == this.el || tagName == 'style' || tagName == 'script') continue;
            var pos = mini.getStyle(node, 'position');
            if (pos == 'absolute' || pos == 'fixed') continue;

            var h = mini.getHeight(node);

            var margin = mini.getMargins(node);
            height = height - h - margin.top - margin.bottom;
        }

        var border = mini.getBorders(this.el);
        var padding = mini.getPaddings(this.el);
        var margin = mini.getMargins(this.el);

        height = height - margin.top - margin.bottom;
        if (jQuery.boxModel) {
            height = height - padding.top - padding.bottom - border.top - border.bottom;
        }
        if (height < 0) height = 0;

        this.el.style.height = height + 'px';

        try {
            childNodes = mini.getChildNodes(this.el);
            for (var i = 0, l = childNodes.length; i < l; i++) {
                var node = childNodes[i];
                mini.layout(node);
            }
        } catch (e) {}
    },
    set_bodyParent: function (value) {
        if (!value) return;

        var el = this._bodyEl;

        var p = value;
        while (p.firstChild) {
            try {
                el.appendChild(p.firstChild);
            } catch (e) {}
        }
        this.doLayout();
    },

    getAttrs: function (el) {
        var attrs = mini.Fit.superclass.getAttrs.call(this, el);

        attrs._bodyParent = el;

        return attrs;
    }
});
mini.regClass(mini.Fit, 'fit');
mini.Layout = mini.Control.extend({
    type: 'layout',
    tag: 'mini-layout',

    props: {
        regions: null,
        splitSize: 5,
        collapseWidth: 28,
        collapseHeight: 25,
        regionWidth: 150,
        regionHeight: 80,
        regionMinWidth: 50,
        regionMinHeight: 25,
        regionMaxWidth: 2000,
        regionMaxHeight: 2000
    },

    initComponent: function () {
        this.regions = this.regions || [];
        this.regionMap = {};
        this.callParent('initComponent');
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-layout';
        this.el.innerHTML = '<div class="mini-layout-border"></div>';

        this._borderEl = this.el.firstChild;

        this.doUpdate();
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini.on(this.el, 'click', this.__OnClick, this);
            mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
            mini.on(this.el, 'mouseover', this.__OnMouseOver, this);
            mini.on(this.el, 'mouseout', this.__OnMouseOut, this);

            mini.on(document, 'mousedown', this.__OnDocMouseDown, this);
        }, this);
    },

    getRegionEl: function (region) {
        var region = this.getRegion(region);
        if (!region) return null;
        return region._el;
    },
    getRegionHeaderEl: function (region) {
        var region = this.getRegion(region);
        if (!region) return null;
        return region._header;
    },
    getRegionBodyEl: function (region) {
        var region = this.getRegion(region);
        if (!region) return null;
        return region._body;
    },
    getRegionSplitEl: function (region) {
        var region = this.getRegion(region);
        if (!region) return null;
        return region._split;
    },
    getRegionProxyEl: function (region) {
        var region = this.getRegion(region);
        if (!region) return null;
        return region._proxy;
    },
    getRegionBox: function (region) {
        var el = this.getRegionEl(region);
        if (el) return mini.getBox(el);
        return null;
    },
    getRegion: function (region) {
        if (typeof region == 'string') return this.regionMap[region];
        return region;
    },
    _getButton: function (region, name) {
        var buttons = region.buttons;
        for (var i = 0, l = buttons.length; i < l; i++) {
            var button = buttons[i];
            if (button.name == name) return button;
        }
    },
    _createRegion: function (options) {
        var region = mini.copyTo(
            {
                region: '',
                title: '',
                iconCls: '',
                iconStyle: '',

                showCloseButton: false,
                showCollapseButton: true,
                buttons: [
                    { name: 'close', cls: 'mini-tools-close', html: '', visible: false },
                    { name: 'collapse', cls: 'mini-tools-collapse', html: '', visible: true }
                ],
                showSplitIcon: false,
                showSplit: true,
                showHeader: true,
                splitSize: this.splitSize,
                collapseSize: this.collapseWidth,
                width: this.regionWidth,
                height: this.regionHeight,
                minWidth: this.regionMinWidth,
                minHeight: this.regionMinHeight,
                maxWidth: this.regionMaxWidth,
                maxHeight: this.regionMaxHeight,
                allowResize: true,

                cls: '',
                style: '',
                headerCls: '',
                headerStyle: '',
                bodyCls: '',
                bodyStyle: '',

                visible: true,
                expanded: true
            },
            options
        );
        return region;
    },
    _CreateRegionEl: function (region) {
        var region = this.getRegion(region);
        if (!region) return;

        mini.append(
            this._borderEl,
            '<div id="' +
                region.region +
                '" class="mini-layout-region"><div class="mini-layout-region-header" style="' +
                region.headerStyle +
                '"></div><div class="mini-layout-region-body" style="' +
                region.bodyStyle +
                '"></div></div>'
        );
        region._el = this._borderEl.lastChild;
        region._header = region._el.firstChild;
        region._body = region._el.lastChild;

        if (region.cls) mini.addClass(region._el, region.cls);
        if (region.style) mini.setStyle(region._el, region.style);

        mini.addClass(region._el, 'mini-layout-region-' + region.region);

        if (region.region != 'center') {
            mini.append(
                this._borderEl,
                '<div uid="' +
                    this.uid +
                    '" id="' +
                    region.region +
                    '" class="mini-layout-split"><div class="mini-layout-spliticon"></div></div>'
            );
            region._split = this._borderEl.lastChild;
            mini.addClass(region._split, 'mini-layout-split-' + region.region);
        }

        if (region.region != 'center') {
            mini.append(this._borderEl, '<div id="' + region.region + '" class="mini-layout-proxy"></div>');
            region._proxy = this._borderEl.lastChild;
            mini.addClass(region._proxy, 'mini-layout-proxy-' + region.region);
        }
    },
    setRegionControls: function (region, value) {
        var region = this.getRegion(region);
        if (!region) return;
        var el = this.getRegionBodyEl(region);
        __mini_setControls(value, el, this);
    },
    setRegions: function (regions) {
        if (!mini.isArray(regions)) return;
        for (var i = 0, l = regions.length; i < l; i++) {
            this.addRegion(regions[i]);
        }
    },
    addRegion: function (region, index) {
        var r1 = region;
        region = this._createRegion(region);

        if (!region.region) region.region = 'center';
        region.region = region.region.toLowerCase();
        if (region.region == 'center' && r1 && !r1.showHeader) {
            region.showHeader = false;
        }
        if (region.region == 'north' || region.region == 'south') {
            if (!r1.collapseSize) {
                region.collapseSize = this.collapseHeight;
            }
        }

        this._measureRegion(region);

        if (typeof index != 'number') index = this.regions.length;
        var r = this.regionMap[region.region];
        if (r) {
            return;
        }
        this.regions.insert(index, region);
        this.regionMap[region.region] = region;

        this._CreateRegionEl(region);

        var el = this.getRegionBodyEl(region);

        var cs = region.body;
        delete region.body;
        if (cs) {
            if (!mini.isArray(cs)) cs = [cs];
            for (var i = 0, l = cs.length; i < l; i++) {
                mini.append(el, cs[i]);
            }
        }

        if (region.bodyParent) {
            var p = region.bodyParent;
            while (p.firstChild) {
                el.appendChild(p.firstChild);
            }
        }
        delete region.bodyParent;

        if (region.controls) {
            this.setRegionControls(region, region.controls);
            delete region.controls;
        }

        this.doUpdate();
    },
    removeRegion: function (region) {
        var region = this.getRegion(region);
        if (!region) return;
        this.regions.remove(region);
        delete this.regionMap[region.region];

        jQuery(region._el).remove();
        jQuery(region._split).remove();
        jQuery(region._proxy).remove();

        this.doUpdate();
    },
    moveRegion: function (region, index) {
        var region = this.getRegion(region);
        if (!region) return;
        var t = this.regions[index];
        if (!t || t == region) return;
        this.regions.remove(region);
        var index = this.region.indexOf(t);
        this.regions.insert(index, region);
        this.doUpdate();
    },
    _measureRegion: function (region) {
        var button = this._getButton(region, 'close');
        button.visible = region.showCloseButton;
        var button = this._getButton(region, 'collapse');
        button.visible = region.showCollapseButton;

        if (region.width < region.minWidth) region.width = mini.minWidth;
        if (region.width > region.maxWidth) region.width = mini.maxWidth;
        if (region.height < region.minHeight) region.height = mini.minHeight;
        if (region.height > region.maxHeight) region.height = mini.maxHeight;
    },
    updateRegion: function (region, options) {
        region = this.getRegion(region);
        if (!region) return;
        if (options) delete options.region;
        mini.copyTo(region, options);

        this._measureRegion(region);

        this.doUpdate();
    },
    expandRegion: function (region) {
        region = this.getRegion(region);
        if (!region) return;
        region.expanded = true;
        this.doUpdate();
    },
    collapseRegion: function (region) {
        region = this.getRegion(region);
        if (!region) return;
        region.expanded = false;
        this.doUpdate();
    },
    toggleRegion: function (region) {
        region = this.getRegion(region);
        if (!region) return;
        if (region.expanded) {
            this.collapseRegion(region);
        } else {
            this.expandRegion(region);
        }
    },
    showRegion: function (region) {
        region = this.getRegion(region);
        if (!region) return;
        region.visible = true;
        this.doUpdate();
    },
    hideRegion: function (region) {
        region = this.getRegion(region);
        if (!region) return;
        region.visible = false;
        this.doUpdate();
    },
    isExpandRegion: function (region) {
        region = this.getRegion(region);
        if (!region) return null;
        return this.region.expanded;
    },
    isVisibleRegion: function (region) {
        region = this.getRegion(region);
        if (!region) return null;
        return this.region.visible;
    },
    _tryToggleRegion: function (region) {
        region = this.getRegion(region);

        var e = {
            region: region,
            cancel: false
        };
        if (region.expanded) {
            this.fire('BeforeCollapse', e);
            if (e.cancel == false) {
                this.collapseRegion(region);
            }
        } else {
            this.fire('BeforeExpand', e);
            if (e.cancel == false) {
                this.expandRegion(region);
            }
        }
    },

    _getProxyElByEvent: function (e) {
        var el = mini.findParent(e.target, 'mini-layout-proxy');
        return el;
    },
    _getRegionElByEvent: function (e) {
        var el = mini.findParent(e.target, 'mini-layout-region');
        return el;
    },
    __OnClick: function (e) {
        if (this._inAniming) return;
        var proxyEl = this._getProxyElByEvent(e);
        if (proxyEl) {
            var region = proxyEl.id;
            var collapseEl = mini.findParent(e.target, 'mini-tools-collapse');
            if (collapseEl) {
                this._tryToggleRegion(region);
            } else {
                this._VirtualToggle(region);
            }
        }

        var regionEl = this._getRegionElByEvent(e);
        if (regionEl && mini.findParent(e.target, 'mini-layout-region-header')) {
            var region = regionEl.id;
            var collapseEl = mini.findParent(e.target, 'mini-tools-collapse');
            if (collapseEl) {
                this._tryToggleRegion(region);
            }
            var closeEl = mini.findParent(e.target, 'mini-tools-close');
            if (closeEl) {
                this.updateRegion(region, { visible: false });
            }
        }
        if (mini.hasClass(e.target, 'mini-layout-spliticon')) {
            var region = e.target.parentNode.id;
            this._tryToggleRegion(region);
        }
    },
    _OnButtonClick: function (region, button, htmlEvent) {
        this.fire('buttonclick', {
            htmlEvent: htmlEvent,
            region: region,
            button: button,
            index: this.buttons.indexOf(button),
            name: button.name
        });
    },
    _OnButtonMouseDown: function (region, button, htmlEvent) {
        this.fire('buttonmousedown', {
            htmlEvent: htmlEvent,
            region: region,
            button: button,
            index: this.buttons.indexOf(button),
            name: button.name
        });
    },
    hoverProxyEl: null,
    __OnMouseOver: function (e) {
        var proxyEl = this._getProxyElByEvent(e);
        if (proxyEl) {
            mini.addClass(proxyEl, 'mini-layout-proxy-hover');
            this.hoverProxyEl = proxyEl;
        }
    },
    __OnMouseOut: function (e) {
        if (this.hoverProxyEl) {
            mini.removeClass(this.hoverProxyEl, 'mini-layout-proxy-hover');
        }
        this.hoverProxyEl = null;
    },

    onButtonClick: function (fn, scope) {
        this.on('buttonclick', fn, scope);
    },
    onButtonMouseDown: function (fn, scope) {
        this.on('buttonmousedown', fn, scope);
    }
});

mini.copyTo(mini.Layout.prototype, {
    _createHeader: function (region, proxy) {
        var s = '<div class="mini-tools">';
        if (proxy) {
            s += '<span class="mini-tools-collapse"></span>';
        } else {
            for (var i = region.buttons.length - 1; i >= 0; i--) {
                var button = region.buttons[i];
                s += '<span class="' + button.cls + '" style="';
                s += button.style + ';' + (button.visible ? '' : 'display:none;') + '">' + button.html + '</span>';
            }
        }
        s += '</div>';

        s +=
            '<div class="mini-layout-region-icon ' +
            region.iconCls +
            '" style="' +
            region.iconStyle +
            ';' +
            (region.iconStyle || region.iconCls ? '' : 'display:none;') +
            '"></div>';
        s += '<div class="mini-layout-region-title">' + region.title + '</div>';
        return s;
    },
    doUpdate: function () {
        for (var i = 0, l = this.regions.length; i < l; i++) {
            var region = this.regions[i];
            var type = region.region;
            var el = region._el,
                split = region._split,
                proxy = region._proxy;

            if (region.cls) mini.addClass(el, region.cls);

            region._header.style.display = region.showHeader ? '' : 'none';
            region._header.innerHTML = this._createHeader(region);
            if (region._proxy) region._proxy.innerHTML = this._createHeader(region, true);

            if (split) {
                mini.removeClass(split, 'mini-layout-split-nodrag');
                if (region.expanded == false || !region.allowResize) {
                    mini.addClass(split, 'mini-layout-split-nodrag');
                }
            }
        }

        this.doLayout();
    },
    doLayout: function () {
        if (this._inAniming) {
            return;
        }

        var h = mini.getHeight(this.el, true);
        var w = mini.getWidth(this.el, true);
        var box = { x: 0, y: 0, width: w, height: h };

        var regions = this.regions.clone();
        var center = this.getRegion('center');
        regions.remove(center);
        if (center) {
            regions.push(center);
        }

        for (var i = 0, l = regions.length; i < l; i++) {
            var region = regions[i];
            region._Expanded = false;
            mini.removeClass(region._el, 'mini-layout-popup');

            var type = region.region;
            var el = region._el,
                split = region._split,
                proxy = region._proxy;
            if (region.visible == false) {
                el.style.display = 'none';
                if (type != 'center') split.style.display = proxy.style.display = 'none';
                continue;
            }
            el.style.display = '';
            if (type != 'center') split.style.display = proxy.style.display = '';

            var x = box.x,
                y = box.y,
                w = box.width,
                h = box.height;
            var cw = region.width,
                ch = region.height;

            if (!region.expanded) {
                if (type == 'west' || type == 'east') {
                    cw = region.collapseSize;
                    mini.setWidth(el, region.width);
                } else if (type == 'north' || type == 'south') {
                    ch = region.collapseSize;
                    mini.setHeight(el, region.height);
                }
            }

            switch (type) {
                case 'north':
                    h = ch;
                    box.y += ch;
                    box.height -= ch;
                    break;
                case 'south':
                    h = ch;
                    y = box.y + box.height - ch;
                    box.height -= ch;
                    break;
                case 'west':
                    w = cw;
                    box.x += cw;
                    box.width -= cw;
                    break;
                case 'east':
                    w = cw;
                    x = box.x + box.width - cw;
                    box.width -= cw;
                    break;
                case 'center':
                    break;
                default:
                    continue;
            }
            if (w < 0) w = 0;
            if (h < 0) h = 0;

            if (type == 'west' || type == 'east') {
                mini.setHeight(el, h);
            }
            if (type == 'north' || type == 'south') {
                mini.setWidth(el, w);
            }

            var style = 'left:' + x + 'px;top:' + y + 'px;';
            var d = el;
            if (!region.expanded) {
                d = proxy;
                el.style.top = '-100px';
                el.style.left = '-1500px';
            } else {
                if (proxy) {
                    proxy.style.left = '-1500px';
                    proxy.style.top = '-100px';
                }
            }
            d.style.left = x + 'px';
            d.style.top = y + 'px';
            mini.setWidth(d, w);
            mini.setHeight(d, h);

            var regionH = jQuery(region._el).height();
            var headerH = region.showHeader ? jQuery(region._header).outerHeight() : 0;
            mini.setHeight(region._body, regionH - headerH);

            if (type == 'center') continue;

            cw = ch = region.splitSize;
            var x = box.x,
                y = box.y,
                w = box.width,
                h = box.height;
            switch (type) {
                case 'north':
                    h = ch;
                    box.y += ch;
                    box.height -= ch;
                    break;
                case 'south':
                    h = ch;
                    y = box.y + box.height - ch;
                    box.height -= ch;
                    break;
                case 'west':
                    w = cw;
                    box.x += cw;
                    box.width -= cw;
                    break;
                case 'east':
                    w = cw;
                    x = box.x + box.width - cw;
                    box.width -= cw;
                    break;
                case 'center':
                    break;
            }
            if (w < 0) w = 0;
            if (h < 0) h = 0;

            split.style.left = x + 'px';
            split.style.top = y + 'px';
            mini.setWidth(split, w);
            mini.setHeight(split, h);

            if (region.showSplit && region.expanded && region.allowResize == true) {
                mini.removeClass(split, 'mini-layout-split-nodrag');
            } else {
                mini.addClass(split, 'mini-layout-split-nodrag');
            }

            split.firstChild.style.display = region.showSplitIcon ? 'block' : 'none';
            if (region.expanded) {
                mini.removeClass(split.firstChild, 'mini-layout-spliticon-collapse');
            } else {
                mini.addClass(split.firstChild, 'mini-layout-spliticon-collapse');
            }
        }
        mini.layout(this._borderEl);

        this.fire('layout');
    },

    __OnMouseDown: function (e) {
        if (this._inAniming) return;
        if (mini.findParent(e.target, 'mini-layout-split')) {
            var uid = jQuery(e.target).attr('uid');
            if (uid != this.uid) return;
            var region = this.getRegion(e.target.id);
            if (region.expanded == false || !region.allowResize || !region.showSplit) return;
            this.dragRegion = region;
            var drag = this._getDrag();
            drag.start(e);
        }
    },
    _getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                capture: true,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    },
    _OnDragStart: function (drag) {
        this._maskProxy = mini.append(document.body, '<div class="mini-resizer-mask"></div>');

        this._dragProxy = mini.append(document.body, '<div class="mini-proxy"></div>');
        this._dragProxy.style.cursor = 'n-resize';
        if (this.dragRegion.region == 'west' || this.dragRegion.region == 'east') {
            this._dragProxy.style.cursor = 'w-resize';
        }

        this.splitBox = mini.getBox(this.dragRegion._split);
        mini.setBox(this._dragProxy, this.splitBox);

        this.elBox = mini.getBox(this.el, true);
    },
    _OnDragMove: function (drag) {
        var xOffset = drag.now[0] - drag.init[0];
        var x = this.splitBox.x + xOffset;
        var yOffset = drag.now[1] - drag.init[1];
        var y = this.splitBox.y + yOffset;
        var right = x + this.splitBox.width;
        var bottom = y + this.splitBox.height;

        var west = this.getRegion('west'),
            east = this.getRegion('east'),
            north = this.getRegion('north'),
            south = this.getRegion('south'),
            center = this.getRegion('center');
        var westWidth = west && west.visible ? west.width : 0;
        var eastWidth = east && east.visible ? east.width : 0;
        var northHeight = north && north.visible ? north.height : 0;
        var southHeight = south && south.visible ? south.height : 0;
        var westSplitWidth = west && west.showSplit ? mini.getWidth(west._split) : 0;
        var eastSplitWidth = east && east.showSplit ? mini.getWidth(east._split) : 0;
        var northSplitHeight = north && north.showSplit ? mini.getHeight(north._split) : 0;
        var southSplitHeight = south && south.showSplit ? mini.getHeight(south._split) : 0;

        var region = this.dragRegion,
            type = region.region;
        if (type == 'west') {
            var maxWidth = this.elBox.width - eastWidth - eastSplitWidth - westSplitWidth - center.minWidth;
            if (x - this.elBox.x > maxWidth) x = maxWidth + this.elBox.x;

            if (x - this.elBox.x < region.minWidth) x = region.minWidth + this.elBox.x;
            if (x - this.elBox.x > region.maxWidth) x = region.maxWidth + this.elBox.x;

            mini.setX(this._dragProxy, x);
        } else if (type == 'east') {
            var maxWidth = this.elBox.width - westWidth - westSplitWidth - eastSplitWidth - center.minWidth;
            if (this.elBox.right - (x + this.splitBox.width) > maxWidth) {
                x = this.elBox.right - maxWidth - this.splitBox.width;
            }

            if (this.elBox.right - (x + this.splitBox.width) < region.minWidth) {
                x = this.elBox.right - region.minWidth - this.splitBox.width;
            }
            if (this.elBox.right - (x + this.splitBox.width) > region.maxWidth) {
                x = this.elBox.right - region.maxWidth - this.splitBox.width;
            }

            mini.setX(this._dragProxy, x);
        } else if (type == 'north') {
            var maxHeight = this.elBox.height - southHeight - southSplitHeight - northSplitHeight - center.minHeight;
            if (y - this.elBox.y > maxHeight) y = maxHeight + this.elBox.y;

            if (y - this.elBox.y < region.minHeight) y = region.minHeight + this.elBox.y;
            if (y - this.elBox.y > region.maxHeight) y = region.maxHeight + this.elBox.y;

            mini.setY(this._dragProxy, y);
        } else if (type == 'south') {
            var maxHeight = this.elBox.height - northHeight - northSplitHeight - southSplitHeight - center.minHeight;
            if (this.elBox.bottom - (y + this.splitBox.height) > maxHeight) {
                y = this.elBox.bottom - maxHeight - this.splitBox.height;
            }

            if (this.elBox.bottom - (y + this.splitBox.height) < region.minHeight) {
                y = this.elBox.bottom - region.minHeight - this.splitBox.height;
            }
            if (this.elBox.bottom - (y + this.splitBox.height) > region.maxHeight) {
                y = this.elBox.bottom - region.maxHeight - this.splitBox.height;
            }

            mini.setY(this._dragProxy, y);
        }
    },
    _OnDragStop: function (drag) {
        var box = mini.getBox(this._dragProxy);

        var region = this.dragRegion,
            type = region.region;
        if (type == 'west') {
            var width = box.x - this.elBox.x;
            this.updateRegion(region, { width: width });
        } else if (type == 'east') {
            var width = this.elBox.right - box.right;
            this.updateRegion(region, { width: width });
        } else if (type == 'north') {
            var height = box.y - this.elBox.y;
            this.updateRegion(region, { height: height });
        } else if (type == 'south') {
            var height = this.elBox.bottom - box.bottom;
            this.updateRegion(region, { height: height });
        }

        jQuery(this._dragProxy).remove();
        this._dragProxy = null;
        this.elBox = this.handlerBox = null;

        jQuery(this._maskProxy).remove();
        this._maskProxy = null;
    },

    _VirtualToggle: function (region) {
        region = this.getRegion(region);

        if (region._Expanded === true) {
            this._VirtualCollapse(region);
        } else {
            this._VirtualExpand(region);
        }
    },
    _VirtualExpand: function (region) {
        if (this._inAniming) return;

        this.doLayout();

        var type = region.region,
            el = region._el;
        region._Expanded = true;
        mini.addClass(el, 'mini-layout-popup');
        var proxyBox = mini.getBox(region._proxy);
        var box = mini.getBox(region._el);

        var config = {};
        if (type == 'east') {
            var x = proxyBox.x;
            var y = proxyBox.y;
            var h = proxyBox.height;

            mini.setHeight(el, h);
            mini.setX(el, x);
            el.style.top = region._proxy.style.top;

            var left = parseInt(el.style.left);
            config = { left: left - box.width };
        } else if (type == 'west') {
            var x = proxyBox.right - box.width;
            var y = proxyBox.y;
            var h = proxyBox.height;

            mini.setHeight(el, h);
            mini.setX(el, x);
            el.style.top = region._proxy.style.top;

            var left = parseInt(el.style.left);
            config = { left: left + box.width };
        } else if (type == 'north') {
            var x = proxyBox.x;
            var y = proxyBox.bottom - box.height;
            var w = proxyBox.width;

            mini.setWidth(el, w);
            mini.setXY(el, x, y);

            var top = parseInt(el.style.top);
            config = { top: top + box.height };
        } else if (type == 'south') {
            var x = proxyBox.x;
            var y = proxyBox.y;
            var w = proxyBox.width;

            mini.setWidth(el, w);
            mini.setXY(el, x, y);

            var top = parseInt(el.style.top);
            config = { top: top - box.height };
        }

        mini.addClass(region._proxy, 'mini-layout-maxZIndex');
        this._inAniming = true;
        var sf = this;
        var jq = jQuery(el);
        jq.animate(config, 250, function () {
            mini.removeClass(region._proxy, 'mini-layout-maxZIndex');
            sf._inAniming = false;
        });
    },
    _VirtualCollapse: function (region) {
        if (this._inAniming) return;
        region._Expanded = false;
        var type = region.region,
            el = region._el;

        var box = mini.getBox(el);

        var config = {};
        if (type == 'east') {
            var left = parseInt(el.style.left);
            config = { left: left + box.width };
        } else if (type == 'west') {
            var left = parseInt(el.style.left);
            config = { left: left - box.width };
        } else if (type == 'north') {
            var top = parseInt(el.style.top);
            config = { top: top - box.height };
        } else if (type == 'south') {
            var top = parseInt(el.style.top);
            config = { top: top + box.height };
        }

        mini.addClass(region._proxy, 'mini-layout-maxZIndex');
        this._inAniming = true;
        var sf = this;
        var jq = jQuery(el);
        jq.animate(config, 250, function () {
            mini.removeClass(region._proxy, 'mini-layout-maxZIndex');
            sf._inAniming = false;
            sf.doLayout();
        });
    },
    __OnDocMouseDown: function (e) {
        if (this._inAniming) return;
        for (var i = 0, l = this.regions.length; i < l; i++) {
            var region = this.regions[i];
            if (!region._Expanded) continue;
            if (mini.isAncestor(region._el, e.target) || mini.isAncestor(region._proxy, e.target)) {
            } else {
                this._VirtualCollapse(region);
            }
        }
    },

    getAttrs: function (el) {
        var attrs = mini.Layout.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        var splitSize = parseInt(jq.attr('splitSize'));
        if (!isNaN(splitSize)) {
            attrs.splitSize = splitSize;
        }

        var regions = [];
        var nodes = mini.getChildNodes(el);
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];

            var o = {};
            regions.push(o);

            o.cls = node.className;

            o.style = node.style.cssText;
            mini._ParseString(node, o, [
                'region',
                'title',
                'iconCls',
                'iconStyle',
                'cls',
                'headerCls',
                'headerStyle',
                'bodyCls',
                'bodyStyle'
            ]);
            mini._ParseBool(node, o, [
                'allowResize',
                'visible',
                'showCloseButton',
                'showCollapseButton',
                'showSplit',
                'showHeader',
                'expanded',
                'showSplitIcon'
            ]);
            mini._ParseInt(node, o, [
                'splitSize',
                'collapseSize',
                'width',
                'height',
                'minWidth',
                'minHeight',
                'maxWidth',
                'maxHeight'
            ]);

            o.bodyParent = node;
        }
        attrs.regions = regions;

        return attrs;
    }
});
mini.regClass(mini.Layout, 'layout');
mini.Box = mini.Container.extend({
    type: 'box',
    tag: 'mini-box',

    props: {
        style: '',
        borderStyle: '',
        bodyStyle: ''
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-box';
        this.el.innerHTML = '<div class="mini-box-border"></div>';
        this._bodyEl = this._borderEl = this.el.firstChild;

        this._contentEl = this._bodyEl;
    },
    _initEvents: function () {},
    doLayout: function () {
        var autoHeight = this.isAutoHeight();

        var autoWidth = this.isAutoWidth();

        var padding = mini.getPaddings(this._bodyEl);
        var margin = mini.getMargins(this._bodyEl);

        if (!autoHeight) {
            var h = this.getHeight(true);
            if (jQuery.boxModel) {
                h = h - padding.top - padding.bottom;
            }
            h = h - margin.top - margin.bottom;
            if (h < 0) h = 0;
            this._bodyEl.style.height = h + 'px';
        } else {
            this._bodyEl.style.height = '';
        }

        var w = this.getWidth(true);
        var elWidth = w;
        w = w - margin.left - margin.right;
        if (jQuery.boxModel) {
            w = w - padding.left - padding.right;
        }
        if (w < 0) w = 0;
        this._bodyEl.style.width = w + 'px';

        mini.layout(this._borderEl);

        this.fire('layout');
    },

    setBodyStyle: function (value) {
        mini.setStyle(this._bodyEl, value);
        this.doLayout();
    }
});
mini.regClass(mini.Box, 'box');

mini.ButtonGroup = mini.Container.extend({
    type: 'buttongroup',
    tag: 'mini-buttongroup',

    initComponent: function () {
        this.callParent('initComponent');
        mini.addClass(this.el, 'mini-buttongroup');
    }
});

mini.OutlookBar = mini.Control.extend({
    type: 'outlookbar',
    tag: 'mini-outlookbar',

    props: {
        width: 180,
        expandOnLoad: false,
        activeIndex: -1,
        autoCollapse: false,
        groupCls: '',
        groupStyle: '',
        groupHeaderCls: '',
        groupHeaderStyle: '',
        groupBodyCls: '',
        groupBodyStyle: '',
        groupHoverCls: '',
        groupActiveCls: '',
        allowAnim: true,
        imgPath: ''
    },

    initComponent: function () {
        this._initGroups();
        this.callParent('initComponent');
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var _allowLayout = this._allowLayout;
        this._allowLayout = false;

        var activeIndex = kv.activeIndex;
        delete kv.activeIndex;

        mini.OutlookBar.superclass.set.call(this, kv);

        if (mini.isNumber(activeIndex)) {
            this.setActiveIndex(activeIndex);
        }

        this._allowLayout = _allowLayout;
        this.doLayout();

        return this;
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-outlookbar';
        this.el.innerHTML = '<div class="mini-outlookbar-border"></div>';
        this._borderEl = this.el.firstChild;
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini.on(this.el, 'click', this.__OnClick, this);
        }, this);
    },

    _createGroupId: function (group) {
        return this.uid + '$' + group._id;
    },
    _GroupId: 1,
    _initGroups: function () {
        this.groups = this.groups || [];
    },
    _createGroupEl: function (group) {
        var id = this._createGroupId(group);
        var s =
            '<div id="' +
            id +
            '" class="mini-outlookbar-group ' +
            group.cls +
            '" style="' +
            group.style +
            '">' +
            '<div class="mini-outlookbar-groupHeader ' +
            group.headerCls +
            '" style="' +
            group.headerStyle +
            ';"></div>' +
            '<div class="mini-outlookbar-groupBody ' +
            group.bodyCls +
            '" style="' +
            group.bodyStyle +
            ';"></div>' +
            '</div>';
        var el = mini.append(this._borderEl, s);

        var bodyEl = el.lastChild;
        var cs = group.body;
        delete group.body;
        if (cs) {
            if (!mini.isArray(cs)) cs = [cs];
            for (var i = 0, l = cs.length; i < l; i++) {
                var node = cs[i];
                mini.append(bodyEl, node);
            }
            cs.length = 0;
        }

        if (group.bodyParent) {
            var p = group.bodyParent;
            while (p.firstChild) {
                bodyEl.appendChild(p.firstChild);
            }
        }
        delete group.bodyParent;

        return el;
    },
    createGroup: function (options) {
        var group = mini.copyTo(
            {
                _id: this._GroupId++,
                name: '',
                title: '',

                cls: '',
                style: '',
                iconCls: '',
                iconStyle: '',
                headerCls: '',
                headerStyle: '',
                bodyCls: '',
                bodyStyle: '',

                visible: true,
                enabled: true,
                showCollapseButton: true,
                expanded: this.expandOnLoad
            },
            options
        );

        return group;
    },
    setGroups: function (groups) {
        if (!mini.isArray(groups)) return;
        this.removeAll();
        for (var i = 0, l = groups.length; i < l; i++) {
            this.addGroup(groups[i]);
        }
    },
    getGroups: function () {
        return this.groups;
    },
    addGroup: function (group, index) {
        if (typeof group == 'string') {
            group = { title: group };
        }
        group = this.createGroup(group);

        if (typeof index != 'number') index = this.groups.length;
        this.groups.insert(index, group);

        var el = this._createGroupEl(group);
        group._el = el;
        var index = this.groups.indexOf(group);
        var targetGroup = this.groups[index + 1];
        if (targetGroup) {
            var tEl = this.getGroupEl(targetGroup);
            jQuery(tEl).before(el);
        }
        this.doUpdate();
        return group;
    },
    updateGroup: function (group, options) {
        var group = this.getGroup(group);
        if (!group) return;
        mini.copyTo(group, options);
        this.doUpdate();
    },
    removeGroup: function (group) {
        group = this.getGroup(group);
        if (!group) return;
        var groupEl = this.getGroupEl(group);
        if (groupEl) groupEl.parentNode.removeChild(groupEl);

        this.groups.remove(group);
        this.doUpdate();
    },
    removeAll: function () {
        for (var i = this.groups.length - 1; i >= 0; i--) {
            this.removeGroup(i);
        }
    },
    moveGroup: function (group, index) {
        group = this.getGroup(group);
        if (!group) return;
        target = this.getGroup(index);

        var groupEl = this.getGroupEl(group);
        this.groups.remove(group);

        if (target) {
            index = this.groups.indexOf(target);
            this.groups.insert(index, group);
            var tEl = this.getGroupEl(target);
            jQuery(tEl).before(groupEl);
        } else {
            this.groups.add(group);
            this._borderEl.appendChild(groupEl);
        }

        this.doUpdate();
    },
    doUpdate: function () {
        for (var i = 0, l = this.groups.length; i < l; i++) {
            var group = this.groups[i];
            var groupEl = group._el;
            var headerEl = groupEl.firstChild;
            var groupBodyEl = groupEl.lastChild;

            var icons =
                '<div class="mini-outlookbar-icon ' + group.iconCls + '" style="' + group.iconStyle + ';"></div>';
            var s =
                '<div class="mini-tools"><span class="mini-tools-collapse"></span></div>' +
                (group.iconStyle || group.iconCls ? icons : '') +
                '<div class="mini-outlookbar-groupTitle">' +
                group.title +
                '</div><div style="clear:both;"></div>';

            headerEl.innerHTML = s;

            if (group.enabled) {
                mini.removeClass(groupEl, 'mini-disabled');
            } else {
                mini.addClass(groupEl, 'mini-disabled');
            }

            mini.addClass(groupEl, group.cls);
            mini.setStyle(groupEl, group.style);

            mini.addClass(groupBodyEl, group.bodyCls);
            mini.setStyle(groupBodyEl, group.bodyStyle);

            mini.addClass(headerEl, group.headerCls);
            mini.setStyle(headerEl, group.headerStyle);

            mini.removeClass(groupEl, 'mini-outlookbar-firstGroup');
            mini.removeClass(groupEl, 'mini-outlookbar-lastGroup');
            if (i == 0) {
                mini.addClass(groupEl, 'mini-outlookbar-firstGroup');
            }
            if (i == l - 1) {
                mini.addClass(groupEl, 'mini-outlookbar-lastGroup');
            }
        }
        this.doLayout();
    },
    doLayout: function () {
        if (this._inAniming) return;

        this._doLayoutInner();

        for (var i = 0, l = this.groups.length; i < l; i++) {
            var group = this.groups[i];
            var groupEl = group._el;
            var groupBodyEl = groupEl.lastChild;

            if (group.expanded) {
                mini.addClass(groupEl, 'mini-outlookbar-expand');
                mini.removeClass(groupEl, 'mini-outlookbar-collapse');
            } else {
                mini.removeClass(groupEl, 'mini-outlookbar-expand');
                mini.addClass(groupEl, 'mini-outlookbar-collapse');
            }
            groupBodyEl.style.height = 'auto';
            groupBodyEl.style.display = group.expanded ? 'block' : 'none';

            groupEl.style.display = group.visible ? '' : 'none';

            var w = mini.getWidth(groupEl, true);
            var padding = mini.getPaddings(groupBodyEl);
            var border = mini.getBorders(groupBodyEl);
            if (jQuery.boxModel) {
                w = w - padding.left - padding.right - border.left - border.right;
            }
            groupBodyEl.style.width = w + 'px';
        }

        var autoHeight = this.isAutoHeight();

        var acGroup = this.getActiveGroup();
        if (!autoHeight && this.autoCollapse && acGroup) {
            var groupEl = this.getGroupEl(this.activeIndex);
            groupEl.lastChild.style.height = this._getFillGroupBodyHeight() + 'px';
        } else {
        }

        mini.layout(this._borderEl);
    },
    _doLayoutInner: function () {
        if (this.isAutoHeight()) {
            this._borderEl.style.height = 'auto';
        } else {
            var h = this.getHeight(true);
            if (!jQuery.boxModel) {
                var b2 = mini.getBorders(this._borderEl);
                h = h + b2.top + b2.bottom;
            }
            if (h < 0) h = 0;
            this._borderEl.style.height = h + 'px';
        }
    },

    _getFillGroupBodyHeight: function () {
        var h = jQuery(this.el).height();
        var b2 = mini.getBorders(this._borderEl);
        h = h - b2.top - b2.bottom;

        var acGroup = this.getActiveGroup();
        var h2 = 0;
        for (var i = 0, l = this.groups.length; i < l; i++) {
            var group = this.groups[i];
            var div = this.getGroupEl(group);
            if (group.visible == false || group == acGroup) continue;
            var display = div.lastChild.style.display;
            div.lastChild.style.display = 'none';
            var dh = jQuery(div).outerHeight();
            div.lastChild.style.display = display;

            var margin = mini.getMargins(div);

            dh = dh + margin.top + margin.bottom;

            h2 += dh;
        }

        h = h - h2;

        var groupEl = this.getGroupEl(this.activeIndex);
        if (!groupEl) return 0;
        h = h - jQuery(groupEl.firstChild).outerHeight();
        if (jQuery.boxModel) {
            var padding = mini.getPaddings(groupEl.lastChild);
            var border = mini.getBorders(groupEl.lastChild);

            h = h - padding.top - padding.bottom - border.top - border.bottom;
        }

        var padding = mini.getPaddings(groupEl);
        var border = mini.getBorders(groupEl);
        var margin = mini.getMargins(groupEl);

        h = h - margin.top - margin.bottom;
        h = h - padding.top - padding.bottom - border.top - border.bottom;

        if (h < 0) h = 0;
        return h;
    },

    getGroup: function (index) {
        if (typeof index == 'object') return index;
        if (typeof index == 'number') {
            return this.groups[index];
        } else {
            for (var i = 0, l = this.groups.length; i < l; i++) {
                var group = this.groups[i];
                if (group.name == index) return group;
            }
        }
    },
    _getGroupById: function (id) {
        for (var i = 0, l = this.groups.length; i < l; i++) {
            var group = this.groups[i];
            if (group._id == id) return group;
        }
    },
    getGroupEl: function (index) {
        var group = this.getGroup(index);
        if (!group) return null;
        return group._el;
    },
    getGroupBodyEl: function (index) {
        var groupEl = this.getGroupEl(index);
        if (groupEl) return groupEl.lastChild;
        return null;
    },

    setAutoCollapse: function (value) {
        this.autoCollapse = value;
    },
    getAutoCollapse: function () {
        return this.autoCollapse;
    },
    setExpandOnLoad: function (value) {
        this.expandOnLoad = value;
    },
    getExpandOnLoad: function () {
        return this.expandOnLoad;
    },

    setActiveIndex: function (value) {
        var group = this.getGroup(value);
        var acGroup = this.getGroup(this.activeIndex);
        var fire = group != acGroup;

        if (group) {
            this.activeIndex = this.groups.indexOf(group);
        } else {
            this.activeIndex = -1;
        }

        var group = this.getGroup(this.activeIndex);
        if (group) {
            var anim = this.allowAnim;
            this.allowAnim = false;
            this.expandGroup(group);
            this.allowAnim = anim;
        }
    },
    getActiveIndex: function () {
        return this.activeIndex;
    },
    getActiveGroup: function () {
        return this.getGroup(this.activeIndex);
    },
    showGroup: function (group) {
        group = this.getGroup(group);
        if (!group || group.visible == true) return;
        group.visible = true;
        this.doUpdate();
    },
    hideGroup: function (group) {
        group = this.getGroup(group);
        if (!group || group.visible == false) return;
        group.visible = false;
        this.doUpdate();
    },
    toggleGroup: function (group) {
        group = this.getGroup(group);
        if (!group) return;
        if (group.expanded) {
            this.collapseGroup(group);
        } else {
            this.expandGroup(group);
        }
    },
    collapseGroup: function (group) {
        group = this.getGroup(group);
        if (!group) return;
        var expanded = group.expanded;

        var fillHeight = 0;
        if (this.autoCollapse && !this.isAutoHeight()) {
            fillHeight = this._getFillGroupBodyHeight();
        }

        var fire = false;
        group.expanded = false;
        var index = this.groups.indexOf(group);
        if (index == this.activeIndex) {
            this.activeIndex = -1;
            fire = true;
        }

        var el = this.getGroupBodyEl(group);
        if (this.allowAnim && expanded) {
            this._inAniming = true;

            el.style.display = 'block';
            el.style.height = 'auto';
            if (this.autoCollapse && !this.isAutoHeight()) {
                el.style.height = fillHeight + 'px';
            }
            var config = { height: '1px' };

            mini.addClass(el, 'mini-outlookbar-overflow');

            var sf = this;
            var jq = jQuery(el);
            jq.animate(config, 180, function () {
                sf._inAniming = false;
                mini.removeClass(el, 'mini-outlookbar-overflow');
                sf.doLayout();
            });
        } else {
            this.doLayout();
        }

        var e = {
            group: group,
            index: this.groups.indexOf(group),
            name: group.name
        };
        this.fire('Collapse', e);

        if (fire) {
            this.fire('activechanged');
        }
    },
    expandGroup: function (group) {
        group = this.getGroup(group);
        if (!group) return;

        var expanded = group.expanded;

        group.expanded = true;
        this.activeIndex = this.groups.indexOf(group);

        fire = true;

        if (this.autoCollapse) {
            for (var i = 0, l = this.groups.length; i < l; i++) {
                var g = this.groups[i];
                if (g.expanded && g != group) {
                    this.collapseGroup(g);
                }
            }
        }

        var el = this.getGroupBodyEl(group);
        if (this.allowAnim && expanded == false) {
            this._inAniming = true;

            el.style.display = 'block';

            if (this.autoCollapse && !this.isAutoHeight()) {
                var fillHeight = this._getFillGroupBodyHeight();
                el.style.height = fillHeight + 'px';
            } else {
                el.style.height = 'auto';
            }

            var h = mini.getHeight(el);

            el.style.height = '1px';
            var config = { height: h + 'px' };

            var overflow = el.style.overflow;
            el.style.overflow = 'hidden';
            mini.addClass(el, 'mini-outlookbar-overflow');

            var sf = this;
            var jq = jQuery(el);
            jq.animate(config, 180, function () {
                el.style.overflow = overflow;
                mini.removeClass(el, 'mini-outlookbar-overflow');
                sf._inAniming = false;
                sf.doLayout();
            });
        } else {
            this.doLayout();
        }

        var e = {
            group: group,
            index: this.groups.indexOf(group),
            name: group.name
        };
        this.fire('Expand', e);

        if (fire) {
            this.fire('activechanged');
        }
    },
    _tryToggleGroup: function (group) {
        group = this.getGroup(group);
        var e = {
            group: group,
            groupIndex: this.groups.indexOf(group),
            groupName: group.name,
            cancel: false
        };
        if (group.expanded) {
            this.fire('BeforeCollapse', e);
            if (e.cancel == false) {
                this.collapseGroup(group);
            }
        } else {
            this.fire('BeforeExpand', e);
            if (e.cancel == false) {
                this.expandGroup(group);
            }
        }
    },

    _getGroupByEvent: function (e) {
        var el = mini.findParent(e.target, 'mini-outlookbar-group');
        if (!el) return null;
        var ids = el.id.split('$');
        var id = ids[ids.length - 1];
        return this._getGroupById(id);
    },
    __OnClick: function (e) {
        if (this._inAniming) return;
        var hd = mini.findParent(e.target, 'mini-outlookbar-groupHeader');
        if (!hd) return;

        var group = this._getGroupByEvent(e);
        if (!group) return;

        this._tryToggleGroup(group);
    },

    parseGroups: function (nodes) {
        var groups = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];

            var group = {};
            groups.push(group);

            group.style = node.style.cssText;
            mini._ParseString(node, group, [
                'name',
                'title',
                'cls',
                'iconCls',
                'iconStyle',
                'headerCls',
                'headerStyle',
                'bodyCls',
                'bodyStyle'
            ]);
            mini._ParseBool(node, group, ['visible', 'enabled', 'showCollapseButton', 'expanded']);

            group.bodyParent = node;
        }
        return groups;
    },
    getAttrs: function (el) {
        var attrs = mini.OutlookBar.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['onactivechanged', 'oncollapse', 'onexpand']);

        mini._ParseBool(el, attrs, ['autoCollapse', 'allowAnim', 'expandOnLoad']);
        mini._ParseInt(el, attrs, ['activeIndex']);

        var nodes = mini.getChildNodes(el);
        attrs.groups = this.parseGroups(nodes);

        return attrs;
    }
});
mini.regClass(mini.OutlookBar, 'outlookbar');
mini.OutlookMenu = mini.OutlookBar.extend({
    type: 'outlookmenu',
    tag: 'mini-outlookmenu',

    props: {
        url: '',
        textField: 'text',
        iconField: 'iconCls',
        iconStyleField: 'iconStyle',
        urlField: 'url',

        resultAsTree: false,
        itemsField: 'children',
        idField: 'id',
        parentField: 'pid',

        style: 'width:100%;height:100%;'
    },

    initComponent: function () {
        this.data = this.data || [];
        this.callParent('initComponent');
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var url = kv.url;
        delete kv.url;
        var activeIndex = kv.activeIndex;
        delete kv.activeIndex;

        mini.OutlookMenu.superclass.set.call(this, kv);

        if (url) {
            this.setUrl(url);
        }
        if (mini.isNumber(activeIndex)) {
            this.setActiveIndex(activeIndex);
        }
        return this;
    },

    destroy: function (removeEl) {
        if (this._menus) {
            var cs = this._menus.clone();
            for (var i = 0, l = cs.length; i < l; i++) {
                var p = cs[i];
                p.destroy();
            }
            this._menus.length = 0;
        }

        mini.OutlookMenu.superclass.destroy.call(this, removeEl);
    },

    _doParseFields: function (list) {
        for (var i = 0, l = list.length; i < l; i++) {
            var o = list[i];
            o.text = o[this.textField];
            o.url = o[this.urlField];
            o.iconCls = o[this.iconField];
        }
    },
    _doLoad: function () {
        var items = [];
        try {
            items = mini.getData(this.url);
        } catch (ex) {
            if (mini_debugger == true) {
                alert('outlooktree json is error.');
            }
        }
        if (this.dataField) {
            items = mini._getMap(this.dataField, items);
        }
        if (!items) items = [];

        if (this.resultAsTree == false) {
            items = mini.arrayToTree(items, this.itemsField, this.idField, this.parentField);
        }

        var list = mini.treeToArray(items, this.itemsField, this.idField, this.parentField);
        this._doParseFields(list);

        this.createNavBarMenu(items);
        this.fire('load');
    },
    loadList: function (list, idField, parentField) {
        idField = idField || this.idField;
        parentField = parentField || this.parentField;
        this._doParseFields(list);
        var tree = mini.arrayToTree(list, this.nodesField, idField, parentField);
        this.load(tree);
    },
    load: function (value) {
        if (typeof value == 'string') {
            this.setUrl(value);
        } else {
            this.createNavBarMenu(value);
        }
    },
    setData: function (value) {
        this.load(value);
    },
    setUrl: function (value) {
        this.url = value;
        this._doLoad();
    },
    getUrl: function () {
        return this.url;
    },
    setTextField: function (value) {
        this.textField = value;
    },
    getTextField: function () {
        return this.textField;
    },
    setIconField: function (value) {
        this.iconField = value;
    },
    getIconField: function () {
        return this.iconField;
    },
    setUrlField: function (value) {
        this.urlField = value;
    },
    getUrlField: function () {
        return this.urlField;
    },
    setResultAsTree: function (value) {
        this.resultAsTree = value;
    },
    getResultAsTree: function () {
        return this.resultAsTree;
    },
    setNodesField: function (value) {
        this.nodesField = value;
    },
    getNodesField: function () {
        return this.nodesField;
    },
    setIdField: function (value) {
        this.idField = value;
    },
    getIdField: function () {
        return this.idField;
    },
    setParentField: function (value) {
        this.parentField = value;
    },
    getParentField: function () {
        return this.parentField;
    },
    _selected: null,
    getSelected: function () {
        return this._selected;
    },
    selectNode: function (node) {
        node = this.getNode(node);
        if (!node) return;

        var menu = this._getOwnerMenu(node);
        if (!menu) return;
        this.expandGroup(menu._ownerGroup);

        setTimeout(function () {
            try {
                menu.setSelectedItem(node);
            } catch (ex) {}
        }, 100);
    },
    findNodes: function (fn, scope) {
        var nodes = [];
        scope = scope || this;
        for (var i = 0, l = this._menus.length; i < l; i++) {
            var items = this._menus[i].getItems();
            var nds = [];
            for (var j = 0, k = items.length; j < k; j++) {
                var item = items[j];
                if (fn && fn.call(scope, item) === true) {
                    nds.push(item);
                }
            }
            nodes.addRange(nds);
        }
        return nodes;
    },
    getNode: function (node) {
        for (var i = 0, l = this._menus.length; i < l; i++) {
            var menu = this._menus[i];
            var n = menu.getItem(node);
            if (n) return n;
        }
        return null;
    },
    getList: function () {
        var list = [];
        for (var i = 0, l = this._menus.length; i < l; i++) {
            var menu = this._menus[i];
            var items = menu.getItems();
            list.addRange(items);
        }
        return list;
    },
    _getOwnerMenu: function (node) {
        if (!node) return;
        for (var i = 0, l = this._menus.length; i < l; i++) {
            var menu = this._menus[i];
            var n = menu.getItem(node);
            if (n) return menu;
        }
    },

    getAttrs: function (el) {
        var attrs = mini.OutlookMenu.superclass.getAttrs.call(this, el);

        attrs.text = el.innerHTML;
        mini._ParseString(el, attrs, [
            'url',
            'textField',
            'urlField',
            'idField',
            'parentField',
            'itemsField',
            'iconField',
            'onitemclick',
            'onitemselect',
            'ondrawnode'
        ]);
        mini._ParseBool(el, attrs, ['resultAsTree']);

        return attrs;
    },

    autoCollapse: true,
    activeIndex: 0,
    createNavBarMenu: function (tree) {
        if (!mini.isArray(tree)) tree = [];
        this.data = tree;

        var groups = [];
        for (var i = 0, l = this.data.length; i < l; i++) {
            var o = this.data[i];
            var group = {};
            group.title = o.text;
            group.iconCls = o.iconCls;
            groups.push(group);

            group._children = o[this.itemsField];
        }

        this.setGroups(groups);
        this.setActiveIndex(this.activeIndex);

        this._menus = [];
        for (var i = 0, l = this.groups.length; i < l; i++) {
            var group = this.groups[i];
            var groupBodyEl = this.getGroupBodyEl(group);

            var menu = new mini.Menu();
            menu._ownerGroup = group;
            menu.set({
                showNavArrow: false,
                style: 'width:100%;height:100%;border:0;background:none',
                borderStyle: 'border:0',
                allowSelectItem: true,
                items: group._children
            });
            menu.render(groupBodyEl);
            menu.on('itemclick', this.__OnItemClick, this);
            menu.on('itemselect', this.__OnItemSelect, this);

            this._onDrawNodes(menu.getItems());

            this._menus.push(menu);
            delete group._children;
        }
    },
    _onDrawNodes: function (items) {
        if (!items) return;
        for (var i = 0, l = items.length; i < l; i++) {
            var item = items[i];
            var e = { node: item, img: item.img, nodeHtml: '' };
            this.fire('drawnode', e);
            if (e.img != item.img && item.setImg) {
                item.setImg(e.img);
            }
            if (e.nodeHtml != '') {
                item.setText(e.nodeHtml);
            }
        }
    },
    __OnItemClick: function (e) {
        var eve = {
            item: e.item,
            htmlEvent: e.htmlEvent
        };
        this.fire('itemclick', eve);
    },
    __OnItemSelect: function (e) {
        if (!e.item) return;
        for (var i = 0, l = this._menus.length; i < l; i++) {
            var menu = this._menus[i];
            if (menu != e.sender) {
                menu.setSelectedItem(null);
            }
        }
        var eve = {
            item: e.item,
            htmlEvent: e.htmlEvent
        };
        this._selected = e.item;
        this.fire('itemselect', eve);
    }
});
mini.regClass(mini.OutlookMenu, 'outlookmenu');

mini.OutlookTree = mini.OutlookBar.extend({
    type: 'outlooktree',
    tag: 'mini-outlooktree',

    props: {
        url: '',
        textField: 'text',
        iconField: 'iconCls',
        iconStyleField: 'iconStyle',
        urlField: 'url',
        resultAsTree: false,
        nodesField: 'children',
        idField: 'id',
        parentField: 'pid',
        style: 'width:100%;height:100%;',

        showTreeLines: true
    },

    initComponent: function () {
        this.data = this.data || [];
        this.callParent('initComponent');
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var url = kv.url;
        delete kv.url;
        var activeIndex = kv.activeIndex;
        delete kv.activeIndex;

        mini.OutlookTree.superclass.set.call(this, kv);

        if (url) {
            this.setUrl(url);
        }
        if (mini.isNumber(activeIndex)) {
            this.setActiveIndex(activeIndex);
        }
        return this;
    },

    destroy: function (removeEl) {
        if (this._trees) {
            var cs = this._trees.clone();
            for (var i = 0, l = cs.length; i < l; i++) {
                var p = cs[i];
                p.destroy();
            }
            this._trees.length = 0;
        }

        mini.OutlookTree.superclass.destroy.call(this, removeEl);
    },

    _doParseFields: function (list) {
        for (var i = 0, l = list.length; i < l; i++) {
            var o = list[i];
            o.text = o[this.textField];
            o.url = o[this.urlField];
            o.iconCls = o[this.iconField];
        }
    },
    _doLoad: function () {
        var items = [];
        try {
            items = mini.getData(this.url);
        } catch (ex) {
            if (mini_debugger == true) {
                alert('outlooktree json is error.');
            }
        }
        if (this.dataField) {
            items = mini._getMap(this.dataField, items);
        }
        if (!items) items = [];

        if (this.resultAsTree == false) {
            items = mini.arrayToTree(items, this.nodesField, this.idField, this.parentField);
        }

        var list = mini.treeToArray(items, this.nodesField, this.idField, this.parentField);
        this._doParseFields(list);

        this.createNavBarTree(items);
        this.fire('load');
    },
    loadList: function (list, idField, parentField) {
        idField = idField || this.idField;
        parentField = parentField || this.parentField;
        this._doParseFields(list);
        var tree = mini.arrayToTree(list, this.nodesField, idField, parentField);
        this.load(tree);
    },
    load: function (value) {
        if (typeof value == 'string') {
            this.setUrl(value);
        } else {
            this.createNavBarTree(value);
        }
    },
    setData: function (value) {
        this.load(value);
    },
    getData: function () {
        return this.data;
    },
    setUrl: function (value) {
        this.url = value;
        if (value) this._doLoad();
    },
    getUrl: function () {
        return this.url;
    },
    setTextField: function (value) {
        this.textField = value;
    },
    getTextField: function () {
        return this.textField;
    },
    setIconField: function (value) {
        this.iconField = value;
    },
    getIconField: function () {
        return this.iconField;
    },
    setUrlField: function (value) {
        this.urlField = value;
    },
    getUrlField: function () {
        return this.urlField;
    },
    setResultAsTree: function (value) {
        this.resultAsTree = value;
    },
    getResultAsTree: function () {
        return this.resultAsTree;
    },
    setNodesField: function (value) {
        this.nodesField = value;
    },
    getNodesField: function () {
        return this.nodesField;
    },
    setIdField: function (value) {
        this.idField = value;
    },
    getIdField: function () {
        return this.idField;
    },
    setParentField: function (value) {
        this.parentField = value;
    },
    getParentField: function () {
        return this.parentField;
    },
    _selected: null,
    getSelected: function () {
        return this._selected;
    },
    selectNode: function (node) {
        node = this.getNode(node);
        if (!node) return;
        var tree = this._getOwnerTree(node);
        tree.selectNode(node);
    },
    expandPath: function (node) {
        node = this.getNode(node);
        if (!node) return;
        var tree = this._getOwnerTree(node);
        tree.expandPath(node);
        this.expandGroup(tree._ownerGroup);
    },
    findNodes: function (fn, scope) {
        var nodes = [];
        scope = scope || this;
        for (var i = 0, l = this._trees.length; i < l; i++) {
            var tree = this._trees[i];
            var nds = tree.findNodes(fn, scope);
            nodes.addRange(nds);
        }
        return nodes;
    },
    getNode: function (node) {
        for (var i = 0, l = this._trees.length; i < l; i++) {
            var tree = this._trees[i];
            var n = tree.getNode(node);
            if (n) return n;
        }
        return null;
    },
    getList: function () {
        var list = [];
        for (var i = 0, l = this._trees.length; i < l; i++) {
            var tree = this._trees[i];
            var nodes = tree.getList();
            list.addRange(nodes);
        }
        return list;
    },
    _getOwnerTree: function (node) {
        if (!node) return;
        for (var i = 0, l = this._trees.length; i < l; i++) {
            var tree = this._trees[i];
            if (tree._idNodes[node._id]) return tree;
        }
    },
    expandOnLoad: false,
    setExpandOnLoad: function (value) {
        this.expandOnLoad = value;
    },
    getExpandOnLoad: function () {
        return this.expandOnLoad;
    },

    getAttrs: function (el) {
        var attrs = mini.OutlookTree.superclass.getAttrs.call(this, el);

        attrs.text = el.innerHTML;
        mini._ParseString(el, attrs, [
            'url',
            'textField',
            'urlField',
            'idField',
            'parentField',
            'nodesField',
            'iconField',
            'onnodeclick',
            'onnodeselect',
            'onnodemousedown',
            'ondrawnode',
            'expandOnLoad'
        ]);
        mini._ParseBool(el, attrs, ['resultAsTree']);

        if (attrs.expandOnLoad) {
            var level = parseInt(attrs.expandOnLoad);
            if (mini.isNumber(level)) {
                attrs.expandOnLoad = level;
            } else {
                attrs.expandOnLoad = attrs.expandOnLoad == 'true' ? true : false;
            }
        }

        return attrs;
    },

    autoCollapse: true,
    activeIndex: 0,
    createNavBarTree: function (tree) {
        if (!mini.isArray(tree)) tree = [];
        this.data = tree;

        var groups = [];
        for (var i = 0, l = this.data.length; i < l; i++) {
            var o = this.data[i];
            var group = {};
            group.title = o.text;
            group.iconCls = o.iconCls;
            groups.push(group);

            group._children = o[this.nodesField];
        }

        this.setGroups(groups);
        this.setActiveIndex(this.activeIndex);

        this._trees = [];
        for (var i = 0, l = this.groups.length; i < l; i++) {
            var group = this.groups[i];
            var groupBodyEl = this.getGroupBodyEl(group);

            var tree = new mini.Tree();

            tree.on('nodeclick', this.__OnNodeClick, this);
            tree.on('nodeselect', this.__OnNodeSelect, this);
            tree.on('nodemousedown', this.__OnNodeMouseDown, this);
            tree.on('drawnode', this.__OnDrawNode, this);

            tree.set({
                idField: this.idField,
                parentField: this.parentField,
                textField: this.textField,
                expandOnLoad: this.expandOnLoad,
                showTreeIcon: true,
                style: 'width:100%;height:100%;border:0;background:none',
                data: group._children
            });
            tree.render(groupBodyEl);

            this._trees.push(tree);
            delete group._children;

            tree._ownerGroup = group;
        }
        this.doLayout();
    },
    __OnNodeMouseDown: function (e) {
        var eve = {
            node: e.node,
            isLeaf: e.sender.isLeaf(e.node),
            htmlEvent: e.htmlEvent
        };
        this.fire('nodemousedown', eve);
    },
    __OnNodeClick: function (e) {
        var eve = {
            node: e.node,
            isLeaf: e.sender.isLeaf(e.node),
            htmlEvent: e.htmlEvent
        };
        this.fire('nodeclick', eve);
    },
    __OnNodeSelect: function (e) {
        if (!e.node) return;
        for (var i = 0, l = this._trees.length; i < l; i++) {
            var tree = this._trees[i];
            if (tree != e.sender) {
                tree.selectNode(null);
            }
        }

        var eve = {
            node: e.node,
            isLeaf: e.sender.isLeaf(e.node),
            htmlEvent: e.htmlEvent
        };
        this._selected = e.node;
        this.fire('nodeselect', eve);
    },
    __OnDrawNode: function (e) {
        this.fire('drawnode', e);
    }
});
mini.regClass(mini.OutlookTree, 'outlooktree');

mini.NavBar = function () {
    mini.NavBar.superclass.constructor.call(this);
};
mini.extend(mini.NavBar, mini.OutlookBar, {
    uiCls: 'mini-navbar'
});
mini.regClass(mini.NavBar, 'navbar');

mini.NavBarMenu = function () {
    mini.NavBarMenu.superclass.constructor.call(this);
};
mini.extend(mini.NavBarMenu, mini.OutlookMenu, {
    uiCls: 'mini-navbarmenu'
});
mini.regClass(mini.NavBarMenu, 'navbarmenu');

mini.NavBarTree = function () {
    mini.NavBarTree.superclass.constructor.call(this);
};
mini.extend(mini.NavBarTree, mini.OutlookTree, {
    uiCls: 'mini-navbartree'
});
mini.regClass(mini.NavBarTree, 'navbartree');
mini.Menu = function (config) {
    this.items = [];
    mini.Menu.superclass.constructor.call(this, config);
};
mini.extend(mini.Menu, mini.Control, {
    uiCls: 'mini-menu'
});
mini.copyTo(mini.Menu.prototype, mini.Popup_prototype);
var mini_Popup_prototype_hide = mini.Popup_prototype.hide;

mini.copyTo(mini.Menu.prototype, {
    height: 'auto',
    width: 'auto',
    minWidth: 140,
    vertical: true,
    allowSelectItem: false,
    _selectedItem: null,
    _itemSelectedCls: 'mini-menuitem-selected',

    textField: 'text',
    resultAsTree: false,
    idField: 'id',
    parentField: 'pid',
    itemsField: 'children',

    showNavArrow: true,

    imgPath: '',

    _clearBorder: false,

    showAction: 'none',
    hideAction: 'outerclick',

    getbyName: function (name) {
        return this.getByName(name);
    },

    getByName: function (name) {
        for (var i = 0, l = this.items.length; i < l; i++) {
            var item = this.items[i];
            if (item.name == name) {
                return item;
            }
            if (item.menu) {
                var control = item.menu.getByName(name);
                if (control) return control;
            }
        }
        return null;
    },

    set: function (obj) {
        if (typeof obj == 'string') {
            return this;
        }

        if (obj.imgPath) this.setImgPath(obj.imgPath);
        delete obj.imgPath;

        this.ownerItem = obj.ownerItem;
        delete obj.ownerItem;

        var url = obj.url;
        delete obj.url;

        mini.Menu.superclass.set.call(this, obj);

        if (url) {
            this.setUrl(url);
        }

        return this;
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-menu';
        this.el.innerHTML =
            '<div class="mini-menu-border"><a class="mini-menu-topArrow" href="#" onclick="return false"></a><div class="mini-menu-inner"></div><a class="mini-menu-bottomArrow" href="#" onclick="return false"></a></div>';
        this._borderEl = this.el.firstChild;

        this._topArrowEl = this._borderEl.childNodes[0];
        this._bottomArrowEl = this._borderEl.childNodes[2];

        this._innerEl = this._borderEl.childNodes[1];
        this._innerEl.innerHTML =
            '<div class="mini-menu-float"></div><div class="mini-menu-toolbar"></div><div style="clear:both;"></div>';
        this._contentEl = this._innerEl.firstChild;
        this._toolbarEl = this._innerEl.childNodes[1];

        if (this.isVertical() == false) mini.addClass(this.el, 'mini-menu-horizontal');
    },
    destroy: function (removeEl) {
        if (this._topArrowEl) {
            this._topArrowEl.onmousedown = this._bottomArrowEl.onmousedown = null;
        }

        this._popupEl = this.popupEl = this._borderEl = this._innerEl = this._contentEl = null;
        this._topArrowEl = this._bottomArrowEl = null;
        this.owner = null;
        mini.un(document, 'mousedown', this.__OnBodyMouseDown, this);
        mini.un(window, 'resize', this.__OnWindowResize, this);

        mini.Menu.superclass.destroy.call(this, removeEl);
    },
    _disableContextMenu: false,
    _initEvents: function () {
        mini._BindEvents(function () {
            mini.on(document, 'mousedown', this.__OnBodyMouseDown, this);
            mini_onOne(this.el, 'mouseover', this.__OnMouseOver, this);
            mini.on(window, 'resize', this.__OnWindowResize, this);
            if (this._disableContextMenu) {
                mini_onOne(
                    this.el,
                    'contextmenu',
                    function (e) {
                        e.preventDefault();
                    },
                    this
                );
            }

            mini_onOne(this._topArrowEl, 'mousedown', this.__OnTopMouseDown, this);
            mini_onOne(this._bottomArrowEl, 'mousedown', this.__OnBottomMouseDown, this);
        }, this);
    },
    within: function (e) {
        if (mini.isAncestor(this.el, e.target)) return true;
        for (var i = 0, l = this.items.length; i < l; i++) {
            var item = this.items[i];
            if (item.within(e)) return true;
        }
        return false;
    },

    setVertical: function (value) {
        this.vertical = value;
        if (!value) {
            mini.addClass(this.el, 'mini-menu-horizontal');
        } else {
            mini.removeClass(this.el, 'mini-menu-horizontal');
        }
    },
    getVertical: function () {
        return this.vertical;
    },
    isVertical: function () {
        return this.vertical;
    },

    show: function () {
        this.setVisible(true);
    },
    hide: function () {
        this.hideItems();
        mini_Popup_prototype_hide.call(this);
    },
    hideItems: function () {
        for (var i = 0, l = this.items.length; i < l; i++) {
            var menuitem = this.items[i];
            menuitem.hideMenu();
        }
    },

    showItemMenu: function (item) {
        for (var i = 0, l = this.items.length; i < l; i++) {
            var menuitem = this.items[i];
            if (menuitem == item) {
                menuitem.showMenu();
            } else {
                menuitem.hideMenu();
            }
        }
    },
    hasShowItemMenu: function () {
        for (var i = 0, l = this.items.length; i < l; i++) {
            var menuitem = this.items[i];
            if (menuitem && menuitem.menu && menuitem.menu.isPopup) {
                return true;
            }
        }
        return false;
    },

    setData: function (value) {
        if (!mini.isArray(value)) value = [];
        this.setItems(value);
    },
    getData: function () {
        return this.getItems();
    },
    setItems: function (items) {
        if (!mini.isArray(items)) items = [];

        this.removeAll();
        var sss = new Date();

        for (var i = 0, l = items.length; i < l; i++) {
            this.addItem(items[i]);
        }
    },
    getItems: function () {
        return this.items;
    },
    addItem: function (item) {
        if (item == '-' || item == '|' || item.type == 'separator') {
            mini.append(this._contentEl, '<span class="mini-separator"></span>');
            return;
        }

        if (!mini.isControl(item) && !mini.getClass(item.type)) {
            item.type = 'menuitem';
        }

        item.ownerMenu = this;

        item = mini.getAndCreate(item);

        this.items.push(item);

        this._contentEl.appendChild(item.el);

        item.ownerMenu = this;

        this.fire('itemschanged');
    },
    removeItem: function (item) {
        item = mini.get(item);
        if (!item) return;
        this.items.remove(item);

        this._contentEl.removeChild(item.el);

        this.fire('itemschanged');
    },
    removeItemAt: function (index) {
        var item = this.items[index];
        this.removeItem(item);
    },
    removeAll: function () {
        var items = mini.Array.clone(this.items);
        for (var i = items.length - 1; i >= 0; i--) {
            this.removeItem(items[i]);
        }
        this._contentEl.innerHTML = '';
    },
    getGroupItems: function (name) {
        if (!name) return [];
        var items = [];
        for (var i = 0, l = this.items.length; i < l; i++) {
            var item = this.items[i];
            if (item.groupName == name) items.push(item);
        }
        return items;
    },
    getItem: function (item) {
        if (typeof item == 'number') return this.items[item];
        if (typeof item == 'string') {
            for (var i = 0, l = this.items.length; i < l; i++) {
                var it = this.items[i];
                if (it.id == item) return it;
            }
            return null;
        }
        if (item && this.items.indexOf(item) != -1) return item;
        return null;
    },

    setAllowSelectItem: function (value) {
        this.allowSelectItem = value;
    },
    getAllowSelectItem: function () {
        return this.allowSelectItem;
    },
    setSelectedItem: function (item) {
        item = this.getItem(item);
        this._OnItemSelect(item);
    },
    getSelectedItem: function (item) {
        return this._selectedItem;
    },

    setShowNavArrow: function (value) {
        this.showNavArrow = value;
    },
    getShowNavArrow: function () {
        return this.showNavArrow;
    },
    setTextField: function (value) {
        this.textField = value;
    },
    getTextField: function () {
        return this.textField;
    },
    setResultAsTree: function (value) {
        this.resultAsTree = value;
    },
    getResultAsTree: function () {
        return this.resultAsTree;
    },
    setIdField: function (value) {
        this.idField = value;
    },
    getIdField: function () {
        return this.idField;
    },
    setParentField: function (value) {
        this.parentField = value;
    },
    getParentField: function () {
        return this.parentField;
    },

    doLayout: function () {
        if (!this.isAutoHeight()) {
            var height = mini.getHeight(this.el, true);

            mini.setHeight(this._borderEl, height);
            this._topArrowEl.style.display = this._bottomArrowEl.style.display = 'none';
            this._contentEl.style.height = 'auto';

            if (this.showNavArrow && this._borderEl.scrollHeight > this._borderEl.clientHeight) {
                this._topArrowEl.style.display = this._bottomArrowEl.style.display = 'block';
                height = mini.getHeight(this._borderEl, true);
                var th = mini.getHeight(this._topArrowEl);
                var bh = mini.getHeight(this._bottomArrowEl);
                var h = height - th - bh;
                if (h < 0) h = 0;
                mini.setHeight(this._contentEl, h);
            } else {
                this._contentEl.style.height = 'auto';
            }
        } else {
            this._borderEl.style.height = 'auto';
            this._contentEl.style.height = 'auto';
        }
    },
    _measureSize: function () {
        if (this.height == 'auto') {
            this.el.style.height = 'auto';
            this._borderEl.style.height = 'auto';
            this._contentEl.style.height = 'auto';
            this._topArrowEl.style.display = this._bottomArrowEl.style.display = 'none';

            var vbox = mini.getViewportBox();
            var box = mini.getBox(this.el);
            this.maxHeight = vbox.height - 25;
            if (this.ownerItem) {
                var box = mini.getBox(this.ownerItem.el);
                var topH = box.top;
                var bottomH = vbox.height - box.bottom;
                var maxHeight = topH > bottomH ? topH : bottomH;
                maxHeight -= 10;
                this.maxHeight = maxHeight;
            }
        }

        this.el.style.display = '';
        var box = mini.getBox(this.el);

        if (box.width > this.maxWidth) {
            mini.setWidth(this.el, this.maxWidth);
            box = mini.getBox(this.el);
        }
        if (box.height > this.maxHeight) {
            mini.setHeight(this.el, this.maxHeight);
            box = mini.getBox(this.el);
        }
        if (box.width < this.minWidth) {
            mini.setWidth(this.el, this.minWidth);
            box = mini.getBox(this.el);
        }
        if (box.height < this.minHeight) {
            mini.setHeight(this.el, this.minHeight);
            box = mini.getBox(this.el);
        }
    },

    url: '',
    _doLoad: function () {
        var items = mini.getData(this.url);

        if (this.dataField) {
            items = mini._getMap(this.dataField, items);
        }
        if (!items) items = [];

        if (this.resultAsTree == false) {
            items = mini.arrayToTree(items, this.itemsField, this.idField, this.parentField);
        }

        var list = mini.treeToArray(items, this.itemsField, this.idField, this.parentField);
        for (var i = 0, l = list.length; i < l; i++) {
            var o = list[i];
            o.text = mini._getMap(this.textField, o);
            if (mini.isNull(o.text)) o.text = '';
        }
        var sss = new Date();
        this.setItems(items);

        this.fire('load');
    },
    loadList: function (list, idField, parentField) {
        if (!list) return;

        idField = idField || this.idField;
        parentField = parentField || this.parentField;

        for (var i = 0, l = list.length; i < l; i++) {
            var o = list[i];
            o.text = mini._getMap(this.textField, o);
            if (mini.isNull(o.text)) o.text = '';
        }

        var tree = mini.arrayToTree(list, this.itemsField, idField, parentField);

        this.load(tree);
    },
    load: function (url) {
        if (typeof url == 'string') {
            this.setUrl(url);
        } else {
            this.setItems(url);
        }
    },
    setUrl: function (value) {
        this.url = value;

        this._doLoad();
    },
    getUrl: function () {
        return this.url;
    },
    hideOnClick: true,
    setHideOnClick: function (value) {
        this.hideOnClick = value;
    },
    getHideOnClick: function () {
        return this.hideOnClick;
    },

    setImgPath: function (value) {
        this.imgPath = value;
    },
    getImgPath: function () {
        return this.imgPath;
    },

    _OnItemClick: function (item, htmlEvent) {
        var e = {
            item: item,
            isLeaf: !item.menu,
            htmlEvent: htmlEvent
        };

        if (item.hideOnClick && !item.menu) {
            if (this.isPopup) {
                this.hide();
            } else {
                this.hideItems();
            }
        }

        if (this.allowSelectItem && this._selectedItem != item) {
            this.setSelectedItem(item);
        }

        this.fire('itemclick', e);
        if (this.ownerItem) {
        }
    },
    _OnItemSelect: function (item) {
        if (this._selectedItem) {
            this._selectedItem.removeCls(this._itemSelectedCls);
        }
        this._selectedItem = item;

        if (this._selectedItem) {
            this._selectedItem.addCls(this._itemSelectedCls);
        }
        var e = {
            item: this._selectedItem
        };
        this.fire('itemselect', e);
    },
    onItemClick: function (fn, scope) {
        this.on('itemclick', fn, scope);
    },
    onItemSelect: function (fn, scope) {
        this.on('itemselect', fn, scope);
    },

    __OnTopMouseDown: function (e) {
        this._startScrollMove(-20);
    },
    __OnBottomMouseDown: function (e) {
        this._startScrollMove(20);
    },
    _startScrollMove: function (value) {
        clearInterval(this._scrollTimer);
        var fn = function () {
            clearInterval(me._scrollTimer);
            mini.un(document, 'mouseup', fn);
        };
        mini.on(document, 'mouseup', fn);

        var me = this;

        this._scrollTimer = setInterval(function () {
            me._contentEl.scrollTop += value;
        }, 50);
    },
    setToolbar: function (value) {
        __mini_setControls(value, this._toolbarEl, this);
    },

    parseItems: function (nodes) {
        var data = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];

            if (node.className == 'separator') {
                data.add('-');
                continue;
            }

            var cnodes = mini.getChildNodes(node);

            var nodeItem = cnodes[0];
            var nodeChild = cnodes[1];

            var o = new mini.MenuItem();

            if (!nodeChild) {
                mini.applyTo.call(o, node);
                data.add(o);
                continue;
            }

            mini.applyTo.call(o, nodeItem);
            o.render(document.body);

            var menu = new mini.Menu();

            mini.applyTo.call(menu, nodeChild);

            o.setMenu(menu);

            menu.render(document.body);

            data.add(o);
        }
        return mini.Array.clone(data);
    },
    getAttrs: function (el) {
        var attrs = mini.Menu.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        mini._ParseString(el, attrs, [
            'popupEl',
            'popupCls',
            'showAction',
            'hideAction',
            'xAlign',
            'yAlign',
            'modalStyle',
            'onbeforeopen',
            'open',
            'onbeforeclose',
            'onclose',
            'url',
            'onitemclick',
            'onitemselect',
            'textField',
            'idField',
            'parentField',
            'toolbar',
            'imgPath'
        ]);
        mini._ParseBool(el, attrs, ['resultAsTree', 'hideOnClick', 'showNavArrow']);

        var nodes = mini.getChildNodes(el);

        for (var i = nodes.length - 1; i >= 0; i--) {
            var node = nodes[i];
            var property = jQuery(node).attr('property');
            if (!property) continue;
            property = property.toLowerCase();
            if (property == 'toolbar') {
                attrs.toolbar = node;
                node.parentNode.removeChild(node);
            }
        }

        var nodes = mini.getChildNodes(el);
        var items = this.parseItems(nodes);
        if (items.length > 0) {
            attrs.items = items;
        }

        var vertical = jq.attr('vertical');
        if (vertical) {
            attrs.vertical = vertical == 'true' ? true : false;
        }
        var allowSelectItem = jq.attr('allowSelectItem');
        if (allowSelectItem) {
            attrs.allowSelectItem = allowSelectItem == 'true' ? true : false;
        }

        return attrs;
    }
});
mini.regClass(mini.Menu, 'menu');

mini.MenuBar = function () {
    mini.MenuBar.superclass.constructor.call(this);
};
mini.extend(mini.MenuBar, mini.Menu, {
    uiCls: 'mini-menubar',
    vertical: false,
    setVertical: function (value) {
        this.vertical = false;
    }
});
mini.regClass(mini.MenuBar, 'menubar');

mini.ContextMenu = function () {
    mini.ContextMenu.superclass.constructor.call(this);
};
mini.extend(mini.ContextMenu, mini.Menu, {
    uiCls: 'mini-contextmenu',
    vertical: true,
    visible: false,
    _disableContextMenu: true,
    setVertical: function (value) {
        this.vertical = true;
    }
});
mini.regClass(mini.ContextMenu, 'contextmenu');

mini.MenuItem = mini.Control.extend({
    type: 'menuitem',
    tag: 'mini-menuitem',

    props: {
        text: '',
        iconCls: '',
        iconStyle: '',
        iconPosition: 'left',

        showIcon: true,
        showAllow: true,

        checked: false,
        checkOnClick: false,
        groupName: '',
        menu: null,
        items: null,
        hideOnClick: true
    },

    hoverCls: 'mini-menuitem-hover',
    pressedCls: 'mini-menuitem-pressed',
    checkedCls: 'mini-menuitem-checked',
    _clearBorder: false,

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        this.ownerMenu = kv.ownerMenu;
        delete kv.ownerMenu;

        mini.MenuItem.superclass.set.call(this, kv);

        return this;
    },

    _create: function () {
        var el = (this.el = document.createElement('div'));
        this.el.className = 'mini-menuitem';

        this.el.innerHTML =
            '<div class="mini-menuitem-inner"><div class="mini-menuitem-icon"></div><div class="mini-menuitem-text"></div><div class="mini-menuitem-allow"></div></div>';
        this._innerEl = this.el.firstChild;
        this._iconEl = this._innerEl.firstChild;
        this._textEl = this._innerEl.childNodes[1];
        this.allowEl = this._innerEl.lastChild;
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini_onOne(this.el, 'mouseover', this.__OnMouseOver, this);
        }, this);

        mini.on(
            this.el,
            'mousedown',
            function (event) {
                if (this.menu) event.stopPropagation();
            },
            this
        );
    },
    _inputEventsInited: false,
    _initInputEvents: function () {
        if (this._inputEventsInited) return;
        this._inputEventsInited = true;

        mini_onOne(this.el, 'click', this.__OnClick, this);
        mini_onOne(this.el, 'mouseup', this.__OnMouseUp, this);

        mini_onOne(this.el, 'mouseout', this.__OnMouseOut, this);
    },
    destroy: function (removeEl) {
        if (this.el) {
            this.el.onmouseover = null;
        }
        this.menu = this._innerEl = this._iconEl = this._textEl = this.allowEl = null;
        mini.MenuItem.superclass.destroy.call(this, removeEl);
    },
    within: function (e) {
        if (mini.isAncestor(this.el, e.target)) return true;
        if (this.menu && this.menu.within(e)) return true;
        return false;
    },
    _getIconImg: function () {
        return this.img && this.getTopMenu() ? this.getTopMenu().imgPath + this.img : this.img;
    },
    _doUpdateIcon: function () {
        var img = this._getIconImg();
        var hasIcon = !!(this.iconStyle || this.iconCls || this.checkOnClick || img);
        if (this._iconEl) {
            mini.setStyle(this._iconEl, this.iconStyle);
            mini.addClass(this._iconEl, this.iconCls);

            if (img) {
                var style = 'background-image:url(' + img + ')';
                mini.setStyle(this._iconEl, style);
            }

            if (this.checked) {
                jQuery(this._iconEl).css({ 'background-image': '' });
                hasIcon = true;
            }

            this._iconEl.style.display = hasIcon ? 'block' : 'none';
        }
        if (this.iconPosition == 'top') {
            mini.addClass(this.el, 'mini-menuitem-icontop');
        } else {
            mini.removeClass(this.el, 'mini-menuitem-icontop');
        }
    },

    doUpdate: function () {
        if (this._textEl) this._textEl.innerHTML = this.text;
        this._doUpdateIcon();

        if (this.checked) {
            mini.addClass(this.el, this.checkedCls);
            jQuery(this._iconEl).css({ 'background-image': '' });
        } else {
            mini.removeClass(this.el, this.checkedCls);
        }
        if (this.allowEl) {
            if (this.menu && this.menu.items.length > 0) {
                this.allowEl.style.display = 'block';
            } else {
                this.allowEl.style.display = 'none';
            }
        }
    },
    setText: function (value) {
        this.text = value;

        if (this._textEl) this._textEl.innerHTML = this.text;
    },
    getText: function () {
        return this.text;
    },
    setIconCls: function (value) {
        mini.removeClass(this._iconEl, this.iconCls);
        this.iconCls = value;

        this._doUpdateIcon();
    },
    getIconCls: function () {
        return this.iconCls;
    },
    setImg: function (value) {
        this.img = value;

        this._doUpdateIcon();
    },
    getImg: function () {
        return this.img;
    },
    setIconStyle: function (value) {
        this.iconStyle = value;

        this._doUpdateIcon();
    },
    getIconStyle: function () {
        return this.iconStyle;
    },
    setIconPosition: function (value) {
        this.iconPosition = value;

        this._doUpdateIcon();
    },
    getIconPosition: function () {
        return this.iconPosition;
    },
    setCheckOnClick: function (value) {
        this.checkOnClick = value;
        if (value) {
            mini.addClass(this.el, 'mini-menuitem-showcheck');
        } else {
            mini.removeClass(this.el, 'mini-menuitem-showcheck');
        }
        this.doUpdate();
    },
    getCheckOnClick: function () {
        return this.checkOnClick;
    },
    setChecked: function (value) {
        if (this.checked != value) {
            this.checked = value;
            this.doUpdate();
            this.fire('checkedchanged');
        }
    },
    getChecked: function () {
        return this.checked;
    },
    setGroupName: function (value) {
        if (this.groupName != value) {
            this.groupName = value;
        }
    },
    getGroupName: function () {
        return this.groupName;
    },
    setChildren: function (value) {
        this.setMenu(value);
    },
    setItems: function (value) {
        this.setMenu(value);
    },
    setMenu: function (value) {
        if (mini.isArray(value)) {
            value = {
                type: 'menu',
                items: value
            };
        }
        if (this.menu !== value) {
            value.ownerItem = this;
            this.menu = mini.getAndCreate(value);
            this.menu.hide();
            this.menu.ownerItem = this;
            this.doUpdate();
            this.menu.on('itemschanged', this.__OnItemsChanged, this);
        }
    },
    getMenu: function () {
        return this.menu;
    },
    showMenu: function () {
        if (this.menu && this.menu.isDisplay() == false) {
            this.menu.setHideAction('outerclick');

            var options = {
                xAlign: 'outright',
                yAlign: 'top',
                outXAlign: 'outleft',

                popupCls: 'mini-menu-popup',
                alwaysView: true
            };

            if (this.ownerMenu && this.ownerMenu.vertical == false) {
                options.xAlign = 'left';
                options.yAlign = 'below';
                options.outXAlign = null;
            }

            this.menu.showAtEl(this.el, options);
        }
    },
    hideMenu: function () {
        if (this.menu) this.menu.hide();
    },
    hide: function () {
        this.hideMenu();
        this.setVisible(false);
    },

    __OnItemsChanged: function (e) {
        this.doUpdate();
    },
    getTopMenu: function () {
        if (this.ownerMenu) {
            if (this.ownerMenu.ownerItem) return this.ownerMenu.ownerItem.getTopMenu();
            else return this.ownerMenu;
        }
        return null;
    },

    __OnClick: function (e) {
        if (this.isReadOnly()) return;

        if (this.checkOnClick) {
            if (this.ownerMenu && this.groupName) {
                var groups = this.ownerMenu.getGroupItems(this.groupName);
                if (groups.length > 0) {
                    if (this.checked == false) {
                        for (var i = 0, l = groups.length; i < l; i++) {
                            var item = groups[i];
                            if (item != this) {
                                item.setChecked(false);
                            }
                        }
                        this.setChecked(true);
                    }
                } else {
                    this.setChecked(!this.checked);
                }
            } else {
                this.setChecked(!this.checked);
            }
        }

        this.fire('click');

        var topMenu = this.getTopMenu();
        if (topMenu) {
            topMenu._OnItemClick(this, e);
        }
    },
    __OnMouseUp: function (e) {
        if (this.isReadOnly()) return;

        if (this.ownerMenu) {
            var me = this;
            setTimeout(function () {
                if (me.isDisplay()) {
                    me.ownerMenu.showItemMenu(me);
                }
            }, 1);
        }
    },
    __OnMouseOver: function (e) {
        if (this.isReadOnly()) return;
        this._initInputEvents();
        mini.addClass(this.el, this.hoverCls);

        this.el.title = this.text;

        if (this._textEl.scrollWidth > this._textEl.clientWidth) {
            this.el.title = this.text;
        } else {
            this.el.title = '';
        }

        if (this.ownerMenu) {
            if (this.ownerMenu.isVertical() == true) {
                this.ownerMenu.showItemMenu(this);
            } else if (this.ownerMenu.hasShowItemMenu()) {
                this.ownerMenu.showItemMenu(this);
            }
        }
    },

    __OnMouseOut: function (e) {
        mini.removeClass(this.el, this.hoverCls);
    },
    onClick: function (fn, scope) {
        this.on('click', fn, scope);
    },
    onCheckedChanged: function (fn, scope) {
        this.on('checkedchanged', fn, scope);
    },

    getAttrs: function (el) {
        var attrs = mini.MenuItem.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        attrs.text = el.innerHTML;
        mini._ParseString(el, attrs, [
            'img',
            'text',
            'iconCls',
            'iconStyle',
            'iconPosition',
            'groupName',
            'onclick',
            'oncheckedchanged'
        ]);
        mini._ParseBool(el, attrs, ['checkOnClick', 'checked']);

        return attrs;
    }
});
mini.regClass(mini.MenuItem, 'menuitem');

mini.Separator = function () {
    mini.Separator.superclass.constructor.call(this);
};
mini.extend(mini.Separator, mini.Control, {
    _clearBorder: false,
    uiCls: 'mini-separator',
    _create: function () {
        this.el = document.createElement('span');
        this.el.className = 'mini-separator';
    }
});
mini.regClass(mini.Separator, 'separator');
mini.ToolBar = mini.Container.extend({
    type: 'toolbar',
    tag: 'mini-toolbar',

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-toolbar';
    },
    _initEvents: function () {},
    doLayout: function () {
        var nodes = mini.getChildNodes(this.el, true);
        for (var i = 0, l = nodes.length; i < l; i++) {
            mini.layout(nodes[i]);
        }
    }
});
mini.Pager = mini.Control.extend({
    type: 'pager',
    tag: 'mini-pager',

    props: {
        pageIndex: 0,
        pageSize: 10,
        totalCount: 0,
        totalPage: 0,

        showPageIndex: true,
        showPageSize: true,
        showTotalCount: true,

        showPageInfo: true,
        showReloadButton: true,

        showButtonText: false,
        showButtonIcon: true,
        buttons: null,

        firstText: '首页',
        prevText: '上一页',
        nextText: '下一页',
        lastText: '尾页',

        pageInfoText: '每页 {0} 条, 共 {1} 条',
        sizeList: [10, 20, 50, 100]
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-pager';

        var s =
            '<div class="mini-pager-left"><table cellspacing="0" cellpadding="0" border="0"><tr><td></td><td></td></tr></table></div><div class="mini-pager-right"></div>';
        this.el.innerHTML = s;

        this._leftEl = this.el.childNodes[0];
        this._rightEl = this.el.childNodes[1];

        var tds = this._leftEl.getElementsByTagName('td');
        this._barEl = tds[0];
        this._barEl2 = tds[1];

        this.sizeEl = mini.append(this._barEl, '<span class="mini-pager-size"></span>');

        this.sizeCombo = new mini.ComboBox();
        this.sizeCombo.setName('pagesize');
        this.sizeCombo.setWidth(48);
        this.sizeCombo.render(this.sizeEl);
        mini.append(this.sizeEl, '<span class="separator"></span>');

        this.firstButton = new mini.Button();
        this.firstButton.render(this._barEl);

        this.prevButton = new mini.Button();
        this.prevButton.render(this._barEl);

        this.indexEl = document.createElement('span');
        this.indexEl.className = 'mini-pager-index';
        this.indexEl.innerHTML =
            '<input id="" type="text" class="mini-pager-num"/><span class="mini-pager-pages">/ 0</span>';
        this._barEl.appendChild(this.indexEl);

        this.numInput = this.indexEl.firstChild;
        this.pagesLabel = this.indexEl.lastChild;

        this.nextButton = new mini.Button();
        this.nextButton.render(this._barEl);

        this.lastButton = new mini.Button();
        this.lastButton.render(this._barEl);

        mini.append(this._barEl, '<span class="separator"></span>');

        this.reloadButton = new mini.Button();
        this.reloadButton.render(this._barEl);

        this.firstButton.setPlain(true);
        this.prevButton.setPlain(true);
        this.nextButton.setPlain(true);
        this.lastButton.setPlain(true);
        this.reloadButton.setPlain(true);

        this.buttonsEl = mini.append(this._barEl2, '<div class="mini-page-buttons"></div>');

        this.updateInfo();
    },
    setButtons: function (value) {
        __mini_setControls(value, this.buttonsEl, this);
    },
    getButtonsEl: function () {
        return this.buttonsEl;
    },
    destroy: function (removeEl) {
        if (this.pageSelect) {
            mini.clearEvent(this.pageSelect);
            this.pageSelect = null;
        }
        if (this.numInput) {
            mini.clearEvent(this.numInput);
            this.numInput = null;
        }
        this.sizeEl = null;
        this.buttonsEl = null;

        mini.Pager.superclass.destroy.call(this, removeEl);
    },
    _initEvents: function () {
        mini.Pager.superclass._initEvents.call(this);

        this.firstButton.on(
            'click',
            function (e) {
                this._OnPageChanged(0);
            },
            this
        );
        this.prevButton.on(
            'click',
            function (e) {
                this._OnPageChanged(this.pageIndex - 1);
            },
            this
        );
        this.nextButton.on(
            'click',
            function (e) {
                this._OnPageChanged(this.pageIndex + 1);
            },
            this
        );
        this.lastButton.on(
            'click',
            function (e) {
                this._OnPageChanged(this.totalPage);
            },
            this
        );
        this.reloadButton.on(
            'click',
            function (e) {
                this._OnPageChanged();
            },
            this
        );

        function doPage() {
            if (changing) return;
            changing = true;
            var index = parseInt(this.numInput.value);
            if (isNaN(index)) {
                this.updateInfo();
            } else {
                this._OnPageChanged(index - 1);
            }
            setTimeout(function () {
                changing = false;
            }, 100);
        }

        var changing = false;
        mini.on(
            this.numInput,
            'change',
            function (e) {
                doPage.call(this);
            },
            this
        );

        mini.on(
            this.numInput,
            'keydown',
            function (e) {
                if (e.keyCode == 13) {
                    doPage.call(this);
                    e.stopPropagation();
                }
            },
            this
        );

        this.sizeCombo.on('valuechanged', this.__OnPageSelectChanged, this);
    },

    setPageIndex: function (value) {
        if (isNaN(value)) return;
        this.pageIndex = value;
        this.invalidate();
    },
    getPageIndex: function () {
        return this.pageIndex;
    },
    setPageSize: function (value) {
        if (isNaN(value)) return;
        this.pageSize = value;
        this.invalidate();
    },
    getPageSize: function () {
        return this.pageSize;
    },
    setTotalCount: function (value) {
        value = parseInt(value);
        if (isNaN(value)) return;
        this.totalCount = value;
        this.invalidate();
    },
    getTotalCount: function () {
        return this.totalCount;
    },
    setSizeList: function (value) {
        if (!mini.isArray(value)) return;
        this.sizeList = value;
        this.invalidate();
    },
    getSizeList: function () {
        return this.sizeList;
    },
    setShowPageSize: function (value) {
        this.showPageSize = value;
        this.invalidate();
    },
    getShowPageSize: function () {
        return this.showPageSize;
    },
    setShowPageIndex: function (value) {
        this.showPageIndex = value;
        this.invalidate();
    },
    getShowPageIndex: function () {
        return this.showPageIndex;
    },
    setShowTotalCount: function (value) {
        this.showTotalCount = value;
        this.invalidate();
    },
    getShowTotalCount: function () {
        return this.showTotalCount;
    },
    setShowPageInfo: function (value) {
        this.showPageInfo = value;
        this.invalidate();
    },
    getShowPageInfo: function () {
        return this.showPageInfo;
    },
    setShowReloadButton: function (value) {
        this.showReloadButton = value;
        this.invalidate();
    },
    getShowReloadButton: function () {
        return this.showReloadButton;
    },

    getTotalPage: function () {
        return this.totalPage;
    },

    refresh: function () {
        this.updateInfo();
    },

    updateInfo: function (index, size, total) {
        if (mini.isNumber(index)) this.pageIndex = parseInt(index);
        if (mini.isNumber(size)) this.pageSize = parseInt(size);
        if (mini.isNumber(total)) this.totalCount = parseInt(total);

        this.totalPage = parseInt(this.totalCount / this.pageSize) + 1;
        if ((this.totalPage - 1) * this.pageSize == this.totalCount) {
            this.totalPage -= 1;
        }
        if (this.totalCount == 0) this.totalPage = 0;

        if (this.pageIndex > this.totalPage - 1) {
            this.pageIndex = this.totalPage - 1;
        }
        if (this.pageIndex <= 0) this.pageIndex = 0;
        if (this.totalPage <= 0) this.totalPage = 0;

        this.firstButton.enable();
        this.prevButton.enable();
        this.nextButton.enable();
        this.lastButton.enable();

        if (this.pageIndex == 0) {
            this.firstButton.disable();
            this.prevButton.disable();
        }
        if (this.pageIndex >= this.totalPage - 1) {
            this.nextButton.disable();
            this.lastButton.disable();
        }
        this.numInput.value = this.pageIndex > -1 ? this.pageIndex + 1 : 0;
        this.pagesLabel.innerHTML = '/ ' + this.totalPage;

        var sizeList = this.sizeList.clone();
        if (sizeList.indexOf(this.pageSize) == -1) {
            sizeList.push(this.pageSize);
            sizeList = sizeList.sort(function (a, b) {
                return a > b;
            });
        }
        var sizes = [];
        for (var i = 0, l = sizeList.length; i < l; i++) {
            var num = sizeList[i];
            var option = {};
            option.text = num;
            option.id = num;
            sizes.push(option);
        }
        this.sizeCombo.setData(sizes);
        this.sizeCombo.setValue(this.pageSize);

        var firstText = this.firstText,
            prevText = this.prevText,
            nextText = this.nextText,
            lastText = this.lastText;
        if (this.showButtonText == false) {
            firstText = prevText = nextText = lastText = '';
        }
        this.firstButton.setText(firstText);
        this.prevButton.setText(prevText);
        this.nextButton.setText(nextText);
        this.lastButton.setText(lastText);

        var firstText = this.firstText,
            prevText = this.prevText,
            nextText = this.nextText,
            lastText = this.lastText;
        if (this.showButtonText == true) {
            firstText = prevText = nextText = lastText = '';
        }
        this.firstButton.setTooltip(firstText);
        this.prevButton.setTooltip(prevText);
        this.nextButton.setTooltip(nextText);
        this.lastButton.setTooltip(lastText);

        this.firstButton.setIconCls(this.showButtonIcon ? 'mini-pager-first' : '');
        this.prevButton.setIconCls(this.showButtonIcon ? 'mini-pager-prev' : '');
        this.nextButton.setIconCls(this.showButtonIcon ? 'mini-pager-next' : '');
        this.lastButton.setIconCls(this.showButtonIcon ? 'mini-pager-last' : '');

        this.reloadButton.setIconCls(this.showButtonIcon ? 'mini-pager-reload' : '');
        this.reloadButton.setVisible(this.showReloadButton);

        var s = this.reloadButton.el.previousSibling;
        if (s) {
            s.style.display = this.showReloadButton ? '' : 'none';
        }

        this._rightEl.innerHTML = String.format(this.pageInfoText, this.pageSize, this.totalCount);

        this.indexEl.style.display = this.showPageIndex ? '' : 'none';
        this.sizeEl.style.display = this.showPageSize ? '' : 'none';
        this._rightEl.style.display = this.showPageInfo ? '' : 'none';

        this.invalidateLayout();
    },
    __OnPageSelectChanged: function (e) {
        var size = parseInt(this.sizeCombo.getValue());
        this._OnPageChanged(0, size);
    },
    _OnPageChanged: function (index, size) {
        var e = {
            pageIndex: mini.isNumber(index) ? index : this.pageIndex,
            pageSize: mini.isNumber(size) ? size : this.pageSize,
            cancel: false
        };
        if (e.pageIndex > this.totalPage - 1) {
            e.pageIndex = this.totalPage - 1;
        }
        if (e.pageIndex < 0) e.pageIndex = 0;

        this.fire('beforepagechanged', e);
        if (e.cancel == true) {
            return;
        }

        this.fire('pagechanged', e);
        this.updateInfo(e.pageIndex, e.pageSize);
    },
    onPageChanged: function (fn, scope) {
        this.on('pagechanged', fn, scope);
    },

    getAttrs: function (el) {
        var attrs = mini.Pager.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['onpagechanged', 'sizeList', 'onbeforepagechanged', 'buttons']);
        mini._ParseBool(el, attrs, [
            'showPageIndex',
            'showPageSize',
            'showTotalCount',
            'showPageInfo',
            'showReloadButton'
        ]);
        mini._ParseInt(el, attrs, ['pageIndex', 'pageSize', 'totalCount']);

        if (typeof attrs.sizeList == 'string') {
            attrs.sizeList = eval(attrs.sizeList);
        }
        if (attrs.buttons) {
            attrs.buttons = mini.byId(attrs.buttons);
        }
        return attrs;
    }
});
mini.regClass(mini.Pager, 'pager');

if (typeof mini_doload == 'undefined') {
    mini_doload = function (e) {};
}

mini.StoreBase = mini.Component.extend({
    props: {
        idField: 'id',
        textField: 'text',
        delimiter: ',',
        multiSelect: false,

        url: '',
        autoLoad: false,
        ajaxOptions: null,

        pageSize: 10,
        pageIndex: 0,
        totalCount: 0,
        totalPage: 0,

        sortField: '',
        sortOrder: '',

        loadParams: null,

        sortMode: 'server',

        pageIndexField: 'pageIndex',
        pageSizeField: 'pageSize',
        sortFieldField: 'sortField',
        sortOrderField: 'sortOrder',
        totalField: 'total',
        dataField: 'data',

        startField: '',
        limitField: '',

        errorField: 'error',
        errorMsgField: 'errorMsg',
        stackTraceField: 'stackTrace',
        checkSelectOnLoad: true,
        selectOnLoad: false,

        ajaxData: null,
        ajaxAsync: true,
        ajaxType: ''
    },

    loaded: false,

    initComponent: function () {
        this.callParent('initComponent');
        this._init();
    },

    destroy: function () {
        this.source = [];
        this.dataview = [];
        this.visibleRows = null;
        this.list = null;

        this._ids = {};
        this._removeds = [];
        if (this._clearOriginals) {
            this._originals = {};
        }
        this._errors = {};

        this._selected = null;
        this._selecteds = [];
        this._idSelecteds = {};

        this._filterInfo = null;
        this._sortInfo = null;

        this.root = { _id: -1, _level: -1 };
        this.viewNodes = null;
        this.dataview = null;
        this.visibleRows = null;
        this.list = null;

        this._parentGroupHash = null;
        this._listIndexes = null;

        mini.StoreBase.superclass.destroy.call(this);
    },

    _originalIdField: '_id',
    _clearOriginals: true,
    _autoCreateNewID: false,

    _init: function () {
        this.source = [];
        this.dataview = [];
        this.visibleRows = null;
        this.list = null;

        this._ids = {};
        this._removeds = [];
        if (this._clearOriginals) {
            this._originals = {};
        }
        this._errors = {};

        this._selected = null;
        this._selecteds = [];
        this._idSelecteds = {};

        this.__changeCount = 0;

        this._parentGroupHash = {};
        this._listIndexes = null;
    },
    getSource: function () {
        return this.source;
    },
    getList: function () {
        return this.source;
    },
    getDataView: function () {
        return this.dataview;
    },
    getVisibleRows: function () {
        if (!this.visibleRows) {
            if (this.isGrouped()) {
                this.visibleRows = mini.Group.dataFromGroups(this.groups, true, false);
            } else {
                this.visibleRows = this.getDataView();
            }
        }
        return this.visibleRows;
    },

    indexOfList: function (record) {
        if (!this._listIndexes) {
            this._listIndexes = {};
            var list = this.getList();
            for (var i = 0, l = list.length; i < l; i++) {
                this._listIndexes[list[i]._id] = i;
            }
        }
        var index = this._listIndexes[record._id];
        if (index == null) index = -1;
        return index;
    },

    setData: function (data) {
        this.loadData(data);
    },
    loadData: function (data) {
        if (!mini.isArray(data)) data = [];

        this._init();
        this._doLoadData(data);
        this.refresh();

        this.fire('loaddata');
        return true;
    },
    _doLoadData: function (data) {
        this.source = data;
        this.dataview = data;

        var ds = this.source,
            ids = this._ids;
        for (var i = 0, l = ds.length; i < l; i++) {
            var record = ds[i];

            record._id = mini.StoreBase.RecordId++;
            ids[record._id] = record;

            record._uid = record._id;
        }
    },
    clearData: function () {
        this._init();
        this.refresh();

        this.fire('cleardata');
    },
    clear: function () {
        this.clearData();
    },

    updateRecord: function (record, field, value) {
        if (mini.isNull(record)) return;
        var getMap = mini._getMap,
            setMap = mini._setMap;

        this.fire('beforeupdate', { record: record });

        if (typeof field == 'string') {
            var oldValue = getMap(field, record);
            if (mini.isEquals(oldValue, value)) {
                return false;
            }
            this.beginChange();

            setMap(field, value, record);
            this._setModified(record, field, oldValue);
            this.endChange();
        } else {
            this.beginChange();
            for (var p in field) {
                var oldValue = getMap(p, record);
                var value = field[p];
                if (mini.isEquals(oldValue, value)) continue;

                setMap(p, value, record);
                this._setModified(record, p, oldValue);
            }
            this.endChange('update');
        }

        this.fire('update', { record: record });
    },
    deleteRecord: function (record) {
        this._setDeleted(record);

        this._dataChanged();
        this.fire('delete', { record: record });
    },
    getByInternalId: function (id) {
        id = typeof id == 'object' ? id._id : id;
        return this._ids[id];
    },
    getById: function (id) {
        var t = typeof id;
        if (t == 'number') return this.getAt(id);
        if (typeof id == 'object') {
            if (this.getByInternalId(id)) return id;
            id = id[this.idField];
        }

        id = String(id);

        var idMap = this.ids;
        if (!idMap) {
            idMap = this.ids = {};
            var data = this.getList();
            for (var i = 0, l = data.length; i < l; i++) {
                var o = data[i];
                var oid = o[this.idField];
                if (!mini.isNull(oid)) idMap[oid] = o;
            }
        }
        return idMap[id];
    },

    getsByIds: function (value) {
        if (mini.isNull(value)) value = '';
        value = String(value);
        var nodes = [];
        var ids = String(value).split(',');
        for (var i = 0, l = ids.length; i < l; i++) {
            var node = this.getById(ids[i]);
            if (node) nodes.push(node);
        }
        return nodes;
    },
    getRecord: function (id) {
        if (typeof id == 'object') return id;
        return this.getRow(id);
    },
    getRow: function (index) {
        var t = typeof index;
        if (t == 'string') return this.getById(index);
        else if (t == 'number') return this.getAt(index);
        else if (t == 'object') return index;
    },

    getValueAndText: function (records, delimiter) {
        if (mini.isNull(records)) records = [];
        delimiter = delimiter || this.delimiter;

        if (typeof records == 'string' || typeof records == 'number') {
            records = this.getsByIds(records);
        } else if (!mini.isArray(records)) {
            records = [records];
        }
        var values = [];
        var texts = [];
        for (var i = 0, l = records.length; i < l; i++) {
            var record = records[i];
            if (record) {
                values.push(this.getItemValue(record));
                texts.push(this.getItemText(record));
            }
        }
        return [values.join(delimiter), texts.join(delimiter)];
    },
    getItemValue: function (item) {
        if (!item) return '';
        var t = mini._getMap(this.idField, item);
        return mini.isNull(t) ? '' : String(t);
    },
    getItemText: function (item) {
        if (!item) return '';

        var t = mini._getMap(this.textField, item);
        return mini.isNull(t) ? '' : String(t);
    },

    isModified: function (record, field) {
        var or = this._originals[record[this._originalIdField]];
        if (!or) return false;
        if (mini.isNull(field)) return false;
        return or.hasOwnProperty(field);
    },
    getOldValue: function (record, field) {
        var or = this._originals[record[this._originalIdField]];
        if (!or) return false;
        if (mini.isNull(field)) return or;
        return or[field];
    },
    cellIsModified: function (record, fields = []) {
        return fields.some((field) => {
            return this.isModified(record, field);
        });
    },
    hasRecord: function (record) {
        return !!this.getByInternalId(record);
    },
    findRecords: function (property, value) {
        var ifFn = typeof property == 'function';
        var fn = property;
        var scope = value || this;
        var data = this.source;
        var records = [];
        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];
            if (ifFn) {
                var ret = fn.call(scope, o);
                if (ret == true) {
                    records[records.length] = o;
                }
                if (ret === 1) break;
            } else {
                if (o[property] == value) {
                    records[records.length] = o;
                }
            }
        }
        return records;
    },
    findRecord: function (property, value) {
        var records = this.findRecords(property, value);
        return records[0];
    },
    each: function (fn, scope) {
        var data = this.getDataView();
        scope = scope || this;
        mini.forEach(data, fn, scope);
    },
    getCount: function () {
        return this.getDataView().length;
    },

    __changeCount: 0,
    beginChange: function () {
        this.__changeCount++;
    },
    endChange: function (action, raise) {
        this.__changeCount--;
        if (this.__changeCount < 0) this.__changeCount = 0;
        if ((raise !== false && this.__changeCount == 0) || raise == true) {
            this.__changeCount = 0;
            this._dataChanged(action);
        }
    },
    _dataChanged: function (action) {
        this.ids = null;
        this.visibleRows = null;
        this.list = null;
        this._listIndexes = null;
        if (this.__changeCount == 0) {
            this.fire('datachanged');
        }
    },

    _setAdded: function (record) {
        record._id = mini.StoreBase.RecordId++;

        if (this._autoCreateNewID && !record[this.idField]) {
            record[this.idField] = UUID();
        }

        record._uid = record._id;

        record._state = 'added';
        this._ids[record._id] = record;
        delete this._originals[record[this._originalIdField]];
    },
    _setModified: function (record, field, oldValue) {
        if (record._state != 'added' && record._state != 'deleted' && record._state != 'removed') {
            record._state = 'modified';
            var or = this._getOriginal(record);
            if (!or.hasOwnProperty(field)) {
                or[field] = oldValue;
            }
        }
    },
    _setDeleted: function (record) {
        if (record._state != 'added' && record._state != 'deleted' && record._state != 'removed') {
            record._state = 'deleted';
        }
    },
    _setRemoved: function (record) {
        delete this._ids[record._id];
        if (record._state != 'added' && record._state != 'removed') {
            record._state = 'removed';
            delete this._originals[record[this._originalIdField]];
            this._removeds.push(record);
        }
    },
    _getOriginal: function (record) {
        var rid = record[this._originalIdField];
        var or = this._originals[rid];
        if (!or) {
            or = this._originals[rid] = {};
        }
        return or;
    },

    _selected: null,
    _selecteds: [],
    _idSelecteds: null,

    isSelected: function (id) {
        if (!id) return false;
        if (typeof id != 'string') id = id._id;
        return !!this._idSelecteds[id];
    },
    setSelected: function (record) {
        record = this.getByInternalId(record);
        var selected = this.getSelected();
        if (selected != record) {
            this._selected = record;
            if (record) {
                this.select(record);
            } else {
                this.deselect(this.getSelected());
            }

            this._OnCurrentChanged(record);
        }
    },
    getSelected: function () {
        if (this.isSelected(this._selected)) return this._selected;
        return this._selecteds[0];
    },
    setCurrent: function (record) {
        this.setSelected(record);
    },
    getCurrent: function () {
        return this.getSelected();
    },
    getSelecteds: function () {
        return this._selecteds.clone();
    },
    select: function (record, fireEvent) {
        if (mini.isNull(record)) return;
        this.selects([record], fireEvent);
    },
    deselect: function (record, fireEvent) {
        if (mini.isNull(record)) return;
        this.deselects([record], fireEvent);
    },
    selectAll: function (fireEvent) {
        var items = this.getDataView();

        this.selects(items, fireEvent);
    },
    deselectAll: function (fireEvent) {
        this.deselects(this.getSelecteds(), fireEvent);
    },
    _fireSelect: function (record, name) {
        var e = { record: record, cancel: false };
        this.fire(name, e);
        return !e.cancel;
    },
    selects: function (records, fireEvent) {
        if (!mini.isArray(records)) return;
        records = records.clone();

        if (this.multiSelect == false) {
            this.deselects(this.getSelecteds());
            if (records.length > 0) records.length = 1;
            this._selecteds = [];
            this._idSelecteds = {};
        }

        var _records = [];
        for (var i = 0, l = records.length; i < l; i++) {
            var record = this.getById(records[i]);
            if (!record) continue;
            if (!this.isSelected(record)) {
                if (fireEvent !== false) {
                    if (!this._fireSelect(record, 'beforeselect')) continue;
                }
                this._selecteds.push(record);
                this._idSelecteds[record._id] = record;
                _records.push(record);
                if (fireEvent !== false) {
                    this.fire('select', { record: record });
                }
            }
        }
        this._OnSelectionChanged(records, true, _records, fireEvent);
    },
    deselects: function (records, fireEvent) {
        if (!mini?.isArray(records)) return;
        records = records.clone();
        var _records = [];
        for (var i = records.length - 1; i >= 0; i--) {
            var record = this.getById(records[i]);
            if (!record) continue;
            if (this.isSelected(record)) {
                if (fireEvent !== false) {
                    if (!this._fireSelect(record, 'beforedeselect')) continue;
                }

                delete this._idSelecteds[record._id];
                _records.push(record);
            }
        }

        this._selecteds = [];
        var _idSelecteds = this._idSelecteds;
        for (var i in _idSelecteds) {
            var o = _idSelecteds[i];
            if (o._id) this._selecteds.push(o);
        }

        for (var i = _records.length - 1; i >= 0; i--) {
            var record = this.getById(_records[i]);
            if (!record) continue;

            if (fireEvent !== false) {
                this.fire('deselect', { record: record });
            }
        }
        this._OnSelectionChanged(records, false, _records, fireEvent);
    },
    _OnSelectionChanged: function (records, select, _records, fireEvent) {
        var e = {
            fireEvent: fireEvent,
            records: records,
            select: select,
            selected: this.getSelected(),
            selecteds: this.getSelecteds(),
            _records: _records
        };
        this.fire('SelectionChanged', e);
        this.fire('selectionchange', e);

        var current = this._current;
        var now = this.getCurrent();
        if (current != now) {
            this._current = now;
            this._OnCurrentChanged(now);
        }
    },
    _OnCurrentChanged: function (record) {
        if (this._currentTimer) {
            clearTimeout(this._currentTimer);
        }
        var me = this;
        this._currentTimer = setTimeout(function () {
            me._currentTimer = null;
            var e = { record: record };
            me.fire('CurrentChanged', e);
            me.fire('currentchange', e);
        }, 30);
    },
    _checkSelecteds: function () {
        for (var i = this._selecteds.length - 1; i >= 0; i--) {
            var record = this._selecteds[i];
            var r = this.getByInternalId(record._id);
            if (!r) {
                this._selecteds.removeAt(i);
                delete this._idSelecteds[record._id];
            }
        }
        if (this._selected && this.getByInternalId(this._selected._id) == null) {
            this._selected = null;
        }
    },

    selectPrev: function () {
        var record = this.getSelected();
        if (!record) {
            record = this.getAt(0);
        } else {
            var index = this.indexOf(record);
            record = this.getAt(index - 1);
        }
        if (record) {
            this.deselectAll();
            this.select(record);
            this.setCurrent(record);
        }
    },
    selectNext: function () {
        var record = this.getSelected();
        if (!record) {
            record = this.getAt(0);
        } else {
            var index = this.indexOf(record);
            record = this.getAt(index + 1);
        }
        if (record) {
            this.deselectAll();
            this.select(record);
            this.setCurrent(record);
        }
    },
    selectFirst: function () {
        var record = this.getAt(0);
        if (record) {
            this.deselectAll();
            this.select(record);
            this.setCurrent(record);
        }
    },
    selectLast: function () {
        var data = this.getVisibleRows();
        var record = this.getAt(data.length - 1);
        if (record) {
            this.deselectAll();
            this.select(record);
            this.setCurrent(record);
        }
    },
    getSelectedsId: function (delimiter) {
        var nodes = this.getSelecteds();
        var vts = this.getValueAndText(nodes, delimiter);
        return vts[0];
    },
    getSelectedsText: function (delimiter) {
        var nodes = this.getSelecteds();
        var vts = this.getValueAndText(nodes, delimiter);
        return vts[1];
    },

    isFiltered: function () {
        return !!this._filterInfo;
    },

    isSorted: function () {
        return !!this._sortInfo;
    },

    isGrouped: function () {
        return this.groupFields && this.groupFields.length > 0;
    },

    _updateCount: 0,

    beginUpdate: function () {
        this._updateCount++;
    },

    endUpdate: function () {
        this._updateCount--;
        if (this._updateCount <= 0) {
            this.refresh();
        }
    },

    isUpdating: function () {
        return this._updateCount > 0;
    },

    refresh: function () {
        if (this._updateCount > 0) return;

        this.dataview = null;
        this.viewNodes = null;
        this.groups = null;

        this._doFilter();
        this._doSort();

        var me = this;
        me._parentGroupHash = {};

        function each(items, parentGroup, clear) {
            for (var i = 0, l = items.length; i < l; i++) {
                var item = items[i];

                if (clear) {
                    if (item._group) delete me._ids[item._id];
                } else {
                    if (parentGroup) me._parentGroupHash[item._id] = parentGroup;

                    if (me.isGroupItem(item)) {
                        me._ids[item._id] = item;
                        each(item.isBottomLevel ? item.items : item.groups, item, clear);
                    }
                }
            }
        }

        if (this.groups) each(this.groups, null, true);

        if (this.isGrouped()) {
            this._doGroup();

            this.dataview = mini.Group.dataFromGroups(this.groups, false, true);
            this.groupview = mini.Group.dataFromGroups(this.groups, true, true);
            each(this.groups);
        }

        this.fireEvent('refresh');

        this._dataChanged();
    },

    _doGroup: function () {
        var data = this.dataview;
        this.groups = mini.Group.groupByFields(data, this.groupFields);
    },

    isGroupItem: function (item) {
        return item._group === true;
    },

    getParentGroup: function (item) {
        return this._parentGroupHash[item._id];
    },

    getGroupLevel: function (item) {
        var level = -1;
        while (item) {
            level++;
            item = this.getParentGroup(item);
        }
        return level;
    },

    expandGroupItem: function (item) {
        item.expanded = true;
        this._dataChanged();
        this.fireEvent('groupitemexpand', { item: item });
    },

    collapseGroupItem: function (item) {
        item.expanded = false;
        this._dataChanged();
        this.fireEvent('groupitemcollapse', { item: item });
    },

    toggleGroupItem: function (item) {
        if (item.expanded) this.collapseGroupItem(item);
        else this.expandGroupItem(item);
    },

    group: function (groupFields) {
        this.groupFields = groupFields;
        this.refresh();
    },

    clearGroup: function () {
        this.groupFields = null;
        this.refresh();
    },

    _filterInfo: null,
    _sortInfo: null,
    filter: function (fn, scope) {
        if (typeof fn != 'function') return;
        scope = scope || this;

        this._filterInfo = [fn, scope];

        this.refresh();

        this.fire('filter');
    },

    clearFilter: function () {
        if (!this._filterInfo) return;
        this._filterInfo = null;
        this.refresh();

        this.fire('clearfilter');
    },
    sort: function (fn, scope, reverse) {
        if (typeof fn != 'function') return;
        scope = scope || this;
        this._sortInfo = [fn, scope, reverse];
        this.refresh();

        this.fire('sort');
    },
    clearSort: function () {
        this._sortInfo = null;

        this.sortField = this.sortOrder = '';

        this.refresh();

        if (this.sortMode == 'server') {
            var params = this.getLoadParams();
            params.sortField = '';
            params.sortOrder = '';

            this.load(params);
        } else {
        }

        this.fire('clearsort');
    },

    _sortMulti: function (fields) {},

    _doClientSortField: function (sortField, sortOrder, dataType) {
        var sortFn = this._getSortFnByField(sortField, dataType);
        if (!sortFn) return;

        var reverse = sortOrder == 'desc';
        this.sort(sortFn, this, reverse);
    },
    _getSortFnByField: function (field, sortType) {
        if (!field) return null;
        var sortFn = null;
        var typeFn = mini.sortTypes[sortType];
        if (!typeFn) typeFn = mini.sortTypes['string'];

        function sortBy(a, b) {
            var a1 = mini._getMap(field, a),
                b1 = mini._getMap(field, b);

            var nullA = mini.isNull(a1) || a1 === '';
            var nullB = mini.isNull(b1) || b1 === '';
            if (nullA) return 0;
            if (nullB) return 1;

            if (sortType == 'chinese') {
                return a1.localeCompare(b1, 'zh');
            }

            var v1 = typeFn(a1);
            var v2 = typeFn(b1);
            if (v1 > v2) return 1;
            else return 0;
        }

        sortFn = sortBy;
        return sortFn;
    },

    getLoadParams: function () {
        return this.loadParams || {};
    },

    load: function (params, success, error, complete) {
        if (typeof params == 'string') {
            this.setUrl(params);
            return;
        }
        if (this._loadTimer) clearTimeout(this._loadTimer);
        this.loadParams = params || {};
        if (!mini.isNumber(this.loadParams.pageIndex)) this.loadParams.pageIndex = 0;

        if (this._xhr) {
            this._xhr.abort();
        }
        if (this.ajaxAsync && mini_ajaxAsyncInvoke) {
            var me = this;
            this._loadTimer = setTimeout(function () {
                me._doLoadAjax(me.loadParams, success, error, complete);
                me._loadTimer = null;
            }, 1);
        } else {
            this._doLoadAjax(this.loadParams, success, error, complete);
        }
    },
    reload: function (success, error, complete) {
        this.load(this.loadParams, success, error, complete);
    },
    gotoPage: function (index, size) {
        var params = this.loadParams || {};
        if (mini.isNumber(index)) params.pageIndex = index;
        if (mini.isNumber(size)) params.pageSize = size;
        this.load(params);
    },
    sortBy: function (sortField, sortOrder) {
        this.sortField = sortField;
        this.sortOrder = sortOrder == 'asc' ? 'asc' : 'desc';
        if (this.sortMode == 'server') {
            var params = this.getLoadParams();
            params.sortField = sortField;
            params.sortOrder = sortOrder;
            params.pageIndex = this.pageIndex;
            this.load(params);
        } else {
        }
    },

    setSortField: function (value) {
        this.sortField = value;
        if (this.sortMode == 'server') {
            var params = this.getLoadParams();
            params.sortField = value;
        }
    },
    setSortOrder: function (value) {
        this.sortOrder = value;
        if (this.sortMode == 'server') {
            var params = this.getLoadParams();
            params.sortOrder = value;
        }
    },

    _doLoadAjax: function (params, success, errorFn, complete, _successHandler) {
        params = params || {};
        if (mini.isNull(params.pageIndex)) params.pageIndex = this.pageIndex;
        if (mini.isNull(params.pageSize)) params.pageSize = this.pageSize;

        if (params.sortField) this.sortField = params.sortField;
        if (params.sortOrder) this.sortOrder = params.sortOrder;
        params.sortField = this.sortField;
        params.sortOrder = this.sortOrder;

        this.loadParams = params;

        var url = this._evalUrl();
        var type = this._evalType(url);

        var obj = mini._evalAjaxData(this.ajaxData, this);

        jQuery.extend(true, params, obj);

        var e = {
            url: url,
            async: this.ajaxAsync,
            type: type,
            data: params,
            params: params,
            cache: false,
            cancel: false
        };

        jQuery.extend(true, e, this.ajaxOptions);

        this._OnBeforeLoad(e);
        if (e.cancel == true) {
            params.pageIndex = this.getPageIndex();
            params.pageSize = this.getPageSize();
            return;
        }

        if (e.data != e.params && e.params != params) {
            e.data = e.params;
        }

        if (e.url != url && e.type == type) {
            e.type = this._evalType(e.url);
        }

        var o = {};
        o[this.pageIndexField] = params.pageIndex;
        o[this.pageSizeField] = params.pageSize;
        if (params.sortField) o[this.sortFieldField] = params.sortField;
        if (params.sortOrder) o[this.sortOrderField] = params.sortOrder;

        if (this.startField && this.limitField) {
            o[this.startField] = params.pageIndex * params.pageSize;
            o[this.limitField] = params.pageSize;
        }

        jQuery.extend(true, params, o);
        jQuery.extend(true, e.data, o);

        if (this.sortMode == 'client') {
            params[this.sortFieldField] = '';
            params[this.sortOrderField] = '';
        }

        var selected = this.getSelected();
        this._currentSelectValue = selected ? selected[this.idField] : null;
        if (mini.isNumber(this._currentSelectValue)) this._currentSelectValue = String(this._currentSelectValue);

        var selecteds = this.getSelecteds();
        var _selectsArr = [];
        for (var i = 0, l = selecteds.length; i < l; i++) {
            var id = selecteds[i][this.idField];
            if (!mini.isNull(id)) id = String(id);
            _selectsArr.push(id);
        }
        this._selectedValue = _selectsArr.length == 0 ? null : _selectsArr;
        if (mini.isNumber(this._selectedValue)) this._selectedValue = String(this._selectedValue);

        var me = this;
        me._resultObject = null;

        var async = e.async;
        mini.copyTo(e, {
            success: function (text, textStatus, xhr) {
                if (!text || text == 'null') {
                    text = '{ total: 0, data: [] }';
                }

                delete e.params;
                var obj = { text: text, result: null, sender: me, options: e, xhr: xhr };
                var result = null;
                try {
                    mini_doload(obj);
                    result = obj.result;
                    if (!result) {
                        result = mini.decode(text);
                    }
                } catch (ex) {
                    if (mini_debugger == true) {
                        alert(url + '\n json is error.');
                    }
                }

                if (result && !mini.isArray(result)) {
                    result.total = parseInt(mini._getMap(me.totalField, result));

                    result.data = mini._getMap(me.dataField, result);
                } else {
                    if (result == null) {
                        result = {};
                        result.data = [];
                        result.total = 0;
                    } else if (mini.isArray(result)) {
                        var r = {};
                        r.data = result;
                        r.total = result.length;
                        result = r;
                    }
                }
                if (!result.data) result.data = [];
                if (!result.total) result.total = 0;
                me._resultObject = result;

                if (!mini.isArray(result.data)) {
                    result.data = [result.data];
                }

                var ex = {
                    xhr: xhr,
                    text: text,
                    textStatus: textStatus,
                    result: result,
                    total: result.total,
                    data: result.data.clone(),

                    pageIndex: params[me.pageIndexField],
                    pageSize: params[me.pageSizeField]
                };

                var error = mini._getMap(me.errorField, result);
                var errorMsg = mini._getMap(me.errorMsgField, result);
                var stackTrace = mini._getMap(me.stackTraceField, result);

                if ((mini.isNumber(error) && error != 0) || error === false) {
                    ex.textStatus = 'servererror';
                    ex.errorCode = error;
                    ex.stackTrace = stackTrace || '';
                    ex.errorMsg = errorMsg || '';
                    if (mini_debugger == true) {
                        alert(url + '\n' + ex.textStatus + '\n' + ex.errorMsg + '\n' + ex.stackTrace);
                    }
                    me.fire('loaderror', ex);
                    if (errorFn) errorFn.call(me, ex);
                } else {
                    if (ex.pageIndex > 0 && ex.data.length == 0) {
                        me.gotoPage(ex.pageIndex - 1);
                        return;
                    }

                    if (_successHandler) {
                        _successHandler(ex);
                    } else {
                        me.pageIndex = ex.pageIndex;
                        me.pageSize = ex.pageSize;
                        me.setTotalCount(ex.total);

                        me._OnPreLoad(ex);

                        me.loaded = true;

                        var sss = new Date();

                        me.setData(ex.data);

                        if (me._selectedValue && me.checkSelectOnLoad) {
                            var selects = [];
                            var _selects = me._selectedValue;
                            if (_selects.length > 0) {
                                for (var i = 0, l = _selects.length; i < l; i++) {
                                    var o = me.getById(_selects[i]);
                                    if (o) {
                                        selects.push(o);
                                    }
                                }

                                if (selects.length) me.selects(selects);

                                me._selected = me.getById(me._currentSelectValue);
                            }
                        }

                        if (me.getSelected() == null && me.selectOnLoad && me.getDataView().length > 0) {
                            me.select(0);
                        }
                        me.fire('load', ex);

                        if (success) {
                            if (async) {
                                setTimeout(function () {
                                    success.call(me, ex);
                                }, 20);
                            } else {
                                success.call(me, ex);
                            }
                        }
                    }
                }
            },
            error: function (xhr, textStatus, errorThrown) {
                if (textStatus == 'abort') return;

                var ex = {
                    xhr: xhr,
                    text: xhr.responseText,
                    textStatus: textStatus
                };
                ex.errorMsg = xhr.responseText;
                ex.errorCode = xhr.status;

                if (mini_debugger == true) {
                    alert(url + '\n' + ex.errorCode + '\n' + ex.errorMsg);
                }

                me.fire('loaderror', ex);
                if (errorFn) errorFn.call(me, ex);
            },
            complete: function (xhr, textStatus) {
                var ex = {
                    xhr: xhr,
                    text: xhr.responseText,
                    textStatus: textStatus
                };
                me.fire('loadcomplete', ex);
                if (complete) complete.call(me, ex);
                me._xhr = null;
            }
        });
        if (this._xhr) {
        }
        this._xhr = mini.ajax(e);
    },
    _OnBeforeLoad: function (e) {
        this.fire('beforeload', e);
    },
    _OnPreLoad: function (e) {
        this.fire('preload', e);
    },
    _evalUrl: function () {
        var url = this.url;
        if (typeof url == 'function') {
            url = url();
        } else {
            try {
                url = window['ev' + 'al'](url);
            } catch (ex) {
                url = this.url;
            }
            if (!url) {
                url = this.url;
            }
        }
        return url;
    },
    _evalType: function (url) {
        var type = this.ajaxType;
        if (!type) {
            type = 'post';
            if (url) {
                if (url.indexOf('.txt') != -1 || url.indexOf('.json') != -1) {
                    type = 'get';
                }
            } else {
                type = 'get';
            }
        }
        return type;
    },

    setUrl: function (value) {
        this.url = value;
        if (this.autoLoad && value) {
            this.load();
        }
    },

    setPageIndex: function (value) {
        this.pageIndex = value;

        var params = this.loadParams || {};
        if (mini.isNumber(value)) params.pageIndex = value;

        this.fire('pageinfochanged');
    },

    setPageSize: function (value) {
        this.pageSize = value;

        var params = this.loadParams || {};
        if (mini.isNumber(value)) params.pageSize = value;

        this.fire('pageinfochanged');
    },

    setTotalCount: function (value) {
        this.totalCount = parseInt(value);
        this.fire('pageinfochanged');
    }
});

mini.StoreBase.GroupItemId = 1;
mini.StoreBase.RecordId = 1;
mini.DataSource = mini.StoreBase;
mini.StoreBase.prototype.getby_id = mini.StoreBase.prototype.getByInternalId;
mini.StoreBase.prototype.getbyId = mini.StoreBase.prototype.getById;

mini.Store = mini.StoreBase.extend({
    type: 'store',

    _init: function () {
        mini.Store.superclass._init.call(this);
        this._filterInfo = null;
        this._sortInfo = null;
    },
    add: function (record) {
        return this.insert(this.source.length, record);
    },
    addRange: function (records) {
        this.insertRange(this.source.length, records);
    },
    insert: function (index, record) {
        if (this.isGrouped()) return false;
        if (!record) return null;
        if (!mini.isNumber(index)) {
            var insertRow = this.getRecord(index);
            if (insertRow) {
                index = this.indexOf(insertRow);
            } else {
                index = this.dataview.length;
            }
        }

        var e = {
            index: index,
            record: record
        };

        this.fire('beforeadd', e);

        var target = this.dataview[index];
        if (target) {
            this.dataview.insert(index, record);
        } else {
            this.dataview.push(record);
        }

        if (this.dataview != this.source) {
            if (target) {
                var sourceIndex = this.source.indexOf(target);
                this.source.insert(sourceIndex, record);
            } else {
                this.source.push(record);
            }
        }

        this._setAdded(record);

        this._dataChanged();

        this.fire('add', e);
    },
    insertRange: function (index, records) {
        if (this.isGrouped()) return false;
        if (!mini.isArray(records)) return;

        if (!mini.isNumber(index)) index = this.dataview.length;

        this.beginChange();
        records = records.clone();
        for (var i = 0, l = records.length; i < l; i++) {
            var record = records[i];
            this.insert(index + i, record);
        }
        this.endChange();
    },
    remove: function (record, autoSelect) {
        var index = this.indexOf(record);
        return this.removeAt(index, autoSelect);
    },
    removeAt: function (index, autoSelect) {
        var record = this.getAt(index);
        if (!record || this.isGroupItem(record)) return null;

        var e = {
            record: record
        };
        this.fire('beforeremove', e);

        var isSelected = this.isSelected(record);

        this.dataview.remove(record);

        if (this.dataview !== this.source) {
            this.source.remove(record);
        }

        if (this.isGrouped()) {
            var parentGroup = this.getParentGroup(record);

            parentGroup.items.remove(record);
        }

        this._setRemoved(record);

        this._checkSelecteds();

        this._dataChanged();

        this.fire('remove', e);

        if (isSelected && autoSelect) {
            var newSelected = this.getAt(index);
            if (!newSelected) newSelected = this.getAt(index - 1);
            this.deselectAll();
            this.select(newSelected);
        }
    },

    removeRange: function (records, autoSelect) {
        if (!mini.isArray(records)) return;
        this.beginChange();
        records = records.clone();

        for (var i = 0, l = records.length; i < l; i++) {
            var o = records[i];
            if (this.isGroupItem(o)) continue;
            this.remove(o, autoSelect);
        }

        this._dataChanged();

        this.endChange();
    },

    move: function (record, newIndex) {
        if (this.isGrouped()) return false;

        if (!record || !mini.isNumber(newIndex)) return;
        if (newIndex < 0) return;
        if (mini.isArray(record)) {
            this.beginChange();

            var rs = record,
                targetRecord = this.getAt(newIndex);
            var sf = this;
            mini.sort(
                rs,
                function (a, b) {
                    return sf.indexOf(a) > sf.indexOf(b);
                },
                this
            );
            for (var i = 0, l = rs.length; i < l; i++) {
                var r = rs[i];
                var index = this.indexOf(targetRecord);
                this.move(r, index);
            }
            this.endChange();
            return;
        }

        var e = {
            index: newIndex,
            record: record
        };
        this.fire('beforemove', e);

        var target = this.dataview[newIndex];

        this.dataview.remove(record);

        var _index = this.dataview.indexOf(target);
        if (_index != -1) {
            newIndex = _index;
        }
        if (target) {
            this.dataview.insert(newIndex, record);
        } else {
            this.dataview.push(record);
        }

        if (this.dataview != this.source) {
            this.source.remove(record);
            var _index = this.source.indexOf(target);
            if (_index != -1) {
                newIndex = _index;
            }
            if (target) {
                this.source.insert(newIndex, record);
            } else {
                this.source.add(record);
            }
        }

        this._dataChanged();

        this.fire('move', e);
    },

    indexOf: function (record) {
        return this.getVisibleRows().indexOf(record);
    },
    getAt: function (index) {
        return this.getVisibleRows()[index];
    },
    getCount: function () {
        return this.getVisibleRows().length;
    },

    getRange: function (start, end) {
        if (start > end) {
            var t = start;
            start = end;
            end = t;
        }
        var range = [];
        for (var i = start, l = end; i <= l; i++) {
            var o = this.dataview[i];
            range.push(o);
        }
        return range;
    },
    selectRange: function (start, end) {
        if (!mini.isNumber(start)) start = this.indexOf(start);
        if (!mini.isNumber(end)) end = this.indexOf(end);
        if (mini.isNull(start) || mini.isNull(end)) return;

        var rs = this.getRange(start, end);
        this.selects(rs);
    },
    toArray: function () {
        return this.source;
    },

    isChanged: function () {
        return this.getChanges().length > 0;
    },

    getChanges: function (rowState, onlyField) {
        var changes = [];
        if (rowState == 'removed' || rowState == null) {
            changes.addRange(this._removeds.clone());
        }
        for (var i = 0, l = this.source.length; i < l; i++) {
            var record = this.source[i];
            if (!record._state) continue;
            if (record._state == rowState || rowState == null) {
                changes[changes.length] = record;
            }
        }

        var rows = changes;
        if (onlyField) {
            for (var i = 0, l = rows.length; i < l; i++) {
                var row = rows[i];
                if (row._state == 'modified') {
                    var newRow = {};
                    newRow._state = row._state;
                    newRow[this.idField] = row[this.idField];
                    for (var field in row) {
                        var modifed = this.isModified(row, field);
                        if (modifed) {
                            newRow[field] = row[field];
                        }
                    }
                    rows[i] = newRow;
                }
            }
        }

        var grid = this;
        mini.sort(changes, function (a, b) {
            var index1 = grid.indexOf(a);
            var index2 = grid.indexOf(b);
            if (index1 > index2) return 1;
            if (index1 < index2) return -1;
            return 0;
        });
        return changes;
    },

    accept: function () {
        this.beginChange();
        for (var i = 0, l = this.source.length; i < l; i++) {
            var record = this.source[i];
            this.acceptRecord(record);
        }
        this._removeds = [];
        this._originals = {};
        this.endChange();
    },
    reject: function () {
        this.beginChange();
        var data = this.source.clone();
        for (var i = 0, l = data.length; i < l; i++) {
            var record = data[i];
            this.rejectRecord(record);
        }
        this._removeds = [];
        this._originals = {};
        this.endChange();
    },
    acceptRecord: function (node) {
        if (!node._state) return;
        delete this._originals[node[this._originalIdField]];
        if (node._state == 'deleted') {
            this.remove(node);
        } else {
            delete node._state;
            delete this._originals[node[this._originalIdField]];
            this._dataChanged();
        }
        this.fire('update', { record: node });
    },
    rejectRecord: function (node) {
        if (!node._state) return;
        if (node._state == 'added') {
            this.remove(node);
        } else if (node._state == 'modified' || node._state == 'deleted') {
            var or = this._getOriginal(node);

            for (var field in or) {
                var val = or[field];
                mini._setMap(field, val, node);
            }

            delete node._state;
            delete this._originals[node[this._originalIdField]];
            this._dataChanged();
            this.fire('update', { record: node });
        }
    },

    _doFilter: function () {
        if (!this._filterInfo) {
            this.dataview = this.source;
            return;
        }
        var fn = this._filterInfo[0],
            scope = this._filterInfo[1];
        var view = [];
        var data = this.source;
        for (var i = 0, l = data.length; i < l; i++) {
            var r = data[i];
            var add = fn.call(scope, r, i, this);
            if (add !== false) {
                view.push(r);
            }
        }
        this.dataview = view;
    },
    _doSort: function () {
        if (!this._sortInfo) return;
        var fn = this._sortInfo[0],
            scope = this._sortInfo[1],
            reverse = this._sortInfo[2];
        var dv = this.getDataView().clone();

        mini.sort(dv, fn, scope);
        if (reverse) dv.reverse();

        this.dataview = dv;
    }
});

mini.regClass(mini.Store, 'datatable');

mini.DataTable = mini.Store;

mini.TreeStore = mini.StoreBase.extend({
    type: 'treestore',
    isTree: true,

    props: {
        expandOnLoad: false,
        idField: 'id',
        parentField: 'pid',
        nodesField: 'children',
        checkedField: 'checked',
        resultAsTree: true,
        dataField: '',
        checkModel: 'cascade',
        autoCheckParent: false,
        onlyLeafCheckable: false
    },

    setCheckRecursive: function (value) {
        this.checkModel = value ? 'cascade' : 'multiple';
    },
    getCheckRecursive: function () {
        return this.checkModel == 'cascade';
    },
    setShowFolderCheckBox: function (value) {
        this.onlyLeafCheckable = !value;
    },
    getShowFolderCheckBox: function () {
        return !this.onlyLeafCheckable;
    },
    _doExpandOnLoad: function (nodes) {
        var nodesField = this.nodesField;
        var expandOnLoad = this.expandOnLoad;

        function eachNodes(nodes, level) {
            for (var i = 0, l = nodes.length; i < l; i++) {
                var node = nodes[i];

                if (mini.isNull(node.expanded)) {
                    if (expandOnLoad === true || (mini.isNumber(expandOnLoad) && level <= expandOnLoad)) {
                        node.expanded = true;
                    } else {
                        node.expanded = false;
                    }
                } else {
                }

                var childs = node[nodesField];
                if (childs) {
                    eachNodes(childs, level + 1);
                }
            }
        }
        eachNodes(nodes, 0);
    },

    _OnBeforeLoad: function (e) {
        var node = this._loadingNode || this.root;
        e.node = node;

        if (this._isNodeLoading()) {
            e.async = true;
            e.isRoot = e.node == this.root;
            if (!e.isRoot) {
                e.data[this.idField] = this.getItemValue(e.node);
            }
        }
        this.fire('beforeload', e);
    },
    _OnPreLoad: function (e) {
        if (this.resultAsTree == false) {
            e.data = mini.arrayToTree(e.data, this.nodesField, this.idField, this.parentField);
        }
        this.fire('preload', e);
    },

    rootVisible: false,
    setRootVisible: function (value) {
        this.rootVisible = value;
        this._dataChanged();
    },

    _init: function () {
        mini.TreeStore.superclass._init.call(this);
        this.root = { _id: -1, _level: -1, expanded: true };
        this.source = this.root[this.nodesField] = [];
        this.viewNodes = null;
        this.dataview = null;
        this.visibleRows = null;
        this.list = null;

        this._ids[this.root._id] = this.root;
    },
    _doLoadData: function (data) {
        data = data || [];

        this._doExpandOnLoad(data);

        this.source = this.root[this.nodesField] = data;
        this.viewNodes = null;
        this.dataview = null;
        this.visibleRows = null;
        this.list = null;

        var sss = new Date();

        var ds = mini.treeToArray(data, this.nodesField);

        var ids = this._ids;
        ids[this.root._id] = this.root;

        var RecordId = mini.DataSource.RecordId;
        for (var i = 0, l = ds.length; i < l; i++) {
            var node = ds[i];

            node._id = RecordId++;
            ids[node._id] = node;

            node._uid = node._id;
        }
        mini.DataSource.RecordId = RecordId;

        var checkedField = this.checkedField;
        var ds = mini.treeToArray(data, this.nodesField, '_id', '_pid', this.root._id);

        this.list = ds;

        var ids = this._ids,
            node,
            parentNode,
            checked;
        for (var i = 0, l = ds.length; i < l; i++) {
            node = ds[i];

            parentNode = ids[node._pid];

            node._level = parentNode._level + 1;
            if (node._state) delete node._state;

            checked = node[checkedField];
            if (checked) {
                node.checked = checked;
                if (node.checked) {
                    node.checked = node.checked != 'false';
                }
            }
        }

        this._doUpdateLoadedCheckedNodes();
    },
    _setAdded: function (node) {
        var parentNode = this.getParentNode(node);
        node._id = mini.DataSource.RecordId++;

        if (this._autoCreateNewID && !node[this.idField]) {
            node[this.idField] = UUID();
        }

        node._uid = node._id;

        node._pid = parentNode._id;
        if (parentNode[this.idField]) {
            node[this.parentField] = parentNode[this.idField];
        }
        node._level = parentNode._level + 1;
        node._state = 'added';
        this._ids[node._id] = node;
        delete this._originals[node[this._originalIdField]];
    },
    _createNodes: function (node) {
        var nodes = node[this.nodesField];
        if (!nodes) {
            nodes = node[this.nodesField] = [];
        }
        if (this.viewNodes && !this.viewNodes[node._id]) {
            this.viewNodes[node._id] = [];
        }
        return nodes;
    },

    addNode: function (node, parentNode) {
        if (!node) return;
        return this.insertNode(node, -1, parentNode);
    },
    addNodes: function (nodes, parentNode, action) {
        if (!mini.isArray(nodes)) return;
        if (mini.isNull(action)) action = 'add';
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            this.insertNode(node, action, parentNode);
        }
    },
    insertNodes: function (nodes, index, parentNode) {
        if (!mini.isNumber(index)) return;
        if (!mini.isArray(nodes)) return;
        if (!parentNode) parentNode = this.root;
        this.beginChange();

        var pnodes = this._createNodes(parentNode);
        if (index < 0 || index > pnodes.length) index = pnodes.length;

        nodes = nodes.clone();
        for (var i = 0, l = nodes.length; i < l; i++) {
            this.insertNode(nodes[i], index + i, parentNode);
        }

        this.endChange();
        return nodes;
    },
    removeNode: function (node) {
        var parentNode = this.getParentNode(node);
        if (!parentNode) return;
        var nodes = this.getChildNodes(parentNode, false, false);
        var index = nodes.indexOf(node);

        return this.removeNodeAt(index, parentNode);
    },
    removeNodes: function (nodes) {
        if (!mini.isArray(nodes)) return;
        this.beginChange();
        nodes = nodes.clone();
        for (var i = 0, l = nodes.length; i < l; i++) {
            this.removeNode(nodes[i]);
        }
        this.endChange();
    },
    moveNodes: function (nodes, targetNode, action) {
        if (!nodes || nodes.length == 0 || !targetNode || !action) return;
        this.beginChange();
        var sf = this;
        mini.sort(
            nodes,
            function (a, b) {
                return sf.indexOf(a) > sf.indexOf(b);
            },
            this
        );
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            this.moveNode(node, targetNode, action);
            if (i != 0) {
                targetNode = node;
                action = 'after';
            }
        }
        this.endChange();
    },

    moveNode: function (node, targetNode, action) {
        if (!node || !targetNode || mini.isNull(action)) return;

        if (this.viewNodes) {
            var parentNode = targetNode;
            var index = action;
            if (index == 'before') {
                parentNode = this.getParentNode(targetNode);
                index = this.indexOfNode(targetNode);
            } else if (index == 'after') {
                parentNode = this.getParentNode(targetNode);
                index = this.indexOfNode(targetNode) + 1;
            } else if (index == 'add' || index == 'append') {
                if (!parentNode[this.nodesField]) parentNode[this.nodesField] = [];
                index = parentNode[this.nodesField].length;
            } else if (!mini.isNumber(index)) {
                return;
            }
            if (this.isAncestor(node, parentNode)) {
                return false;
            }

            var childNodes = this.viewNodes[parentNode._id];
            if (!childNodes) childNodes = this.viewNodes[parentNode._id] = [];

            var childNodes = this.getChildNodes(parentNode);
            if (index < 0 || index > childNodes.length) index = childNodes.length;

            var ___node = {};
            childNodes.insert(index, ___node);

            var oldParentNode = this.getParentNode(node);
            var oldChildNodes = this.getChildNodes(oldParentNode);
            oldChildNodes.remove(node);

            index = childNodes.indexOf(___node);
            childNodes[index] = node;
        }

        var parentNode = targetNode;
        var index = action;
        var childNodes = this._createNodes(parentNode);

        if (index == 'before') {
            parentNode = this.getParentNode(targetNode);
            childNodes = this._createNodes(parentNode);
            index = childNodes.indexOf(targetNode);
        } else if (index == 'after') {
            parentNode = this.getParentNode(targetNode);
            childNodes = this._createNodes(parentNode);
            index = childNodes.indexOf(targetNode) + 1;
        } else if (index == 'add' || index == 'append') {
            index = childNodes.length;
        } else if (!mini.isNumber(index)) {
            return;
        }
        if (this.isAncestor(node, parentNode)) {
            return false;
        }

        if (index < 0 || index > childNodes.length) index = childNodes.length;

        var ___node = {};
        childNodes.insert(index, ___node);

        var oldParentNode = this.getParentNode(node);
        oldParentNode[this.nodesField].remove(node);

        index = childNodes.indexOf(___node);
        childNodes[index] = node;

        this._updateParentAndLevel(node, parentNode);

        this._dataChanged();
        var e = {
            oldParentNode: oldParentNode,
            parentNode: parentNode,
            index: index,
            node: node
        };

        this.fire('movenode', e);
    },

    insertNode: function (node, index, parentNode) {
        if (!node) return;
        if (!parentNode) {
            parentNode = this.root;
            index = 'add';
        }
        if (!mini.isNumber(index)) {
            switch (index) {
                case 'before':
                    index = this.indexOfNode(parentNode);
                    parentNode = this.getParentNode(parentNode);
                    node = this.insertNode(node, index, parentNode);
                    break;
                case 'after':
                    index = this.indexOfNode(parentNode);
                    parentNode = this.getParentNode(parentNode);
                    node = this.insertNode(node, index + 1, parentNode);
                    break;
                case 'append':
                case 'add':
                    node = this.addNode(node, parentNode);
                    break;
                default:
                    break;
            }
            return node;
        }

        var nodes2 = this._createNodes(parentNode);
        var nodes = this.getChildNodes(parentNode);
        if (index < 0 || index > nodes.length) index = nodes.length;

        nodes.insert(index, node);

        if (this.viewNodes) {
            var preNode = nodes[index - 1];
            if (preNode) {
                var index2 = nodes2.indexOf(preNode);
                nodes2.insert(index2 + 1, node);
            } else {
                nodes2.insert(0, node);
            }
        }

        node._pid = parentNode._id;
        this._setAdded(node);

        var me = this;
        var children = node[this.nodesField];
        if (children) {
            function each(children, p) {
                for (var i = 0, l = children.length; i < l; i++) {
                    var n = children[i];
                    n._pid = p._id;
                    me._setAdded(n);
                    if (n[me.nodesField]) each(n[me.nodesField], n);
                }
            }
            each(children, node);
        }

        this._dataChanged();
        var e = {
            parentNode: parentNode,
            index: index,
            node: node
        };
        this.fire('addnode', e);
        return node;
    },
    removeNodeAt: function (index, parentNode) {
        if (!parentNode) parentNode = this.root;

        var nodes = this.getChildNodes(parentNode, false, false);
        var node = nodes[index];
        if (!node) return null;

        nodes.removeAt(index);
        if (this.viewNodes) {
            var nodes2 = parentNode[this.nodesField];
            nodes2.remove(node);

            var childNodes = this.viewNodes[parentNode._id];
            if (childNodes) {
                mini.Array.remove(childNodes, node);
            }
        }

        if (this.isGrouped()) {
            var parentGroup = this.getParentGroup(node);
            parentGroup.items.remove(node);
        }

        this._setRemoved(node);
        this.cascadeChild(
            node,
            function (n, i, p) {
                this._setRemoved(n);
            },
            this
        );

        this._checkSelecteds();

        this._dataChanged();
        var e = {
            parentNode: parentNode,
            index: index,
            node: node
        };
        this.fire('removenode', e);

        return node;
    },

    bubbleParent: function (node, fn, scope) {
        scope = scope || this;
        if (node) fn.call(this, node);
        var parentNode = this.getParentNode(node);
        if (parentNode && parentNode != this.root) {
            this.bubbleParent(parentNode, fn, scope);
        }
    },

    cascadeChild: function (node, fn, scope) {
        if (!fn) return;
        if (!node) node = this.root;

        var nodes = this.getChildNodes(node);
        if (nodes) {
            nodes = nodes.clone();
            for (var i = 0, l = nodes.length; i < l; i++) {
                var c = nodes[i];
                if (fn.call(scope || this, c, i, node) === false) return;
                this.cascadeChild(c, fn, scope);
            }
        }
    },

    eachChild: function (node, fn, scope) {
        if (!fn || !node) return;
        var nodes = node[this.nodesField];
        if (nodes) {
            var list = nodes.clone();
            for (var i = 0, l = list.length; i < l; i++) {
                var o = list[i];
                if (fn.call(scope || this, o, i, node) === false) break;
            }
        }
    },

    collapse: function (node, deep) {
        node = this.getNode(node);
        if (!node) return;
        this.beginChange();

        node.expanded = false;
        if (deep) {
            this.eachChild(
                node,
                function (o) {
                    if (o[this.nodesField] != null) {
                        this.collapse(o, deep);
                    }
                },
                this
            );
        }

        this.endChange('collapse');

        var e = {
            node: node
        };
        this.fire('collapse', e);
    },
    expand: function (node, deep) {
        node = this.getNode(node);
        if (!node) return;
        this.beginChange();

        node.expanded = true;
        if (deep) {
            this.eachChild(
                node,
                function (o) {
                    if (o[this.nodesField] != null) {
                        this.expand(o, deep);
                    }
                },
                this
            );
        }

        this.endChange('expand');

        var e = {
            node: node
        };
        this.fire('expand', e);
    },
    toggle: function (node) {
        if (this.isExpandedNode(node)) this.collapse(node);
        else this.expand(node);
    },
    expandNode: function (node) {
        this.expand(node);
    },
    collapseNode: function (node) {
        this.collapse(node);
    },
    collapseAll: function () {
        this.collapse(this.root, true);
    },
    expandAll: function () {
        this.expand(this.root, true);
    },
    collapseLevel: function (level, deep) {
        this.beginChange();
        this.each(function (node) {
            var nodeLevel = this.getLevel(node);
            if (level == nodeLevel) {
                this.collapse(node, deep);
            }
        }, this);
        this.endChange();
    },
    expandLevel: function (level, deep) {
        this.beginChange();
        this.each(function (node) {
            var nodeLevel = this.getLevel(node);
            if (level == nodeLevel) {
                this.expand(node, deep);
            }
        }, this);
        this.endChange();
    },
    expandPath: function (node) {
        node = this.getNode(node);
        if (!node) return;
        var ans = this.getAncestors(node);
        for (var i = 0, l = ans.length; i < l; i++) {
            this.expandNode(ans[i]);
        }
    },
    collapsePath: function (node) {
        node = this.getNode(node);
        if (!node) return;
        var ans = this.getAncestors(node);
        for (var i = 0, l = ans.length; i < l; i++) {
            this.collapseNode(ans[i]);
        }
    },

    isAncestor: function (parentNode, node) {
        if (parentNode == node) return true;
        if (!parentNode || !node) return false;
        if (parentNode == this.getRootNode()) return true;
        var as = this.getAncestors(node);
        for (var i = 0, l = as.length; i < l; i++) {
            if (as[i] == parentNode) return true;
        }
        return false;
    },

    getAncestors: function (node) {
        var as = [];
        while (1) {
            var parentNode = this.getParentNode(node);
            if (!parentNode || parentNode == this.root) break;
            as[as.length] = parentNode;
            node = parentNode;
        }
        as.reverse();
        return as;
    },
    getNode: function (node) {
        if (typeof node == 'object') return node;
        return this.getRecord(node);
    },
    getRootNode: function () {
        return this.root;
    },
    getParentNode: function (node) {
        if (!node) return null;
        return this.getByInternalId(node._pid);
    },
    getAllChildNodes: function (node, view) {
        return this.getChildNodes(node, true, view);
    },
    getChildNodes: function (node, all, useView) {
        node = this.getNode(node);
        if (!node) node = this.getRootNode();
        var nodes = node[this.nodesField];

        if (this.viewNodes && useView !== false) {
            nodes = this.viewNodes[node._id];
        }

        if (all === true && nodes) {
            var view = [];
            for (var i = 0, l = nodes.length; i < l; i++) {
                var cnode = nodes[i];
                view[view.length] = cnode;
                var cnodes = this.getChildNodes(cnode, all, useView);
                if (cnodes && cnodes.length > 0) {
                    view.addRange(cnodes);
                }
            }
            nodes = view;
        }
        return nodes || [];
    },
    getChildNodeAt: function (index, node) {
        var nodes = this.getChildNodes(node);
        if (nodes) return nodes[index];
        return null;
    },

    hasChildNodes: function (node) {
        var nodes = this.getChildNodes(node);
        return nodes.length > 0;
    },
    getNodeLevel: function (node) {
        return node._level + (this.rootVisible ? 1 : 0);
    },
    getLevel: function (node) {
        return node._level + (this.rootVisible ? 1 : 0);
    },

    _is_true: function (v) {
        return String(v) == 'true' || v === 1 || v === 'Y' || v === 'y';
    },
    _is_false: function (v) {
        return String(v) == 'false' || v === 0 || v === 'N' || v === 'n';
    },
    leafField: 'isLeaf',
    isLeafNode: function (node) {
        return this.isLeaf(node);
    },
    isLeaf: function (node) {
        if (!node) return false;
        var v = node[this.leafField];
        if (!node || this._is_false(v)) return false;
        var nodes = this.getChildNodes(node, false, false);
        if (nodes.length > 0) return false;
        return true;
    },
    hasChildren: function (node) {
        var subNodes = this.getChildNodes(node);
        return !!(subNodes && subNodes.length > 0);
    },
    isFirstNode: function (node) {
        if (node == this.root) return true;
        var parentNode = this.getParentNode(node);
        if (!parentNode) return false;
        return this.getFirstNode(parentNode) == node;
    },
    isLastNode: function (node) {
        if (node == this.root) return true;
        var parentNode = this.getParentNode(node);
        if (!parentNode) return false;
        return this.getLastNode(parentNode) == node;
    },
    isCheckedNode: function (node) {
        return node.checked === true;
    },
    isExpandedNode: function (node) {
        return node.expanded == true || node.expanded == 1 || mini.isNull(node.expanded);
    },
    isEnabledNode: function (node) {
        return node.enabled !== false;
    },
    isVisible: function (node) {
        return this.isVisibleNode(node);
    },
    isVisibleNode: function (node) {
        if (node.visible == false) return false;
        var pnode = this._ids[node._pid];
        if (!pnode || pnode == this.root) return true;
        if (pnode.expanded === false) return false;
        return this.isVisibleNode(pnode);
    },
    getNextNode: function (node) {
        var parentNode = this.getByInternalId(node._pid);
        if (!parentNode) return null;
        var index = this.indexOfNode(node);
        return this.getChildNodes(parentNode)[index + 1];
    },
    getPrevNode: function (node) {
        var parentNode = this.getByInternalId(node._pid);
        if (!parentNode) return null;
        var index = this.indexOfNode(node);
        return this.getChildNodes(parentNode)[index - 1];
    },
    getFirstNode: function (parentNode) {
        return this.getChildNodes(parentNode)[0];
    },
    getLastNode: function (parentNode) {
        var nodes = this.getChildNodes(parentNode);
        return nodes[nodes.length - 1];
    },
    indexOfParent: function (node) {
        return this.indexOfNode(node);
    },
    indexOfNode: function (node) {
        var parentNode = this.getByInternalId(node._pid);
        if (parentNode) {
            return this.getChildNodes(parentNode).indexOf(node);
        }
        return -1;
    },
    indexOfList: function (node) {
        return this.getList().indexOf(node);
    },
    indexOf: function (record) {
        return this.getVisibleRows().indexOf(record);
    },
    getAt: function (index) {
        return this.getVisibleRows()[index];
    },
    getCount: function () {
        return this.getVisibleRows().length;
    },
    getRange: function (start, end) {
        if (start > end) {
            var t = start;
            start = end;
            end = t;
        }

        var data = this.getVisibleRows();
        var range = [];
        for (var i = start, l = end; i <= l; i++) {
            var o = data[i];
            if (o) {
                range.push(o);
            }
        }
        return range;
    },
    selectRange: function (start, end) {
        var data = this.getChildNodes(this.root, true);
        if (!mini.isNumber(start)) start = data.indexOf(start);
        if (!mini.isNumber(end)) end = data.indexOf(end);
        if (mini.isNull(start) || mini.isNull(end)) return;

        var rs = this.getRange(start, end);
        this.selects(rs);
    },
    findRecords: function (property, value) {
        var data = this.getList();

        var ifFn = typeof property == 'function';
        var fn = property;
        var scope = value || this;
        var records = [];

        if (!mini.isNull(value)) value = String(value);

        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];

            if (ifFn) {
                var ret = fn.call(scope, o);
                if (ret == true) {
                    records[records.length] = o;
                }
                if (ret === 1) break;
            } else {
                if (value.indexOf(',') != -1) {
                    var vls = value.split(',');
                    for (var j = 0, len = vls.length; j < len; j++) {
                        var v = vls[j];
                        if (o[property] == v) {
                            records[records.length] = o;
                        }
                    }
                } else {
                    if (o[property] == value) {
                        records[records.length] = o;
                    }
                }
            }
        }
        return records;
    },

    _dataChangedCount: 0,
    _dataChanged: function (action) {
        this._dataChangedCount++;
        if (action != 'update') {
            this.ids = null;
            this.dataview = null;
            this.visibleRows = null;

            if (action == 'collapse' || action == 'expand' || action == 'loaddata') {
            } else {
                this.list = null;
                this._listIndexes = null;
            }
        }
        if (this.__changeCount == 0) {
            this.fire('datachanged');
        }
    },

    _createDataView: function () {
        var data = !this.viewNodes ? this.getList().clone() : this.getChildNodes(this.root, true);

        if (this.rootVisible && data[0] != this.root) {
            if (!this.root.expanded) data = [];
            data.unshift(this.root);
        }

        return data;
    },

    _createVisibleRows: function () {
        var data = [],
            nodesField = this.nodesField,
            viewNodes = this.viewNodes,
            inView = !!viewNodes,
            node,
            children;

        function getChildren(node) {
            return inView ? viewNodes[node._id] : node[nodesField];
        }

        function each(nodes) {
            for (var i = 0, l = nodes.length; i < l; i++) {
                node = nodes[i];
                data[data.length] = node;

                if (node.expanded === false) {
                } else {
                    children = getChildren(node);
                    if (children) each(children);
                }
            }
        }

        each(getChildren(this.root));

        if (this.rootVisible && data[0] != this.root) {
            if (!this.root.expanded) data = [];
            data.unshift(this.root);
        }

        return data;
    },

    getList: function () {
        if (!this.list) {
            this.list = mini.treeToList(this.source, this.nodesField);
        }
        return this.list;
    },

    getDataView: function () {
        if (!this.dataview) {
            this.dataview = this._createDataView();
        }
        return this.dataview;
    },

    getVisibleRows: function () {
        if (!this.visibleRows) {
            if (this.isGrouped()) {
                this.visibleRows = mini.Group.dataFromGroups(this.groups, true, false);
            } else {
                this.visibleRows = this._createVisibleRows();
            }
        }
        return this.visibleRows;
    },

    includeParentOnGroup: false,

    _doGroup: function () {
        var data = this.getAllChildNodes(this.root, true);

        if (!this.includeParentOnGroup) {
            for (var i = data.length - 1; i >= 0; i--) {
                var item = data[i];
                if (this.hasChildren(item)) {
                    data.removeAt(i);
                }
            }
        }

        if (this._sortInfo) {
            var fn = this._sortInfo[0],
                scope = this._sortInfo[1],
                reverse = this._sortInfo[2];
            mini.sort(data, fn, scope);
            if (reverse) data.reverse();
        }

        this.groups = mini.Group.groupByFields(data, this.groupFields);
    },

    includeParentOnFilter: true,

    _doFilter: function () {
        if (!this._filterInfo) {
            this.viewNodes = null;
            return;
        }
        var me = this;
        var fn = this._filterInfo[0],
            scope = this._filterInfo[1];

        this._filterAddNodes = {};

        var viewNodes = (this.viewNodes = {}),
            nodesField = this.nodesField;
        function filter(node) {
            var nodes = node[nodesField];
            if (!nodes) return false;
            var id = node._id;
            var views = (viewNodes[id] = []);

            for (var i = 0, l = nodes.length; i < l; i++) {
                var r = nodes[i];

                var add = fn.call(scope, r, i, me);
                var hasChildren = filter(r);

                if (add) {
                    me._filterAddNodes[r._id] = r;
                }

                if (add === true || hasChildren) {
                    views.push(r);
                }
            }

            if (views.length == 0) delete viewNodes[id];

            return views.length > 0;
        }

        filter(this.root);

        if (!me.includeParentOnFilter) {
            var vnodes = {};

            function findAddChildren(nodes, rootItems) {
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i];
                    if (me._filterAddNodes[node._id]) {
                        rootItems.push(node);
                        continue;
                    }
                    var children = viewNodes[node._id];
                    if (children) {
                        findAddChildren(children, rootItems);
                    }
                }
            }

            var rootItems = [];
            findAddChildren(viewNodes['-1'], rootItems);
            viewNodes['-1'] = rootItems;
        }
    },

    _doSort: function () {
        if (!this._filterInfo && !this._sortInfo) {
            this.viewNodes = null;
            return;
        }
        if (!this._sortInfo) return;
        var fn = this._sortInfo[0],
            scope = this._sortInfo[1],
            reverse = this._sortInfo[2];
        var nodesField = this.nodesField;
        if (!this.viewNodes) {
            var viewNodes = (this.viewNodes = {});

            viewNodes[this.root._id] = this.root[nodesField].clone();
            this.cascadeChild(this.root, function (node, i, p) {
                var nodes = node[nodesField];
                if (nodes) {
                    viewNodes[node._id] = nodes.clone();
                }
            });
        }

        var sf = this;
        function sort(node) {
            var nodes = sf.getChildNodes(node);
            mini.sort(nodes, fn, scope);
            if (reverse) nodes.reverse();
            for (var i = 0, l = nodes.length; i < l; i++) {
                var r = nodes[i];
                sort(r);
            }
        }
        sort(this.root);
    },

    toArray: function () {
        if (!this._array || this._dataChangedCount != this._dataChangedCount2) {
            this._dataChangedCount2 = this._dataChangedCount;
            this._array = this.getChildNodes(this.root, true, false);
        }

        return this._array;
    },

    toTree: function () {
        return this.root[this.nodesField];
    },

    isChanged: function () {
        return this.getChanges().length > 0;
    },

    getChanges: function (rowState, onlyField) {
        var me = this,
            changes = [];
        if (rowState == 'removed' || rowState == null) {
            changes.addRange(this._removeds.clone());
        }

        var allNodes = this.getAllChildNodes(this.root, false);

        for (var i = 0, l = allNodes.length; i < l; i++) {
            var record = allNodes[i];
            if (record._state == null || record._state == '') continue;
            if (record._state == rowState || rowState == null) {
                changes[changes.length] = record;
            }
        }

        var rows = changes;
        if (onlyField) {
            for (var i = 0, l = rows.length; i < l; i++) {
                var row = rows[i];
                if (row._state == 'modified') {
                    var newRow = {};
                    newRow._state = row._state;
                    newRow[this.idField] = row[this.idField];
                    for (var field in row) {
                        var modifed = this.isModified(row, field);
                        if (modifed) {
                            newRow[field] = row[field];
                        }
                    }
                    rows[i] = newRow;
                }
            }
        }
        return changes;
    },

    accept: function (node) {
        node = node || this.root;
        this.beginChange();
        this.cascadeChild(
            this.root,
            function (node) {
                this.acceptRecord(node);
            },
            this
        );
        this._removeds = [];
        this._originals = {};
        this.endChange();
    },
    reject: function (node) {
        this.beginChange();
        this.cascadeChild(
            this.root,
            function (node) {
                this.rejectRecord(node);
            },
            this
        );
        this._removeds = [];
        this._originals = {};
        this.endChange();
    },
    acceptRecord: function (node) {
        if (!node._state) return;
        delete this._originals[node[this._originalIdField]];
        if (node._state == 'deleted') {
            this.removeNode(node);
        } else {
            delete node._state;
            delete this._originals[node[this._originalIdField]];
            this._dataChanged();
            this.fire('update', { record: node });
        }
    },
    acceptRecordFields: function (node, fields = []) {
        let original = this._originals[node[this._originalIdField]];
        original &&
            fields.forEach((field) => {
                if (Object.prototype.hasOwnProperty.call(original, field)) {
                    delete original[field];
                }
            });

        if (Object.keys(original).length === 0) this.acceptRecord(node);
        else {
            this._dataChanged();
            this.fire('update', { record: node });
        }
    },
    rejectRecord: function (node) {
        if (!node._state) return;
        if (node._state == 'added') {
            this.removeNode(node);
        } else if (node._state == 'modified' || node._state == 'deleted') {
            var or = this._getOriginal(node);
            mini.copyTo(node, or);
            delete node._state;
            delete this._originals[node[this._originalIdField]];
            this._dataChanged();
            this.fire('update', { record: node });
        }
    },

    upGrade: function (task) {
        if (this.isGrouped()) return false;

        var parentTask = this.getParentNode(task);
        if (parentTask == this.root || task == this.root) {
            return false;
        }

        var pNodes = parentTask[this.nodesField];

        var index = pNodes.indexOf(task);
        var appendIndex = task[this.nodesField] ? task[this.nodesField].length : 0;

        for (var i = pNodes.length - 1; i >= index; i--) {
            var o = pNodes[i];
            pNodes.removeAt(i);
            if (o != task) {
                if (!task[this.nodesField]) task[this.nodesField] = [];
                task[this.nodesField].insert(appendIndex, o);
            }
        }

        var pparentTask = this.getParentNode(parentTask);
        var ppNodes = pparentTask[this.nodesField];
        var index = ppNodes.indexOf(parentTask);
        ppNodes.insert(index + 1, task);

        this._updateParentAndLevel(task, pparentTask);

        this._doFilter();

        this._dataChanged();
    },
    downGrade: function (node) {
        if (this.isGrouped()) return false;

        if (this.isFirstNode(node)) {
            return false;
        }

        var oldParentNode = this.getParentNode(node);

        var opNodes = oldParentNode[this.nodesField];

        var index = opNodes.indexOf(node);

        var parentNode = opNodes[index - 1];

        opNodes.removeAt(index);
        if (!parentNode[this.nodesField]) parentNode[this.nodesField] = [];
        parentNode[this.nodesField].push(node);

        this._updateParentAndLevel(node, parentNode);

        this._doFilter();

        this._dataChanged();
    },

    updateNodeState: function (node) {
        var children = node.children || [];
        for (var i = 0, l = children.length; i < l; i++) {
            this._updateParentAndLevel(children[i], node);
        }
    },

    _updateParentAndLevel: function (node, parentNode) {
        var that = this;
        node._pid = parentNode._id;
        node._level = parentNode._level + 1;
        node[that.parentField] = parentNode[that.idField];
        if (!node[that.parentField]) node[that.parentField] = parentNode._id;

        this.cascadeChild(
            node,
            function (n, i, p) {
                n._pid = p._id;
                n._level = p._level + 1;

                n[that.parentField] = p[that.idField];
            },
            this
        );
        this._setModified(node);
    },

    setCheckModel: function (value) {
        this.checkModel = value;
    },
    getCheckModel: function () {
        return this.checkModel;
    },
    setOnlyLeafCheckable: function (value) {
        this.onlyLeafCheckable = value;
    },
    getOnlyLeafCheckable: function () {
        return this.onlyLeafCheckable;
    },
    setAutoCheckParent: function (value) {
        this.autoCheckParent = value;
    },
    getAutoCheckParent: function () {
        return this.autoCheckParent;
    },
    _doUpdateLoadedCheckedNodes: function () {
        var nodes = this.getList();

        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            if (node.checked == true) {
                if (this.autoCheckParent == false || !this.hasChildNodes(node)) {
                    this._doUpdateNodeCheckState(node);
                }
            }
        }
    },
    _doUpdateNodeCheckState: function (node) {
        if (!node) return;

        var checked = this.isChecked(node);
        if (this.checkModel == 'cascade' || this.autoCheckParent) {
            this.cascadeChild(
                node,
                function (cnode) {
                    this.doCheckNodes(cnode, checked);
                },
                this
            );

            if (!this.autoCheckParent) {
                var ans = this.getAncestors(node);
                ans.reverse();
                for (var i = 0, l = ans.length; i < l; i++) {
                    var pnode = ans[i];

                    var childNodes = this.getChildNodes(pnode);
                    var checkAll = true;
                    for (var ii = 0, ll = childNodes.length; ii < ll; ii++) {
                        var cnode = childNodes[ii];
                        if (!this.isCheckedNode(cnode)) {
                            checkAll = false;
                        }
                    }
                    if (checkAll) this.doCheckNodes(pnode, true);
                    else {
                        this.doCheckNodes(pnode, false);
                    }

                    this.fire('checkchanged', { nodes: [pnode], _nodes: [pnode] });
                }
            }
        }
        var that = this;

        function hasCheckedChildNode(pnode) {
            var childNodes = that.getChildNodes(pnode);
            for (var ii = 0, ll = childNodes.length; ii < ll; ii++) {
                var cnode = childNodes[ii];
                if (that.isCheckedNode(cnode)) {
                    return true;
                }
            }
            return false;
        }
        if (this.autoCheckParent) {
            var ans = this.getAncestors(node);
            ans.reverse();
            for (var i = 0, l = ans.length; i < l; i++) {
                var pnode = ans[i];

                pnode.checked = hasCheckedChildNode(pnode);

                this.fire('checkchanged', { nodes: [pnode], _nodes: [pnode] });
            }
        }
    },
    doCheckNodes: function (nodes, checked, cascade) {
        if (!nodes) return;
        if (typeof nodes == 'string') {
            nodes = nodes.split(',');
        }
        if (!mini.isArray(nodes)) nodes = [nodes];
        nodes = nodes.clone();
        var _nodes = [];
        checked = checked !== false;

        if (cascade === true) {
            if (this.checkModel == 'single') {
                this.uncheckAllNodes();
            }
        }
        for (var i = nodes.length - 1; i >= 0; i--) {
            var node = this.getRecord(nodes[i]);
            if (!node || (checked && node.checked === true) || (!checked && node.checked !== true)) {
                if (node) {
                    if (cascade === true) {
                        this._doUpdateNodeCheckState(node);
                    }
                    if (!checked && !this.isLeaf(node)) {
                        _nodes.push(node);
                    }
                }
                continue;
            }
            node.checked = checked;
            _nodes.push(node);
            if (cascade === true) {
                this._doUpdateNodeCheckState(node);
            }
        }

        var me = this;
        setTimeout(function () {
            me.fire('_checkchanged', { nodes: nodes, _nodes: _nodes, checked: checked });
        }, 1);
    },
    checkNode: function (node, cascade) {
        this.doCheckNodes([node], true, cascade !== false);
    },
    uncheckNode: function (node, cascade) {
        this.doCheckNodes([node], false, cascade !== false);
    },
    checkNodes: function (nodes, cascade) {
        if (!mini.isArray(nodes)) nodes = [];
        this.doCheckNodes(nodes, true, cascade !== false);
    },
    uncheckNodes: function (nodes, cascade) {
        if (!mini.isArray(nodes)) nodes = [];
        this.doCheckNodes(nodes, false, cascade !== false);
    },
    checkAllNodes: function () {
        var nodes = this.getList();
        this.doCheckNodes(nodes, true, false);
    },
    uncheckAllNodes: function () {
        var nodes = this.getList();
        this.doCheckNodes(nodes, false, false);
    },

    doGetCheckedNodes: function (sourceNodes, mode) {
        if (mode === false) mode = 'leaf';
        var nodes = [];
        var maps = {};

        for (var j = 0, k = sourceNodes.length; j < k; j++) {
            var node = sourceNodes[j];
            var isLeaf = this.isLeafNode(node);
            if (mode === true) {
                if (!maps[node._id]) {
                    maps[node._id] = node;
                    nodes.push(node);
                }
                var ans = this.getAncestors(node);
                for (var i = 0, l = ans.length; i < l; i++) {
                    var anode = ans[i];
                    if (!maps[anode._id]) {
                        maps[anode._id] = anode;
                        nodes.push(anode);
                    }
                }
            } else if (mode === 'parent') {
                if (!isLeaf) {
                    if (!maps[node._id]) {
                        maps[node._id] = node;
                        nodes.push(node);
                    }
                }
            } else if (mode === 'leaf') {
                if (isLeaf) {
                    if (!maps[node._id]) {
                        maps[node._id] = node;
                        nodes.push(node);
                    }
                }
            } else {
                if (!maps[node._id]) {
                    maps[node._id] = node;
                    nodes.push(node);
                }
            }
        }
        return nodes;
    },

    getCheckedNodes: function (mode) {
        var nodes = [];

        this.cascadeChild(this.root, function (node) {
            if (node.checked == true) nodes.push(node);
        });

        nodes = this.doGetCheckedNodes(nodes, mode);

        return nodes;
    },

    getCheckedNodesId: function (mode, delimiter) {
        var nodes = this.getCheckedNodes(mode);
        var vts = this.getValueAndText(nodes, delimiter);
        return vts[0];
    },
    getCheckedNodesText: function (mode, delimiter) {
        var nodes = this.getCheckedNodes(mode);
        var vts = this.getValueAndText(nodes, delimiter);
        return vts[1];
    },
    isChecked: function (node) {
        node = this.getRecord(node);
        if (!node) return null;
        return node.checked === true || node.checked === 1;
    },
    getCheckState: function (node) {
        node = this.getRecord(node);
        if (!node) return null;
        if (node.checked === true) return 'checked';
        if (!node[this.nodesField]) return 'unchecked';

        if (node.indeterminate) return 'indeterminate';

        var children = this.getChildNodes(node, true);
        for (var i = 0, l = children.length; i < l; i++) {
            var node = children[i];
            if (node.checked === true) return 'indeterminate';
        }
        return 'unchecked';
    },
    getUnCheckableNodes: function () {
        var nodes = [];
        this.cascadeChild(
            this.root,
            function (node) {
                var checkable = this.getCheckable(node);
                if (checkable == false) {
                    nodes.push(node);
                }
            },
            this
        );
        return nodes;
    },
    setCheckable: function (nodes, checkable) {
        if (!nodes) return;
        if (!mini.isArray(nodes)) nodes = [nodes];
        nodes = nodes.clone();
        checkable = !!checkable;
        for (var i = nodes.length - 1; i >= 0; i--) {
            var node = this.getRecord(nodes[i]);
            if (!node) {
                continue;
            }
            node.checkable = checked;
        }
    },
    getCheckable: function (node) {
        node = this.getRecord(node);
        if (!node) return false;
        if (node.checkable === true) return true;
        if (node.checkable === false) return false;
        return this.isLeafNode(node) ? true : !this.onlyLeafCheckable;
    },
    showNodeCheckbox: function (node, show) {},

    reload: function (success, error, complete) {
        this._loadingNode = null;

        this.load(this.loadParams, success, error, complete);
    },
    _isNodeLoading: function () {
        return !!this._loadingNode;
    },
    loadNode: function (node, expand) {
        this._loadingNode = node;
        var e = { node: node };
        this.fire('beforeloadnode', e);

        var time = new Date();

        var me = this;
        me._doLoadAjax(
            me.loadParams,
            null,
            null,
            null,
            function (e) {
                var t = new Date() - time;
                if (t < 60) t = 60 - t;

                setTimeout(function () {
                    e.node = node;
                    me._OnPreLoad(e);

                    me._loadingNode = null;
                    if (me.loadParams) delete me.loadParams[me.idField];

                    var oldNodes = node[me.nodesField];
                    me.removeNodes(oldNodes);

                    var nodes = e.data;
                    if (nodes && nodes.length > 0) {
                        me.collapse(node);

                        me.addNodes(nodes, node);

                        var all = me.getAllChildNodes(node);
                        for (var i = 0, l = all.length; i < l; i++) {
                            var treeNode = all[i];

                            delete treeNode._state;
                        }

                        if (expand !== false) {
                            me.expand(node, true);
                        } else {
                            me.collapse(node, true);
                        }
                    } else {
                        delete node[me.leafField];
                        me.expand(node, true);
                    }

                    me.fire('loadnode', e);
                    me.fire('load', e);
                }, t);
            },
            true
        );
    }
});
mini.regClass(mini.TreeStore, 'datatree');

mini.DataTree = mini.TreeStore;

mini._Columns = {};
mini._getColumn = function (columnType) {
    var columnFn = mini._Columns[columnType.toLowerCase()];
    if (!columnFn) return {};
    return columnFn();
};

mini.IndexColumn = function (config) {
    return mini.copyTo(
        {
            width: 30,
            cellCls: '',
            align: 'center',
            draggable: false,
            allowDrag: true,
            init: function (grid) {
                grid.on('addrow', this.__OnIndexChanged, this);
                grid.on('removerow', this.__OnIndexChanged, this);
                grid.on('moverow', this.__OnIndexChanged, this);

                if (grid.isTree) {
                    grid.on('loadnode', this.__OnIndexChanged, this);
                    this._gridUID = grid.uid;
                    this._rowIdField = '_id';
                }
            },
            getNumberId: function (record) {
                return this._gridUID + '$number$' + record[this._rowIdField];
            },
            createNumber: function (grid, rowIndex) {
                if (mini.isNull(grid.pageIndex)) {
                    return rowIndex + 1;
                } else return grid.pageIndex * grid.pageSize + rowIndex + 1;
            },
            renderer: function (e) {
                var grid = e.sender;
                if (this.draggable) {
                    if (!e.cellStyle) e.cellStyle = '';
                    e.cellStyle += ';cursor:move;';
                }
                var s = '<div id="' + this.getNumberId(e.record) + '">';

                var index = e.rowIndex + 1;

                if (grid.store) {
                    index = grid.store.indexOfList(e.record) + 1;
                } else {
                    index = grid.data.indexOf(e.record) + 1;
                }

                if (index == 0) {
                } else {
                    if (mini.isNull(grid.pageIndex)) s += index;
                    else s += grid.pageIndex * grid.pageSize + index;
                }
                s += '</div>';
                return s;
            },
            __OnIndexChanged: function (e) {
                var grid = e.sender;

                var records = grid.toArray();

                for (var i = 0, l = records.length; i < l; i++) {
                    var record = records[i];
                    var id = this.getNumberId(record);
                    var ck = document.getElementById(id);
                    if (ck) ck.innerHTML = this.createNumber(grid, i);
                }
            }
        },
        config
    );
};
mini._Columns['indexcolumn'] = mini.IndexColumn;

mini.CheckColumn = function (config) {
    return mini.copyTo(
        {
            width: 30,
            cellCls: 'mini-checkcolumn',
            headerCls: 'mini-checkcolumn',
            _multiRowSelect: true,
            header: function (column) {
                var id = this.uid + 'checkall';
                var s = '<input type="checkbox" id="' + id + '" />';
                if (this.multiSelect == false) s = '';
                return s;
            },
            getCheckId: function (record) {
                return this._gridUID + '$checkcolumn$' + record[this._rowIdField];
            },
            init: function (grid) {
                grid.on('selectionchanged', this.__OnSelectionChanged, this);
                grid.on('HeaderCellClick', this.__OnHeaderCellClick, this);
            },
            renderer: function (e) {
                var id = this.getCheckId(e.record);
                var selected = e.sender.isSelected ? e.sender.isSelected(e.record) : false;

                var type = 'checkbox';

                var grid = e.sender;
                if (grid.multiSelect == false) type = 'radio';

                return (
                    '<input type="' +
                    type +
                    '" id="' +
                    id +
                    '" ' +
                    (selected ? 'checked' : '') +
                    ' hidefocus style="outline:none;" onclick="return false"/>'
                );
            },
            __OnHeaderCellClick: function (e) {
                var grid = e.sender;
                if (e.column != this) return;
                var id = grid.uid + 'checkall';
                var ck = document.getElementById(id);
                if (ck) {
                    if (grid.getMultiSelect()) {
                        if (ck.checked) {
                            grid.selectAll();
                        } else {
                            grid.deselectAll();
                        }
                    } else {
                        grid.deselectAll();
                        if (ck.checked) {
                            grid.select(0);
                        }
                    }
                    grid.fire('checkall');
                }
            },
            __OnSelectionChanged: function (e) {
                var grid = e.sender;

                var records = grid.store ? grid.store.getDataView() : grid.getData();

                for (var i = 0, l = records.length; i < l; i++) {
                    var record = records[i];
                    var select = grid.isSelected(record);
                    var id = grid.uid + '$checkcolumn$' + record[grid._rowIdField];
                    var ck = document.getElementById(id);

                    if (ck) ck.checked = select;
                }
                var me = this;
                if (!this._timer) {
                    this._timer = setTimeout(function () {
                        me._doCheckState(grid);
                        me._timer = null;
                    }, 10);
                }
            },
            _doCheckState: function (grid) {
                var id = grid.uid + 'checkall';
                var ck = document.getElementById(id);
                if (ck && grid._getSelectAllCheckState) {
                    var state = grid._getSelectAllCheckState();
                    if (state == 'has') {
                        ck.indeterminate = true;
                        ck.checked = true;
                    } else {
                        ck.indeterminate = false;
                        ck.checked = state;
                    }
                }
            }
        },
        config
    );
};
mini._Columns['checkcolumn'] = mini.CheckColumn;

mini.ExpandColumn = function (config) {
    return mini.copyTo(
        {
            width: 30,
            cellCls: '',
            align: 'center',
            draggable: false,
            cellStyle: 'padding:0',
            renderer: function (e) {
                return '<a class="mini-grid-ecIcon" href="javascript:#" onclick="return false"></a>';
            },
            init: function (grid) {
                grid.on('cellclick', this.__OnCellClick, this);
            },
            __OnCellClick: function (e) {
                var grid = e.sender;
                if (e.column == this && grid.isShowRowDetail) {
                    if (mini.findParent(e.htmlEvent.target, 'mini-grid-ecIcon')) {
                        var isShow = grid.isShowRowDetail(e.record);
                        if (grid.autoHideRowDetail) {
                            grid.hideAllRowDetail();
                        }

                        if (isShow) {
                            grid.hideRowDetail(e.record);
                        } else {
                            grid.showRowDetail(e.record);
                        }
                    }
                }
            }
        },
        config
    );
};
mini._Columns['expandcolumn'] = mini.ExpandColumn;

mini.CheckBoxColumn = function (config) {
    return mini.copyTo(
        {
            _type: 'checkboxcolumn',
            header: '#',
            headerAlign: 'center',
            cellCls: 'mini-checkcolumn',
            trueValue: true,
            falseValue: false,
            readOnly: false,
            getCheckId: function (record) {
                return this._gridUID + '$checkbox$' + record[this._rowIdField];
            },
            getCheckBoxEl: function (record) {
                return document.getElementById(this.getCheckId(record));
            },
            renderer: function (e) {
                var id = this.getCheckId(e.record);
                var v = mini._getMap(e.field, e.record);
                var checked = v == this.trueValue ? true : false;
                var type = 'checkbox';

                return (
                    '<input type="' +
                    type +
                    '" id="' +
                    id +
                    '" ' +
                    (checked ? 'checked' : '') +
                    ' hidefocus style="outline:none;" onclick="return false;"/>'
                );
            },

            init: function (grid) {
                this.grid = grid;
                function oneditchange(e) {
                    if (grid.isReadOnly() || this.readOnly) return;
                    e.value = mini._getMap(e.field, e.record);
                    grid.fire('cellbeginedit', e);

                    if (e.cancel !== true) {
                        var v = mini._getMap(e.column.field, e.record);
                        var value = v == this.trueValue ? this.falseValue : this.trueValue;
                        if (grid._OnCellCommitEdit) {
                            grid._OnCellCommitEdit(e.record, e.column, value);
                        }
                    }
                }
                function onEdit(e) {
                    if (e.column == this) {
                        var id = this.getCheckId(e.record);
                        var ck = e.htmlEvent.target;
                        if (ck.id == id) {
                            if (grid.allowCellEdit) {
                                e.cancel = false;
                                oneditchange.call(this, e);
                            } else {
                                if (grid.isEditingRow && grid.isEditingRow(e.record)) {
                                    setTimeout(function () {
                                        ck.checked = !ck.checked;
                                    }, 1);
                                }
                            }
                        }
                    }
                }
                grid.on('cellclick', onEdit, this);
                mini.on(
                    this.grid.el,
                    'keydown',
                    function (e) {
                        if (e.keyCode == 32 && grid.allowCellEdit) {
                            var currentCell = grid.getCurrentCell();
                            if (!currentCell) return;
                            var ex = { record: currentCell[0], column: currentCell[1] };
                            ex.field = ex.column.field;
                            oneditchange.call(this, ex);
                            e.preventDefault();
                        }
                    },
                    this
                );

                var tv = parseInt(this.trueValue),
                    fv = parseInt(this.falseValue);
                if (!isNaN(tv)) this.trueValue = tv;
                if (!isNaN(fv)) this.falseValue = fv;
            }
        },
        config
    );
};
mini._Columns['checkboxcolumn'] = mini.CheckBoxColumn;

mini.RadioButtonColumn = function (config) {
    return mini.copyTo(
        {
            _type: 'radiobuttoncolumn',
            header: '',
            headerAlign: 'center',
            cellCls: 'mini-checkcolumn',
            trueValue: true,
            falseValue: false,
            readOnly: false,
            getCheckId: function (record) {
                return this._gridUID + '$radio$' + record[this._rowIdField];
            },
            getCheckBoxEl: function (record) {
                return document.getElementById(this.getCheckId(record));
            },
            renderer: function (e) {
                var grid = e.sender;
                var id = this.getCheckId(e.record);
                var v = mini._getMap(e.field, e.record);
                var checked = v == this.trueValue ? true : false;
                var type = 'radio';
                var name = grid._id + e.column.field;

                var disabled = '';

                var s = '<div style="position:relative;">';
                s +=
                    '<input name="' +
                    name +
                    '" type="' +
                    type +
                    '" id="' +
                    id +
                    '" ' +
                    (checked ? 'checked' : '') +
                    ' hidefocus style="outline:none;" onclick="return false;" style="position:relative;z-index:1;"/>';
                if (!grid.allowCellEdit) {
                    if (!grid.isEditingRow(e.record)) {
                        s += '<div class="mini-grid-radio-mask"></div>';
                    }
                }
                s += '</div>';
                return s;
            },

            init: function (grid) {
                this.grid = grid;

                function oneditchange(e) {
                    if (grid.isReadOnly() || this.readOnly) return;
                    e.value = mini._getMap(e.field, e.record);
                    grid.fire('cellbeginedit', e);

                    if (e.cancel !== true) {
                        var v = mini._getMap(e.column.field, e.record);
                        if (v == this.trueValue) return;
                        var value = v == this.trueValue ? this.falseValue : this.trueValue;

                        var data = grid.getData();

                        for (var i = 0, l = data.length; i < l; i++) {
                            var row = data[i];
                            if (row == e.record) continue;
                            var v = mini._getMap(e.column.field, row);
                            if (v != this.falseValue) {
                                grid.updateRow(row, e.column.field, this.falseValue);
                            }
                        }

                        if (grid._OnCellCommitEdit) {
                            grid._OnCellCommitEdit(e.record, e.column, value);
                        }
                    }
                }
                function onEdit(e) {
                    if (e.column == this) {
                        var id = this.getCheckId(e.record);
                        var ck = e.htmlEvent.target;
                        if (ck.id == id) {
                            if (grid.allowCellEdit) {
                                e.cancel = false;
                                oneditchange.call(this, e);
                            } else {
                                if (grid.isEditingRow && grid.isEditingRow(e.record)) {
                                    var that = this;
                                    setTimeout(function () {
                                        ck.checked = true;

                                        var data = grid.getData();
                                        for (var i = 0, l = data.length; i < l; i++) {
                                            var row = data[i];
                                            if (row == e.record) continue;
                                            var field = e.column.field;
                                            var v = mini._getMap(field, row);
                                            if (v != that.falseValue) {
                                                if (row != e.record) {
                                                    if (grid._dataSource) {
                                                        mini._setMap(e.column.field, that.falseValue, row);
                                                        grid._dataSource._setModified(row, field, v);
                                                    } else {
                                                        var o = {};
                                                        mini._setMap(field, that.falseValue, o);
                                                        grid._doUpdateRow(row, o);
                                                    }
                                                }
                                            }
                                        }
                                    }, 1);
                                }
                            }
                        }
                    }
                }
                grid.on('cellclick', onEdit, this);

                mini.on(
                    this.grid.el,
                    'keydown',
                    function (e) {
                        if (e.keyCode == 32 && grid.allowCellEdit) {
                            var currentCell = grid.getCurrentCell();
                            if (!currentCell) return;
                            if (currentCell[1] != this) return;
                            var ex = { record: currentCell[0], column: currentCell[1] };
                            ex.field = ex.column.field;
                            oneditchange.call(this, ex);
                            e.preventDefault();
                        }
                    },
                    this
                );

                var tv = parseInt(this.trueValue),
                    fv = parseInt(this.falseValue);
                if (!isNaN(tv)) this.trueValue = tv;
                if (!isNaN(fv)) this.falseValue = fv;
            }
        },
        config
    );
};
mini._Columns['radiobuttoncolumn'] = mini.RadioButtonColumn;

mini.ComboBoxColumn = function (config) {
    return mini.copyTo(
        {
            renderer: function (e) {
                var value = !mini.isNull(e.value) ? String(e.value) : '';
                var values = value.split(',');

                var valueField = 'id',
                    textField = 'text';

                var valueMaps = {};

                var editor = e.column.editor;
                if (editor && editor.type == 'combobox') {
                    var combo = this.__editor;
                    if (!combo) {
                        if (mini.isControl(editor)) {
                            combo = editor;
                        } else {
                            editor = mini.clone(editor);
                            combo = mini.create(editor);
                        }
                        this.__editor = combo;
                    }

                    valueField = combo.getValueField();
                    textField = combo.getTextField();

                    var data = combo.data;
                    if (this._data != data) {
                        this._valueMaps = null;
                    }
                    valueMaps = this._valueMaps;
                    if (!valueMaps) {
                        valueMaps = {};
                        for (var i = 0, l = data.length; i < l; i++) {
                            var o = data[i];
                            valueMaps[o[valueField]] = o;
                        }
                        this._valueMaps = valueMaps;
                        this._data = data;
                    }
                }

                var texts = [];
                for (var i = 0, l = values.length; i < l; i++) {
                    var id = values[i];
                    var o = valueMaps[id];
                    if (o) {
                        var text = o[textField];
                        if (text === null || text === undefined) {
                            text = '';
                        }
                        texts.push(text);
                    }
                }
                return texts.join(',');
            }
        },
        config
    );
};
mini._Columns['comboboxcolumn'] = mini.ComboBoxColumn;
mini.DataGrid = mini.Control.extend({
    type: 'datagrid',
    tag: 'mini-datagrid',

    props: {
        width: 300,
        height: 'auto',
        allowCellValid: false,
        cellEditAction: 'cellmouseup',
        showEmptyText: false,
        emptyText: 'No data returned.',
        cellEditClicks: 1,
        showModified: true,
        showDirty: true,
        showNewRow: true,
        minWidth: 300,
        minHeight: 150,
        maxWidth: 5000,
        maxHeight: 3000,
        virtualScroll: false,
        allowCellWrap: false,
        allowHeaderWrap: false,
        showColumnsMenu: false,
        bodyCls: '',
        bodyStyle: '',
        footerCls: '',
        footerStyle: '',
        pagerCls: '',
        pagerStyle: '',
        idField: 'id',
        data: null,
        columns: null,
        allowResize: false,
        selectOnLoad: false,
        columnWidth: 120,
        columnMinWidth: 20,
        columnMaxWidth: 2000,
        fitColumns: true,
        autoHideRowDetail: true,
        showHeader: true,
        showFooter: true,
        showTop: false,
        showHGridLines: true,
        showVGridLines: true,
        showFilterRow: false,
        showSummaryRow: false,
        sortMode: 'server',
        allowSortColumn: true,
        allowMoveColumn: true,
        allowResizeColumn: true,
        enableHotTrack: true,
        allowRowSelect: true,
        multiSelect: false,
        allowAlternating: false,
        allowUnselect: false,
        frozenStartColumn: -1,
        frozenEndColumn: -1
    },

    _displayStyle: 'block',
    _rowIdField: '_uid',
    _viewRegion: null,
    _virtualRows: 50,

    frozenCls: 'mini-grid-frozen',
    frozenCellCls: 'mini-grid-frozenCell',
    alternatingCls: 'mini-grid-row-alt',
    rowCls: 'mini-grid-row',
    rowHoverCls: 'mini-grid-row-hover',
    rowSelectedCls: 'mini-grid-row-selected',
    headerCellCls: 'mini-grid-headerCell',
    cellCls: 'mini-grid-cell',

    initComponent: function () {
        this.data = this.data || [];
        this.columns = this.columns || [];
        this._idRows = {};
        this._removes = [];
        this._originals = {};

        this._bottomColumns = [];
        this._idColumns = {};
        this._nameColumns = {};

        this._selecteds = [];
        this._idSelecteds = {};

        this._cellErrors = [];
        this._cellMapErrors = {};

        this.callParent('initComponent');

        this.doUpdate();

        var sf = this;
        setTimeout(function () {
            if (sf.autoLoad && this.url) {
                sf.reload();
            }
        }, 1);
    },

    isFrozen: function () {
        return this.frozenStartColumn >= 0 && this.frozenEndColumn >= this.frozenStartColumn;
    },

    _create: function () {
        var el = (this.el = document.createElement('div'));
        this.el.className = 'mini-grid';
        this.el.style.display = 'block';

        this.el.tabIndex = 1;
        var s =
            '<div class="mini-grid-border">' +
            '<div class="mini-grid-header"><div class="mini-grid-headerInner"></div></div>' +
            '<div class="mini-grid-filterRow"></div>' +
            '<div class="mini-grid-body"><div class="mini-grid-bodyInner"></div><div class="mini-grid-body-scrollHeight"></div></div>' +
            '<div class="mini-grid-scroller"><div></div></div>' +
            '<div class="mini-grid-summaryRow"></div>' +
            '<div class="mini-grid-footer"></div>' +
            '<div class="mini-resizer-trigger" style=""></div>' +
            '<a href="#" class="mini-grid-focus" style="position:absolute;left:-10px;top:-10px;width:0px;height:0px;outline:none;" hideFocus onclick="return false" ></a>' +
            '</div>';
        this.el.innerHTML = s;

        this._borderEl = this.el.firstChild;
        this._headerEl = this._borderEl.childNodes[0];
        this._filterEl = this._borderEl.childNodes[1];
        this._bodyEl = this._borderEl.childNodes[2];
        this._bodyInnerEl = this._bodyEl.childNodes[0];
        this._bodyScrollEl = this._bodyEl.childNodes[1];

        this._headerInnerEl = this._headerEl.firstChild;

        this._scrollEl = this._borderEl.childNodes[3];
        this._summaryEl = this._borderEl.childNodes[4];
        this._footerEl = this._borderEl.childNodes[5];
        this._resizeEl = this._borderEl.childNodes[6];
        this._focusEl = this._borderEl.childNodes[7];

        this._doUpdateFilterRow();
        this.refreshSummaryRow();

        mini.setStyle(this._bodyEl, this.bodyStyle);
        mini.addClass(this._bodyEl, this.bodyCls);

        this._createPager();

        this._doShowRows();
    },
    destroy: function (removeEl) {
        if (this._bodyEl) {
            mini.clearEvent(this._bodyEl);

            this._bodyEl = null;
        }
        if (this._scrollEl) {
            mini.clearEvent(this._scrollEl);

            this._scrollEl = null;
        }
        this._borderEl = null;
        this._headerEl = null;
        this._filterEl = null;
        this._bodyEl = null;
        this._scrollEl = null;
        this._summaryEl = null;
        this._footerEl = null;
        this._resizeEl = null;
        mini.DataGrid.superclass.destroy.call(this, removeEl);
    },
    _initEvents: function () {
        js_touchScroll(this._bodyEl);

        mini._BindEvents(function () {
            mini.on(this.el, 'click', this.__OnClick, this);
            mini.on(this.el, 'dblclick', this.__OnDblClick, this);

            mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
            mini.on(this.el, 'mouseup', this.__OnMouseUp, this);
            mini.on(this.el, 'mousemove', this.__OnMouseMove, this);
            mini.on(this.el, 'mouseover', this.__OnMouseOver, this);
            mini.on(this.el, 'mouseout', this.__OnMouseOut, this);

            mini.on(this.el, 'keydown', this.__OnKeyDown, this);
            mini.on(this.el, 'keyup', this.__OnKeyUp, this);

            mini.on(this.el, 'contextmenu', this.__OnContextMenu, this);

            mini.on(this._bodyEl, 'scroll', this.__OnBodyScroll, this);
            mini.on(this._scrollEl, 'scroll', this.__OnHScroll, this);

            mini.on(this.el, 'mousewheel', this.__OnMousewheel, this);
        }, this);

        this._Resizer = new mini._Resizer(this);
        this._Splitter = new mini._ColumnSplitter(this);
        this._ColumnMove = new mini._ColumnMove(this);
        this._Select = new mini._GridSelect(this);
        this._CellTip = new mini._CellToolTip(this);
        this._Sort = new mini._GridSort(this);
        this._ColumnsMenu = new mini._ColumnsMenu(this);
    },

    _doShowRows: function () {
        this._resizeEl.style.display = this.allowResize ? '' : 'none';
        this._footerEl.style.display = this.showFooter ? '' : 'none';
        this._summaryEl.style.display = this.showSummaryRow ? '' : 'none';
        this._filterEl.style.display = this.showFilterRow ? '' : 'none';
        this._headerEl.style.display = this.showHeader ? '' : 'none';
    },
    focus: function () {
        try {
            var row = this.getCurrent();
            if (row) {
                var rowEl = this._getRowEl(row);
                if (rowEl) {
                    var rowBox = mini.getBox(rowEl);
                    mini.setY(this._focusEl, rowBox.top);

                    if (isOpera) {
                        rowEl.focus();
                    } else if (isChrome) {
                        this.el.focus();
                    } else if (isGecko) {
                        this.el.focus();
                    } else {
                        this._focusEl.focus();
                    }
                }
            } else {
                this._focusEl.focus();
            }
        } catch (e) {}
    },
    _createPager: function () {
        this.pager = new mini.Pager();
        this.pager.render(this._footerEl);
        this.bindPager(this.pager);
    },
    setPagerButtons: function (value) {
        this.pager.setButtons(value);
    },
    setPager: function (value) {
        if (typeof value == 'string') {
            var el = mini.byId(value);
            if (!el) return;
            mini.parse(value);
            value = mini.get(value);
        }
        if (value) {
            this.bindPager(value);
        }
    },
    bindPager: function (pager) {
        pager.on('beforepagechanged', this.__OnPageChanged, this);
        this.on(
            'load',
            function (e) {
                pager.updateInfo(this.pageIndex, this.pageSize, this.totalCount);
                this.totalPage = pager.totalPage;
            },
            this
        );
    },

    setIdField: function (value) {
        this.idField = value;
    },
    getIdField: function () {
        return this.idField;
    },
    setUrl: function (url) {
        this.url = url;
    },
    getUrl: function (url) {
        return this.url;
    },
    setAutoLoad: function (value) {
        this.autoLoad = value;
    },
    getAutoLoad: function (value) {
        return this.autoLoad;
    },
    accept: function () {
        this._canUpdateRowEl = false;
        var data = this.getData();
        for (var i = 0, l = data.length; i < l; i++) {
            var row = data[i];
            this.acceptRecord(row);
        }
        this._canUpdateRowEl = true;

        this.doUpdate();
    },
    acceptRecord: function (row) {
        row = this.getRow(row);
        if (!row) return;

        if (row._state == 'removed') {
            this._removes.remove(row);
        }

        delete this._originals[row._uid];
        delete row._state;

        if (this._canUpdateRowEl) {
            this._updateRowEl(row);
        }
    },
    _clearOriginals: true,
    loadData: function (data) {
        if (!mini.isArray(data)) data = [];

        this.data = data;

        if (this._clearOriginals == true) {
            this._originals = {};
        }
        this._removes = [];
        this._idRows = {};
        this._selecteds = [];
        this._idSelecteds = {};

        this._cellErrors = [];
        this._cellMapErrors = {};

        this._margedCells = null;
        this._mergedCellMaps = null;

        this._groupDataView = null;

        for (var i = 0, l = data.length; i < l; i++) {
            var row = data[i];
            row._id = mini.DataGrid.RowID;
            row._uid = row._id;

            row._index = i;
            this._idRows[row._id] = row;

            mini.DataGrid.RowID += 1;
        }

        this.doUpdate();
    },
    setData: function (data) {
        this.loadData(data);
    },
    getData: function () {
        return this.data;
    },
    toArray: function () {
        return this.data;
    },

    getHeaderHeight: function () {
        return this.showHeader ? mini.getHeight(this._headerEl) : 0;
    },
    getFooterHeight: function () {
        return this.showFooter ? mini.getHeight(this._footerEl) : 0;
    },
    getFilterRowHeight: function () {
        return this.showFilterRow ? mini.getHeight(this._filterEl) : 0;
    },
    getSummaryRowHeight: function () {
        return this.showSummaryRow ? mini.getHeight(this._summaryEl) : 0;
    },
    _getScrollHeight: function () {
        return this.isFrozen() ? mini.getHeight(this._scrollEl) : 0;
    },

    _CreateTopTr: function (name) {
        var isEmpty = name == 'empty';
        var height = 0;
        if (isEmpty && this.showEmptyText == false) height = 1;

        var s = '';
        var columns = this.getBottomColumns();
        if (isEmpty) {
            s += '<tr style="height:' + height + 'px">';
        } else {
            if (isIE) {
                if (isIE6 || isIE7 || (isIE8 && !mini.boxModel) || (isIE9 && !mini.boxModel)) {
                    s += '<tr style="display:none;height:0px;">';
                } else {
                    s += '<tr style="height:0px;">';
                }
            } else {
                s += '<tr style="height:' + height + 'px">';
            }
        }
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            var width = column.width;
            var id = this._createColumnId(column) + '_' + name;

            s += '<td id="' + id + '" style="padding:0;border:0;margin:0;height:' + height + 'px;';
            if (column.width) s += 'width:' + column.width;

            if (i < this.frozenStartColumn || column.visible == false) {
                s += ';display:none;';
            }

            s += '" ></td>';
        }
        s += '</tr>';
        return s;
    },
    _doUpdateFilterRow: function () {
        if (this._filterEl.firstChild) {
            this._filterEl.removeChild(this._filterEl.firstChild);
        }
        var isFrozen = this.isFrozen();
        var columns = this.getBottomColumns();
        var sb = [];
        sb[sb.length] = '<table class="mini-grid-table" cellspacing="0" cellpadding="0">';
        sb[sb.length] = this._CreateTopTr('filter');
        sb[sb.length] = '<tr >';
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            var id = this._createFilterCellId(column);

            sb[sb.length] = '<td id="';
            sb[sb.length] = id;
            sb[sb.length] = '" class="mini-grid-filterCell" style="';
            if ((isFrozen && i < this.frozenStartColumn) || column.visible == false || column._hide == true) {
                sb[sb.length] = ';display:none;';
            }
            sb[sb.length] = '"><span class="mini-grid-hspace"></span></td>';
        }

        sb[sb.length] = '</tr></table><div class="mini-grid-scrollCell"></div>';
        this._filterEl.innerHTML = sb.join('');

        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            if (column.filter) {
                var cellEl = this.getFilterCellEl(i);
                column.filter.render(cellEl);
            }
        }
    },
    refreshSummaryRow: function () {
        var records = this.getData();
        if (this._summaryEl.firstChild) {
            this._summaryEl.removeChild(this._summaryEl.firstChild);
        }
        var isFrozen = this.isFrozen();
        var columns = this.getBottomColumns();
        var sb = [];
        sb[sb.length] = '<table class="mini-grid-table" cellspacing="0" cellpadding="0">';
        sb[sb.length] = this._CreateTopTr('summary');
        sb[sb.length] = '<tr >';
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            var id = this._createSummaryCellId(column);

            var e = this._OnDrawSummaryCell(records, column);

            sb[sb.length] = '<td id="';
            sb[sb.length] = id;
            sb[sb.length] = '" class="mini-grid-summaryCell ' + e.cellCls + '" style="' + e.cellStyle + ';';
            if ((isFrozen && i < this.frozenStartColumn) || column.visible == false || column._hide == true) {
                sb[sb.length] = ';display:none;';
            }
            sb[sb.length] = '">';
            sb[sb.length] = e.cellHtml;
            sb[sb.length] = '</td>';
        }

        sb[sb.length] = '</tr></table><div class="mini-grid-scrollCell"></div>';
        this._summaryEl.innerHTML = sb.join('');
    },
    _createHeaderText: function (column) {
        var header = column.header;
        if (typeof header == 'function') header = header.call(this, column);
        if (mini.isNull(header) || header === '') header = '&nbsp;';
        return header;
    },
    _doUpdateHeader: function (style) {
        style = style || '';
        var isFrozen = this.isFrozen();

        var rows = this.getColumnRows();

        var bottomColumns = this.getBottomColumns();
        var columnLength = bottomColumns.length;

        var sb = [];
        sb[sb.length] =
            '<table style="' + style + ';display:table" class="mini-grid-table" cellspacing="0" cellpadding="0">';
        sb[sb.length] = this._CreateTopTr('header');

        for (var j = 0, k = rows.length; j < k; j++) {
            var columns = rows[j];

            sb[sb.length] = '<tr >';
            for (var i = 0, l = columns.length; i < l; i++) {
                var column = columns[i];
                var header = this._createHeaderText(column);

                var columnId = this._createColumnId(column);

                var sortCls = '';
                if (this.sortField == column.field) {
                    sortCls = this.sortOrder == 'asc' ? 'mini-grid-asc' : 'mini-grid-desc';
                }

                sb[sb.length] = '<td id="';
                sb[sb.length] = columnId;
                sb[sb.length] = '" class="mini-grid-headerCell ' + sortCls + ' ' + (column.headerCls || '') + ' ';

                if (i == columnLength - 1) {
                    sb[sb.length] = ' mini-grid-last-column ';
                }

                sb[sb.length] = '" style="';
                var bottomIndex = bottomColumns.indexOf(column);
                if (
                    (isFrozen && bottomIndex != -1 && bottomIndex < this.frozenStartColumn) ||
                    column.visible == false ||
                    column._hide == true
                ) {
                    sb[sb.length] = ';display:none;';
                }

                if (column.columns && column.columns.length > 0 && column.colspan == 0) {
                    sb[sb.length] = ';display:none;';
                }

                if (column.headerStyle) {
                    sb[sb.length] = column.headerStyle + ';';
                }
                if (column.headerAlign) {
                    sb[sb.length] = 'text-align:' + column.headerAlign + ';';
                }

                sb[sb.length] = '" ';

                if (column.rowspan) {
                    sb[sb.length] = 'rowspan="' + column.rowspan + '" ';
                }
                if (column.colspan) {
                    sb[sb.length] = 'colspan="' + column.colspan + '" ';
                }

                sb[sb.length] = '><div class="mini-grid-cellInner">';

                sb[sb.length] = header;

                if (sortCls) {
                    sb[sb.length] = '<span class="mini-grid-sortIcon"></span>';
                }

                sb[sb.length] = '</div>';

                sb[sb.length] = '</td>';
            }
            sb[sb.length] = '</tr>';
        }
        sb[sb.length] = '</table>';

        var s = sb.join('');
        s = '<div class="mini-grid-header">' + s + '</div>';

        var s = '<div class="mini-grid-scrollHeaderCell"></div>';
        s += '<div class="mini-grid-topRightCell"></div>';

        this._headerInnerEl.innerHTML = sb.join('') + s;
        this._topRightCellEl = this._headerInnerEl.lastChild;

        this.fire('refreshHeader');
    },
    _destroyEditors: function () {
        var controls = mini.getChildControls(this);
        var editors = [];
        for (var i = 0, l = controls.length; i < l; i++) {
            var ui = controls[i];
            if (ui.el && mini.findParent(ui.el, this.rowCls)) {
                editors.push(ui);
                ui.destroy();
            }
        }
    },
    refreshBody: function () {
        this._destroyEditors();

        var columns = this.getBottomColumns();

        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            delete column._hide;
        }

        this._doUpdateHeader();

        var data = this.data;

        var isVirtualScroll = this.isVirtualScroll();
        var viewRegion = this._markRegion();

        var sb = [];

        var autoHeight = this.isAutoHeight();
        var top = 0;

        if (isVirtualScroll) {
            top = viewRegion.top;
        }

        if (autoHeight) {
            sb[sb.length] = '<table class="mini-grid-table" cellspacing="0" cellpadding="0">';
        } else {
            sb[sb.length] =
                '<table style="position:absolute;top:' +
                top +
                'px;left:0;" class="mini-grid-table" cellspacing="0" cellpadding="0">';
        }

        sb[sb.length] = this._CreateTopTr('body');

        if (data.length > 0) {
            if (this.isGrouping()) {
                var rowIndex = 0;

                var groups = this._getGroupDataView();
                var visibleColumns = this.getVisibleColumns();

                for (var j = 0, k = groups.length; j < k; j++) {
                    var group = groups[j];
                    var id = this.uid + '_group_' + group.id;
                    var e = this._OnDrawGroup(group);

                    sb[sb.length] =
                        '<tr id="' +
                        id +
                        '" class="mini-grid-groupRow"><td class="mini-grid-groupCell" colspan="' +
                        visibleColumns.length +
                        '"><div class="mini-grid-groupHeader">';
                    sb[sb.length] = '<div class="mini-grid-group-ecicon"></div>';
                    sb[sb.length] = '<div class="mini-grid-groupTitle">' + e.cellHtml + '</div>';
                    sb[sb.length] = '</div></td></tr>';

                    var rows = group.rows;
                    for (var i = 0, l = rows.length; i < l; i++) {
                        var row = rows[i];
                        this._createRow(row, sb, rowIndex++);
                    }

                    if (this.showGroupSummary) {
                    }
                }
            } else {
                if (isVirtualScroll) {
                    var start = viewRegion.start,
                        end = viewRegion.end;
                    for (var i = start, l = end; i < l; i++) {
                        var row = data[i];
                        this._createRow(row, sb, i);
                    }
                } else {
                    for (var i = 0, l = data.length; i < l; i++) {
                        var row = data[i];
                        this._createRow(row, sb, i);
                    }
                }
            }
        } else {
            if (this.showEmptyText) {
                sb[sb.length] =
                    '<tr ><td class="mini-grid-emptyText" colspan="' +
                    this.getVisibleColumns().length +
                    '">' +
                    this.emptyText +
                    '</td></tr>';
            }
        }
        sb[sb.length] = '</table>';

        if (this._bodyInnerEl.firstChild) {
            this._bodyInnerEl.removeChild(this._bodyInnerEl.firstChild);
        }

        this._bodyInnerEl.innerHTML = sb.join('');

        if (isVirtualScroll) {
            this._rowHeight = 23;
            try {
                var rowEl = this._bodyInnerEl.firstChild.rows[1];
                if (rowEl) this._rowHeight = rowEl.offsetHeight;
            } catch (ex) {}
            var rowAllHeight = this._rowHeight * this.data.length;

            this._bodyScrollEl.style.display = 'block';
            this._bodyScrollEl.style.height = rowAllHeight + 'px';
        } else {
            this._bodyScrollEl.style.display = 'none';
        }
    },

    _createRow: function (row, sb, rowIndex) {
        if (!mini.isNumber(rowIndex)) rowIndex = this.indexOf(row);

        var lastRow = rowIndex == this.data.length - 1;

        var isFrozen = this.isFrozen();
        var ret = !sb;
        if (!sb) sb = [];
        var columns = this.getBottomColumns();

        var rowClsIndex = -1;
        var rowCls = ' ';
        var rowStyleIndex = -1;
        var rowStyle = ' ';

        sb[sb.length] = '<tr id="';
        sb[sb.length] = this._createRowId(row);
        sb[sb.length] = '" class="mini-grid-row ';
        if (this.isSelected(row)) {
            sb[sb.length] = this.rowSelectedCls;
            sb[sb.length] = ' ';
        }

        if (row._state == 'deleted') sb[sb.length] = 'mini-grid-deleteRow ';
        if (row._state == 'added' && this.showNewRow) sb[sb.length] = 'mini-grid-newRow ';

        if (this.allowAlternating && rowIndex % 2 == 1) {
            sb[sb.length] = this.alternatingCls;
            sb[sb.length] = ' ';
        }

        rowClsIndex = sb.length;
        sb[sb.length] = rowCls;
        sb[sb.length] = '" style="';
        rowStyleIndex = sb.length;
        sb[sb.length] = rowStyle;
        sb[sb.length] = '">';

        var columnsCount = columns.length - 1;

        for (var j = 0, k = columnsCount; j <= k; j++) {
            var column = columns[j];

            var isModified = column.field ? this._HasRowModified(row, column.field) : false;
            var error = this.getCellError(row, column);

            var e = this._OnDrawCell(row, column, rowIndex, j);

            var cellId = this._createCellId(row, column);

            sb[sb.length] = '<td id="';
            sb[sb.length] = cellId;
            sb[sb.length] = '" class="mini-grid-cell ';
            if (e.cellCls) sb[sb.length] = e.cellCls;
            if (error) sb[sb.length] = ' mini-grid-cell-error ';

            if (this._currentCell && this._currentCell[0] == row && this._currentCell[1] == column) {
                sb[sb.length] = ' ';
                sb[sb.length] = this._cellSelectedCls;
            }

            if (lastRow) {
                sb[sb.length] = ' mini-grid-last-row ';
            }
            if (j == columnsCount) {
                sb[sb.length] = ' mini-grid-last-column ';
            }

            if (isFrozen && this.frozenStartColumn <= j && j <= this.frozenEndColumn) {
                sb[sb.length] = ' ';
                sb[sb.length] = this.frozenCellCls + ' ';
            }

            sb[sb.length] = '" style="';

            if (column.align) {
                sb[sb.length] = 'text-align:';
                sb[sb.length] = column.align;
                sb[sb.length] = ';';
            }

            if (e.allowCellWrap) {
                sb[sb.length] = 'white-space:normal;text-overflow:normal;word-break:break-all;';
            }

            if (e.cellStyle) {
                sb[sb.length] = e.cellStyle;
                sb[sb.length] = ';';
            }

            if ((isFrozen && j < this.frozenStartColumn) || column.visible == false || column._hide == true) {
                sb[sb.length] = 'display:none;';
            }
            if (e.visible == false) {
                sb[sb.length] = 'display:none;';
            }

            sb[sb.length] = '" ';

            if (e.rowSpan) {
                sb[sb.length] = 'rowspan="' + e.rowSpan + '"';
            }
            if (e.colSpan) {
                sb[sb.length] = 'colspan="' + e.colSpan + '"';
            }

            sb[sb.length] = '>';

            var dirtyCls = isModified && this.showModified && this.showDirty ? 'mini-grid-cell-dirty' : '';

            sb[sb.length] = '<div class="mini-grid-cell-inner ' + dirtyCls + '">';
            if (isModified && this.showModified && this.showDirty) {
            }

            sb[sb.length] = e.cellHtml;

            sb[sb.length] = '</div>';

            sb[sb.length] = '</td>';

            if (e.rowCls) rowCls = e.rowCls;
            if (e.rowStyle) rowStyle = e.rowStyle;
        }

        sb[rowClsIndex] = rowCls;
        sb[rowStyleIndex] = rowStyle;

        sb[sb.length] = '</tr>';

        if (ret) {
            return sb.join('');
        }
    },
    isVirtualScroll: function () {
        return this.virtualScroll && this.isAutoHeight() == false && this.isGrouping() == false;
    },
    getScrollLeft: function () {
        return this.isFrozen() ? this._scrollEl.scrollLeft : this._bodyEl.scrollLeft;
    },

    doUpdate: function () {
        var sss = new Date();
        if (this._allowUpdate === false) return;

        if (this.isAutoHeight() == true) {
            this.addCls('mini-grid-auto');
        } else {
            this.removeCls('mini-grid-auto');
        }

        if (this.refreshSummaryRow) this.refreshSummaryRow();

        this.refreshBody();

        this.invalidateLayout();
    },
    _fixIE: function () {
        if (isIE) {
            this._borderEl.style.display = 'none';
            h = this.getHeight(true);
            w = this.getWidth(true);
            this._borderEl.style.display = '';
        }
    },

    doLayout: function () {
        this._filterEl.scrollLeft =
            this._summaryEl.scrollLeft =
            this._headerInnerEl.scrollLeft =
                this._bodyEl.scrollLeft;

        var sss = new Date();

        var isFrozen = this.isFrozen();

        var headerTable = this._headerInnerEl.firstChild,
            bodyTable = this._bodyInnerEl.firstChild;
        var filterTable = this._filterEl.firstChild,
            summaryTable = this._summaryEl.firstChild;

        var data = this.getData();
        if (data.length == 0) {
            bodyTable.style.height = '1px';
        } else {
            bodyTable.style.height = 'auto';
        }

        var autoHeight = this.isAutoHeight();

        h = this.getHeight(true);
        w = this.getWidth(true);

        var elWidth = w;
        if (elWidth < 17) elWidth = 17;
        if (h < 0) h = 0;

        var bodyWidth = elWidth,
            bodyHeight = 2000;

        if (!autoHeight) {
            h =
                h -
                this.getHeaderHeight() -
                this.getFooterHeight() -
                this.getFilterRowHeight() -
                this.getSummaryRowHeight() -
                this._getScrollHeight();
            h += 1;
            if (h < 0) h = 0;

            this._bodyEl.style.height = h + 'px';

            bodyHeight = h;
        } else {
            this._bodyEl.style.height = 'auto';
        }

        var bodyScrollHeight = this._bodyEl.scrollHeight;
        var bodyClientHeight = this._bodyEl.clientHeight;

        var hiddenY = jQuery(this._bodyEl).css('overflow-y') == 'hidden';
        if (this.isFitColumns()) {
            if (hiddenY || bodyClientHeight >= bodyScrollHeight || autoHeight) {
                var w = bodyWidth + 'px';
                headerTable.style.width = w;
                bodyTable.style.width = w;
                filterTable.style.width = w;
                summaryTable.style.width = w;
            } else {
                var w = parseInt(bodyWidth - 18);
                if (w < 0) w = 0;
                w = w + 'px';
                headerTable.style.width = w;
                bodyTable.style.width = w;
                filterTable.style.width = w;
                summaryTable.style.width = w;
            }
            if (autoHeight) {
                if (bodyWidth >= this._bodyEl.scrollWidth - 1) {
                    this._bodyEl.style.height = 'auto';
                } else {
                    this._bodyEl.style.height = bodyTable.offsetHeight + 17 + 'px';
                }
            }
            if (autoHeight && isFrozen) {
                this._bodyEl.style.height = 'auto';
            }
        } else {
            headerTable.style.width = bodyTable.style.width = '0px';
            filterTable.style.width = summaryTable.style.width = '0px';
        }

        if (this.isFitColumns()) {
            if (!hiddenY && bodyClientHeight < bodyScrollHeight) {
                var w = elWidth - 18;
                if (w < 0) w = 0;
            } else {
                this._headerInnerEl.style.width = '100%';
                this._filterEl.style.width = '100%';
                this._summaryEl.style.width = '100%';
                this._footerEl.style.width = 'auto';
            }
        } else {
            this._headerInnerEl.style.width = '100%';
            this._filterEl.style.width = '100%';
            this._summaryEl.style.width = '100%';
            this._footerEl.style.width = 'auto';
        }

        if (this.isFrozen()) {
            if (!hiddenY && bodyClientHeight < this._bodyEl.scrollHeight) {
                this._scrollEl.style.width = elWidth - 17 + 'px';
            } else {
                this._scrollEl.style.width = elWidth + 'px';
            }

            if (this._bodyEl.offsetWidth < bodyTable.offsetWidth || this.isFrozen()) {
                this._scrollEl.firstChild.style.width = this._getColumnsScrollWidth() + 'px';
                headerTable.style.width = bodyTable.style.width = '0px';
                filterTable.style.width = summaryTable.style.width = '0px';
            } else {
                this._scrollEl.firstChild.style.width = '0px';
            }
        } else {
        }

        if (this.data.length == 0) {
            this._doInnerLayout();
        } else {
            var me = this;
            if (!this._innerLayoutTimer) {
                this._innerLayoutTimer = setTimeout(function () {
                    me._doInnerLayout();
                    me._innerLayoutTimer = null;
                }, 10);
            }
        }

        this._doLayoutTopRightCell();

        this.fire('layout');

        if (this.isFrozen()) {
            if (this._scrollEl.scrollLeft != this.__frozenScrollLeft) {
                this._doScrollFrozen();
            }
        }
    },

    _doLayoutTopRightCell: function () {
        var headerTable = this._headerInnerEl.firstChild;
        var width = headerTable.offsetWidth + 1;
        var height = headerTable.offsetHeight - 1;
        if (height < 0) height = 0;
        this._topRightCellEl.style.left = width + 'px';
        this._topRightCellEl.style.height = height + 'px';
    },

    _doInnerLayout: function () {
        this._doLayoutDetailRows();
        this._doLayoutEditingRows();
        mini.layout(this._filterEl);
        mini.layout(this._summaryEl);
        mini.layout(this._footerEl);
        mini.repaint(this.el);
        this._doLayouted = true;
    },

    setFitColumns: function (value) {
        this.fitColumns = value;

        if (this.fitColumns) {
            mini.removeClass(this.el, 'mini-grid-fixcolumns');
        } else {
            mini.addClass(this.el, 'mini-grid-fixcolumns');
        }

        this.invalidateLayout();
    },
    getFitColumns: function (value) {
        return this.fitColumns;
    },
    isFitColumns: function () {
        return this.fitColumns && !this.isFrozen();
    },
    _getColumnsScrollWidth: function () {
        if (this._bodyEl.offsetWidth < this._bodyInnerEl.firstChild.offsetWidth || this.isFrozen()) {
            var width = 0;
            var columns = this.getBottomColumns();
            for (var i = 0, l = columns.length; i < l; i++) {
                var column = columns[i];

                width += this.getColumnWidth(column);
            }
            return width;
        } else {
            return 0;
        }
    },
    _createRowId: function (row) {
        return this.uid + '_' + row._uid;
    },
    _createCellId: function (row, column) {
        return this.uid + '_' + row._uid + '_' + column._id;
    },
    _createFilterCellId: function (column) {
        return this.uid + '_filter_' + column._id;
    },
    _createSummaryCellId: function (column) {
        return this.uid + '_summary_' + column._id;
    },
    _createRowDetailId: function (row) {
        return this.uid + '_detail_' + row._uid;
    },
    _getHeaderScrollEl: function () {
        return this._headerInnerEl;
    },
    getFilterCellEl: function (column) {
        column = this.getColumn(column);
        if (!column) return null;

        return mini.byId(this._createFilterCellId(column), this.el);
    },
    getSummaryCellEl: function (column) {
        column = this.getColumn(column);
        if (!column) return null;
        return mini.byId(this._createSummaryCellId(column), this.el);
    },

    _getRowEl: function (row) {
        row = this.getRow(row);
        if (!row) return null;
        var id = this._createRowId(row);
        return mini.byId(id, this.el);
    },
    getCellBox: function (row, column) {
        row = this.getRow(row);
        column = this.getColumn(column);
        if (!row || !column) return null;
        var cellEl = this._getCellEl(row, column);
        if (!cellEl) return null;
        return mini.getBox(cellEl);
    },
    getRowBox: function (row) {
        var rowEl = this._getRowEl(row);
        if (rowEl) return mini.getBox(rowEl);
        return null;
    },
    getRowsBox: function () {
        var rowBoxs = [];
        var rows = this.data;
        var top = 0;

        for (var i = 0, l = rows.length; i < l; i++) {
            var row = rows[i];
            var id = this._createRowId(row);
            var rowEl = document.getElementById(id);
            if (rowEl) {
                var h = rowEl.offsetHeight;
                rowBoxs[i] = { top: top, height: h, bottom: top + h };
                top += h;
            }
        }
        return rowBoxs;
    },
    setColumnWidth: function (column, width) {
        column = this.getColumn(column);
        if (!column) return;
        if (mini.isNumber(width)) width += 'px';
        column.width = width;

        var id1 = this._createColumnId(column) + '_header';
        var id2 = this._createColumnId(column) + '_body';
        var id3 = this._createColumnId(column) + '_filter';
        var id4 = this._createColumnId(column) + '_summary';
        var el1 = document.getElementById(id1);
        var el2 = document.getElementById(id2);
        var el3 = document.getElementById(id3);
        var el4 = document.getElementById(id4);
        if (el1) el1.style.width = width;
        if (el2) el2.style.width = width;
        if (el3) el3.style.width = width;
        if (el4) el4.style.width = width;

        this.invalidateLayout();

        this.fire('columnschanged');
    },
    getColumnWidth: function (column) {
        column = this.getColumn(column);
        if (!column) return 0;
        if (column.visible == false) return 0;

        var w = 0;
        var id = this._createColumnId(column) + '_body';
        var el = document.getElementById(id);
        if (el) {
            var display = el.style.display;
            el.style.display = '';
            w = mini.getWidth(el);
            el.style.display = display;
        }
        return w;
    },
    _doVisibleColumn: function (column, visible) {
        var columnEl = document.getElementById(this._createColumnId(column));
        if (columnEl) columnEl.style.display = visible ? '' : 'none';

        var filterCell = document.getElementById(this._createFilterCellId(column));
        if (filterCell) filterCell.style.display = visible ? '' : 'none';

        var summaryCell = document.getElementById(this._createSummaryCellId(column));
        if (summaryCell) summaryCell.style.display = visible ? '' : 'none';

        var id1 = this._createColumnId(column) + '_header';
        var id2 = this._createColumnId(column) + '_body';
        var id3 = this._createColumnId(column) + '_filter';
        var id4 = this._createColumnId(column) + '_summary';
        var el1 = document.getElementById(id1);
        if (el1) el1.style.display = visible ? '' : 'none';
        var el3 = document.getElementById(id3);
        if (el3) el3.style.display = visible ? '' : 'none';
        var el4 = document.getElementById(id4);
        if (el4) el4.style.display = visible ? '' : 'none';

        if (el2) {
            if (visible && el2.style.display == '') return;
            if (!visible && el2.style.display == 'none') return;
        }

        var el2 = document.getElementById(id2);
        if (el2) el2.style.display = visible ? '' : 'none';

        var data = this.data;

        if (this.isVirtualScroll()) {
            var viewRegion = this._markRegion();
            var start = viewRegion.start,
                end = viewRegion.end;
            for (var i = start, l = end; i < l; i++) {
                var row = data[i];
                var cellId = this._createCellId(row, column);
                var cellEl = document.getElementById(cellId);
                if (cellEl) {
                    cellEl.style.display = visible ? '' : 'none';
                }
            }
        } else {
            for (var i = 0, l = this.data.length; i < l; i++) {
                var row = this.data[i];
                var cellId = this._createCellId(row, column);
                var cellEl = document.getElementById(cellId);
                if (cellEl) {
                    cellEl.style.display = visible ? '' : 'none';
                }
            }
        }
    },
    _doClassColumn: function (column, cls, add) {
        var data = this.data;

        if (this.isVirtualScroll()) {
            var viewRegion = this._markRegion();
            var start = viewRegion.start,
                end = viewRegion.end;
            for (var i = start, l = end; i < l; i++) {
                var row = data[i];
                var cellId = this._createCellId(row, column);
                var cellEl = document.getElementById(cellId);
                if (cellEl) {
                    if (add) {
                        mini.addClass(cellEl, cls);
                    } else {
                        mini.removeClass(cellEl, cls);
                    }
                }
            }
        } else {
            for (var i = 0, l = this.data.length; i < l; i++) {
                var row = this.data[i];
                var cellId = this._createCellId(row, column);
                var cellEl = document.getElementById(cellId);
                if (cellEl) {
                    if (add) {
                        mini.addClass(cellEl, cls);
                    } else {
                        mini.removeClass(cellEl, cls);
                    }
                }
            }
        }
    },

    __doFrozen: function () {
        if (!this.el) return;
        this._scrollEl.scrollLeft = this._headerInnerEl.scrollLeft = this._bodyEl.scrollLeft = 0;

        var isFrozen = this.isFrozen();
        if (isFrozen) {
            mini.addClass(this.el, this.frozenCls);
        } else {
            mini.removeClass(this.el, this.frozenCls);
        }

        var columns = this.getBottomColumns();

        var filterTable = this._filterEl.firstChild,
            summaryTable = this._summaryEl.firstChild;

        if (isFrozen) {
            filterTable.style.height = jQuery(filterTable).outerHeight() + 'px';
            summaryTable.style.height = jQuery(summaryTable).outerHeight() + 'px';
        } else {
            filterTable.style.height = 'auto';
            summaryTable.style.height = 'auto';
        }

        if (this.isFrozen()) {
            for (var i = 0, l = columns.length; i < l; i++) {
                var column = columns[i];
                if (this.frozenStartColumn <= i && i <= this.frozenEndColumn) {
                    this._doClassColumn(column, this.frozenCellCls, true);
                } else {
                    this._doClassColumn(column, this.frozenCellCls, false);
                }
            }

            this._doFixRowsHeight(true);
        } else {
            for (var i = 0, l = columns.length; i < l; i++) {
                var column = columns[i];
                delete column._hide;
                if (column.visible) {
                    this._doVisibleColumn(column, true);
                }
                this._doClassColumn(column, this.frozenCellCls, false);
            }
            this._doUpdateHeader();

            this._doFixRowsHeight(false);
        }

        this.invalidateLayout();

        this._fixIE();
    },
    _deferFrozen: function () {
        this._headerTableHeight = mini.getHeight(this._headerInnerEl.firstChild);

        var me = this;
        if (this._deferFrozenTimer) clearTimeout(this._deferFrozenTimer);
        this._deferFrozenTimer = setTimeout(function () {
            me.__doFrozen();
        }, 1);
    },
    setFrozenStartColumn: function (value) {
        var sss = new Date();
        value = parseInt(value);
        if (isNaN(value)) return;
        this.frozenStartColumn = value;
        this._deferFrozen();
    },
    getFrozenStartColumn: function () {
        return this.frozenStartColumn;
    },
    setFrozenEndColumn: function (value) {
        value = parseInt(value);
        if (isNaN(value)) return;
        this.frozenEndColumn = value;

        this._deferFrozen();
    },
    getFrozenEndColumn: function () {
        return this.frozenEndColumn;
    },
    unFrozenColumns: function () {
        this.setFrozenStartColumn(-1);
        this.setFrozenEndColumn(-1);
    },
    frozenColumns: function (start, end) {
        this.unFrozenColumns();
        this.setFrozenStartColumn(start);
        this.setFrozenEndColumn(end);
    },
    _rowHeight: 23,

    _markRegion: function () {
        var region = this._getViewNowRegion();

        var rowHeight = this._rowHeight;
        var scrollTop = this._bodyEl.scrollTop;

        var start = region.start,
            end = region.end;
        for (var i = 0, l = this.data.length; i < l; i += this._virtualRows) {
            var i2 = i + this._virtualRows;
            if (i <= start && start < i2) {
                start = i;
            }
            if (i < end && end <= i2) {
                end = i2;
            }
        }
        if (end > this.data.length) end = this.data.length;

        var top = start * rowHeight;

        this._viewRegion = { start: start, end: end, top: top };

        return this._viewRegion;
    },
    _getViewNowRegion: function () {
        var rowHeight = this._rowHeight;
        var scrollTop = this._bodyEl.scrollTop;
        var bodyHeight = this._bodyEl.offsetHeight;

        var startRow = parseInt(scrollTop / rowHeight);
        var endRow = parseInt((scrollTop + bodyHeight) / rowHeight) + 1;
        var region = { start: startRow, end: endRow };
        return region;
    },
    _canVirtualUpdate: function () {
        if (!this._viewRegion) return true;
        var region = this._getViewNowRegion();
        if (this._viewRegion.start <= region.start && region.end <= this._viewRegion.end) return false;
        return true;
    },
    _tryUpdateScroll: function () {
        var doUpdate = this._canVirtualUpdate();
        if (doUpdate) {
            this.doUpdate();
        }
    },
    __OnBodyScroll: function (e) {
        this._filterEl.scrollLeft =
            this._summaryEl.scrollLeft =
            this._headerInnerEl.scrollLeft =
                this._bodyEl.scrollLeft;

        var me = this;
        setTimeout(function () {
            me._headerInnerEl.scrollLeft = me._bodyEl.scrollLeft;
        }, 10);

        if (this.isVirtualScroll()) {
            var me = this;
            if (this._scrollTopTimer) {
                clearTimeout(this._scrollTopTimer);
            }
            this._scrollTopTimer = setTimeout(function () {
                me._scrollTopTimer = null;
                me._tryUpdateScroll();
            }, 100);
        }
    },
    __OnHScroll: function (e) {
        var me = this;
        if (this._HScrollTimer) return;
        this._HScrollTimer = setTimeout(function () {
            me._doScrollFrozen();
            me._HScrollTimer = null;
        }, 30);
    },
    _doScrollFrozen: function () {
        if (!this.isFrozen()) return;

        var columns = this.getBottomColumns();

        var x = this._scrollEl.scrollLeft;
        this.__frozenScrollLeft = x;

        var startColumn = this.frozenEndColumn;
        var left = 0;
        for (var i = startColumn + 1, l = columns.length; i < l; i++) {
            var column = columns[i];
            if (!column.visible) {
                continue;
            }
            var w = this.getColumnWidth(column);
            if (x <= left) break;
            startColumn = i;
            left += w;
        }

        if (this._lastStartColumn === startColumn) {
            return;
        }

        this._lastStartColumn = startColumn;

        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            delete column._hide;
            if (this.frozenEndColumn < i && i <= startColumn) {
                column._hide = true;
            }
        }

        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];

            if (
                i < this.frozenStartColumn ||
                (i > this.frozenEndColumn && i < startColumn) ||
                column.visible == false
            ) {
                this._doVisibleColumn(column, false);
            } else {
                this._doVisibleColumn(column, true);
            }
        }

        var style = 'width:100%;';
        if (this._scrollEl.offsetWidth < this._scrollEl.scrollWidth || !this.isFitColumns()) {
            style = 'width:0px';
        }

        this._doUpdateHeader(style);

        var h = this._headerTableHeight;
        if (mini.isIE9) h -= 1;
        mini.setHeight(this._headerInnerEl.firstChild, h);

        for (var i = this.frozenEndColumn + 1, l = columns.length; i < l; i++) {
            var column = columns[i];
            if (!column.visible) continue;
            if (i <= startColumn) {
                this._doVisibleColumn(column, false);
            } else {
                this._doVisibleColumn(column, true);
            }
        }

        this._doUpdateDetailColSpan();

        this._doMargeCells();

        this._doLayoutTopRightCell();

        this.fire('layout');
    },

    _doFixRowsHeight: function (fix) {
        var data = this.data;
        for (var i = 0, l = data.length; i < l; i++) {
            var row = data[i];
            var rowEl = this._getRowEl(row);
            if (rowEl) {
                if (fix) {
                    var h = 0;

                    rowEl.style.height = h + 'px';
                } else {
                    rowEl.style.height = '';
                }
            }
        }
    },

    _doGridLines: function () {
        if (this.showVGridLines) {
            mini.removeClass(this.el, 'mini-grid-hideVLine');
        } else {
            mini.addClass(this.el, 'mini-grid-hideVLine');
        }
        if (this.showHGridLines) {
            mini.removeClass(this.el, 'mini-grid-hideHLine');
        } else {
            mini.addClass(this.el, 'mini-grid-hideHLine');
        }
    },
    setShowHGridLines: function (value) {
        if (this.showHGridLines != value) {
            this.showHGridLines = value;
            this._doGridLines();
            this.invalidateLayout();
        }
    },
    getShowHGridLines: function () {
        return this.showHGridLines;
    },
    setShowVGridLines: function (value) {
        if (this.showVGridLines != value) {
            this.showVGridLines = value;
            this._doGridLines();
            this.invalidateLayout();
        }
    },
    getShowVGridLines: function () {
        return this.showVGridLines;
    },
    setShowFilterRow: function (value) {
        if (this.showFilterRow != value) {
            this.showFilterRow = value;
            this._doShowRows();
            this.invalidateLayout();
        }
    },
    getShowFilterRow: function () {
        return this.showFilterRow;
    },
    setShowSummaryRow: function (value) {
        if (this.showSummaryRow != value) {
            this.showSummaryRow = value;
            this._doShowRows();
            this.invalidateLayout();
        }
    },
    getShowSummaryRow: function () {
        return this.showSummaryRow;
    },
    _doAlternating: function () {
        if (this.allowAlternating == false) return;
        var data = this.data;
        for (var i = 0, l = data.length; i < l; i++) {
            var row = data[i];
            var rowEl = this._getRowEl(row);
            if (rowEl) {
                if (this.allowAlternating && i % 2 == 1) {
                    mini.addClass(rowEl, this.alternatingCls);
                } else {
                    mini.removeClass(rowEl, this.alternatingCls);
                }
            }
        }
    },
    setAllowAlternating: function (value) {
        if (this.allowAlternating != value) {
            this.allowAlternating = value;
            this._doAlternating();
        }
    },
    getAllowAlternating: function () {
        return this.allowAlternating;
    },
    setEnableHotTrack: function (value) {
        if (this.enableHotTrack != value) {
            this.enableHotTrack = value;
        }
    },
    getEnableHotTrack: function () {
        return this.enableHotTrack;
    },
    setShowLoading: function (value) {
        this.showLoading = value;
    },
    setAllowCellWrap: function (value) {
        if (this.allowCellWrap != value) {
            this.allowCellWrap = value;
        }
    },
    getAllowCellWrap: function () {
        return this.allowCellWrap;
    },
    setAllowHeaderWrap: function (value) {
        this.allowHeaderWrap = value;
        mini.removeClass(this.el, 'mini-grid-headerWrap');
        if (value) {
            mini.addClass(this.el, 'mini-grid-headerWrap');
        }
    },
    getAllowHeaderWrap: function () {
        return this.allowHeaderWrap;
    },
    setShowColumnsMenu: function (value) {
        this.showColumnsMenu = value;
    },
    getShowColumnsMenu: function () {
        return this.showColumnsMenu;
    },
    setEditNextOnEnterKey: function (value) {
        this.editNextOnEnterKey = value;
    },
    getEditNextOnEnterKey: function () {
        return this.editNextOnEnterKey;
    },
    setEditOnTabKey: function (value) {
        this.editOnTabKey = value;
    },
    getEditOnTabKey: function () {
        return this.editOnTabKey;
    },

    setVirtualScroll: function (value) {
        if (this.virtualScroll != value) {
            this.virtualScroll = value;
        }
    },
    getVirtualScroll: function () {
        return this.virtualScroll;
    },

    setScrollTop: function (value) {
        this.scrollTop = value;
        this._bodyEl.scrollTop = value;
    },
    getScrollTop: function () {
        return this._bodyEl.scrollTop;
    },
    setBodyStyle: function (value) {
        this.bodyStyle = value;
        mini.setStyle(this._bodyEl, value);
    },
    getBodyStyle: function () {
        return this.bodyStyle;
    },
    setBodyCls: function (value) {
        this.bodyCls = value;
        mini.addClass(this._bodyEl, value);
    },
    getBodyCls: function () {
        return this.bodyCls;
    },
    setFooterStyle: function (value) {
        this.footerStyle = value;
        mini.setStyle(this._footerEl, value);
    },
    getFooterStyle: function () {
        return this.footerStyle;
    },
    setFooterCls: function (value) {
        this.footerCls = value;
        mini.addClass(this._footerEl, value);
    },
    getFooterCls: function () {
        return this.footerCls;
    },
    setShowHeader: function (value) {
        this.showHeader = value;
        this._doShowRows();
        this.invalidateLayout();
    },
    setShowColumns: function (value) {
        this.setShowHeader(value);
    },
    getShowColumns: function () {
        return this.showHeader;
    },
    setShowPager: function (value) {
        this.setShowFooter(value);
    },
    getShowPager: function () {
        return this.showFooter;
    },
    setShowFooter: function (value) {
        this.showFooter = value;
        this._doShowRows();
        this.invalidateLayout();
    },
    getShowFooter: function () {
        return this.showFooter;
    },
    setAutoHideRowDetail: function (value) {
        this.autoHideRowDetail = value;
    },

    setAllowResize: function (value) {
        this.allowResize = value;

        this._resizeEl.style.display = this.allowResize ? '' : 'none';
    },

    __allowLayout: true,

    showAllRowDetail: function () {
        this.__allowLayout = false;
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.data[i];
            this.showRowDetail(row);
        }
        this.__allowLayout = true;
        this.invalidateLayout();
    },
    hideAllRowDetail: function () {
        this.__allowLayout = false;
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.data[i];
            if (this.isShowRowDetail(row)) {
                this.hideRowDetail(row);
            }
        }
        this.__allowLayout = true;
        this.invalidateLayout();
    },
    showRowDetail: function (row) {
        row = this.getRow(row);
        if (!row) return;
        var tr = this.getRowDetailEl(row);
        tr.style.display = '';

        row._showDetail = true;

        var rowEl = this._getRowEl(row);
        mini.addClass(rowEl, 'mini-grid-expandRow');

        this.fire('showrowdetail', { record: row });

        if (this.__allowLayout) {
            this.invalidateLayout();
        }
        var me = this;
    },
    hideRowDetail: function (row) {
        row = this.getRow(row);
        if (!row) return;
        var id = this._createRowDetailId(row);
        var tr = document.getElementById(id);
        if (tr) {
            tr.style.display = 'none';
        }
        delete row._showDetail;
        var rowEl = this._getRowEl(row);
        mini.removeClass(rowEl, 'mini-grid-expandRow');

        this.fire('hiderowdetail', { record: row });
        if (this.__allowLayout) {
            this.invalidateLayout();
        }
    },
    toggleRowDetail: function (row) {
        row = this.getRow(row);
        if (!row) return;
        if (grid.isShowRowDetail(row)) {
            grid.hideRowDetail(row);
        } else {
            grid.showRowDetail(row);
        }
    },
    isShowRowDetail: function (row) {
        row = this.getRow(row);
        if (!row) return false;
        return !!row._showDetail;
    },
    getRowDetailEl: function (row) {
        row = this.getRow(row);
        if (!row) return null;
        var id = this._createRowDetailId(row);
        var el = document.getElementById(id);
        if (!el) {
            el = this._createRowDetail(row);
        }
        return el;
    },
    getRowDetailCellEl: function (row) {
        var el = this.getRowDetailEl(row);
        if (el) return el.cells[0];
    },
    _createRowDetail: function (row) {
        var tr = this._getRowEl(row);
        var id = this._createRowDetailId(row);
        var colSpan = this.getBottomColumns().length;
        jQuery(tr).after(
            '<tr id="' +
                id +
                '" class="mini-grid-detailRow"><td class="mini-grid-detailCell" colspan="' +
                colSpan +
                '"></td></tr>'
        );
        this._doUpdateDetailColSpan();
        return document.getElementById(id);
    },
    _getColSpan: function () {
        var tr = this._bodyInnerEl.firstChild.getElementsByTagName('tr')[0];
        var tds = tr.getElementsByTagName('td');
        var colSpan = 0;
        for (var i = 0, l = tds.length; i < l; i++) {
            var td = tds[i];
            if (td.style.display != 'none') {
                colSpan++;
            }
        }
        return colSpan;
    },
    _doUpdateDetailColSpan: function () {
        var trs = jQuery('.mini-grid-detailRow', this.el);

        var colSpan = this._getColSpan();
        for (var i = 0, l = trs.length; i < l; i++) {
            var tr = trs[i];
            var td = tr.firstChild;
            td.colSpan = colSpan;
        }
    },
    _doLayoutDetailRows: function () {
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.data[i];
            if (row._showDetail == true) {
                var id = this._createRowDetailId(row);
                var el = document.getElementById(id);
                if (el) {
                    mini.layout(el);
                }
            }
        }
    },
    _doLayoutEditingRows: function () {
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.data[i];
            if (row._editing == true) {
                var el = this._getRowEl(row);
                if (el) {
                    mini.layout(el);
                }
            }
        }
    },

    __OnPageChanged: function (e) {
        e.cancel = true;
        this.gotoPage(e.pageIndex, e.pageSize);
    },
    setShowReloadButton: function (value) {
        this.pager.setShowReloadButton(value);
    },
    getShowReloadButton: function () {
        return this.pager.getShowReloadButton();
    },
    setShowPageInfo: function (value) {
        this.pager.setShowPageInfo(value);
    },
    getShowPageInfo: function () {
        return this.pager.getShowPageInfo();
    },
    setSizeList: function (value) {
        if (!mini.isArray(value)) return;
        this.pager.setSizeList(value);
    },
    getSizeList: function () {
        return this.pager.getSizeList();
    },
    setPageSize: function (value) {
        value = parseInt(value);
        if (isNaN(value)) return;
        this.pageSize = value;
        if (this.pager) this.pager.updateInfo(this.pageIndex, this.pageSize, this.totalCount);
    },
    getPageSize: function () {
        return this.pageSize;
    },
    setPageIndex: function (value) {
        value = parseInt(value);
        if (isNaN(value)) return;
        this.pageIndex = value;
        if (this.pager) this.pager.updateInfo(this.pageIndex, this.pageSize, this.totalCount);
    },
    getPageIndex: function () {
        return this.pageIndex;
    },
    setShowPageSize: function (value) {
        this.showPageSize = value;
        this.pager.setShowPageSize(value);
    },
    getShowPageSize: function () {
        return this.showPageSize;
    },
    setShowPageIndex: function (value) {
        this.showPageIndex = value;
        this.pager.setShowPageIndex(value);
    },
    getShowPageIndex: function () {
        return this.showPageIndex;
    },
    setShowTotalCount: function (value) {
        this.showTotalCount = value;
        this.pager.setShowTotalCount(value);
    },
    getShowTotalCount: function () {
        return this.showTotalCount;
    },

    setPageIndexField: function (value) {
        this.pageIndexField = value;
    },
    getPageIndexField: function () {
        return this.pageIndexField;
    },
    setPageSizeField: function (value) {
        this.pageSizeField = value;
    },
    getPageSizeField: function () {
        return this.pageSizeField;
    },
    setSortFieldField: function (value) {
        this.sortFieldField = value;
    },
    getSortFieldField: function () {
        return this.sortFieldField;
    },
    setSortOrderField: function (value) {
        this.sortOrderField = value;
    },
    getSortOrderField: function () {
        return this.sortOrderField;
    },
    setTotalField: function (value) {
        this.totalField = value;
    },
    getTotalField: function () {
        return this.totalField;
    },
    setDataField: function (value) {
        this.dataField = value;
    },
    getDataField: function () {
        return this.dataField;
    },

    getSortField: function () {
        return this.sortField;
    },
    getSortOrder: function () {
        return this.sortOrder;
    },

    pageIndex: 0,
    pageSize: 10,
    totalCount: 0,
    totalPage: 0,
    showPageInfo: true,

    pageIndexField: 'pageIndex',
    pageSizeField: 'pageSize',
    sortFieldField: 'sortField',
    sortOrderField: 'sortOrder',
    totalField: 'total',

    showPageSize: true,
    showPageIndex: true,
    showTotalCount: true,

    setTotalCount: function (value) {
        this.totalCount = value;
        this.pager.setTotalCount(value);
    },
    getTotalCount: function () {
        return this.totalCount;
    },
    getTotalPage: function () {
        return this.totalPage;
    },

    sortField: '',
    sortOrder: '',

    url: '',
    autoLoad: false,
    loadParams: null,

    ajaxAsync: true,
    ajaxMethod: 'post',
    showLoading: true,

    resultAsData: false,
    checkSelectOnLoad: true,
    setCheckSelectOnLoad: function (value) {
        this.checkSelectOnLoad = value;
    },
    getCheckSelectOnLoad: function () {
        return this.checkSelectOnLoad;
    },

    totalField: 'total',
    dataField: 'data',
    _getFromData: function (result) {
        return result.data;
    },
    getResultObject: function () {
        return this._resultObject ? this._resultObject : {};
    },
    _doLoad: function (params, success, fail) {
        try {
            var url = eval(this.url);
            if (url != undefined) {
                this.url = url;
            }
        } catch (e) {}

        params = params || {};
        if (mini.isNull(params.pageIndex)) params.pageIndex = this.pageIndex;
        if (mini.isNull(params.pageSize)) params.pageSize = this.pageSize;
        params.sortField = this.sortField;
        params.sortOrder = this.sortOrder;

        if (this.sortMode != 'server') {
            params.sortField = this.sortField = '';
            params.sortOrder = this.sortOrder = '';
        }

        this.loadParams = params;

        var o = {};
        o[this.pageIndexField] = params.pageIndex;
        o[this.pageSizeField] = params.pageSize;
        if (params.sortField) o[this.sortFieldField] = params.sortField;
        if (params.sortOrder) o[this.sortOrderField] = params.sortOrder;

        mini.copyTo(params, o);

        var url = this.url;
        var ajaxMethod = this.ajaxMethod;
        if (url) {
            if (url.indexOf('.txt') != -1 || url.indexOf('.json') != -1) {
                ajaxMethod = 'get';
            }
        } else {
            ajaxMethod = 'get';
        }

        var e = {
            url: url,
            async: this.ajaxAsync,
            type: ajaxMethod,
            data: params,
            params: params,
            cache: false,
            cancel: false
        };
        this.fire('beforeload', e);
        if (e.data != e.params && e.params != params) {
            e.data = e.params;
        }
        if (e.cancel == true) {
            params.pageIndex = this.getPageIndex();
            params.pageSize = this.getPageSize();

            return;
        }
        if (this.showLoading) {
            this.loading();
        }

        this._selectedValue = this._selected ? this._selected[this.idField] : null;

        var sf = (me = this);
        var url = e.url;

        mini.copyTo(e, {
            success: function (text, code, jqXHR) {
                var result = null;
                try {
                    result = mini.decode(text);
                } catch (ex) {
                    if (mini_debugger == true) {
                        alert(url + '\ndatagrid json is error.');
                    }
                }

                if (result && !mini.isArray(result)) {
                    result.total = parseInt(mini._getMap(me.totalField, result));
                    result.data = mini._getMap(me.dataField, result);
                } else {
                    if (result == null) {
                        result = {};
                        result.data = [];
                        result.total = 0;
                    } else if (mini.isArray(result)) {
                        var r = {};
                        r.data = result;
                        r.total = result.length;
                        result = r;
                    }
                }
                if (!result.data) result.data = [];
                if (!result.total) result.total = 0;
                sf._resultObject = result;

                sf.unmask();

                if (mini.isNumber(result.error) && result.error != 0) {
                    var e = { errorCode: result.error, xmlHttp: jqXHR, errorMsg: result.message, result: result };
                    if (mini_debugger == true) {
                        alert(url + '\n' + e.errorMsg + '\n' + result.stackTrace);
                    }
                    sf.fire('loaderror', e);
                    if (fail) {
                        fail.call(sf, e);
                    }
                    return;
                }

                var total = result.total;
                var data = sf._getFromData(result);

                if (mini.isNumber(params.pageIndex)) sf.pageIndex = params.pageIndex;
                if (mini.isNumber(params.pageSize)) sf.pageSize = params.pageSize;
                if (mini.isNumber(total)) sf.totalCount = total;

                var ex = { result: result, data: data, total: total, cancel: false, xmlHttp: jqXHR };
                sf.fire('preload', ex);
                if (ex.cancel == true) return;

                var allowLayout = sf._allowLayout;
                sf._allowLayout = false;
                sf.loadData(ex.data);

                if (sf._selectedValue && sf.checkSelectOnLoad) {
                    var o = sf.getRowById(sf._selectedValue);

                    if (o) {
                        sf.select(o);
                    } else {
                        sf.deselectAll();
                    }
                } else if (sf._selected) {
                    sf.deselectAll();
                }

                if (sf.getSelected() == null && sf.selectOnLoad && sf.data.length > 0) {
                    sf.select(0);
                }

                if (sf.collapseGroupOnLoad) {
                    sf.collapseGroups();
                }

                sf.fire('load', ex);

                if (success) success.call(sf, ex);

                sf._allowLayout = allowLayout;
                sf.doLayout();
            },
            error: function (jqXHR, textStatus, errorThrown) {
                var ex = {
                    xmlHttp: jqXHR,
                    errorMsg: jqXHR.responseText,
                    errorCode: jqXHR.status
                };

                if (mini_debugger == true) {
                    alert(url + '\n' + ex.errorCode + '\n' + ex.errorMsg);
                }
                sf.fire('loaderror', ex);

                sf.unmask();

                if (fail) {
                    fail.call(sf, ex);
                }
            }
        });

        this._ajaxer = mini.ajax(e);
    },

    load: function (params, success, fail) {
        if (this._loadTimer) clearTimeout(this._loadTimer);
        var sf = this;

        var el = mini.byClass('mini-grid-emptyText', this.el);
        if (el) el.style.display = 'none';

        this.cancelEdit();

        this.loadParams = params || {};

        if (this.ajaxAsync) {
            this._loadTimer = setTimeout(function () {
                sf._doLoad(params, success, fail);
            }, 1);
        } else {
            sf._doLoad(params, success, fail);
        }
    },
    reload: function (success, error) {
        this.accept();
        this.load(this.loadParams, success, error);
    },
    gotoPage: function (index, size) {
        var params = this.loadParams || {};
        if (mini.isNumber(index)) params.pageIndex = index;
        if (mini.isNumber(size)) params.pageSize = size;
        this.load(params);
    },
    sortBy: function (sortField, sortOrder) {
        this.sortField = sortField;
        this.sortOrder = sortOrder == 'asc' ? 'asc' : 'desc';

        if (this.sortMode == 'server') {
            var params = this.loadParams || {};
            params.sortField = sortField;
            params.sortOrder = sortOrder;
            params.pageIndex = this.pageIndex;
            var me = this;
            this.load(params, function () {
                me.fire('sort');
            });
        } else {
            var data = this.getData().clone();
            var sortFn = this._getSortFnByField(sortField);
            if (!sortFn) return;

            var arr1 = [];
            for (var i = data.length - 1; i >= 0; i--) {
                var o = data[i];
                var v = mini._getMap(sortField, o);

                if (mini.isNull(v) || v === '') {
                    arr1.insert(0, o);
                    data.removeAt(i);
                }
            }
            data = data.clone();
            mini.sort(data, sortFn, this);
            data.insertRange(0, arr1);

            if (this.sortOrder == 'desc') {
                data.reverse();
            }

            this.data = data;
            this.doUpdate();

            this.fire('sort');
        }
    },
    clearSort: function () {
        this.sortField = '';
        this.sortOrder = '';
        this.reload();
    },
    _getSortFnByField: function (field) {
        if (!field) return null;
        var sortType = 'string';
        var sortFn = null;
        var columns = this.getBottomColumns();
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            if (column.field == field) {
                if (column.dataType) sortType = column.dataType.toLowerCase();
                break;
            }
        }

        var typeFn = mini.sortTypes[sortType];
        if (!typeFn) typeFn = mini.sortTypes['string'];
        function sortBy(a, b) {
            var a1 = mini._getMap(field, a),
                b1 = mini._getMap(field, b);

            var v1 = typeFn(a1);
            var v2 = typeFn(b1);
            if (v1 > v2) return 1;
            else if (v1 == v2) return 0;
            else return -1;
        }

        sortFn = sortBy;
        return sortFn;
    },

    allowCellSelect: false,
    allowCellEdit: false,
    _cellSelectedCls: 'mini-grid-cell-selected',

    _currentCell: null,
    _editingCell: null,
    _editingControl: null,
    _editWrap: null,

    _doCurrentCell: function (select) {
        if (this._currentCell) {
            var record = this._currentCell[0],
                column = this._currentCell[1];
            var cellEl = this._getCellEl(record, column);
            if (cellEl) {
                if (select) {
                    mini.addClass(cellEl, this._cellSelectedCls);
                } else {
                    mini.removeClass(cellEl, this._cellSelectedCls);
                }
            }
        }
    },
    setCurrentCell: function (cell) {
        if (this._currentCell != cell) {
            this._doCurrentCell(false);
            this._currentCell = cell;
            if (cell) {
                var row = this.getRow(cell[0]);
                var column = this.getColumn(cell[1]);
                if (row && column) {
                    this._currentCell = [row, column];
                } else {
                    this._currentCell = null;
                }
            }
            this._doCurrentCell(true);
            if (cell) {
                if (this.isFrozen()) {
                    this.scrollIntoView(cell[0]);
                } else {
                    this.scrollIntoView(cell[0]);
                }
            }
            this.fire('currentcellchanged');
        }
    },
    getCurrentCell: function () {
        var cc = this._currentCell;
        if (cc) {
            if (this.data.indexOf(cc[0]) == -1) {
                this._currentCell = null;
                cc = null;
            }
        }
        return cc;
    },

    setAllowCellSelect: function (value) {
        this.allowCellSelect = value;
    },
    getAllowCellSelect: function (value) {
        return this.allowCellSelect;
    },
    setAllowCellEdit: function (value) {
        this.allowCellEdit = value;
    },
    getAllowCellEdit: function (value) {
        return this.allowCellEdit;
    },

    beginEditCell: function (row, column) {
        row = this.getRow(row);
        column = this.getColumn(column);
        var cell = [row, column];
        if (row && column) {
            this.setCurrentCell(cell);
        }

        var cell = this.getCurrentCell();
        if (this._editingCell && cell) {
            if (this._editingCell[0] == cell[0] && this._editingCell[1] == cell[1]) return;
        }

        if (this._editingCell) this.commitEdit();
        if (cell) {
            var row = cell[0],
                column = cell[1];
            var canEdit = this._OnCellBeginEdit(row, column, this.getCellEditor(column));
            if (canEdit !== false) {
                this.scrollIntoView(row, column);
                this._editingCell = cell;
                this._OnCellShowingEdit(row, column);
            }
        }
    },
    isEditingCell: function (cell) {
        return this._editingCell && this._editingCell[0] == cell[0] && this._editingCell[1] == cell[1];
    },

    cancelEdit: function () {
        if (this.allowCellEdit) {
            if (this._editingCell) {
                this._OnCellEndEdit();
            }
        } else {
            if (this.isEditing()) {
                this._allowLayout = false;
                var data = this.data.clone();
                for (var i = 0, l = data.length; i < l; i++) {
                    var row = data[i];
                    if (row._editing == true) this.cancelEditRow(i);
                }
                this._allowLayout = true;
                this.invalidateLayout();
            }
        }
    },
    commitEdit: function () {
        if (this.allowCellEdit) {
            if (this._editingCell) {
                this._OnCellCommitEdit(this._editingCell[0], this._editingCell[1]);
                this._OnCellEndEdit();
            }
        } else {
            if (this.isEditing()) {
                this._allowLayout = false;
                var data = this.data.clone();
                for (var i = 0, l = data.length; i < l; i++) {
                    var row = data[i];
                    if (row._editing == true) this.commitEditRow(i);
                }
                this._allowLayout = true;

                this.invalidateLayout();
            }
        }
    },

    getCellEditor: function (column, row) {
        column = this.getColumn(column);
        if (!column) return;
        if (this.allowCellEdit) {
            var editor = column.__editor;

            if (!editor) {
                editor = mini.getAndCreate(column.editor);
            }
            if (editor && editor != column.editor) {
                column.editor = editor;
            }
            return editor;
        } else {
            row = this.getRow(row);
            column = this.getColumn(column);
            if (!row) row = this.getEditingRow();
            if (!row || !column) return null;
            var id = this.uid + '_' + row._uid + '_' + column._id + '_editor';
            return mini.get(id);
        }
    },

    _OnCellBeginEdit: function (record, column, editor) {
        var value = mini._getMap(column.field, record);
        var e = {
            sender: this,
            rowIndex: this.data.indexOf(record),
            row: record,
            record: record,
            column: column,
            field: column.field,
            editor: editor,
            value: value,
            cancel: false
        };

        this.fire('cellbeginedit', e);

        if (!mini.isNull(column.defaultValue) && (mini.isNull(e.value) || e.value === '')) {
            var defaultValue = column.defaultValue;

            var obj = mini.clone({ d: defaultValue });
            e.value = obj.d;
        }

        var editor = e.editor;
        value = e.value;

        if (e.cancel) {
            return false;
        }
        if (!editor) return false;

        if (mini.isNull(value)) value = '';
        if (editor.setValue) {
            editor.setValue(value);
        }
        editor.ownerRowID = record._uid;

        if (column.displayField && editor.setText) {
            var text = mini._getMap(column.displayField, record);

            if (!mini.isNull(column.defaultText) && (mini.isNull(text) || text === '')) {
                var obj = mini.clone({ d: column.defaultText });
                text = obj.d;
            }

            editor.setText(text);
        }

        if (this.allowCellEdit) {
            this._editingControl = e.editor;
        }

        return true;
    },
    _OnCellCommitEdit: function (record, column, value, editor) {
        var e = {
            sender: this,
            record: record,
            rowIndex: this.data.indexOf(record),
            row: record,
            column: column,
            field: column.field,
            editor: editor ? editor : this.getCellEditor(column),
            value: mini.isNull(value) ? '' : value,
            text: '',
            cancel: false
        };

        if (e.editor && e.editor.getValue) {
            try {
                e.editor.blur();
            } catch (ex) {}

            e.value = e.editor.getValue();
        }
        if (e.editor && e.editor.getText) {
            e.text = e.editor.getText();
        }

        var oldValue = mini._getMap(column.field, record),
            newValue = e.value;
        if (mini.isEquals(oldValue, newValue)) return e;

        this.fire('cellcommitedit', e);

        if (e.cancel == false) {
            if (this.allowCellEdit) {
                var o = {};
                o[column.field] = e.value;

                if (column.displayField) {
                    o[column.displayField] = e.text;
                }
                this.updateRow(record, o);
            }
        }
        return e;
    },
    _OnCellEndEdit: function () {
        if (!this._editingCell) return;
        var record = this._editingCell[0];
        var column = this._editingCell[1];
        var e = {
            sender: this,
            record: record,
            rowIndex: this.data.indexOf(record),
            row: record,
            column: column,
            field: column.field,
            editor: this._editingControl,
            value: record[column.field]
        };

        this.fire('cellendedit', e);

        if (this.allowCellEdit) {
            var editor = e.editor;
            if (editor && editor.setIsValid) {
                editor.setIsValid(true);
            }

            if (this._editWrap) this._editWrap.style.display = 'none';
            var childNodes = this._editWrap.childNodes;
            for (var i = childNodes.length - 1; i >= 0; i--) {
                var el = childNodes[i];
                this._editWrap.removeChild(el);
            }

            if (editor && editor.hidePopup) {
                editor.hidePopup();
            }
            if (editor && editor.setValue) {
                editor.setValue('');
            }

            this._editingControl = null;
            this._editingCell = null;

            if (this.allowCellValid) {
                this.validateCell(record, column);
            }
        }
    },
    _OnCellShowingEdit: function (record, column) {
        if (!this._editingControl) return false;

        var cellBox = this.getCellBox(record, column);
        var viewWidth = mini.getViewportBox().width;
        if (cellBox.right > viewWidth) {
            cellBox.width = viewWidth - cellBox.left;
            if (cellBox.width < 10) cellBox.width = 10;
            cellBox.right = cellBox.left + cellBox.width;
        }
        var e = {
            sender: this,
            rowIndex: this.data.indexOf(record),
            record: record,
            row: record,
            column: column,
            field: column.field,
            cellBox: cellBox,
            editor: this._editingControl
        };

        this.fire('cellshowingedit', e);

        var editor = e.editor;
        if (editor && editor.setIsValid) {
            editor.setIsValid(true);
        }

        var editWrap = this._getEditWrap(cellBox);
        this._editWrap.style.zIndex = mini.getMaxZIndex();

        if (editor.render) {
            editor.render(this._editWrap);
            setTimeout(function () {
                editor.focus();
                if (editor.selectText) editor.selectText();
            }, 50);
            if (editor.setVisible) editor.setVisible(true);
        } else if (editor.el) {
            this._editWrap.appendChild(editor.el);
            setTimeout(function () {
                try {
                    editor.el.focus();
                } catch (e) {}
            }, 50);
        }

        if (editor.setWidth) {
            var width = cellBox.width;
            if (width < 20) width = 20;
            editor.setWidth(width);
        }
        if (editor.setHeight && editor.type == 'textarea') {
            var height = cellBox.height - 1;
            if (editor.minHeight && height < editor.minHeight) height = editor.minHeight;
            editor.setHeight(height);
        }
        if (editor.setWidth) {
            var width = cellBox.width - 1;
            if (editor.minWidth && width < editor.minWidth) width = editor.minWidth;
            editor.setWidth(width);
        }
        mini.on(document, 'mousedown', this.__OnBodyMouseDown, this);

        if (column.autoShowPopup && editor.showPopup) {
            editor.showPopup();
        }
    },
    __OnBodyMouseDown: function (e) {
        if (this._editingControl) {
            var cell = this._getCellByEvent(e);

            if (this._editingCell && cell) {
                if (this._editingCell[0] == cell.record && this._editingCell[1] == cell.column) {
                    return false;
                }
            }

            var within = false;
            if (this._editingControl.within) within = this._editingControl.within(e);
            else within = mini.isAncestor(this._editWrap, e.target);

            if (within == false) {
                var me = this;
                if (mini.isAncestor(this._bodyEl, e.target) == false) {
                    setTimeout(function () {
                        me.commitEdit();
                    }, 1);
                } else {
                    var cell1 = me._editingCell;
                    setTimeout(function () {
                        var cell2 = me._editingCell;
                        if (cell1 == cell2) {
                            me.commitEdit();
                        }
                    }, 70);
                }
                mini.un(document, 'mousedown', this.__OnBodyMouseDown, this);
            }
        }
    },
    _getEditWrap: function (box) {
        if (!this._editWrap) {
            this._editWrap = mini.append(
                document.body,
                '<div class="mini-grid-editwrap" style="position:absolute;"></div>'
            );

            mini.on(this._editWrap, 'keydown', this.___OnEditControlKeyDown, this);
        }
        this._editWrap.style.zIndex = 1000000000;
        this._editWrap.style.display = 'block';
        mini.setXY(this._editWrap, box.x, box.y);
        mini.setWidth(this._editWrap, box.width);

        var viewWidth = mini.getViewportBox().width;
        if (box.x > viewWidth) mini.setX(this._editWrap, -1000);

        return this._editWrap;
    },
    ___OnEditControlKeyDown: function (e) {
        var editor = this._editingControl;

        if (e.keyCode == 13 && editor && editor.type == 'textarea') {
            return;
        }

        if (e.keyCode == 13) {
            var cell = this._editingCell;
            if (cell && cell[1] && cell[1].enterCommit === false) return;

            this.commitEdit();
            this.focus();

            if (this.editNextOnEnterKey) {
                this._beginEditNextCell(e.shiftKey == false);
            } else {
            }
        } else if (e.keyCode == 27) {
            this.cancelEdit();
            this.focus();
        } else if (e.keyCode == 9) {
            this.commitEdit();
            if (this.editOnTabKey) {
                e.preventDefault();
                this.commitEdit();
                this._beginEditNextCell(e.shiftKey == false);
            } else {
            }
        }
    },

    editNextOnEnterKey: false,
    editOnTabKey: true,
    createOnEnter: false,
    _beginEditNextCell: function (next) {
        var grid = this;
        var currentCell = this.getCurrentCell();
        if (!currentCell) return;
        this.focus();
        var columns = grid.getBottomVisibleColumns();

        var column = currentCell ? currentCell[1] : null,
            record = currentCell ? currentCell[0] : null;

        var columnIndex = columns.indexOf(column);
        var rowIndex = grid.indexOf(record);
        var count = grid.getData().length;

        if (next === false) {
            columnIndex -= 1;
            column = columns[columnIndex];
            if (!column) {
                column = columns[columns.length - 1];
                record = grid.getAt(rowIndex - 1);
                if (!record) {
                    return;
                }
            }
        } else {
            columnIndex += 1;
            column = columns[columnIndex];
            if (!column) {
                column = columns[0];
                record = grid.getAt(rowIndex + 1);
                if (!record) {
                    if (this.createOnEnter) {
                        record = {};

                        this.addRow(record);
                    } else {
                        return;
                    }
                }
            }
        }

        var currentCell = [record, column];
        grid.setCurrentCell(currentCell);
        grid.deselectAll();
        grid.setCurrent(record);
        grid.scrollIntoView(record, column);

        grid.beginEditCell();
    },

    getEditorOwnerRow: function (editor) {
        var uid = editor.ownerRowID;
        return this.getRowByUID(uid);
    },

    beginEditRow: function (row) {
        if (this.allowCellEdit) return;

        var sss = new Date();

        row = this.getRow(row);
        if (!row) return;
        var rowEl = this._getRowEl(row);
        if (!rowEl) return;

        row._editing = true;

        var s = this._createRow(row);
        var rowEl = this._getRowEl(row);
        jQuery(rowEl).before(s);
        rowEl.parentNode.removeChild(rowEl);

        var rowEl = this._getRowEl(row);
        mini.addClass(rowEl, 'mini-grid-rowEdit');

        var columns = this.getBottomColumns();
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            var value = row[column.field];

            var cellId = this._createCellId(row, columns[i]);
            var cellEl = document.getElementById(cellId);
            if (!cellEl) continue;

            if (typeof column.editor == 'string') {
                column.editor = eval('(' + column.editor + ')');
            }

            var editorConfig = mini.copyTo({}, column.editor);

            editorConfig.id = this.uid + '_' + row._uid + '_' + column._id + '_editor';
            var editor = mini.create(editorConfig);

            if (this._OnCellBeginEdit(row, column, editor)) {
                if (editor) {
                    mini.addClass(cellEl, 'mini-grid-cellEdit');
                    cellEl.innerHTML = '';
                    cellEl.appendChild(editor.el);
                    mini.addClass(editor.el, 'mini-grid-editor');
                }
            }
        }

        this.invalidateLayout();
    },
    cancelEditRow: function (row) {
        if (this.allowCellEdit) return;

        row = this.getRow(row);
        if (!row || !row._editing) return;
        delete row._editing;

        var rowEl = this._getRowEl(row);

        var columns = this.getBottomColumns();
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];

            var cellId = this._createCellId(row, columns[i]);
            var cellEl = document.getElementById(cellId);

            var editorEl = cellEl.firstChild;
            var editor = mini.get(editorEl);
            if (!editor) continue;

            editor.destroy();
        }

        var s = this._createRow(row);
        jQuery(rowEl).before(s);
        rowEl.parentNode.removeChild(rowEl);

        this.invalidateLayout();
    },
    commitEditRow: function (row) {
        if (this.allowCellEdit) return;

        row = this.getRow(row);
        if (!row || !row._editing) return;

        var rowData = this.getEditRowData(row, false, false);

        this._canUpdateRowEl = false;
        this.updateRow(row, rowData);
        this._canUpdateRowEl = true;

        this.cancelEditRow(row);
    },
    isEditing: function () {
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.data[i];
            if (row._editing == true) return true;
        }
        return false;
    },
    isEditingRow: function (row) {
        row = this.getRow(row);
        if (!row) return false;
        return !!row._editing;
    },
    isNewRow: function (row) {
        return row._state == 'added';
    },
    getEditingRows: function () {
        var rows = [];
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.data[i];
            if (row._editing == true) rows.push(row);
        }
        return rows;
    },
    getEditingRow: function () {
        var rows = this.getEditingRows();
        return rows[0];
    },
    getEditData: function (all) {
        var data = [];
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.data[i];
            if (row._editing == true) {
                var rowData = this.getEditRowData(i, all);
                rowData._index = i;

                data.push(rowData);
            }
        }
        return data;
    },
    getEditRowData: function (row, all, deep) {
        row = this.getRow(row);

        if (!row || !row._editing) return null;

        var rowData = {};

        var columns = this.getBottomColumns();
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            var cellId = this._createCellId(row, columns[i]);
            var cellEl = document.getElementById(cellId);

            var e = null;
            if (column.type == 'checkboxcolumn' || column.type == 'radiobuttoncolumn') {
                var ck = column.getCheckBoxEl(row);
                var value = ck.checked ? column.trueValue : column.falseValue;
                e = this._OnCellCommitEdit(row, column, value);
            } else {
                var editorEl = cellEl.firstChild;
                var editor = mini.get(editorEl);
                if (!editor) continue;
                e = this._OnCellCommitEdit(row, column, null, editor);
            }
            if (deep !== false) {
                mini._setMap(column.field, e.value, rowData);
                if (column.displayField) {
                    mini._setMap(column.displayField, e.text, rowData);
                }
            } else {
                rowData[column.field] = e.value;
                if (column.displayField) {
                    rowData[column.displayField] = e.text;
                }
            }
        }

        rowData[this.idField] = row[this.idField];

        if (all) {
            var o = mini.copyTo({}, row);
            rowData = mini.copyTo(o, rowData);
        }

        return rowData;
    },

    isChanged: function () {
        return this.getChanges().length > 0;
    },
    getChanges: function (state, onlyField) {
        var rows = [];
        if (!state || state == 'removed') {
            rows.addRange(this._removes);
        }
        for (var i = 0, l = this.data.length; i < l; i++) {
            var row = this.data[i];
            if (row._state && (!state || state == row._state)) {
                rows.push(row);
            }
        }
        if (onlyField) {
            for (var i = 0, l = rows.length; i < l; i++) {
                var row = rows[i];
                if (row._state == 'modified') {
                    var newRow = {};
                    newRow._state = row._state;
                    newRow[this.idField] = row[this.idField];
                    for (var field in row) {
                        var modifed = this._HasRowModified(row, field);
                        if (modifed) {
                            newRow[field] = row[field];
                        }
                    }
                    rows[i] = newRow;
                }
            }
        }
        return rows;
    },

    isChanged: function () {
        var data = this.getChanges();
        return data.length > 0;
    },
    _originalIdField: '_uid',
    _getOriginal: function (record) {
        var rid = record[this._originalIdField];
        var or = this._originals[rid];
        if (!or) {
            or = this._originals[rid] = {};
        }
        return or;
    },
    _HasRowModified: function (reocrd, field) {
        var or = this._originals[reocrd[this._originalIdField]];
        if (!or) return false;
        if (mini.isNull(field)) return false;
        return or.hasOwnProperty(field);
    },
    _doUpdateRow: function (row, rowData) {
        var updated = false;
        for (var field in rowData) {
            var newValue = rowData[field];
            var oldValue = mini._getMap(field, row);

            if (mini.isEquals(oldValue, newValue)) continue;

            mini._setMap(field, newValue, row);

            if (row._state != 'added') {
                row._state = 'modified';
                var or = this._getOriginal(row);
                if (!or.hasOwnProperty(field)) {
                    or[field] = oldValue;
                }
            }

            updated = true;
        }
        return updated;
    },
    _canUpdateRowEl: true,
    _updateRowEl: function (row) {
        var me = this;

        var s = me._createRow(row);
        var rowEl = me._getRowEl(row);
        jQuery(rowEl).before(s);
        rowEl.parentNode.removeChild(rowEl);
    },
    updateRow: function (row, rowData, value) {
        row = this.getRow(row);
        if (!row || !rowData) return;

        if (typeof rowData == 'string') {
            var o = {};
            o[rowData] = value;
            rowData = o;
        }

        var updated = this._doUpdateRow(row, rowData);
        if (updated == false) return;

        if (this._canUpdateRowEl) {
            this._updateRowEl(row);
        }

        if (row._state == 'modified') {
            this.fire('updaterow', { record: row, row: row });
        }

        if (row == this.getSelected()) {
            this._OnCurrentChanged(row);
        }

        this._doMargeCells();
        this.refreshSummaryRow();

        this.invalidateLayout();
    },

    deleteRows: function (rows) {
        if (!mini.isArray(rows)) return;
        rows = rows.clone();
        for (var i = 0, l = rows.length; i < l; i++) {
            this.deleteRow(rows[i]);
        }
    },
    deleteRow: function (row) {
        row = this.getRow(row);
        if (!row || row._state == 'deleted') return;
        if (row._state == 'added') {
            this.removeRow(row, true);
        } else {
            if (this.isEditingRow(row)) this.cancelEditRow(row);

            row._state = 'deleted';
            var rowEl = this._getRowEl(row);
            mini.addClass(rowEl, 'mini-grid-deleteRow');

            this.fire('deleterow', { record: row, row: row });
        }
        this.refreshSummaryRow();
    },

    removeRows: function (rows, autoSelect) {
        if (!mini.isArray(rows)) return;
        rows = rows.clone();
        for (var i = 0, l = rows.length; i < l; i++) {
            this.removeRow(rows[i], autoSelect);
        }
    },
    removeSelected: function () {
        var row = this.getSelected();
        if (row) {
            this.removeRow(row, true);
        }
    },
    removeRow: function (row, autoSelect) {
        row = this.getRow(row);
        if (!row) return;

        var isCurrent = row == this.getSelected();

        var isSelected = this.isSelected(row);

        var index = this.data.indexOf(row);

        this.data.remove(row);

        if (row._state != 'added') {
            row._state = 'removed';
            this._removes.push(row);
            delete this._originals[row[this._originalIdField]];
        }

        delete this._idRows[row._uid];

        var s = this._createRow(row);
        var rowEl = this._getRowEl(row);
        if (rowEl) rowEl.parentNode.removeChild(rowEl);

        var id = this._createRowDetailId(row);
        var tr = document.getElementById(id);
        if (tr) {
            tr.parentNode.removeChild(tr);
        }

        if (isSelected && autoSelect) {
            var newSelected = this.getAt(index);
            if (!newSelected) newSelected = this.getAt(index - 1);
            this.deselectAll();
            this.select(newSelected);
        }

        this._checkSelecteds();

        this._removeRowError(row);
        this.fire('removerow', { record: row, row: row });

        if (isCurrent) {
            this._OnCurrentChanged(row);
        }
        this._doAlternating();
        this.invalidateLayout();

        this._doMargeCells();

        this.refreshSummaryRow();
    },
    autoCreateNewID: false,
    addRows: function (rows, index) {
        if (!mini.isArray(rows)) return;

        rows = rows.clone();
        for (var i = 0, l = rows.length; i < l; i++) {
            this.addRow(rows[i], index);
        }
    },
    addRow: function (row, index) {
        if (mini.isNull(index)) index = this.data.length;
        index = this.indexOf(index);
        var indexRow = this.getRow(index);
        this.data.insert(index, row);

        if (!row[this.idField]) {
            if (this.autoCreateNewID) {
                row[this.idField] = UUID();
            }
            var e = { row: row, record: row };
            this.fire('beforeaddrow', e);
        }

        row._state = 'added';

        delete this._idRows[row._uid];
        row._id = mini.DataGrid.RowID++;
        row._uid = row._id;
        this._idRows[row._uid] = row;

        var s = this._createRow(row);
        if (indexRow) {
            var rowEl = this._getRowEl(indexRow);
            jQuery(rowEl).before(s);
        } else {
            mini.append(this._bodyInnerEl.firstChild, s);
        }

        this._doAlternating();

        this.invalidateLayout();

        this.fire('addrow', { record: row, row: row });

        var el = jQuery('.mini-grid-emptyText', this._bodyEl)[0];
        if (el) {
            mini.removeNode(el.parentNode);
        }

        this._doMargeCells();

        this.refreshSummaryRow();
    },
    moveRow: function (row, index) {
        row = this.getRow(row);
        if (!row) return;
        if (index < 0) return;

        if (index > this.data.length) return;

        var targetRow = this.getRow(index);

        if (row == targetRow) return;
        this.data.remove(row);

        var rowEl = this._getRowEl(row);
        if (targetRow) {
            index = this.data.indexOf(targetRow);
            this.data.insert(index, row);
            var rowEl2 = this._getRowEl(targetRow);
            jQuery(rowEl2).before(rowEl);
        } else {
            this.data.insert(this.data.length, row);

            var table = this._bodyInnerEl.firstChild;
            mini.append(table.firstChild || table, rowEl);
        }
        this._doAlternating();
        this.invalidateLayout();

        this.scrollIntoView(row);

        this.fire('moverow', { record: row, row: row, index: index });

        this._doMargeCells();
    },
    moveUp: function (items) {
        if (!mini.isArray(items)) return;

        var me = this;
        items = items.sort(function (a, b) {
            var i1 = me.indexOf(a);
            var i2 = me.indexOf(b);
            if (i1 > i2) return 1;
            return -1;
        });
        for (var i = 0, l = items.length; i < l; i++) {
            var item = items[i];
            var index = this.indexOf(item);
            this.moveRow(item, index - 1);
        }
    },
    moveDown: function (items) {
        if (!mini.isArray(items)) return;

        var me = this;
        items = items.sort(function (a, b) {
            var i1 = me.indexOf(a);
            var i2 = me.indexOf(b);
            if (i1 > i2) return 1;
            return -1;
        });
        items.reverse();
        for (var i = 0, l = items.length; i < l; i++) {
            var item = items[i];
            var index = this.indexOf(item);
            this.moveRow(item, index + 2);
        }
    },
    clearRows: function () {
        this.data = [];
        this.doUpdate();
    },
    indexOf: function (row) {
        if (typeof row == 'number') return row;
        if (this.isGrouping()) {
            var g = this._getGroupDataView();
            return g.data.indexOf(row);
        } else {
            return this.data.indexOf(row);
        }
    },
    getAt: function (index) {
        if (this.isGrouping()) {
            var g = this._getGroupDataView();
            return g.data[index];
        } else {
            return this.data[index];
        }
    },
    getRow: function (index) {
        var t = typeof index;
        if (t == 'number') return this.data[index];
        else if (t == 'object') return index;
        else return this.getRowById(index);
    },

    getRowByValue: function (value) {
        for (var i = 0, l = this.data.length; i < l; i++) {
            var o = this.data[i];
            if (o[this.idField] == value) return o;
        }
    },
    getRowById: function (id) {
        return this.getRowByValue(id);
    },
    getRowByUID: function (uid) {
        return this._idRows[uid];
    },

    findRows: function (fn) {
        var rows = [];
        if (fn) {
            for (var i = 0, l = this.data.length; i < l; i++) {
                var row = this.data[i];
                var ret = fn(row);
                if (ret) rows.push(row);
                if (ret === 1) break;
            }
        }
        return rows;
    },
    findRow: function (fn) {
        if (fn) {
            for (var i = 0, l = this.data.length; i < l; i++) {
                var row = this.data[i];
                if (fn(row) === true) return row;
            }
        }
    },

    collapseGroupOnLoad: false,
    setCollapseGroupOnLoad: function (value) {
        this.collapseGroupOnLoad = value;
    },
    getCollapseGroupOnLoad: function () {
        return this.collapseGroupOnLoad;
    },

    showGroupSummary: false,
    setShowGroupSummary: function (value) {
        this.showGroupSummary = value;
    },
    getShowGroupSummary: function () {
        return this.showGroupSummary;
    },

    collapseGroups: function () {
        if (!this._groupDataView) return;
        for (var i = 0, l = this._groupDataView.length; i < l; i++) {
            var g = this._groupDataView[i];
            this._CollapseGroup(g);
        }
    },
    expandGroups: function () {
        if (!this._groupDataView) return;
        for (var i = 0, l = this._groupDataView.length; i < l; i++) {
            var g = this._groupDataView[i];
            this._ExpandGroup(g);
        }
    },
    _CollapseGroup: function (group) {
        var rows = group.rows;
        for (var i = 0, l = rows.length; i < l; i++) {
            var row = rows[i];
            var rowEl = this._getRowEl(row);
            if (rowEl) rowEl.style.display = 'none';

            var rowEl = this.getRowDetailEl(row);
            if (rowEl) rowEl.style.display = 'none';
        }
        group.expanded = false;
        var id = this.uid + '_group_' + group.id;
        var rowGroupEl = document.getElementById(id);
        if (rowGroupEl) mini.addClass(rowGroupEl, 'mini-grid-group-collapse');

        this.invalidateLayout();
    },
    _ExpandGroup: function (group) {
        var rows = group.rows;
        for (var i = 0, l = rows.length; i < l; i++) {
            var row = rows[i];
            var rowEl = this._getRowEl(row);
            if (rowEl) rowEl.style.display = '';

            var rowEl = this.getRowDetailEl(row);
            if (rowEl) rowEl.style.display = row._showDetail ? '' : 'none';
        }
        group.expanded = true;
        var id = this.uid + '_group_' + group.id;
        var rowGroupEl = document.getElementById(id);
        if (rowGroupEl) mini.removeClass(rowGroupEl, 'mini-grid-group-collapse');
        this.invalidateLayout();
    },

    _GroupID: 1,
    _groupField: '',
    _groupDir: '',

    groupBy: function (field, dir) {
        if (!field) return;
        this._groupField = field;
        if (typeof dir == 'string') dir = dir.toLowerCase();
        this._groupDir = dir;
        this._groupDataView = null;
        this.doUpdate();
    },
    clearGroup: function () {
        this._groupField = '';
        this._groupDir = '';
        this._groupDataView = null;
        this.doUpdate();
    },
    getGroupField: function () {
        return this._groupField;
    },
    getGroupDir: function () {
        return this._groupDir;
    },
    isGrouping: function () {
        return this._groupField != '';
    },
    _getGroupDataView: function () {
        if (this.isGrouping() == false) return null;

        if (!this._groupDataView) {
            var field = this._groupField,
                dir = this._groupDir;

            var data = this.data.clone();

            if (typeof dir == 'function') {
                mini.sort(data, dir);
            } else {
                mini.sort(
                    data,
                    function (a, b) {
                        var v1 = a[field];
                        var v2 = b[field];
                        if (v1 > v2) return 1;
                        else return 0;
                    },
                    this
                );
                if (dir == 'desc') data.reverse();
            }

            var groups = [];
            var groupMaps = {};
            for (var i = 0, l = data.length; i < l; i++) {
                var o = data[i];
                var v = o[field];
                var p = mini.isDate(v) ? v?.getTime() : v;
                var group = groupMaps[p];
                if (!group) {
                    group = groupMaps[p] = {};
                    group.header = field;
                    group.field = field;
                    group.dir = dir;
                    group.value = v;
                    group.rows = [];
                    groups.push(group);
                    group.id = this._GroupID++;
                }
                group.rows.push(o);
            }

            this._groupDataView = groups;

            var data = [];
            for (var i = 0, l = groups.length; i < l; i++) {
                data.addRange(groups[i].rows);
            }

            this._groupDataView.data = data;
        }
        return this._groupDataView;
    },

    _getGroupByID: function (id) {
        if (!this._groupDataView) return null;
        var groups = this._groupDataView;
        for (var i = 0, l = groups.length; i < l; i++) {
            var group = groups[i];
            if (group.id == id) return group;
        }
    },
    _OnDrawGroup: function (group) {
        var e = {
            group: group,
            rows: group.rows,
            field: group.field,
            dir: group.dir,
            value: group.value,
            cellHtml: group.header + ' : ' + group.value
        };
        this.fire('drawgroup', e);
        return e;
    },

    onDrawGroupHeader: function (fn, scope) {
        this.on('drawgroupheader', fn, scope);
    },
    onDrawGroupSummary: function (fn, scope) {
        this.on('drawgroupsummary', fn, scope);
    },

    mergeColumns: function (columns) {
        if (columns && mini.isArray(columns) == false) columns = [columns];

        var grid = this;
        var bottomColumns = grid.getBottomColumns();
        if (!columns) columns = bottomColumns;
        var data = grid.getData().clone();
        data.push({});

        var __cells = [];

        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            column = grid.getColumn(column);
            if (!column) continue;
            var cells = margeCells(column);
            __cells.addRange(cells);
        }

        grid.mergeCells(__cells);

        function margeCells(column) {
            if (!column.field) return;
            var cells = [];
            var rowIndex = -1,
                rowSpan = 1,
                columnIndex = bottomColumns.indexOf(column);
            var cellValue = null;
            for (var i = 0, l = data.length; i < l; i++) {
                var row = data[i];
                var value = row[column.field];

                if (rowIndex == -1 || value != cellValue) {
                    if (rowSpan > 1) {
                        var cell = { rowIndex: rowIndex, columnIndex: columnIndex, rowSpan: rowSpan, colSpan: 1 };
                        cells.push(cell);
                    }
                    rowIndex = i;
                    rowSpan = 1;
                    cellValue = value;
                } else {
                    rowSpan++;
                }
            }

            return cells;
        }
    },

    mergeCells: function (cells) {
        if (!mini.isArray(cells)) return;
        this._margedCells = cells;
        this._doMargeCells();

        var _mergedCellMaps = (this._mergedCellMaps = {});
        function doMargedCellMaps(rowIndex, columnIndex, rowSpan, colSpan, cell) {
            for (var i = rowIndex, l = rowIndex + rowSpan; i < l; i++) {
                for (var j = columnIndex, k = columnIndex + colSpan; j < k; j++) {
                    if (i == rowIndex && j == columnIndex) {
                        _mergedCellMaps[i + ':' + j] = cell;
                    } else {
                        _mergedCellMaps[i + ':' + j] = true;
                    }
                }
            }
        }
        var cells = this._margedCells;
        if (cells) {
            for (var i = 0, l = cells.length; i < l; i++) {
                var cell = cells[i];
                if (!cell.rowSpan) cell.rowSpan = 1;
                if (!cell.colSpan) cell.colSpan = 1;
                doMargedCellMaps(cell.rowIndex, cell.columnIndex, cell.rowSpan, cell.colSpan, cell);
            }
        }
    },
    margeCells: function (cells) {
        this.mergeCells(cells);
    },
    _isCellVisible: function (rowIndex, columnIndex) {
        if (!this._mergedCellMaps) return true;
        var ret = this._mergedCellMaps[rowIndex + ':' + columnIndex];
        return !(ret === true);
    },

    _doMargeCells: function () {
        function _doMargeCells() {
            var cells = this._margedCells;
            if (!cells) return;
            for (var i = 0, l = cells.length; i < l; i++) {
                var cell = cells[i];
                if (!cell.rowSpan) cell.rowSpan = 1;
                if (!cell.colSpan) cell.colSpan = 1;
                var cellEls = this._getCellEls(cell.rowIndex, cell.columnIndex, cell.rowSpan, cell.colSpan);

                for (var j = 0, k = cellEls.length; j < k; j++) {
                    var el = cellEls[j];
                    if (j != 0) {
                        el.style.display = 'none';
                    } else {
                        el.rowSpan = cell.rowSpan;
                        el.colSpan = cell.colSpan;
                    }
                }
            }
        }

        _doMargeCells.call(this);
    },
    _getCellEls: function (rowIndex, columnIndex, rowSpan, colSpan) {
        var cells = [];
        if (!mini.isNumber(rowIndex)) return [];
        if (!mini.isNumber(columnIndex)) return [];

        var columns = this.getBottomColumns();
        var data = this.data;

        for (var i = rowIndex, l = rowIndex + rowSpan; i < l; i++) {
            for (var j = columnIndex, k = columnIndex + colSpan; j < k; j++) {
                var cell = this._getCellEl(i, j);
                if (cell) cells.push(cell);
            }
        }

        return cells;
    },

    _selected: null,
    _selecteds: [],
    _checkSelecteds: function () {
        var rows = this._selecteds;
        for (var i = rows.length - 1; i >= 0; i--) {
            var row = rows[i];
            if (!!this._idRows[row._uid] == false) {
                rows.removeAt(i);
                delete this._idSelecteds[row._uid];
            }
        }
        if (this._selected) {
            if (!!this._idSelecteds[this._selected._uid] == false) {
                this._selected = null;
            }
        }
    },

    setAllowUnselect: function (value) {
        this.allowUnselect = value;
    },
    getAllowUnselect: function (value) {
        return this.allowUnselect;
    },
    setAllowRowSelect: function (value) {
        this.allowRowSelect = value;
    },
    getAllowRowSelect: function (value) {
        return this.allowRowSelect;
    },
    setMultiSelect: function (value) {
        if (this.multiSelect != value) {
            this.multiSelect = value;
            this._doUpdateHeader();
        }
    },
    getMultiSelect: function () {
        return this.multiSelect;
    },
    _getSelectAllCheckState: function () {
        var data = this.getData();
        var state = true;
        if (data.length == 0) {
            state = false;
            return state;
        }

        var selectedCount = 0;
        for (var i = 0, l = data.length; i < l; i++) {
            var o = data[i];
            if (this.isSelected(o)) {
                selectedCount++;
            } else {
            }
        }

        if (data.length == selectedCount) {
            state = true;
        } else if (selectedCount == 0) {
            state = false;
        } else {
            state = 'has';
        }

        return state;
    },
    isSelected: function (record) {
        record = this.getRow(record);
        if (!record) return false;
        return !!this._idSelecteds[record._uid];
    },
    getSelecteds: function () {
        this._checkSelecteds();
        return this._selecteds.clone();
    },
    setCurrent: function (record) {
        this.setSelected(record);
    },
    getCurrent: function () {
        return this.getSelected();
    },
    getSelected: function () {
        this._checkSelecteds();
        return this._selected;
    },
    scrollIntoView: function (row, column) {
        try {
            if (column) {
                var cellEl = this._getCellEl(row, column);
                mini.scrollIntoView(cellEl, this._bodyEl, true);
            } else {
                var rowEl = this._getRowEl(row);
                mini.scrollIntoView(rowEl, this._bodyEl, false);
            }
        } catch (e) {}
    },
    setSelected: function (record) {
        if (record) {
            this.select(record);
        } else {
            this.deselect(this._selected);
        }
        if (this._selected) {
            this.scrollIntoView(this._selected);
        }
        this._blurRow();
    },
    select: function (record) {
        if (this.multiSelect == false) {
            this.deselectAll();
        }

        record = this.getRow(record);
        if (!record) return;

        this._selected = record;
        this.selects([record]);
    },
    deselect: function (record) {
        record = this.getRow(record);
        if (!record) return;

        this.deselects([record]);
    },
    selectAll: function () {
        var data = this.data.clone();
        this.selects(data);
    },
    deselectAll: function () {
        var selecteds = this._selecteds.clone();
        this._selected = null;
        this.deselects(selecteds);
    },
    clearSelect: function () {
        this.deselectAll();
    },

    selects: function (records) {
        if (!records || records.length == 0) return;
        var sss = new Date();

        records = records.clone();
        for (var i = records.length - 1; i >= 0; i--) {
            var record = this.getRow(records[i]);
            if (record) {
                records[i] = record;
            } else {
                records.removeAt(i);
            }
        }

        var idRows = {};
        var data = this.getData();
        for (var i = 0, l = data.length; i < l; i++) {
            var o = this.getRow(data[i]);

            var id = o[this.idField];
            if (id) {
                idRows[o[this.idField]] = o;
            }
        }
        var newRows = [];
        for (var i = 0, l = records.length; i < l; i++) {
            var record = records[i];
            var row = this._idRows[record._uid];
            if (!row) {
                record = idRows[record[this.idField]];
            }
            if (record) newRows.push(record);
        }
        records = newRows;

        records = records.clone();
        this._doSelects(records, true);

        for (var i = 0, l = records.length; i < l; i++) {
            var record = records[i];

            if (!this.isSelected(record)) {
                this._selecteds.push(record);
                this._idSelecteds[record._uid] = record;
            }
        }

        this._OnSelectionChanged();
    },
    deselects: function (records) {
        if (!records) records = [];

        records = records.clone();
        for (var i = records.length - 1; i >= 0; i--) {
            var record = this.getRow(records[i]);
            if (record) {
                records[i] = record;
            } else {
                records.removeAt(i);
            }
        }

        records = records.clone();
        this._doSelects(records, false);
        for (var i = records.length - 1; i >= 0; i--) {
            var record = records[i];
            if (this.isSelected(record)) {
                this._selecteds.remove(record);
                delete this._idSelecteds[record._uid];
            }
        }
        if (records.indexOf(this._selected) != -1) this._selected = null;

        this._OnSelectionChanged();
    },
    _doSelects: function (rows, select) {
        var sss = new Date();
        for (var i = 0, l = rows.length; i < l; i++) {
            var record = rows[i];
            if (select) {
                this.addRowCls(record, this.rowSelectedCls);
            } else {
                this.removeRowCls(record, this.rowSelectedCls);
            }
        }
    },
    _OnSelectionChanged: function () {
        if (this._selectionTimer) {
            clearTimeout(this._selectionTimer);
        }
        var me = this;
        this._selectionTimer = setTimeout(function () {
            var e = {
                selecteds: me.getSelecteds(),
                selected: me.getSelected()
            };
            me.fire('SelectionChanged', e);
            me._OnCurrentChanged(e.selected);
        }, 1);
    },
    _OnCurrentChanged: function (row) {
        if (this._currentTimer) {
            clearTimeout(this._currentTimer);
        }
        var me = this;
        this._currentTimer = setTimeout(function () {
            var e = { record: row, row: row };
            me.fire('CurrentChanged', e);
            me._currentTimer = null;
        }, 1);
    },

    addRowCls: function (row, cls) {
        var rowEl = this._getRowEl(row);
        if (rowEl) mini.addClass(rowEl, cls);
    },
    removeRowCls: function (row, cls) {
        var rowEl = this._getRowEl(row);
        if (rowEl) mini.removeClass(rowEl, cls);
    },
    _focusRow: function (row, view) {
        row = this.getRow(row);
        if (!row || row == this._focusedRow) {
            return;
        }
        var dom = this._getRowEl(row);
        if (view && dom) {
            this.scrollIntoView(row);
        }
        if (this._focusedRow == row) return;
        this._blurRow();
        this._focusedRow = row;

        mini.addClass(dom, this.rowHoverCls);
    },
    _blurRow: function () {
        if (!this._focusedRow) return;
        var dom = this._getRowEl(this._focusedRow);
        if (dom) {
            mini.removeClass(dom, this.rowHoverCls);
        }
        this._focusedRow = null;
    },
    _getRecordByEvent: function (e) {
        var t = mini.findParent(e.target, this.rowCls);
        if (!t) return null;
        var ids = t.id.split('_');
        var uid = ids[ids.length - 1];
        return this.getRowByUID(uid);
    },

    __OnMousewheel: function (e, delta) {
        if (this.allowCellEdit) {
            this.commitEdit();
        }

        var overflowY = jQuery(this._bodyEl).css('overflow-y');
        if (overflowY == 'hidden') {
            var wheelDelta = e.wheelDelta || -e.detail * 24;
            var top = this._bodyEl.scrollTop;

            top -= wheelDelta;
            this._bodyEl.scrollTop = top;

            if (top == this._bodyEl.scrollTop) {
                e.preventDefault();
            } else {
            }

            var e = {
                scrollTop: this._bodyEl.scrollTop,
                direction: 'vertical'
            };

            this.fire('scroll', e);
        }
    },
    __OnClick: function (e) {
        var rowGroupEl = mini.findParent(e.target, 'mini-grid-groupRow');
        if (rowGroupEl) {
            var ids = rowGroupEl.id.split('_');
            var id = ids[ids.length - 1];
            var group = this._getGroupByID(id);
            if (group) {
                var expanded = !(group.expanded === false ? false : true);
                if (expanded) this._ExpandGroup(group);
                else this._CollapseGroup(group);
            }
        } else {
            this._fireEvent(e, 'Click');
        }
    },
    _tryFocus: function (e) {
        try {
            var tagName = e.target.tagName.toLowerCase();
            if (tagName == 'input' || tagName == 'textarea' || tagName == 'select') return;
            if (
                mini.isAncestor(this._filterEl, e.target) ||
                mini.isAncestor(this._summaryEl, e.target) ||
                mini.isAncestor(this._footerEl, e.target) ||
                mini.findParent(e.target, 'mini-grid-rowEdit') ||
                mini.findParent(e.target, 'mini-grid-detailRow')
            ) {
            } else {
                var me = this;

                me.focus();
            }
        } catch (ex) {}
    },
    __OnDblClick: function (e) {
        this._fireEvent(e, 'Dblclick');
    },
    __OnMouseDown: function (e) {
        this._fireEvent(e, 'MouseDown');
        this._tryFocus(e);
    },
    __OnMouseUp: function (e) {
        if (mini.isAncestor(this.el, e.target)) {
            this._tryFocus(e);
            this._fireEvent(e, 'MouseUp');
        }
    },
    __OnMouseMove: function (e) {
        this._fireEvent(e, 'MouseMove');
    },
    __OnMouseOver: function (e) {
        this._fireEvent(e, 'MouseOver');
    },
    __OnMouseOut: function (e) {
        this._fireEvent(e, 'MouseOut');
    },
    __OnKeyDown: function (e) {
        this._fireEvent(e, 'KeyDown');
    },
    __OnKeyUp: function (e) {
        this._fireEvent(e, 'KeyUp');
    },
    __OnContextMenu: function (e) {
        this._fireEvent(e, 'ContextMenu');
    },
    _fireEvent: function (e, name) {
        if (!this.enabled) return;

        var cell = this._getCellByEvent(e);
        var record = cell.record,
            column = cell.column;
        if (record) {
            var eve = {
                record: record,
                row: record,
                htmlEvent: e
            };

            var fn = this['_OnRow' + name];
            if (fn) {
                fn.call(this, eve);
            } else {
                this.fire('row' + name, eve);
            }
        }
        if (column) {
            var eve = {
                column: column,
                field: column.field,
                htmlEvent: e
            };

            var fn = this['_OnColumn' + name];
            if (fn) {
                fn.call(this, eve);
            } else {
                this.fire('column' + name, eve);
            }
        }

        if (record && column) {
            var eve = {
                sender: this,
                record: record,
                row: record,
                column: column,
                field: column.field,
                htmlEvent: e
            };

            var fn = this['_OnCell' + name];
            if (fn) {
                fn.call(this, eve);
            } else {
                this.fire('cell' + name, eve);
            }

            if (column['onCell' + name]) {
                column['onCell' + name].call(column, eve);
            }
        }

        if (!record && column) {
            var eve = {
                column: column,
                htmlEvent: e
            };
            var fn = this['_OnHeaderCell' + name];
            if (fn) {
                fn.call(this, eve);
            } else {
                var evName = 'onheadercell' + name.toLowerCase();
                if (column[evName]) {
                    eve.sender = this;
                    column[evName](eve);
                }

                this.fire('headercell' + name, eve);
            }
        }

        if (!record) this._blurRow();
    },

    _OnDrawCell: function (record, column, rowIndex, columnIndex) {
        var value = mini._getMap(column.field, record);

        var e = {
            sender: this,
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            record: record,
            row: record,
            column: column,
            field: column.field,
            value: value,
            cellHtml: value,
            rowCls: null,
            cellCls: column.cellCls || '',
            rowStyle: null,
            cellStyle: column.cellStyle || '',
            allowCellWrap: this.allowCellWrap,
            autoEscape: column.autoEscape
        };

        e.visible = this._isCellVisible(rowIndex, columnIndex);
        if (e.visible == true && this._mergedCellMaps) {
            var cell = this._mergedCellMaps[rowIndex + ':' + columnIndex];
            if (cell) {
                e.rowSpan = cell.rowSpan;
                e.colSpan = cell.colSpan;
            }
        }

        if (column.dateFormat) {
            if (mini.isDate(e.value)) {
                e.cellHtml = mini.formatDate(value, column.dateFormat);
            } else e.cellHtml = value;
        }

        if (column.dataType == 'float') {
            var value = parseFloat(e.value);
            if (!isNaN(value)) {
                decimalPlaces = parseInt(column.decimalPlaces);
                if (isNaN(decimalPlaces)) decimalPlaces = 0;
                e.cellHtml = value.toFixed(decimalPlaces);
            }
        }

        if (column.dataType == 'currency') {
            e.cellHtml = mini.formatCurrency(e.value, column.currencyUnit);
        }

        if (column.displayField) {
            e.cellHtml = mini._getMap(column.displayField, record);
        }
        if (e.autoEscape == true) {
            e.cellHtml = mini.htmlEncode(e.cellHtml);
        }

        var renderer = column.renderer;
        if (renderer) {
            fn = typeof renderer == 'function' ? renderer : mini._getFunctoin(renderer);
            if (fn) {
                e.cellHtml = fn.call(column, e);
            }
        }

        this.fire('drawcell', e);

        if (e.cellHtml && !!e.cellHtml.unshift && e.cellHtml.length == 0) {
            e.cellHtml = '&nbsp;';
        }

        if (e.cellHtml === null || e.cellHtml === undefined || e.cellHtml === '') e.cellHtml = '&nbsp;';

        return e;
    },
    _OnDrawSummaryCell: function (records, column) {
        var e = {
            result: this.getResultObject(),
            sender: this,
            data: records,
            column: column,
            field: column.field,
            value: '',
            cellHtml: '',
            cellCls: column.cellCls || '',
            cellStyle: column.cellStyle || '',
            allowCellWrap: this.allowCellWrap
        };

        if (column.summaryType) {
            var fn = mini.summaryTypes[column.summaryType];
            if (fn) {
                e.value = fn(records, column.field);
            }
        }

        var value = e.value;
        e.cellHtml = e.value;

        if (e.value && parseInt(e.value) != e.value && e.value.toFixed) {
            decimalPlaces = parseInt(column.decimalPlaces);
            if (isNaN(decimalPlaces)) decimalPlaces = 2;

            e.cellHtml = parseFloat(e.value.toFixed(decimalPlaces));
        }

        if (column.dateFormat) {
            if (mini.isDate(e.value)) {
                e.cellHtml = mini.formatDate(value, column.dateFormat);
            } else e.cellHtml = value;
        }
        if (column.dataType == 'currency') {
            e.cellHtml = mini.formatCurrency(e.cellHtml, column.currencyUnit);
        }

        var renderer = column.summaryRenderer;
        if (renderer) {
            fn = typeof renderer == 'function' ? renderer : window[renderer];
            if (fn) {
                e.cellHtml = fn.call(column, e);
            }
        }
        column.summaryValue = e.value;

        this.fire('drawsummarycell', e);

        if (e.cellHtml === null || e.cellHtml === undefined || e.cellHtml === '') e.cellHtml = '&nbsp;';

        return e;
    },
    _OnDrawGroupSummaryCell: function (records, column) {
        var e = {
            sender: this,
            data: records,
            column: column,
            field: column.field,
            value: '',
            cellHtml: '',
            cellCls: column.cellCls || '',
            cellStyle: column.cellStyle || '',
            allowCellWrap: this.allowCellWrap
        };

        if (column.groupSummaryType) {
            var fn = mini.groupSummaryType[column.summaryType];
            if (fn) {
                e.value = fn(records, column.field);
            }
        }
        e.cellHtml = e.value;

        var renderer = column.groupSummaryRenderer;
        if (renderer) {
            fn = typeof renderer == 'function' ? renderer : window[renderer];
            if (fn) {
                e.cellHtml = fn.call(column, e);
            }
        }

        this.fire('drawgroupsummarycell', e);

        if (e.cellHtml === null || e.cellHtml === undefined || e.cellHtml === '') e.cellHtml = '&nbsp;';

        return e;
    },

    _OnCellMouseDown: function (e) {
        var record = e.record;

        this.fire('cellmousedown', e);
    },
    _OnRowMouseOut: function (e) {
        if (!this.enabled) return;
        if (mini.isAncestor(this.el, e.target)) return;
    },
    _OnRowMouseMove: function (e) {
        record = e.record;
        if (!this.enabled || record.enabled === false || this.enableHotTrack == false) return;

        this.fire('rowmousemove', e);

        var me = this;

        me._focusRow(record);
    },
    _OnHeaderCellClick: function (e) {
        e.sender = this;
        var column = e.column;

        if (!mini.hasClass(e.htmlEvent.target, 'mini-grid-splitter')) {
            if (this.allowSortColumn && this.isEditing() == false) {
                if (!column.columns || column.columns.length == 0) {
                    if (column.field && column.allowSort !== false) {
                        var sortOrder = 'asc';
                        if (this.sortField == column.field) {
                            sortOrder = this.sortOrder == 'asc' ? 'desc' : 'asc';
                        }
                        this.sortBy(column.field, sortOrder);
                    }
                }
            }
            this.fire('headercellclick', e);
        }
    },

    __OnHtmlContextMenu: function (e) {
        var ev = {
            popupEl: this.el,
            htmlEvent: e,
            cancel: false
        };

        if (mini.isAncestor(this._headerEl, e.target)) {
            if (this.headerContextMenu) {
                this.headerContextMenu.fire('BeforeOpen', ev);
                if (ev.cancel == true) return;
                this.headerContextMenu.fire('opening', ev);
                if (ev.cancel == true) return;
                this.headerContextMenu.showAtPos(e.pageX, e.pageY);
                this.headerContextMenu.fire('Open', ev);
            }
        } else {
            var d = mini.findParent(e.target, 'mini-grid-detailRow');
            if (d && mini.isAncestor(this.el, d)) return;

            if (this.contextMenu) {
                this.contextMenu.fire('BeforeOpen', ev);
                if (ev.cancel == true) return;
                this.contextMenu.fire('opening', ev);
                if (ev.cancel == true) return;
                this.contextMenu.showAtPos(e.pageX, e.pageY);
                this.contextMenu.fire('Open', ev);
            }
        }
        return false;
    },
    headerContextMenu: null,
    setHeaderContextMenu: function (value) {
        var ui = this._getContextMenu(value);
        if (!ui) return;
        if (this.headerContextMenu !== ui) {
            this.headerContextMenu = ui;
            this.headerContextMenu.owner = this;
            mini.on(this.el, 'contextmenu', this.__OnHtmlContextMenu, this);
        }
    },
    getHeaderContextMenu: function () {
        return this.headerContextMenu;
    },

    columnsMenu: null,
    createColumnsMenu: function () {
        if (!this.columnsMenu) {
            this.columnsMenu = mini.create({
                type: 'menu',
                items: [
                    { type: 'menuitem', text: 'Sort Asc' },
                    { type: 'menuitem', text: 'Sort Desc' },
                    '-',
                    { type: 'menuitem', text: 'Columns', name: 'columns', items: [] }
                ]
            });
        }
        var items = [];

        return this.columnsMenu;
    },
    _doShowColumnsMenu: function (column) {
        var menu = this.createColumnsMenu();
        var el = this._getColumnEl(column);
        var box = mini.getBox(el);
        menu.showAtPos(box.right - 17, box.bottom);
    },

    onRowDblClick: function (fn, scope) {
        this.on('rowdblclick', fn, scope);
    },
    onRowClick: function (fn, scope) {
        this.on('rowclick', fn, scope);
    },
    onRowMouseDown: function (fn, scope) {
        this.on('rowmousedown', fn, scope);
    },
    onRowContextMenu: function (fn, scope) {
        this.on('rowcontextmenu', fn, scope);
    },
    onCellClick: function (fn, scope) {
        this.on('cellclick', fn, scope);
    },
    onCellMouseDown: function (fn, scope) {
        this.on('cellmousedown', fn, scope);
    },
    onCellContextMenu: function (fn, scope) {
        this.on('cellcontextmenu', fn, scope);
    },
    onBeforeLoad: function (fn, scope) {
        this.on('beforeload', fn, scope);
    },
    onLoad: function (fn, scope) {
        this.on('load', fn, scope);
    },
    onLoadError: function (fn, scope) {
        this.on('loaderror', fn, scope);
    },
    onPreLoad: function (fn, scope) {
        this.on('preload', fn, scope);
    },

    onDrawCell: function (fn, scope) {
        this.on('drawcell', fn, scope);
    },
    onCellBeginEdit: function (fn, scope) {
        this.on('cellbeginedit', fn, scope);
    },

    getAttrs: function (el) {
        var ctor = this.constructor;
        ctor.parseColumns = function (el) {
            return mini._ParseColumns(el);
        };

        var attrs = mini.DataGrid.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'url',
            'sizeList',
            'bodyCls',
            'bodyStyle',
            'footerCls',
            'footerStyle',
            'pagerCls',
            'pagerStyle',
            'onheadercellclick',
            'onheadercellmousedown',
            'onheadercellcontextmenu',
            'onrowdblclick',
            'onrowclick',
            'onrowmousedown',
            'onrowcontextmenu',
            'oncellclick',
            'oncellmousedown',
            'oncellcontextmenu',
            'onbeforeload',
            'onpreload',
            'onloaderror',
            'onload',
            'ondrawcell',
            'oncellbeginedit',
            'onselectionchanged',
            'onshowrowdetail',
            'onhiderowdetail',
            'idField',
            'valueField',
            'ajaxMethod',
            'ondrawgroup',
            'pager',
            'oncellcommitedit',
            'oncellendedit',
            'headerContextMenu',
            'loadingMsg',
            'emptyText',
            'cellEditAction',
            'sortMode',
            'oncellvalidation',
            'onsort',
            'pageIndexField',
            'pageSizeField',
            'sortFieldField',
            'sortOrderField',
            'totalField',
            'dataField',
            'ondrawsummarycell',
            'ondrawgroupsummarycell',
            'onresize',
            'oncolumnschanged',
            'pagerButtons'
        ]);

        mini._ParseBool(el, attrs, [
            'showColumns',
            'showHeader',
            'showPager',
            'showFooter',
            'showTop',
            'allowSortColumn',
            'allowMoveColumn',
            'allowResizeColumn',
            'showHGridLines',
            'showVGridLines',
            'showFilterRow',
            'showSummaryRow',
            'showFooter',
            'showTop',
            'fitColumns',
            'showLoading',
            'multiSelect',
            'allowAlternating',
            'resultAsData',
            'allowRowSelect',
            'allowUnselect',
            'enableHotTrack',
            'showPageIndex',
            'showPageSize',
            'showTotalCount',
            'checkSelectOnLoad',
            'allowResize',
            'autoLoad',
            'autoHideRowDetail',
            'allowCellSelect',
            'allowCellEdit',
            'allowCellWrap',
            'allowHeaderWrap',
            'selectOnLoad',
            'virtualScroll',
            'collapseGroupOnLoad',
            'showGroupSummary',
            'showEmptyText',
            'allowCellValid',
            'showModified',
            'showColumnsMenu',
            'showPageInfo',
            'showReloadButton',
            'showNewRow',
            'editNextOnEnterKey',
            'createOnEnter'
        ]);

        mini._ParseInt(el, attrs, ['columnWidth', 'frozenStartColumn', 'frozenEndColumn', 'pageIndex', 'pageSize']);

        if (typeof attrs.sizeList == 'string') {
            attrs.sizeList = window['ev' + 'al'](attrs.sizeList);
        }
        if (!attrs.idField && attrs.valueField) {
            attrs.idField = attrs.valueField;
        }

        if (attrs.pagerButtons) {
            attrs.pagerButtons = mini.byId(attrs.pagerButtons);
        }

        return attrs;
    }
});

mini_Column_Prototype = {
    _getColumnEl: function (column) {
        column = this.getColumn(column);
        if (!column) return null;
        var id = this._createColumnId(column);
        return document.getElementById(id);
    },
    _getCellEl: function (row, column) {
        row = this.getRow ? this.getRow(row) : this.getNode(row);
        column = this.getColumn(column);
        if (!row || !column) return null;
        var id = this._createCellId(row, column);
        return document.getElementById(id);
    },
    _getCellByEvent: function (e) {
        var record = this._getRecordByEvent ? this._getRecordByEvent(e) : this._getNodeByEvent(e);
        var column = this._getColumnByEvent(e);
        return {
            record: record,
            column: column
        };
    },
    _getColumnByEvent: function (e) {
        var t = mini.findParent(e.target, this.cellCls);
        if (!t) t = mini.findParent(e.target, this.headerCellCls);
        if (t) {
            var ids = t.id.split('_');
            var id = ids[ids.length - 1];
            return this._getColumnById(id);
        }
        return null;
    },
    _createColumnId: function (column) {
        return this.uid + '_column_' + column._id;
    },
    getColumnBox: function (column) {
        var id = this._createColumnId(column);
        var el = document.getElementById(id);
        if (el) {
            var box = mini.getBox(el);
            box.x -= 1;
            box.left = box.x;
            box.right = box.x + box.width;
            return box;
        }
    },

    setColumns: function (value) {
        if (!mini.isArray(value)) value = [];
        this.columns = value;

        this._idColumns = {};
        this._nameColumns = {};
        this._bottomColumns = [];

        this.maxColumnLevel = 0;
        var level = 0;

        function init(column, index, parentColumn) {
            if (column.type) {
                if (!mini.isNull(column.header) && typeof column.header !== 'function') {
                    if (column.header.trim() == '') {
                        delete column.header;
                    }
                }
                var col = mini._getColumn(column.type);
                if (col) {
                    var _column = mini.copyTo({}, column);
                    mini.copyTo(column, col);
                    mini.copyTo(column, _column);
                }
            }

            var width = parseInt(column.width);
            if (mini.isNumber(width) && String(width) == column.width) column.width = width + 'px';
            if (mini.isNull(column.width)) column.width = this.columnWidth + 'px';
            column.visible = column.visible !== false;
            column.allowResize = column.allowResize !== false;
            column.allowMove = column.allowMove !== false;
            column.allowSort = column.allowSort === true;
            column.allowDrag = !!column.allowDrag;
            column.readOnly = !!column.readOnly;
            column.autoEscape = !!column.autoEscape;

            if (!column._id) column._id = mini.DataGrid.ColumnID++;
            column._gridUID = this.uid;
            column._rowIdField = this._rowIdField;
            column._pid = parentColumn == this ? -1 : parentColumn._id;
            this._idColumns[column._id] = column;
            if (column.name) this._nameColumns[column.name] = column;

            if (!column.columns || column.columns.length == 0) {
                this._bottomColumns.push(column);
            }

            column.level = level;
            level += 1;
            this.eachColumns(column, init, this);
            level -= 1;
            if (column.level > this.maxColumnLevel) this.maxColumnLevel = column.level;

            if (typeof column.editor == 'string') {
                var cls = mini.getClass(column.editor);
                if (cls) {
                    column.editor = { type: column.editor };
                } else {
                    column.editor = eval('(' + column.editor + ')');
                }
            }

            column.editorConfig = column.editor;

            if (typeof column.filter == 'string') {
                column.filter = eval('(' + column.filter + ')');
            }
            if (column.filter && !column.filter.el) {
                column.filter = mini.create(column.filter);
            }

            if (typeof column.init == 'function' && column.inited != true) {
                column.init(this);
            }
            column.inited = true;
        }
        this.eachColumns(this, init, this);

        if (this._doUpdateFilterRow) this._doUpdateFilterRow();

        this.doUpdate();

        this.fire('columnschanged');
    },
    getColumns: function () {
        return this.columns;
    },
    getBottomColumns: function () {
        return this._bottomColumns;
    },
    getVisibleColumns: function () {
        var columns = this.getBottomColumns();
        var cs = [];
        for (var i = 0, l = columns.length; i < l; i++) {
            var c = columns[i];
            if (c.visible) cs.push(c);
        }
        return cs;
    },
    getBottomVisibleColumns: function () {
        var columns = [];
        for (var i = 0, l = this._bottomColumns.length; i < l; i++) {
            var c = this._bottomColumns[i];
            if (this.isVisibleColumn(c)) columns.push(c);
        }
        return columns;
    },
    eachColumns: function (column, fn, scope) {
        var columns = column.columns;
        if (columns) {
            var list = columns.clone();
            for (var i = 0, l = list.length; i < l; i++) {
                var o = list[i];
                if (fn.call(scope, o, i, column) === false) break;
            }
        }
    },
    getColumn: function (index) {
        var t = typeof index;
        if (t == 'number') return this.getBottomColumns()[index];
        else if (t == 'object') return index;
        else {
            return this._nameColumns[index];
        }
    },
    getColumnByField: function (field) {
        if (!field) return;
        var columns = this.getBottomColumns();
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            if (column.field == field) return column;
        }
        return column;
    },
    _getColumnById: function (id) {
        return this._idColumns[id];
    },
    getParentColumn: function (column) {
        column = this.getColumn(column);
        var pid = column._pid;
        if (pid == -1) return this;
        return this._idColumns[pid];
    },
    getAncestorColumns: function (node) {
        var as = [];
        while (1) {
            var parentNode = this.getParentColumn(node);
            if (!parentNode || parentNode == this) break;
            as[as.length] = parentNode;
            node = parentNode;
        }
        as.reverse();
        return as;
    },
    isAncestorColumn: function (parentNode, node) {
        if (parentNode == node) return true;
        if (!parentNode || !node) return false;
        var as = this.getAncestorColumns(node);
        for (var i = 0, l = as.length; i < l; i++) {
            if (as[i] == parentNode) return true;
        }
        return false;
    },
    isVisibleColumn: function (column) {
        column = this.getColumn(column);
        var columns = this.getAncestorColumns(column);
        for (var i = 0, l = columns.length; i < l; i++) {
            if (columns[i].visible == false) return false;
        }
        return true;
    },
    updateColumn: function (column, option) {
        column = this.getColumn(column);
        if (!column) return;
        mini.copyTo(column, option);
        this.setColumns(this.columns);
    },
    removeColumn: function (column) {
        column = this.getColumn(column);
        var pcolumn = this.getParentColumn(column);
        if (column && pcolumn) {
            pcolumn.columns.remove(column);
            this.setColumns(this.columns);
        }
        return column;
    },
    moveColumn: function (column, targetColumn, action) {
        column = this.getColumn(column);
        targetColumn = this.getColumn(targetColumn);
        if (!column || !targetColumn || !action || column == targetColumn) return;

        if (this.isAncestorColumn(column, targetColumn)) {
            return;
        }

        var pcolumn = this.getParentColumn(column);
        if (pcolumn) {
            pcolumn.columns.remove(column);
        }

        var parentColumn = targetColumn;
        var index = action;
        if (index == 'before') {
            parentColumn = this.getParentColumn(targetColumn);
            index = parentColumn.columns.indexOf(targetColumn);
        } else if (index == 'after') {
            parentColumn = this.getParentColumn(targetColumn);
            index = parentColumn.columns.indexOf(targetColumn) + 1;
        } else if (index == 'add' || index == 'append') {
            if (!parentColumn.columns) parentColumn.columns = [];
            index = parentColumn.columns.length;
        } else if (!mini.isNumber(index)) {
            return;
        }

        parentColumn.columns.insert(index, column);

        this.setColumns(this.columns);
    },
    hideColumns: function (columns) {
        if (this.allowCellEdit) {
            this.commitEdit();
        }
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = this.getColumn(columns[i]);
            if (!column) continue;
            column.visible = false;
        }
        this.setColumns(this.columns);
    },
    showColumns: function (columns) {
        if (this.allowCellEdit) {
            this.commitEdit();
        }
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = this.getColumn(columns[i]);
            if (!column) continue;
            column.visible = true;
        }
        this.setColumns(this.columns);
    },
    hideColumn: function (column) {
        column = this.getColumn(column);
        if (!column) return;

        if (this.allowCellEdit) {
            this.commitEdit();
        }

        column.visible = false;
        this.setColumns(this.columns);
    },
    showColumn: function (column) {
        column = this.getColumn(column);
        if (!column) return;

        if (this.allowCellEdit) {
            this.commitEdit();
        }

        column.visible = true;
        this.setColumns(this.columns);
    },
    getColumnRows: function () {
        var maxLevel = this.getMaxColumnLevel();
        var dcs = [];
        for (var i = 0, l = maxLevel; i <= l; i++) {
            dcs.push([]);
        }

        function getColSpan(col) {
            var subColumns = mini.treeToArray(col.columns, 'columns');
            var colSpan = 0;
            for (var i = 0, l = subColumns.length; i < l; i++) {
                var c = subColumns[i];
                if (c.visible != true || c._hide == true) continue;
                if (!c.columns || c.columns.length == 0) {
                    colSpan += 1;
                }
            }
            return colSpan;
        }

        var list = mini.treeToArray(this.columns, 'columns');

        for (var i = 0, l = list.length; i < l; i++) {
            var column = list[i];
            var cols = dcs[column.level];

            if (column.columns && column.columns.length > 0) {
                column.colspan = getColSpan(column);
            }
            if ((!column.columns || column.columns.length == 0) && column.level < maxLevel) {
                column.rowspan = maxLevel - column.level + 1;
            }

            cols.push(column);
        }

        return dcs;
    },
    getMaxColumnLevel: function () {
        return this.maxColumnLevel;
    }
};

mini.copyTo(mini.DataGrid.prototype, mini_Column_Prototype);

mini._GridSort = function (grid) {
    this.grid = grid;

    mini.on(grid._headerEl, 'mousemove', this.__OnGridHeaderMouseMove, this);
    mini.on(grid._headerEl, 'mouseout', this.__OnGridHeaderMouseOut, this);
};
mini._GridSort.prototype = {
    __OnGridHeaderMouseOut: function (e) {
        if (this._focusedColumnEl) {
            mini.removeClass(this._focusedColumnEl, 'mini-grid-headerCell-hover');
        }
    },
    __OnGridHeaderMouseMove: function (e) {
        var t = mini.findParent(e.target, 'mini-grid-headerCell');
        if (t) {
            mini.addClass(t, 'mini-grid-headerCell-hover');
            this._focusedColumnEl = t;
        }
    },
    __onGridHeaderCellClick: function (e) {}
};

mini._ColumnSplitter = function (grid) {
    this.grid = grid;
    mini.on(this.grid.el, 'mousedown', this.__onGridMouseDown, this);

    grid.on('layout', this.__OnGridLayout, this);
};
mini._ColumnSplitter.prototype = {
    __OnGridLayout: function (e) {
        if (this.splittersEl) mini.removeNode(this.splittersEl);
        if (this.splitterTimer) return;
        var grid = this.grid;
        if (grid.isDisplay() == false) return;

        var sf = this;
        this.splitterTimer = setTimeout(function () {
            if (!grid.el) return;

            var bottomColumns = grid.getBottomColumns();
            var columnLength = bottomColumns.length;

            var headerBox = mini.getBox(grid._headerEl, true);
            var scrollLeft = grid.getScrollLeft();

            var sb = [];

            for (var i = 0, l = bottomColumns.length; i < l; i++) {
                var column = bottomColumns[i];
                var box = grid.getColumnBox(column);
                if (!box) break;
                var top = box.top - headerBox.top;
                var left = box.right - headerBox.left - 2;
                var height = box.height;

                if (grid.isFrozen && grid.isFrozen()) {
                    if (i >= grid.frozenStartColumn) {
                    }
                } else {
                    left += scrollLeft;
                }

                var pcolumn = grid.getParentColumn(column);
                if (pcolumn && pcolumn.columns) {
                    if (pcolumn.columns[pcolumn.columns.length - 1] == column) {
                        if (height + 5 < headerBox.height) {
                            top = 0;
                            height = headerBox.height;
                        }
                    }
                }

                if (grid.allowResizeColumn && column.allowResize) {
                    sb[sb.length] =
                        '<div id="' +
                        column._id +
                        '" class="mini-grid-splitter" style="left:' +
                        (left - 1) +
                        'px;top:' +
                        top +
                        'px;height:' +
                        height +
                        'px;"></div>';
                }
            }

            var s = sb.join('');

            sf.splittersEl = document.createElement('div');
            sf.splittersEl.className = 'mini-grid-splitters';
            sf.splittersEl.innerHTML = s;

            var el = grid._getHeaderScrollEl();
            el.appendChild(sf.splittersEl);

            sf.splitterTimer = null;
        }, 100);
    },
    __onGridMouseDown: function (e) {
        var grid = this.grid;
        var t = e.target;

        if (mini.hasClass(t, 'mini-grid-splitter')) {
            var column = grid._idColumns[t.id];
            if (grid.allowResizeColumn && column && column.allowResize) {
                this.splitterColumn = column;
                this.getDrag().start(e);
            }
        }
    },
    getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                capture: true,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    },
    _OnDragStart: function (drag) {
        var grid = this.grid;
        var columnBox = grid.getColumnBox(this.splitterColumn);
        this.columnBox = columnBox;
        this._dragProxy = mini.append(document.body, '<div class="mini-grid-proxy"></div>');

        var box = grid.getBox(true);
        box.x = columnBox.x;
        box.width = columnBox.width;
        box.right = columnBox.right;
        mini.setBox(this._dragProxy, box);
    },
    _OnDragMove: function (drag) {
        var grid = this.grid;
        var box = mini.copyTo({}, this.columnBox);
        var width = box.width + (drag.now[0] - drag.init[0]);
        if (width < grid.columnMinWidth) width = grid.columnMinWidth;
        if (width > grid.columnMaxWidth) width = grid.columnMaxWidth;

        mini.setWidth(this._dragProxy, width);
    },
    _OnDragStop: function (drag) {
        var grid = this.grid;
        var box = mini.getBox(this._dragProxy);
        var sf = this;
        var allowSort = grid.allowSortColumn;
        grid.allowSortColumn = false;
        setTimeout(function () {
            jQuery(sf._dragProxy).remove();
            sf._dragProxy = null;

            grid.allowSortColumn = allowSort;
        }, 10);

        var column = this.splitterColumn;

        var columnWidth = parseInt(column.width);
        if (columnWidth + '%' != column.width) {
            var width = grid.getColumnWidth(column);
            var w = parseInt((columnWidth / width) * box.width);
            grid.setColumnWidth(column, w);
        }
    }
};

mini._ColumnMove = function (grid) {
    this.grid = grid;
    mini.on(this.grid.el, 'mousedown', this.__onGridMouseDown, this);
};
mini._ColumnMove.prototype = {
    __onGridMouseDown: function (e) {
        var grid = this.grid;

        if (grid.isEditing && grid.isEditing()) return;
        if (mini.hasClass(e.target, 'mini-grid-splitter')) return;

        if (e.button == mini.MouseButton.Right) return;
        var t = mini.findParent(e.target, grid.headerCellCls);
        if (t) {
            this._remove();

            var column = grid._getColumnByEvent(e);
            if (grid.allowMoveColumn && column && column.allowMove) {
                this.dragColumn = column;
                this._columnEl = t;
                this.getDrag().start(e);
            }
        }
    },
    getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                capture: false,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    },
    _OnDragStart: function (drag) {
        function createHeaderCell(column) {
            var header = column.header;
            if (typeof header == 'function') header = header.call(grid, column);
            if (mini.isNull(header) || header === '') header = '&nbsp;';
            return header;
        }

        var grid = this.grid;
        this._dragProxy = mini.append(document.body, '<div class="mini-grid-columnproxy"></div>');
        this._dragProxy.innerHTML =
            '<div class="mini-grid-columnproxy-inner" style="height:26px;">' +
            createHeaderCell(this.dragColumn) +
            '</div>';
        mini.setXY(this._dragProxy, drag.now[0] + 15, drag.now[1] + 18);
        mini.addClass(this._dragProxy, 'mini-grid-no');

        this.moveTop = mini.append(document.body, '<div class="mini-grid-movetop"></div>');
        this.moveBottom = mini.append(document.body, '<div class="mini-grid-movebottom"></div>');
    },
    _OnDragMove: function (drag) {
        var grid = this.grid;
        var x = drag.now[0];

        mini.setXY(this._dragProxy, x + 15, drag.now[1] + 18);

        this.targetColumn = this.insertAction = null;
        var t = mini.findParent(drag.event.target, grid.headerCellCls);
        if (t) {
            var column = grid._getColumnByEvent(drag.event);
            if (column && column != this.dragColumn) {
                var p1 = grid.getParentColumn(this.dragColumn);
                var p2 = grid.getParentColumn(column);
                if (p1 == p2) {
                    this.targetColumn = column;
                    this.insertAction = 'before';
                    var columnBox = grid.getColumnBox(this.targetColumn);

                    if (x > columnBox.x + columnBox.width / 2) {
                        this.insertAction = 'after';
                    }
                }
            }
        }

        if (this.targetColumn) {
            mini.addClass(this._dragProxy, 'mini-grid-ok');
            mini.removeClass(this._dragProxy, 'mini-grid-no');

            var box = grid.getColumnBox(this.targetColumn);

            this.moveTop.style.display = 'block';
            this.moveBottom.style.display = 'block';
            if (this.insertAction == 'before') {
                mini.setXY(this.moveTop, box.x - 4, box.y - 9);
                mini.setXY(this.moveBottom, box.x - 4, box.bottom);
            } else {
                mini.setXY(this.moveTop, box.right - 4, box.y - 9);
                mini.setXY(this.moveBottom, box.right - 4, box.bottom);
            }
        } else {
            mini.removeClass(this._dragProxy, 'mini-grid-ok');
            mini.addClass(this._dragProxy, 'mini-grid-no');

            this.moveTop.style.display = 'none';
            this.moveBottom.style.display = 'none';
        }
    },
    _remove: function () {
        var grid = this.grid;
        mini.removeNode(this._dragProxy);
        mini.removeNode(this.moveTop);
        mini.removeNode(this.moveBottom);
        this._dragProxy = this.moveTop = this.moveBottom = this.dragColumn = this.targetColumn = null;
    },
    _OnDragStop: function (drag) {
        var grid = this.grid;
        grid.moveColumn(this.dragColumn, this.targetColumn, this.insertAction);
        this._remove();
    }
};

mini._GridSelect = function (grid) {
    this.grid = grid;
    this.grid.on('cellmousedown', this.__onGridCellMouseDown, this);

    this.grid.on('cellmouseup', this.__onGridCellClick, this);
    this.grid.on('celldblclick', this.__onGridCellClick, this);

    mini.on(this.grid.el, 'keydown', this.__OnGridKeyDown, this);
};
mini._GridSelect.prototype = {
    __OnGridKeyDown: function (e) {
        var grid = this.grid;
        if (
            mini.isAncestor(grid._filterEl, e.target) ||
            mini.isAncestor(grid._summaryEl, e.target) ||
            mini.isAncestor(grid._footerEl, e.target) ||
            mini.findParent(e.target, 'mini-grid-detailRow') ||
            mini.findParent(e.target, 'mini-grid-rowEdit')
        ) {
            return;
        }

        var currentCell = grid.getCurrentCell();

        if (e.shiftKey || e.ctrlKey || e.altKey) {
            return;
        }

        if (e.keyCode == 37 || e.keyCode == 38 || e.keyCode == 39 || e.keyCode == 40) {
            e.preventDefault();
        }

        var columns = grid.getBottomVisibleColumns();

        var column = currentCell ? currentCell[1] : null,
            record = currentCell ? currentCell[0] : null;
        if (!currentCell) record = grid.getCurrent();
        var columnIndex = columns.indexOf(column);
        var rowIndex = grid.indexOf(record);
        var count = grid.getData().length;

        switch (e.keyCode) {
            case 9:
                if (grid.allowCellEdit && grid.editOnTabKey) {
                    e.preventDefault();

                    grid._beginEditNextCell(e.shiftKey == false);
                    return;
                }

                break;
            case 27:
                break;
            case 13:
                if (grid.allowCellEdit && grid.editNextOnEnterKey) {
                    if (grid.isEditingCell(currentCell) || !column.editor) {
                        grid._beginEditNextCell(e.shiftKey == false);
                        return;
                    }
                }
                if (grid.allowCellEdit && currentCell && !column.readOnly) {
                    grid.beginEditCell();
                }
                break;
            case 37:
                if (column) {
                    if (columnIndex > 0) {
                        columnIndex -= 1;
                    }
                } else {
                    columnIndex = 0;
                }
                break;
            case 38:
                if (record) {
                    if (rowIndex > 0) rowIndex -= 1;
                } else {
                    rowIndex = 0;
                }
                if (rowIndex != 0 && grid.isVirtualScroll()) {
                    if (grid._viewRegion.start > rowIndex) {
                        grid._bodyEl.scrollTop -= grid._rowHeight;
                        grid._tryUpdateScroll();
                    }
                }
                break;
            case 39:
                if (column) {
                    if (columnIndex < columns.length - 1) {
                        columnIndex += 1;
                    }
                } else {
                    columnIndex = 0;
                }
                break;
            case 40:
                if (record) {
                    if (rowIndex < count - 1) rowIndex += 1;
                } else {
                    rowIndex = 0;
                }
                if (grid.isVirtualScroll()) {
                    if (grid._viewRegion.end < rowIndex) {
                        grid._bodyEl.scrollTop += grid._rowHeight;
                        grid._tryUpdateScroll();
                    }
                }
                break;
            default:
                break;
        }

        column = columns[columnIndex];
        record = grid.getAt(rowIndex);

        if (column && record && grid.allowCellSelect) {
            var currentCell = [record, column];
            grid.setCurrentCell(currentCell);
            grid.scrollIntoView(record, column);
        }

        if (record && grid.allowRowSelect) {
            grid.deselectAll();
            grid.setCurrent(record);
        }
    },
    __onGridCellClick: function (e) {
        var grid = this.grid;
        if (grid.allowCellEdit == false) return;

        if (this.grid.cellEditAction != e.type || e.htmlEvent.button != 0) return;

        var record = e.record,
            column = e.column;
        if (!column.readOnly && !this.grid.isReadOnly()) {
            if (e.htmlEvent.shiftKey || e.htmlEvent.ctrlKey) {
            } else {
                var lastCurrentCell = this.lastCurrentCell;
                var currentCell = this.grid.getCurrentCell();
                var allowEdit = false;
                if (this.grid.cellEditClicks == 2 && lastCurrentCell && currentCell) {
                    if (lastCurrentCell[0] == currentCell[0] && lastCurrentCell[1] == currentCell[1]) {
                        allowEdit = true;
                    }
                }
                this.lastCurrentCell = currentCell;

                if (this.grid.cellEditClicks == 1 || allowEdit) {
                    this.grid.beginEditCell();
                }
            }
        }
    },
    __onGridCellMouseDown: function (e) {
        var me = this;
        setTimeout(function () {
            me.__doSelect(e);
        }, 1);
    },

    __doSelect: function (e) {
        var record = e.record,
            column = e.column;
        var grid = this.grid;

        if (this.grid.allowCellSelect) {
            var cell = [record, column];
            this.grid.setCurrentCell(cell);
        }

        if (grid.allowRowSelect) {
            if (grid.multiSelect) {
                this.grid.el.onselectstart = function () {};
                if (e.htmlEvent.shiftKey) {
                    this.grid.el.onselectstart = function () {
                        return false;
                    };
                    e.htmlEvent.preventDefault();

                    if (!this.currentRecord) {
                        this.grid.select(record);
                        this.currentRecord = this.grid.getSelected();
                    } else {
                        this.grid.deselectAll();
                        this.grid.selectRange(this.currentRecord, record);
                    }
                } else {
                    this.grid.el.onselectstart = function () {};
                    if (e.htmlEvent.ctrlKey) {
                        this.grid.el.onselectstart = function () {
                            return false;
                        };
                        try {
                            e.htmlEvent.preventDefault();
                        } catch (ex) {}
                    }

                    if (e.column._multiRowSelect === true || e.htmlEvent.ctrlKey || grid.allowUnselect) {
                        if (grid.isSelected(record)) {
                            grid.deselect(record);
                        } else {
                            grid.select(record);
                        }
                    } else {
                        if (grid.isSelected(record)) {
                        } else {
                            grid.deselectAll();
                            grid.select(record);
                        }
                    }
                    this.currentRecord = this.grid.getSelected();
                }
            } else {
                if (!grid.isSelected(record)) {
                    grid.deselectAll();
                    grid.select(record);
                } else {
                    if (e.htmlEvent.ctrlKey) {
                        grid.deselectAll();
                    }
                }
            }
        }
    }
};

mini._CellToolTip = function (grid) {
    this.grid = grid;
    mini.on(this.grid.el, 'mousemove', this.__onGridMouseMove, this);
};
mini._CellToolTip.prototype = {
    __onGridMouseMove: function (e) {
        var grid = this.grid;
        var cell = grid._getCellByEvent(e);

        var cellEl = grid._getCellEl(cell.record, cell.column);

        var error = grid.getCellError(cell.record, cell.column);
        if (cellEl) {
            if (error) {
                cellEl.title = error.errorText;
                return;
            }

            if (cellEl.firstChild) {
                if (
                    mini.hasClass(cellEl.firstChild, 'mini-grid-cell-inner') ||
                    mini.hasClass(cellEl.firstChild, 'mini-treegrid-treecolumn-inner')
                ) {
                    cellEl = cellEl.firstChild;
                }
            }
            if (cellEl.scrollWidth > cellEl.clientWidth) {
                var s = cellEl.innerText || cellEl.textContent || '';
                cellEl.title = s.trim();
            } else {
                cellEl.title = '';
            }
        }
    }
};

mini._ColumnsMenu = function (grid) {
    this.grid = grid;
    this.menu = this.createMenu();
    mini.on(grid.el, 'contextmenu', this.__OnContextMenu, this);
};
mini._ColumnsMenu.prototype = {
    createMenu: function () {
        var menu = mini.create({ type: 'menu', hideOnClick: false });
        menu.on('itemclick', this.__OnItemClick, this);
        return menu;
    },
    updateMenu: function () {
        var grid = this.grid,
            menu = this.menu;
        var columns = grid.getBottomColumns();
        var items = [];
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            var item = {};
            item.checked = column.visible;
            item.checkOnClick = true;
            item.text = grid._createHeaderText(column);
            if (item.text == '&nbsp;') {
                if (column.type == 'indexcolumn') item.text = '序号';
                if (column.type == 'checkcolumn') item.text = '选择';
            }
            items.push(item);

            item._column = column;
        }
        menu.setItems(items);
    },
    __OnContextMenu: function (e) {
        var grid = this.grid;
        if (grid.showColumnsMenu == false) return;
        if (mini.isAncestor(grid._headerEl, e.target) == false) return;
        this.updateMenu();
        this.menu.showAtPos(e.pageX, e.pageY);
        return false;
    },
    __OnItemClick: function (e) {
        var grid = this.grid,
            menu = this.menu;
        var columns = grid.getBottomColumns();
        var items = menu.getItems();
        var item = e.item,
            column = item._column;

        var checkedCount = 0;
        for (var i = 0, l = items.length; i < l; i++) {
            var it = items[i];
            if (it.getChecked()) checkedCount++;
        }
        if (checkedCount < 1) {
            item.setChecked(true);
        }

        var checked = item.getChecked();
        if (checked) grid.showColumn(column);
        else grid.hideColumn(column);
    }
};

mini_CellValidator_Prototype = {
    getCellErrors: function () {
        var errors = this._cellErrors.clone();

        var data = this.data;
        for (var i = 0, l = errors.length; i < l; i++) {
            var error = errors[i];
            var row = error.record;
            var column = error.column;
            if (data.indexOf(row) == -1) {
                var id = row[this._rowIdField] + '_' + column._id;
                delete this._cellMapErrors[id];
                this._cellErrors.remove(error);
            }
        }

        return this._cellErrors;
    },
    getCellError: function (row, column) {
        row = this.getNode ? this.getNode(row) : this.getRow(row);
        column = this.getColumn(column);
        if (!row || !column) return;

        var id = row[this._rowIdField] + '_' + column._id;
        return this._cellMapErrors[id];
    },
    isValid: function () {
        return this.getCellErrors().length == 0;
    },
    validate: function () {
        var data = this.data;
        for (var i = 0, l = data.length; i < l; i++) {
            var row = data[i];
            this.validateRow(row);
        }
    },
    validateRow: function (row) {
        var columns = this.getBottomColumns();
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            this.validateCell(row, column);
        }
    },
    validateCell: function (row, column) {
        row = this.getNode ? this.getNode(row) : this.getRow(row);
        column = this.getColumn(column);
        if (!row || !column) return;
        var e = {
            record: row,
            row: row,
            node: row,
            column: column,
            field: column.field,
            value: row[column.field],
            isValid: true,
            errorText: ''
        };

        if (column.vtype) {
            mini._ValidateVType(column.vtype, e.value, e, column);
        }

        if (e.isValid == true && column.unique && column.field) {
            var maps = {};
            var data = this.data,
                field = column.field;
            for (var i = 0, l = data.length; i < l; i++) {
                var o = data[i];
                var v = o[field];
                if (mini.isNull(v) || v === '') {
                } else {
                    var old = maps[v];
                    if (old && o == row) {
                        e.isValid = false;
                        e.errorText = mini._getErrorText(column, 'uniqueErrorText');

                        this.setCellIsValid(old, column, e.isValid, e.errorText);
                        break;
                    }
                    maps[v] = o;
                }
            }
        }

        this.fire('cellvalidation', e);
        this.setCellIsValid(row, column, e.isValid, e.errorText);
    },

    setIsValid: function (value) {
        if (value) {
            var errors = this._cellErrors.clone();
            for (var i = 0, l = errors.length; i < l; i++) {
                var error = errors[i];
                this.setCellIsValid(error.record, error.column, true);
            }
        }
    },
    _removeRowError: function (row) {
        var columns = this.getColumns();
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            var id = row[this._rowIdField] + '_' + column._id;
            var error = this._cellMapErrors[id];
            if (error) {
                delete this._cellMapErrors[id];
                this._cellErrors.remove(error);
            }
        }
    },
    setCellIsValid: function (row, column, isValid, errorText) {
        row = this.getNode ? this.getNode(row) : this.getRow(row);
        column = this.getColumn(column);
        if (!row || !column) return;
        var id = row[this._rowIdField] + '_' + column._id;
        var cellEl = this._getCellEl(row, column);

        var error = this._cellMapErrors[id];
        delete this._cellMapErrors[id];
        this._cellErrors.remove(error);

        if (isValid === true) {
            if (cellEl && error) {
                mini.removeClass(cellEl, 'mini-grid-cell-error');
            }
        } else {
            error = { record: row, column: column, isValid: isValid, errorText: errorText };
            this._cellMapErrors[id] = error;
            this._cellErrors.add(error);
            if (cellEl) {
                mini.addClass(cellEl, 'mini-grid-cell-error');
            }
        }
    }
};

mini.copyTo(mini.DataGrid.prototype, mini_CellValidator_Prototype);

mini.GridEditor = function () {
    this._inited = true;
    mini.Control.superclass.constructor.call(this);

    this._create();
    this.el.uid = this.uid;

    this._initEvents();

    this._doInit();

    this.addCls(this.uiCls);
};
mini.extend(mini.GridEditor, mini.Control, {
    el: null,
    _create: function () {
        this.el = document.createElement('input');
        this.el.type = 'text';
        this.el.style.width = '100%';
    },
    getValue: function () {
        return this.el.value;
    },
    setValue: function (value) {
        this.el.value = value;
    },
    setWidth: function (value) {}
});

mini.DataGrid.RowID = 0;
mini.DataGrid.ColumnID = 0;

mini.getTextByValue = function (value, data, idField, textField) {
    data = data || [];
    if (value == null) value = '';
    var values = mini.isArray(value) ? value : String(value).split(',');
    var texts = [];
    for (var i = 0, l = values.length; i < l; i++) {
        var value = values[i];
        for (var j = 0, k = data.length; j < k; j++) {
            var record = data[j];
            if (String(record[idField]) == String(value)) {
                texts.push(record[textField]);
                break;
            }
        }
    }
    return texts.join(',');
};

mini.Tree = mini.Control.extend({
    isTree: true,
    _displayStyle: 'block',
    _selectedNode: null,
    props: {
        autoEscape: false,

        loadOnExpand: true,

        removeOnCollapse: true,

        expandOnDblClick: true,

        expandOnNodeClick: false,

        value: '',
        allowSelect: true,
        showCheckBox: false,
        showFolderCheckBox: true,
        showExpandButtons: true,
        enableHotTrack: true,
        showArrow: false,

        expandOnLoad: false,

        delimiter: ',',

        url: '',

        root: null,

        resultAsTree: true,

        parentField: 'pid',
        idField: 'id',
        textField: 'text',
        iconField: 'iconCls',
        nodesField: 'children',
        checkedField: 'checked',

        showTreeIcon: false,
        showTreeLines: true,
        checkRecursive: false,

        allowAnim: true,
        leafIcon: 'mini-tree-leaf',
        folderIcon: 'mini-tree-folder'
    },

    checkBoxCls: 'mini-tree-checkbox',
    selectedNodeCls: 'mini-tree-selectedNode',
    nodeHoverCls: 'mini-tree-node-hover',

    borderCls: 'mini-tree-border',
    headerCls: 'mini-tree-header',
    bodyCls: 'mini-tree-body',

    nodeCls: 'mini-tree-node',
    nodesCls: 'mini-tree-nodes',

    expandNodeCls: 'mini-tree-expand',
    collapseNodeCls: 'mini-tree-collapse',
    eciconCls: 'mini-tree-node-ecicon',
    inNodeCls: 'mini-tree-nodeshow',

    initComponent: function () {
        this._ajaxOption = {
            async: false,
            type: 'get'
        };

        this.root = { _id: -1, _pid: '', _level: -1 };
        this.data = this.root[this.nodesField] = this.data || [];

        this._idNodes = {};
        this.idNodes = {};
        this._viewNodes = null;

        this.callParent('initComponent');

        this.on(
            'beforeexpand',
            function (e) {
                var node = e.node;
                var isLeaf = this.isLeaf(node);
                var cs = node[this.nodesField];

                if (!isLeaf && (!cs || cs.length == 0)) {
                    if (this.loadOnExpand && node.asyncLoad !== false) {
                        e.cancel = true;
                        this.loadNode(node);
                    }
                }
            },
            this
        );
    },

    set: function (kv) {
        if (typeof kv == 'string') {
            return this;
        }

        var value = kv.value;
        delete kv.value;
        var url = kv.url;
        delete kv.url;
        var data = kv.data;
        delete kv.data;

        this.callParent('set', kv);

        if (!mini.isNull(data)) {
            this.setData(data);
        }
        if (!mini.isNull(url)) {
            this.setUrl(url);
        }
        if (!mini.isNull(value)) {
            this.setValue(value);
        }

        return this;
    },

    uiCls: 'mini-tree',
    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-tree';

        if (this.showTreeLines == true) {
            mini.addClass(this.el, 'mini-tree-treeLine');
        }
        this.el.style.display = 'block';

        this._borderEl = mini.append(
            this.el,
            '<div class="' +
                this.borderCls +
                '">' +
                '<div class="' +
                this.headerCls +
                '"></div><div class="' +
                this.bodyCls +
                '"></div></div>'
        );
        this._headerEl = this._borderEl.childNodes[0];
        this._bodyEl = this._borderEl.childNodes[1];

        this._DragDrop = new mini._TreeDragDrop(this);
    },
    _initEvents: function () {
        mini._BindEvents(function () {
            mini.on(this.el, 'click', this.__OnClick, this);
            mini.on(this.el, 'dblclick', this.__OnDblClick, this);
            mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
            mini.on(this.el, 'mousemove', this.__OnMouseMove, this);
            mini.on(this.el, 'mouseout', this.__OnMouseOut, this);
        }, this);
    },
    _changed: false,
    isChanged: function () {
        return this._changed;
    },
    accept: function () {
        this._changed = false;
    },

    autoLoad: true,
    setAutoLoad: function (value) {
        this.autoLoad = value;
    },
    getAutoLoad: function () {
        return this.autoLoad;
    },
    ajaxType: '',
    setAjaxType: function (value) {
        this.ajaxType = value;
    },
    getAjaxType: function () {
        return this.ajaxType;
    },

    load: function (data) {
        if (typeof data == 'string') {
            this.url = data;
            this._doLoad({}, this.root);
        } else if (mini.isArray(data)) {
            this.setData(data);
        } else {
            this._doLoad(data, this.root);
        }
    },
    setData: function (data) {
        this.loadData(data);
        this.data = data;

        this._cellErrors = [];
        this._cellMapErrors = {};
    },
    getData: function () {
        return this.data;
    },
    toArray: function () {
        return this.getList();
    },
    getList: function () {
        if (!this._list) {
            this._list = mini.treeToArray(this.root[this.nodesField], this.nodesField, '_id', '_pid', '-1');

            this._indexs = {};
            for (var i = 0, l = this._list.length; i < l; i++) {
                var node = this._list[i];
                this._indexs[node[this.idField]] = i;
            }
        }
        return this._list;
    },
    _clearTree: function () {
        this._list = null;
        this._indexs = null;
    },
    loadList: function (list, idField, parentField) {
        idField = idField || this.idField;
        parentField = parentField || this.parentField;
        var tree = mini.arrayToTree(list, this.nodesField, idField, parentField);
        this.setData(tree);
    },
    loadData: function (data) {
        if (!mini.isArray(data)) data = [];

        this._changed = false;

        this.root[this.nodesField] = data;

        this.data = data;

        this.idNodes = {};
        this._idNodes = {};

        this._updateParentAndLevel(this.root, null);

        var checkedField = this.checkedField;
        this.cascadeChild(
            this.root,
            function (node) {
                node.checked = node[checkedField];

                if (mini.isNull(node.expanded)) {
                    var level = this.getLevel(node);
                    if (
                        this.expandOnLoad === true ||
                        (mini.isNumber(this.expandOnLoad) && level <= this.expandOnLoad)
                    ) {
                        node.expanded = true;
                    } else {
                        node.expanded = false;
                    }
                }

                if (node.isLeaf === false) {
                    var cs = node[this.nodesField];
                    if (cs && cs.length > 0) {
                    }
                }
            },
            this
        );

        this._viewNodes = null;

        this._selectedNode = null;

        this.doUpdate();
    },
    clearData: function () {
        this.loadData([]);
    },
    setUrl: function (url) {
        this.url = url;
        if (this.autoLoad && url) {
            this.load(url);
        }
    },
    getUrl: function () {
        return this.url;
    },
    loadNode: function (node, expand) {
        node = this.getNode(node);
        if (!node) return;
        if (this.isLeaf(node)) return;

        var params = {};

        params[this.idField] = this.getItemValue(node);

        var sf = this;

        sf.addNodeCls(node, 'mini-tree-loading');

        var async = this._ajaxOption.async;
        this._ajaxOption.async = true;

        var time = new Date();
        this._doLoad(
            params,
            node,
            function (data) {
                var t = new Date() - time;
                if (t < 60) t = 60 - t;

                setTimeout(function () {
                    sf._ajaxOption.async = async;

                    sf.removeNodeCls(node, 'mini-tree-loading');
                    sf.removeNodes(node[sf.nodesField]);
                    if (data && data.length > 0) {
                        sf.addNodes(data, node);
                        if (expand !== false) {
                            sf.expandNode(node, true);
                        } else {
                            sf.collapseNode(node, true);
                        }
                        sf.fire('loadnode', { node: node });
                    } else {
                        delete node.isLeaf;
                        sf._doUpdateNodeTitle(node);
                    }
                }, t);
            },
            function (error) {
                sf.removeNodeCls(node, 'mini-tree-loading');
            }
        );
        this.ajaxAsync = false;
    },
    _ajaxOption: {
        async: false,
        type: 'get'
    },
    setAjaxOption: function (option) {
        mini.copyTo(this._ajaxOption, option);
    },
    getAjaxOption: function (option) {
        return this._ajaxOption;
    },

    _doLoad: function (params, node, success, fail) {
        if (!params) params = {};
        try {
            var url = eval(this.url);
            if (url != undefined) {
                this.url = url;
            }
        } catch (e) {}

        var isRoot = node == this.root;
        var e = {
            url: this.url,
            async: this._ajaxOption.async,
            type: this.ajaxType ? this.ajaxType : this._ajaxOption.type,
            params: params,
            data: params,
            cache: false,
            cancel: false,
            node: node,
            isRoot: isRoot
        };
        this.fire('beforeload', e);
        if (e.data != e.params && e.params != params) {
            e.data = e.params;
        }
        if (e.cancel == true) return;

        if (node != this.root) {
        }

        var sf = this;
        mini.copyTo(e, {
            success: function (text, code, jqXHR) {
                var data = null;
                try {
                    data = mini.decode(text);
                } catch (ex) {
                    data = [];
                    if (mini_debugger == true) {
                        alert('tree json is error.');
                    }
                }
                if (sf.dataField) {
                    data = mini._getMap(sf.dataField, data);
                }
                if (!data) data = [];

                var ex = { result: data, data: data, cancel: false, node: node };

                if (sf.resultAsTree == false) {
                    ex.data = mini.arrayToTree(ex.data, sf.nodesField, sf.idField, sf.parentField);
                }

                sf.fire('preload', ex);
                if (ex.cancel == true) return;

                if (isRoot) {
                    sf.setData(ex.data);
                }

                if (success) success(ex.data);

                sf._doCheckLoadNodes();

                sf.fire('load', ex);
            },
            error: function (jqXHR, textStatus, errorThrown) {
                var e = {
                    xmlHttp: jqXHR,
                    errorCode: textStatus
                };

                if (fail) fail(e);

                if (mini_debugger == true) {
                    alert('network error');
                }

                sf.fire('loaderror', e);
            }
        });
        this._ajaxer = mini.ajax(e);
    },

    getItemValue: function (item) {
        if (!item) return '';
        var t = mini._getMap(this.idField, item);
        return mini.isNull(t) ? '' : String(t);
    },
    getItemText: function (item) {
        if (!item) return '';
        var t = mini._getMap(this.textField, item);
        return mini.isNull(t) ? '' : String(t);
    },
    _OnDrawNode: function (node) {
        var showCheckBox = this.showCheckBox;
        if (showCheckBox && this.hasChildren(node)) {
            showCheckBox = this.showFolderCheckBox;
        }

        var nodeHtml = this.getItemText(node);
        var e = {
            isLeaf: this.isLeaf(node),
            node: node,
            nodeHtml: nodeHtml,
            nodeCls: '',
            nodeStyle: '',
            showCheckBox: showCheckBox,
            iconCls: this.getNodeIcon(node),
            img: node[this.imgField],
            showTreeIcon: this.showTreeIcon
        };
        if (this.autoEscape == true) {
            e.nodeHtml = mini.htmlEncode(e.nodeHtml);
        }

        this.fire('drawnode', e);
        if (e.nodeHtml === null || e.nodeHtml === undefined || e.nodeHtml === '') e.nodeHtml = '&nbsp;';
        return e;
    },
    _createNodeTitle: function (node, useEdit, sb) {
        var isReturn = !sb;
        if (!sb) sb = [];
        var text = node[this.textField];
        if (text === null || text === undefined) text = '';

        var isLeaf = this.isLeaf(node);
        var level = this.getLevel(node);

        var e = this._OnDrawNode(node);

        var cls = e.nodeCls;

        if (!isLeaf) {
            cls = this.isExpandedNode(node) ? this.expandNodeCls : this.collapseNodeCls;
        }

        if (this._selectedNode == node) {
            cls += ' ' + this.selectedNodeCls;
        }

        if (node.enabled === false) {
            cls += ' mini-disabled';
        }
        if (!isLeaf) {
            cls += ' mini-tree-parentNode';
        }

        var subNodes = this.getChildNodes(node);
        var hasChilds = subNodes && subNodes.length > 0;

        sb[sb.length] = '<div class="mini-tree-nodetitle ' + cls + '" style="' + e.nodeStyle + '">';

        var parentNode = this.getParentNode(node);
        var ii = 0;

        for (var i = ii; i <= level; i++) {
            if (i == level) continue;

            if (isLeaf) {
                if (this.showExpandButtons == false && i >= level - 1) {
                    continue;
                }
            }

            var indentStyle = '';
            if (this._isInViewLastNode(node, i)) {
                indentStyle = 'background:none';
            }

            sb[sb.length] = '<span class="mini-tree-indent " style="' + indentStyle + '"></span>';
        }

        var ecCls = '';
        if (this._isViewFirstNode(node)) {
            ecCls = 'mini-tree-node-ecicon-first';
        } else if (this._isViewLastNode(node)) {
            ecCls = 'mini-tree-node-ecicon-last';
        }

        if (this._isViewFirstNode(node) && this._isViewLastNode(node)) {
            ecCls = 'mini-tree-node-ecicon-last';
            if (parentNode == this.root) {
                ecCls = 'mini-tree-node-ecicon-firstLast';
            }
        }

        if (!isLeaf) {
            sb[sb.length] =
                '<a class="' +
                this.eciconCls +
                ' ' +
                ecCls +
                '" style="' +
                (this.showExpandButtons ? '' : 'display:none') +
                '" href="javascript:void(0);" onclick="return false;" hidefocus></a>';
        } else {
            sb[sb.length] = '<span class="' + this.eciconCls + ' ' + ecCls + '" ></span>';
        }

        sb[sb.length] = '<span class="mini-tree-nodeshow">';
        if (e.showTreeIcon) {
            if (e.img) {
                var img = this.imgPath + e.img;
                sb[sb.length] = '<span class="mini-tree-icon" style="background-image:url(' + img + ');"></span>';
            } else {
                sb[sb.length] = '<span class="' + e.iconCls + ' mini-tree-icon"></span>';
            }
        }

        if (e.showCheckBox) {
            var ckid = this._createCheckNodeId(node);
            var checked = this.isCheckedNode(node);

            sb[sb.length] =
                '<input type="checkbox" id="' +
                ckid +
                '" class="' +
                this.checkBoxCls +
                '" hidefocus ' +
                (checked ? 'checked' : '') +
                ' ' +
                (node.enabled === false ? 'disabled' : '') +
                '/>';
        }

        sb[sb.length] = '<span class="mini-tree-nodetext">';
        if (useEdit) {
            var editId = this.uid + '_edit_' + node._id;
            var text = node[this.textField];
            if (text === null || text === undefined) text = '';
            sb[sb.length] = '<input id="' + editId + '" type="text" class="mini-tree-editinput" value="' + text + '"/>';
        } else {
            sb[sb.length] = e.nodeHtml;
        }

        sb[sb.length] = '</span>';
        sb[sb.length] = '</span>';

        sb[sb.length] = '</div>';

        if (isReturn) return sb.join('');
    },
    _createNode: function (node, sb) {
        var isReturn = !sb;
        if (!sb) sb = [];
        if (!node) return '';
        var nodeId = this._createNodeId(node);
        var display = this.isVisibleNode(node) ? '' : 'display:none';

        sb[sb.length] = '<div id="';
        sb[sb.length] = nodeId;
        sb[sb.length] = '" class="';
        sb[sb.length] = this.nodeCls;
        sb[sb.length] = '" style="';
        sb[sb.length] = display;
        sb[sb.length] = '">';

        this._createNodeTitle(node, false, sb);

        var nodes = this._getViewChildNodes(node);

        if (nodes) {
            if (this.removeOnCollapse && this.isExpandedNode(node)) {
                this._createNodes(nodes, node, sb);
            }
        }

        sb[sb.length] = '</div>';
        if (isReturn) return sb.join('');
    },
    _createNodes: function (nodes, pnode, sb) {
        var isReturn = !sb;
        if (!sb) sb = [];

        if (!nodes) return '';

        var nodesId = this._createNodesId(pnode);

        var display = this.isExpandedNode(pnode) ? '' : 'display:none';

        sb[sb.length] = '<div id="';
        sb[sb.length] = nodesId;
        sb[sb.length] = '" class="';
        sb[sb.length] = this.nodesCls;
        sb[sb.length] = '" style="';
        sb[sb.length] = display;
        sb[sb.length] = '">';
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];

            this._createNode(node, sb);
        }
        sb[sb.length] = '</div>';

        if (isReturn) return sb.join('');
    },
    doUpdate: function () {
        if (!this._allowUpdate) return;

        var nodes = this._getViewChildNodes(this.root);
        var sb = [];
        this._createNodes(nodes, this.root, sb);
        var s = sb.join('');
        this._bodyEl.innerHTML = s;

        this._deferLayout();
    },
    _doLayoutHeader: function () {},

    _deferLayout: function () {
        var me = this;
        if (this._layoutTimer) return;
        this._layoutTimer = setTimeout(function () {
            me.doLayout();
            me._layoutTimer = null;
        }, 1);
    },
    doLayout: function () {
        if (this.showCheckBox) {
            mini.addClass(this.el, 'mini-tree-showCheckBox');
        } else {
            mini.removeClass(this.el, 'mini-tree-showCheckBox');
        }

        if (this.enableHotTrack) {
            mini.addClass(this.el, 'mini-tree-hottrack');
        } else {
            mini.removeClass(this.el, 'mini-tree-hottrack');
        }

        var rootNodesEl = this.el.firstChild;
        if (rootNodesEl) {
            mini.addClass(rootNodesEl, 'mini-tree-rootnodes');
        }
    },

    filter: function (fn, scope) {
        scope = scope || this;
        var viewNodes = (this._viewNodes = {}),
            nodesField = this.nodesField;
        function filter(node) {
            var nodes = node[nodesField];
            if (!nodes) return false;
            var id = node._id;
            var views = [];

            for (var i = 0, l = nodes.length; i < l; i++) {
                var r = nodes[i];
                var cadd = filter(r);
                var add = fn.call(scope, r, i, this);

                if (add === true || cadd) {
                    views.push(r);
                }
            }
            if (views.length > 0) viewNodes[id] = views;
            return views.length > 0;
        }

        filter(this.root);

        this.doUpdate();
    },
    clearFilter: function () {
        if (this._viewNodes) {
            this._viewNodes = null;
            this.doUpdate();
        }
    },

    setShowCheckBox: function (value) {
        if (this.showCheckBox != value) {
            this.showCheckBox = value;
            this.doUpdate();
        }
    },
    getShowCheckBox: function () {
        return this.showCheckBox;
    },
    setShowFolderCheckBox: function (value) {
        if (this.showFolderCheckBox != value) {
            this.showFolderCheckBox = value;
            this.doUpdate();
        }
    },
    getShowFolderCheckBox: function () {
        return this.showFolderCheckBox;
    },
    setAllowSelect: function (value) {
        if (this.allowSelect != value) {
            this.allowSelect = value;
            this.doUpdate();
        }
    },
    getAllowSelect: function () {
        return this.allowSelect;
    },
    setShowTreeIcon: function (value) {
        if (this.showTreeIcon != value) {
            this.showTreeIcon = value;
            this.doUpdate();
        }
    },
    getShowTreeIcon: function () {
        return this.showTreeIcon;
    },
    setShowExpandButtons: function (value) {
        if (this.showExpandButtons != value) {
            this.showExpandButtons = value;
            this.doUpdate();
        }
    },
    getShowExpandButtons: function () {
        return this.showExpandButtons;
    },
    setEnableHotTrack: function (value) {
        this.enableHotTrack = value;
        this.invalidateLayout();
    },
    getEnableHotTrack: function () {
        return this.enableHotTrack;
    },
    setExpandOnLoad: function (value) {
        this.expandOnLoad = value;
    },
    getExpandOnLoad: function () {
        return this.expandOnLoad;
    },
    setCheckRecursive: function (value) {
        this.checkRecursive = value;
    },
    getCheckRecursive: function () {
        return this.checkRecursive;
    },
    getNodeIcon: function (node) {
        var icon = mini._getMap(this.iconField, node);
        if (!icon) {
            if (this.isLeaf(node)) icon = this.leafIcon;
            else icon = this.folderIcon;
        }
        return icon;
    },

    isAncestor: function (parentNode, node) {
        if (parentNode == node) return true;
        if (!parentNode || !node) return false;
        var as = this.getAncestors(node);
        for (var i = 0, l = as.length; i < l; i++) {
            if (as[i] == parentNode) return true;
        }
        return false;
    },

    getAncestors: function (node) {
        var as = [];
        while (1) {
            var parentNode = this.getParentNode(node);
            if (!parentNode || parentNode == this.root) break;
            as[as.length] = parentNode;
            node = parentNode;
        }
        as.reverse();
        return as;
    },
    getRootNode: function () {
        return this.root;
    },
    getParentNode: function (node) {
        if (!node) return null;
        if (node._pid == this.root._id) return this.root;
        return this._idNodes[node._pid];
    },
    _isViewFirstNode: function (node) {
        if (this._viewNodes) {
            var pnode = this.getParentNode(node);
            var nodes = this._getViewChildNodes(pnode);
            return nodes[0] === node;
        } else {
            return this.isFirstNode(node);
        }
    },
    _isViewLastNode: function (node) {
        if (this._viewNodes) {
            var pnode = this.getParentNode(node);
            var nodes = this._getViewChildNodes(pnode);
            return nodes[nodes.length - 1] === node;
        } else {
            return this.isLastNode(node);
        }
    },
    _isInViewLastNode: function (node, level) {
        if (this._viewNodes) {
            var pnode = null;
            var ans = this.getAncestors(node);
            for (var i = 0, l = ans.length; i < l; i++) {
                var a = ans[i];
                if (this.getLevel(a) == level) {
                    pnode = a;
                }
            }
            if (!pnode || pnode == this.root) return false;
            return this._isViewLastNode(pnode);
        } else {
            return this.isInLastNode(node, level);
        }
    },

    _getViewChildNodes: function (node) {
        if (this._viewNodes) {
            return this._viewNodes[node._id];
        } else {
            return this.getChildNodes(node);
        }
    },
    getChildNodes: function (node) {
        node = this.getNode(node);
        if (!node) return null;
        return node[this.nodesField];
    },
    getAllChildNodes: function (node) {
        node = this.getNode(node);
        if (!node) return [];
        var nodes = [];
        this.cascadeChild(
            node,
            function (cnode) {
                nodes.push(cnode);
            },
            this
        );
        return nodes;
    },
    indexOf: function (node) {
        node = this.getNode(node);
        if (!node) return -1;

        this.getList();
        var index = this._indexs[node[this.idField]];
        if (mini.isNull(index)) return -1;
        return index;
    },
    getAt: function (index) {
        var list = this.getList();
        return list[index];
    },
    indexOfChildren: function (node) {
        var parentNode = this.getParentNode(node);
        if (!parentNode) return -1;
        var childNodes = parentNode[this.nodesField];
        return childNodes.indexOf(node);
    },
    hasChildren: function (node) {
        var subNodes = this.getChildNodes(node);
        return !!(subNodes && subNodes.length > 0);
    },
    isLeaf: function (node) {
        if (!node || node.isLeaf === false || node.isLeaf === 0) return false;
        var nodes = this.getChildNodes(node);
        if (nodes && nodes.length > 0) return false;
        return true;
    },
    getLevel: function (node) {
        return node._level;
    },
    isExpandedNode: function (node) {
        node = this.getNode(node);
        if (!node) return false;
        return node.expanded == true || mini.isNull(node.expanded);
    },
    isCheckedNode: function (node) {
        node = this.getNode(node);
        if (!node) return false;
        return node.checked == true;
    },
    isVisibleNode: function (node) {
        if (node.visible == false) return false;
        var pnode = this.getParentNode(node);
        if (!pnode || pnode == this.root) return true;
        if (pnode.expanded === false) return false;
        return this.isVisibleNode(pnode);
    },

    isEnabledNode: function (node) {
        return node.enabled !== false || this.enabled;
    },
    isFirstNode: function (node) {
        var pnode = this.getParentNode(node);
        var nodes = this.getChildNodes(pnode);
        return nodes[0] === node;
    },
    isLastNode: function (node) {
        var pnode = this.getParentNode(node);
        var nodes = this.getChildNodes(pnode);
        return nodes[nodes.length - 1] === node;
    },
    isInLastNode: function (node, level) {
        var pnode = null;
        var ans = this.getAncestors(node);
        for (var i = 0, l = ans.length; i < l; i++) {
            var a = ans[i];
            if (this.getLevel(a) == level) {
                pnode = a;
            }
        }
        if (!pnode || pnode == this.root) return false;
        return this.isLastNode(pnode);
    },

    bubbleParent: function (node, fn, scope) {
        scope = scope || this;
        if (node) fn.call(this, node);
        var parentNode = this.getParentNode(node);
        if (parentNode && parentNode != this.root) {
            this.bubbleParent(parentNode, fn, scope);
        }
    },

    cascadeChild: function (node, fn, scope) {
        if (!fn) return;
        if (!node) node = this.root;
        var nodes = node[this.nodesField];
        if (nodes) {
            nodes = nodes.clone();
            for (var i = 0, l = nodes.length; i < l; i++) {
                var c = nodes[i];
                if (fn.call(scope || this, c, i, node) === false) return;
                this.cascadeChild(c, fn, scope);
            }
        }
    },

    eachChild: function (node, fn, scope) {
        if (!fn || !node) return;
        var nodes = node[this.nodesField];
        if (nodes) {
            var list = nodes.clone();
            for (var i = 0, l = list.length; i < l; i++) {
                var o = list[i];
                if (fn.call(scope || this, o, i, node) === false) break;
            }
        }
    },
    _updateParentAndLevel: function (node, parentNode) {
        if (!node._id) {
            node._id = mini.Tree.NodeUID++;
        }
        this._idNodes[node._id] = node;
        this.idNodes[node[this.idField]] = node;
        node._pid = parentNode ? parentNode._id : '';
        node._level = parentNode ? parentNode._level + 1 : -1;
        this.cascadeChild(
            node,
            function (n, i, p) {
                if (!n._id) {
                    n._id = mini.Tree.NodeUID++;
                }
                this._idNodes[n._id] = n;
                this.idNodes[n[this.idField]] = n;
                n._pid = p._id;
                n._level = p._level + 1;
            },
            this
        );

        this._clearTree();
    },

    _updateNodeElLevel: function (node) {
        var sf = this;
        function updateECIcon(node) {
            sf._doUpdateNodeTitle(node);
        }
        if (node != this.root) {
            updateECIcon(node);
        }
        this.cascadeChild(
            node,
            function (node) {
                updateECIcon(node);
            },
            this
        );
    },

    removeNodes: function (nodes) {
        if (!mini.isArray(nodes)) return;
        nodes = nodes.clone();
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            this.removeNode(node);
        }
    },
    _doUpdateNodeTitle: function (node) {
        var s = this._createNodeTitle(node);
        var nodeEl = this._getNodeEl(node);
        if (nodeEl) {
            jQuery(nodeEl.firstChild).replaceWith(s);
        }
    },
    setNodeText: function (node, text) {
        node = this.getNode(node);
        if (!node) return;

        node[this.textField] = text;
        this._doUpdateNodeTitle(node);
        this._changed = true;
    },
    setNodeIconCls: function (node, iconCls) {
        node = this.getNode(node);
        if (!node) return;

        node[this.iconField] = iconCls;
        this._doUpdateNodeTitle(node);
        this._changed = true;
    },
    updateNode: function (node, obj) {
        node = this.getNode(node);
        if (!node || !obj) return;
        var cs = node[this.nodesField];
        mini.copyTo(node, obj);
        node[this.nodesField] = cs;
        this._doUpdateNodeTitle(node);
        this._changed = true;
    },
    removeNode: function (node) {
        node = this.getNode(node);
        if (!node) return;

        if (this._selectedNode == node) {
            this._selectedNode = null;
        }

        var nodes = [node];
        this.cascadeChild(
            node,
            function (n) {
                nodes.push(n);
            },
            this
        );

        var parentNode = this.getParentNode(node);
        parentNode[this.nodesField].remove(node);
        this._updateParentAndLevel(node, parentNode);

        var nodeEl = this._getNodeEl(node);
        if (nodeEl) {
            nodeEl.parentNode.removeChild(nodeEl);
        }
        this._updateNodeElLevel(parentNode);

        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            delete node._id;
            delete node._pid;
            delete this._idNodes[node._id];
            delete this.idNodes[node[this.idField]];
        }

        this._changed = true;
    },
    addNodes: function (nodes, parentNode, action) {
        if (!mini.isArray(nodes)) return;
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            this.addNode(node, action, parentNode);
        }
    },

    addNode: function (node, index, parentNode) {
        node = this.getNode(node);
        if (!node) return;
        if (!parentNode) index = 'add';
        var targetNode = parentNode;
        switch (index) {
            case 'before':
                if (!targetNode) return;
                parentNode = this.getParentNode(targetNode);
                var childNodes = parentNode[this.nodesField];
                index = childNodes.indexOf(targetNode);
                break;
            case 'after':
                if (!targetNode) return;
                parentNode = this.getParentNode(targetNode);
                var childNodes = parentNode[this.nodesField];
                index = childNodes.indexOf(targetNode) + 1;
                break;
            case 'add':
                break;
            default:
                break;
        }
        parentNode = this.getNode(parentNode);
        if (!parentNode) parentNode = this.root;
        var nodes = parentNode[this.nodesField];
        if (!nodes) nodes = parentNode[this.nodesField] = [];

        index = parseInt(index);
        if (isNaN(index)) index = nodes.length;

        var targetNode = nodes[index];
        if (!targetNode) index = nodes.length;

        nodes.insert(index, node);
        this._updateParentAndLevel(node, parentNode);

        var nodesEl = this._getNodesEl(parentNode);
        if (nodesEl) {
            var s = this._createNode(node);
            var index = nodes.indexOf(node) + 1;
            var targetNode = nodes[index];
            if (targetNode) {
                var targetEl = this._getNodeEl(targetNode);
                jQuery(targetEl).before(s);
            } else {
                mini.append(nodesEl, s);
            }
        } else {
            var s = this._createNode(parentNode);
            var nodeEl = this._getNodeEl(parentNode);
            jQuery(nodeEl).replaceWith(s);
        }

        parentNode = this.getParentNode(node);
        this._updateNodeElLevel(parentNode);

        this._changed = true;
    },
    moveNodes: function (nodes, targetNode, action) {
        if (!nodes || nodes.length == 0 || !targetNode || !action) return;
        this.beginUpdate();
        var sf = this;
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            this.moveNode(node, targetNode, action);
            if (i != 0) {
                targetNode = node;
                action = 'after';
            }
        }
        this.endUpdate();
    },
    moveNode: function (node, targetNode, action) {
        node = this.getNode(node);
        targetNode = this.getNode(targetNode);
        if (!node || !targetNode || !action) return false;

        if (this.isAncestor(node, targetNode)) return false;

        var index = -1;
        var parentNode = null;
        switch (action) {
            case 'before':
                parentNode = this.getParentNode(targetNode);
                index = this.indexOfChildren(targetNode);
                break;
            case 'after':
                parentNode = this.getParentNode(targetNode);
                index = this.indexOfChildren(targetNode) + 1;
                break;
            default:
                parentNode = targetNode;
                var childNodes = this.getChildNodes(parentNode);
                if (!childNodes) {
                    childNodes = parentNode[this.nodesField] = [];
                }
                index = childNodes.length;
                break;
        }

        var _node = {};

        var childNodes = this.getChildNodes(parentNode);
        childNodes.insert(index, _node);

        var _parentNode = this.getParentNode(node);
        var _childNodes = this.getChildNodes(_parentNode);
        _childNodes.remove(node);

        index = childNodes.indexOf(_node);
        childNodes[index] = node;

        this._updateParentAndLevel(node, parentNode);

        this.doUpdate();

        this._changed = true;

        return true;
    },

    isEditingNode: function (node) {
        return this._editingNode == node;
    },
    beginEdit: function (node) {
        node = this.getNode(node);
        if (!node) return;

        var nodeEl = this._getNodeEl(node);
        var s = this._createNodeTitle(node, true);
        var nodeEl = this._getNodeEl(node);
        if (nodeEl) {
            jQuery(nodeEl.firstChild).replaceWith(s);
        }
        this._editingNode = node;

        var editId = this.uid + '_edit_' + node._id;

        this._editInput = document.getElementById(editId);

        this._editInput.focus();
        mini.selectRange(this._editInput, 1000, 1000);
        mini.on(this._editInput, 'keydown', this.__OnEditInputKeyDown, this);
        mini.on(this._editInput, 'blur', this.__OnEditInputBlur, this);
    },
    cancelEdit: function () {
        if (this._editingNode) {
            this._doUpdateNodeTitle(this._editingNode);

            mini.un(this._editInput, 'keydown', this.__OnEditInputKeyDown, this);
            mini.un(this._editInput, 'blur', this.__OnEditInputBlur, this);
        }
        this._editingNode = null;
        this._editInput = null;
    },
    __OnEditInputKeyDown: function (e) {
        if (e.keyCode == 13) {
            var text = this._editInput.value;
            this.setNodeText(this._editingNode, text);
            this.cancelEdit();
            this.fire('endedit', { node: this._editingNode, text: text });
        } else if (e.keyCode == 27) {
            this.cancelEdit();
        }
    },
    __OnEditInputBlur: function (e) {
        var text = this._editInput.value;
        this.setNodeText(this._editingNode, text);
        this.cancelEdit();
        this.fire('endedit', { node: this._editingNode, text: text });
    },

    _getNodeByEvent: function (e) {
        if (mini.hasClass(e.target, this.nodesCls)) return null;
        var t = mini.findParent(e.target, this.nodeCls);
        if (t) {
            var ids = t.id.split('_');
            var id = ids[ids.length - 1];
            var node = this._idNodes[id];
            return node;
        }
        return null;
    },
    _createNodeId: function (node) {
        return this.uid + '_' + node._id;
    },
    _createNodesId: function (node) {
        return this.uid + '_nodes_' + node._id;
    },
    _createCheckNodeId: function (node) {
        return this.uid + '_check_' + node._id;
    },
    addNodeCls: function (node, cls) {
        var nodeEl = this._getNodeEl(node);
        if (nodeEl) mini.addClass(nodeEl, cls);
    },
    removeNodeCls: function (node, cls) {
        var nodeEl = this._getNodeEl(node);
        if (nodeEl) mini.removeClass(nodeEl, cls);
    },
    getNodeBox: function (node) {
        var el = this._getNodeEl(node);

        if (el) return mini.getBox(el.firstChild);
    },
    _getNodeEl: function (node) {
        if (!node) return null;
        var id = this._createNodeId(node);
        return document.getElementById(id);
    },
    _getNodeHoverEl: function (node) {
        if (!node) return null;
        var el = this._getNodeTitleEl(node);
        if (el) {
            el = mini.byClass(this.inNodeCls, el);
            return el;
        }
        return null;
    },
    _getNodeTitleEl: function (node) {
        var el = this._getNodeEl(node);
        if (el) return el.firstChild;
    },
    _getNodesEl: function (node) {
        if (!node) return null;
        if (this.isVisibleNode(node) == false) return null;
        var id = this._createNodesId(node);
        return mini.byId(id, this.el);
    },
    _getCheckBoxEl: function (node) {
        if (!node) return null;
        if (this.isVisibleNode(node) == false) return null;
        var id = this._createCheckNodeId(node);
        return mini.byId(id, this.el);
    },
    findNodes: function (fn, scope) {
        var nodes = [];
        scope = scope || this;
        this.cascadeChild(
            this.root,
            function (node) {
                if (fn && fn.call(scope, node) === true) {
                    nodes.push(node);
                }
            },
            this
        );
        return nodes;
    },
    getNode: function (node) {
        if (typeof node == 'object') return node;
        return this.idNodes[node] || null;
    },
    hideNode: function (node) {
        node = this.getNode(node);
        if (!node) return;
        node.visible = false;
        var el = this._getNodeEl(node);
        el.style.display = 'none';
    },
    showNode: function (node) {
        node = this.getNode(node);
        if (!node) return;
        node.visible = false;
        var el = this._getNodeEl(node);
        el.style.display = '';
    },
    enableNode: function (node) {
        node = this.getNode(node);
        if (!node) return;
        node.enabled = true;
        var el = this._getNodeEl(node);
        mini.removeClass(el, 'mini-disabled');
        var ck = this._getCheckBoxEl(node);
        if (ck) ck.disabled = false;
    },
    disableNode: function (node) {
        node = this.getNode(node);
        if (!node) return;
        node.enabled = false;
        var el = this._getNodeEl(node);
        mini.addClass(el, 'mini-disabled');
        var ck = this._getCheckBoxEl(node);
        if (ck) ck.disabled = true;
    },
    _allowExpandLayout: true,
    expandNode: function (node, allowAnim) {
        node = this.getNode(node);
        if (!node) return;
        var isExpand = this.isExpandedNode(node);
        if (isExpand) return;

        if (this.isLeaf(node)) return;

        node.expanded = true;

        var nodeEl = this._getNodeEl(node);
        if (this.removeOnCollapse && nodeEl) {
            var s = this._createNode(node);
            jQuery(nodeEl).before(s);
            jQuery(nodeEl).remove();
        }

        var el = this._getNodesEl(node);
        if (el) el.style.display = '';
        var el = this._getNodeEl(node);
        if (el) {
            var titleEl = el.firstChild;
            mini.removeClass(titleEl, this.collapseNodeCls);
            mini.addClass(titleEl, this.expandNodeCls);
        }
        this.fire('expand', { node: node });

        allowAnim = allowAnim && !mini.isIE6;

        var nodes = this._getViewChildNodes(node);
        if (allowAnim && nodes && nodes.length > 0) {
            this._inAniming = true;
            var el = this._getNodesEl(node);
            if (!el) return;
            var h = mini.getHeight(el);
            el.style.height = '1px';
            if (this._doPositoin) {
                el.style.position = 'relative';
            }
            var config = { height: h + 'px' };

            var sf = this;
            var jq = jQuery(el);
            jq.animate(config, 180, function () {
                sf._inAniming = false;
                sf._doLayoutHeader();
                clearInterval(sf._animateTimer);

                el.style.height = 'auto';

                if (sf._doPositoin) {
                    el.style.position = 'static';
                }

                mini.repaint(nodeEl);
            });
            clearInterval(this._animateTimer);
            this._animateTimer = setInterval(function () {
                sf._doLayoutHeader();
            }, 60);
        }
        this._doLayoutHeader();

        function doIndeterminate() {
            var nodes = this.getAllChildNodes(node);
            nodes.push(node);
            for (var i = 0, l = nodes.length; i < l; i++) {
                var node = nodes[i];
                if (node && node._indeterminate) {
                    var checkboxEl = this._getCheckBoxEl(node);
                    if (checkboxEl && node._indeterminate) {
                        checkboxEl.indeterminate = node._indeterminate;
                    }
                }
            }
        }
        var me = this;

        doIndeterminate.call(me);
    },
    collapseNode: function (node, allowAnim) {
        node = this.getNode(node);
        if (!node) return;

        var isExpand = this.isExpandedNode(node);
        if (!isExpand) return;

        if (this.isLeaf(node)) return;

        node.expanded = false;
        var nodeEl = this._getNodeEl(node);

        var el = this._getNodesEl(node);
        if (el) el.style.display = 'none';
        var el = this._getNodeEl(node);
        if (el) {
            var titleEl = el.firstChild;
            mini.removeClass(titleEl, this.expandNodeCls);
            mini.addClass(titleEl, this.collapseNodeCls);
        }
        this.fire('collapse', { node: node });

        allowAnim = allowAnim && !mini.isIE6;
        var nodes = this._getViewChildNodes(node);
        if (allowAnim && nodes && nodes.length > 0) {
            this._inAniming = true;
            var el = this._getNodesEl(node);
            if (!el) return;
            el.style.display = '';
            el.style.height = 'auto';
            if (this._doPositoin) {
                el.style.position = 'relative';
            }

            var h = mini.getHeight(el);
            var config = { height: '1px' };

            var sf = this;
            var jq = jQuery(el);
            jq.animate(config, 180, function () {
                el.style.display = 'none';
                el.style.height = 'auto';
                if (sf._doPositoin) {
                    el.style.position = 'static';
                }
                sf._inAniming = false;
                sf._doLayoutHeader();
                clearInterval(sf._animateTimer);

                var nodesEl = sf._getNodesEl(node);
                if (sf.removeOnCollapse && nodesEl) {
                    jQuery(nodesEl).remove();
                }

                mini.repaint(nodeEl);
            });
            clearInterval(this._animateTimer);
            this._animateTimer = setInterval(function () {
                sf._doLayoutHeader();
            }, 60);
        } else {
            var nodesEl = this._getNodesEl(node);
            if (this.removeOnCollapse && nodesEl) {
                jQuery(nodesEl).remove();
            }
        }

        this._doLayoutHeader();

        if (this._allowExpandLayout) {
            mini.repaint(this.el);
        }
    },
    toggleNode: function (node, allowAnim) {
        if (this.isExpandedNode(node)) {
            this.collapseNode(node, allowAnim);
        } else {
            this.expandNode(node, allowAnim);
        }
    },
    expandLevel: function (level) {
        this.cascadeChild(
            this.root,
            function (node) {
                if (this.getLevel(node) == level) {
                    if (node[this.nodesField] != null) {
                        this.expandNode(node);
                    }
                }
            },
            this
        );
    },
    collapseLevel: function (level) {
        this.cascadeChild(
            this.root,
            function (node) {
                if (this.getLevel(node) == level) {
                    if (node[this.nodesField] != null) {
                        this.collapseNode(node);
                    }
                }
            },
            this
        );
    },
    expandAll: function () {
        this.cascadeChild(
            this.root,
            function (node) {
                if (node[this.nodesField] != null) {
                    this.expandNode(node);
                }
            },
            this
        );
    },
    collapseAll: function () {
        this.cascadeChild(
            this.root,
            function (node) {
                if (node[this.nodesField] != null) {
                    this.collapseNode(node);
                }
            },
            this
        );
    },
    expandPath: function (node) {
        node = this.getNode(node);
        if (!node) return;
        var ans = this.getAncestors(node);
        for (var i = 0, l = ans.length; i < l; i++) {
            this.expandNode(ans[i]);
        }
    },
    collapsePath: function (node) {
        node = this.getNode(node);
        if (!node) return;
        var ans = this.getAncestors(node);
        for (var i = 0, l = ans.length; i < l; i++) {
            this.collapseNode(ans[i]);
        }
    },
    selectNode: function (node) {
        node = this.getNode(node);
        var el = this._getNodeEl(this._selectedNode);
        if (el) {
            mini.removeClass(el.firstChild, this.selectedNodeCls);
        }
        this._selectedNode = node;
        var el = this._getNodeEl(this._selectedNode);
        if (el) {
            mini.addClass(el.firstChild, this.selectedNodeCls);
        }

        var ev = { node: node, isLeaf: this.isLeaf(node) };
        this.fire('nodeselect', ev);
    },
    getSelectedNode: function () {
        return this._selectedNode;
    },
    getSelectedNodes: function () {
        var nodes = [];
        if (this._selectedNode) nodes.push(this._selectedNode);
        return nodes;
    },

    doUpdateCheckedState: function () {},

    autoCheckParent: false,
    setAutoCheckParent: function (value) {
        this.autoCheckParent = value;
    },
    getAutoCheckParent: function (value) {
        return this.autoCheckParent;
    },

    hasCheckedChildNode: function (pnode) {
        var checked = false;
        var nodes = this.getAllChildNodes(pnode);
        for (var i = 0, l = nodes.length; i < l; i++) {
            var n = nodes[i];
            if (this.isCheckedNode(n)) {
                checked = true;
                break;
            }
        }
        return checked;
    },

    _doCheckLoadNodes: function () {
        var nodes = this.getList();
        var checkNodes = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            if (node.checked) {
                checkNodes.push(node);
            }
        }

        for (var i = 0, l = checkNodes.length; i < l; i++) {
            var node = checkNodes[i];
            this._doCheckNode(node, true, this.checkRecursive);
        }
    },

    _doCheckNode: function (node, checked, checkRecursive) {
        var checkNode = node;
        var ckNodes = [];

        node.checked = checked;
        node._indeterminate = false;
        ckNodes.push(node);

        if (checkRecursive) {
            this.cascadeChild(
                node,
                function (cnode) {
                    cnode.checked = checked;
                    cnode._indeterminate = false;
                    ckNodes.push(cnode);
                },
                this
            );

            var ans = this.getAncestors(node);
            ans.reverse();
            for (var i = 0, l = ans.length; i < l; i++) {
                var pnode = ans[i];
                var childNodes = this.getChildNodes(pnode);
                var checkAll = true,
                    hasCheck = false;
                for (var ii = 0, ll = childNodes.length; ii < ll; ii++) {
                    var cnode = childNodes[ii];
                    if (this.isCheckedNode(cnode)) {
                        hasCheck = true;
                    } else {
                        checkAll = false;
                    }
                }
                if (checkAll) {
                    pnode.checked = true;
                    pnode._indeterminate = false;
                } else {
                    pnode.checked = false;
                    pnode._indeterminate = hasCheck;
                }
                ckNodes.push(pnode);
            }
        }

        for (var i = 0, l = ckNodes.length; i < l; i++) {
            var node = ckNodes[i];
            var checkEl = this._getCheckBoxEl(node);
            if (checkEl) {
                if (node.checked) {
                    checkEl.indeterminate = false;
                    checkEl.checked = true;
                } else {
                    checkEl.indeterminate = node._indeterminate;
                    checkEl.checked = false;
                }
            }
        }

        if (this.autoCheckParent) {
            var ans = this.getAncestors(checkNode);

            for (var i = 0, l = ans.length; i < l; i++) {
                var pnode = ans[i];
                var hasCheck = this.hasCheckedChildNode(pnode);
                if (hasCheck) {
                    pnode.checked = true;
                    pnode._indeterminate = false;

                    var checkEl = this._getCheckBoxEl(pnode);
                    if (checkEl) {
                        checkEl.indeterminate = false;
                        checkEl.checked = true;
                    }
                }
            }
        }
    },
    checkNode: function (node) {
        node = this.getNode(node);
        if (!node) return;
        this._doCheckNode(node, true, this.checkRecursive);
    },
    uncheckNode: function (node) {
        node = this.getNode(node);
        if (!node) return;
        this._doCheckNode(node, false, this.checkRecursive);
    },
    checkNodes: function (nodes) {
        if (!mini.isArray(nodes)) nodes = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            this.checkNode(node);
        }
    },
    uncheckNodes: function (nodes) {
        if (!mini.isArray(nodes)) nodes = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            this.uncheckNode(node);
        }
    },
    checkAllNodes: function () {
        this.cascadeChild(
            this.root,
            function (node) {
                this._doCheckNode(node, true, false);
            },
            this
        );
    },
    uncheckAllNodes: function (nodes) {
        this.cascadeChild(
            this.root,
            function (node) {
                this._doCheckNode(node, false, false);
            },
            this
        );
    },
    getCheckedNodes: function (haveParent) {
        var nodes = [];
        var maps = {};
        this.cascadeChild(
            this.root,
            function (node) {
                if (node.checked == true) {
                    if (!maps[node._id]) {
                        if (haveParent === false && this.isLeaf(node) == false) {
                        } else {
                            maps[node._id] = node;
                            nodes.push(node);
                        }
                    }
                    if (haveParent) {
                        var ans = this.getAncestors(node);
                        for (var i = 0, l = ans.length; i < l; i++) {
                            var anode = ans[i];
                            if (!maps[anode._id]) {
                                maps[anode._id] = anode;
                                nodes.push(anode);
                            }
                        }
                    }
                }
            },
            this
        );
        return nodes;
    },
    setValue: function (value) {
        if (mini.isNull(value)) value = '';
        value = String(value);

        var nodes = this.getCheckedNodes();
        this.uncheckNodes(nodes);

        this.value = value;

        if (this.showCheckBox) {
            var ids = String(value).split(',');
            for (var i = 0, l = ids.length; i < l; i++) {
                this.checkNode(ids[i]);
            }
        } else {
            this.selectNode(value);
        }
    },
    getNodesByValue: function (value) {
        if (mini.isNull(value)) value = '';
        value = String(value);
        var nodes = [];
        var ids = String(value).split(',');
        for (var i = 0, l = ids.length; i < l; i++) {
            var node = this.getNode(ids[i]);
            if (node) nodes.push(node);
        }
        return nodes;
    },
    getValueAndText: function (records) {
        if (mini.isNull(records)) records = [];
        if (!mini.isArray(records)) {
            records = this.getNodesByValue(records);
        }
        var values = [];
        var texts = [];
        for (var i = 0, l = records.length; i < l; i++) {
            var record = records[i];
            if (record) {
                values.push(this.getItemValue(record));
                texts.push(this.getItemText(record));
            }
        }
        return [values.join(this.delimiter), texts.join(this.delimiter)];
    },
    getValue: function (haveParent) {
        var nodes = this.getCheckedNodes(haveParent);
        var sb = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var id = this.getItemValue(nodes[i]);
            if (id) sb.push(id);
        }
        return sb.join(',');
    },
    setResultAsTree: function (value) {
        this.resultAsTree = value;
    },
    getResultAsTree: function () {
        return this.resultAsTree;
    },
    setParentField: function (value) {
        this.parentField = value;
    },
    getParentField: function () {
        return this.parentField;
    },
    setIdField: function (value) {
        this.idField = value;
    },
    getIdField: function () {
        return this.idField;
    },
    setTextField: function (value) {
        this.textField = value;
    },
    getTextField: function () {
        return this.textField;
    },
    setShowTreeLines: function (value) {
        this.showTreeLines = value;
        if (value == true) {
            mini.addClass(this.el, 'mini-tree-treeLine');
        } else {
            mini.removeClass(this.el, 'mini-tree-treeLine');
        }
    },
    getShowTreeLines: function () {
        return this.showTreeLines;
    },
    setShowArrow: function (value) {
        this.showArrow = value;
        if (value == true) {
            mini.addClass(this.el, 'mini-tree-showArrows');
        } else {
            mini.removeClass(this.el, 'mini-tree-showArrows');
        }
    },
    getShowArrow: function () {
        return this.showArrow;
    },

    setCheckedField: function (value) {
        this.checkedField = value;
    },
    getCheckedField: function () {
        return this.checkedField;
    },
    setIconField: function (value) {
        this.iconField = value;
    },
    getIconField: function () {
        return this.iconField;
    },
    setNodesField: function (value) {
        this.nodesField = value;
    },
    getNodesField: function () {
        return this.nodesField;
    },
    setTreeColumn: function (value) {
        this.treeColumn = value;
    },
    getTreeColumn: function () {
        return this.treeColumn;
    },
    setLeafIcon: function (value) {
        this.leafIcon = value;
    },
    getLeafIcon: function () {
        return this.leafIcon;
    },
    setFolderIcon: function (value) {
        this.folderIcon = value;
    },
    getFolderIcon: function () {
        return this.folderIcon;
    },
    setExpandOnDblClick: function (value) {
        this.expandOnDblClick = value;
    },
    getExpandOnDblClick: function () {
        return this.expandOnDblClick;
    },
    setExpandOnNodeClick: function (value) {
        this.expandOnNodeClick = value;
        if (value) {
            mini.addClass(this.el, 'mini-tree-nodeclick');
        } else {
            mini.removeClass(this.el, 'mini-tree-nodeclick');
        }
    },
    getExpandOnNodeClick: function () {
        return this.expandOnNodeClick;
    },

    setRemoveOnCollapse: function (value) {
        this.removeOnCollapse = value;
    },
    getRemoveOnCollapse: function () {
        return this.removeOnCollapse;
    },
    setLoadOnExpand: function (value) {
        this.loadOnExpand = value;
    },
    getLoadOnExpand: function () {
        return this.loadOnExpand;
    },
    setAutoEscape: function (value) {
        this.autoEscape = value;
    },
    getAutoEscape: function () {
        return this.autoEscape;
    },

    __OnDblClick: function (e) {
        if (!this.enabled) return;
        if (mini.findParent(e.target, this.checkBoxCls)) return;

        var node = this._getNodeByEvent(e);
        if (node && node.enabled !== false) {
            if (mini.findParent(e.target, this.inNodeCls)) {
                var expanded = this.isExpandedNode(node);

                var ev = {
                    node: node,
                    expanded: expanded,
                    cancel: false
                };

                if (this.expandOnDblClick && !this._inAniming) {
                    if (expanded) {
                        this.fire('beforecollapse', ev);
                        if (ev.cancel == true) return;
                        this.collapseNode(node, this.allowAnim);
                    } else {
                        this.fire('beforeexpand', ev);
                        if (ev.cancel == true) return;
                        this.expandNode(node, this.allowAnim);
                    }
                }

                this.fire('nodedblclick', { htmlEvent: e, node: node, isLeaf: this.isLeaf(node) });
            }
        }
    },
    __OnClick: function (e) {
        if (!this.enabled) return;
        var node = this._getNodeByEvent(e);
        if (node && node.enabled !== false) {
            var allow = mini.findParent(e.target, this.inNodeCls) && this.expandOnNodeClick;
            if (mini.findParent(e.target, this.checkBoxCls)) allow = false;
            if ((mini.findParent(e.target, this.eciconCls) || allow) && this.isLeaf(node) == false) {
                if (this._inAniming) return;
                var expanded = this.isExpandedNode(node);
                var ev = {
                    node: node,
                    expanded: expanded,
                    cancel: false
                };

                if (!this._inAniming) {
                    if (expanded) {
                        this.fire('beforecollapse', ev);
                        if (ev.cancel == true) return;
                        this.collapseNode(node, this.allowAnim);
                    } else {
                        this.fire('beforeexpand', ev);
                        if (ev.cancel == true) return;
                        this.expandNode(node, this.allowAnim);
                    }
                }
            } else if (mini.findParent(e.target, this.checkBoxCls)) {
                var checked = this.isCheckedNode(node);
                var ev = {
                    isLeaf: this.isLeaf(node),
                    node: node,
                    checked: checked,
                    checkRecursive: this.checkRecursive,
                    htmlEvent: e,
                    cancel: false
                };

                this.fire('beforenodecheck', ev);
                if (ev.cancel == true) {
                    e.preventDefault();
                    return;
                }
                if (checked) {
                    this.uncheckNode(node);
                } else {
                    this.checkNode(node);
                }
                this.fire('nodecheck', ev);
            } else {
                this._OnNodeClick(node, e);
            }
        }
    },
    __OnMouseDown: function (e) {
        if (!this.enabled) return;
        if (this._editInput) this._editInput.blur();

        var node = this._getNodeByEvent(e);
        if (node) {
            if (mini.findParent(e.target, this.eciconCls)) {
            } else if (mini.findParent(e.target, this.checkBoxCls)) {
            } else {
                this._OnNodeMouseDown(node, e);
            }
        }
    },
    _OnNodeMouseDown: function (node, htmlEvent) {
        var show = mini.findParent(htmlEvent.target, this.inNodeCls);
        if (!show) return null;
        if (!this.isEnabledNode(node)) return;

        var ev = { node: node, cancel: false, isLeaf: this.isLeaf(node), htmlEvent: htmlEvent };

        if (this.allowSelect && node.allowSelect !== false) {
            if (this._selectedNode != node) {
                this.fire('beforenodeselect', ev);
                if (ev.cancel != true) {
                    this.selectNode(node);
                }
            }
        }

        this.fire('nodeMouseDown', ev);
    },
    _OnNodeClick: function (node, htmlEvent) {
        var show = mini.findParent(htmlEvent.target, this.inNodeCls);
        if (!show) return null;
        if (htmlEvent.target.tagName.toLowerCase() == 'a') {
            htmlEvent.target.hideFocus = true;
        }
        if (!this.isEnabledNode(node)) return;

        var ev = { node: node, cancel: false, isLeaf: this.isLeaf(node), htmlEvent: htmlEvent };

        if (this._getColumnByEvent) {
            var column = this._getColumnByEvent(htmlEvent);
            if (column) {
                ev.column = column;
                ev.field = column.field;
            }
        }

        this.fire('nodeClick', ev);
    },

    __OnMouseMove: function (e) {
        var node = this._getNodeByEvent(e);
        if (node) {
            this._OnNodeMouseMove(node, e);
        }
    },
    __OnMouseOut: function (e) {
        var node = this._getNodeByEvent(e);
        if (node) {
            this._OnNodeMouseOut(node, e);
        }
    },

    _OnNodeMouseOut: function (node, e) {
        if (!this.isEnabledNode(node)) return;
        if (!mini.findParent(e.target, this.inNodeCls)) return;

        this.blurNode();

        var e = {
            node: node,
            htmlEvent: e
        };
        this.fire('nodemouseout', e);
    },
    _OnNodeMouseMove: function (node, e) {
        if (!this.isEnabledNode(node)) return;
        if (!mini.findParent(e.target, this.inNodeCls)) return;
        if (this.enableHotTrack == true) {
            this.focusNode(node);
        }
        var e = {
            node: node,
            htmlEvent: e
        };
        this.fire('nodemousemove', e);
    },
    focusNode: function (node, view) {
        node = this.getNode(node);
        if (!node) return;
        function doFocus() {
            var dom = this._getNodeHoverEl(node);
            if (view && dom) {
                this.scrollIntoView(node);
            }
            if (this._focusedNode == node) return;
            this.blurNode();
            this._focusedNode = node;

            mini.addClass(dom, this.nodeHoverCls);
        }
        var me = this;
        setTimeout(function () {
            doFocus.call(me);
        }, 1);
    },
    blurNode: function () {
        if (!this._focusedNode) return;

        var dom = this._getNodeHoverEl(this._focusedNode);
        if (dom) {
            mini.removeClass(dom, this.nodeHoverCls);
        }
        this._focusedNode = null;
    },
    scrollIntoView: function (node) {
        node = this.getNode(node);
        if (!node) return;
        this.expandPath(node);
        var itemEl = this._getNodeEl(node);
        mini.scrollIntoView(itemEl, this.el, false);
    },

    __OnHtmlContextMenu: function (e) {
        if (mini.isAncestor(this._headerEl, e.target)) {
            return true;
        }
        return mini.Tree.superclass.__OnHtmlContextMenu.call(this, e);
    },

    onNodeClick: function (fn, scope) {
        this.on('nodeClick', fn, scope);
    },
    onBeforeNodeSelect: function (fn, scope) {
        this.on('beforenodeselect', fn, scope);
    },
    onNodeSelect: function (fn, scope) {
        this.on('nodeselect', fn, scope);
    },
    onBeforeNodeCheck: function (fn, scope) {
        this.on('beforenodecheck', fn, scope);
    },
    onCheckNode: function (fn, scope) {
        this.on('nodecheck', fn, scope);
    },
    onNodeMouseDown: function (fn, scope) {
        this.on('nodemousedown', fn, scope);
    },
    onBeforeExpand: function (fn, scope) {
        this.on('beforeexpand', fn, scope);
    },
    onExpand: function (fn, scope) {
        this.on('expand', fn, scope);
    },
    onBeforeCollapse: function (fn, scope) {
        this.on('beforecollapse', fn, scope);
    },
    onCollapse: function (fn, scope) {
        this.on('collapse', fn, scope);
    },
    onBeforeLoad: function (fn, scope) {
        this.on('beforeload', fn, scope);
    },
    onLoad: function (fn, scope) {
        this.on('load', fn, scope);
    },
    onLoadError: function (fn, scope) {
        this.on('loaderror', fn, scope);
    },
    onDataLoad: function (fn, scope) {
        this.on('dataload', fn, scope);
    },

    _getDragData: function () {
        return this.getSelectedNodes().clone();
    },
    _getDragText: function (dragNodes) {
        return 'Nodes ' + dragNodes.length;
    },

    allowDrag: false,
    allowDrop: false,
    dragGroupName: '',
    dropGroupName: '',
    allowLeafDropIn: false,
    setAllowLeafDropIn: function (value) {
        this.allowLeafDropIn = value;
    },
    getAllowLeafDropIn: function () {
        return this.allowLeafDropIn;
    },
    setAllowDrag: function (value) {
        this.allowDrag = value;
    },
    getAllowDrag: function () {
        return this.allowDrag;
    },
    setAllowDrop: function (value) {
        this.allowDrop = value;
    },
    getAllowDrop: function () {
        return this.allowDrop;
    },
    setDragGroupName: function (value) {
        this.dragGroupName = value;
    },
    getDragGroupName: function () {
        return this.dragGroupName;
    },
    setDropGroupName: function (value) {
        this.dropGroupName = value;
    },
    getDropGroupName: function () {
        return this.dropGroupName;
    },
    isAllowDrag: function (node) {
        if (!this.allowDrag) return false;
        if (node.allowDrag === false) return false;
        return true;
    },
    _OnDragStart: function (node) {
        var e = {
            node: node,
            nodes: this._getDragData(),
            dragText: this._getDragText(this._getDragData()),
            cancel: false
        };
        this.fire('DragStart', e);
        return e;
    },
    _OnDragDrop: function (dragNodes, dropNode, dragAction) {
        dragNodes = dragNodes.clone();
        var e = {
            dragNodes: dragNodes,
            targetNode: dropNode,
            action: dragAction,
            cancel: false
        };

        e.dragNode = e.dragNodes[0];
        e.dropNode = e.targetNode;
        e.dragAction = e.action;

        this.fire('beforedrop', e);
        this.fire('DragDrop', e);
        return e;
    },
    _OnGiveFeedback: function (effect, dragNodes, dropNode, from) {
        var e = {};
        e.from = from;
        e.effect = effect;
        e.nodes = dragNodes;
        e.targetNode = dropNode;

        e.node = e.nodes[0];

        e.dragNodes = dragNodes;
        e.dragNode = e.dragNodes[0];
        e.dropNode = e.targetNode;
        e.dragAction = e.action;

        this.fire('givefeedback', e);
        return e;
    },

    imgPath: '',
    setImgPath: function (value) {
        this.imgPath = value;
    },
    getImgPath: function () {
        return this.imgPath;
    },
    imgField: 'img',
    setImgField: function (value) {
        this.imgField = value;
    },
    getImgField: function () {
        return this.imgField;
    },

    getAttrs: function (el) {
        var attrs = mini.Tree.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, [
            'value',
            'url',
            'idField',
            'textField',
            'iconField',
            'nodesField',
            'parentField',
            'valueField',
            'checkedField',
            'leafIcon',
            'folderIcon',
            'ondrawnode',
            'onbeforenodeselect',
            'onnodeselect',
            'onnodemousedown',
            'onnodeclick',
            'onnodedblclick',
            'onbeforeload',
            'onpreload',
            'onload',
            'onloaderror',
            'ondataload',
            'onbeforenodecheck',
            'onnodecheck',
            'onbeforeexpand',
            'onexpand',
            'onbeforecollapse',
            'oncollapse',
            'dragGroupName',
            'dropGroupName',
            'onendedit',
            'expandOnLoad',
            'ajaxOption',
            'ondragstart',
            'onbeforedrop',
            'ondrop',
            'ongivefeedback',
            'ajaxType',
            'imgPath',
            'imgField'
        ]);

        mini._ParseBool(el, attrs, [
            'allowSelect',
            'showCheckBox',
            'showExpandButtons',
            'showTreeIcon',
            'showTreeLines',
            'checkRecursive',
            'enableHotTrack',
            'showFolderCheckBox',
            'resultAsTree',
            'allowLeafDropIn',
            'allowDrag',
            'allowDrop',
            'showArrow',
            'expandOnDblClick',
            'removeOnCollapse',
            'autoCheckParent',
            'loadOnExpand',
            'expandOnNodeClick',
            'autoEscape',
            'autoLoad'
        ]);
        if (attrs.ajaxOption) {
            attrs.ajaxOption = mini.decode(attrs.ajaxOption);
        }

        if (attrs.expandOnLoad) {
            var level = parseInt(attrs.expandOnLoad);
            if (mini.isNumber(level)) {
                attrs.expandOnLoad = level;
            } else {
                attrs.expandOnLoad = attrs.expandOnLoad == 'true' ? true : false;
            }
        }

        var idField = attrs.idField || this.idField;
        var textField = attrs.textField || this.textField;
        var iconField = attrs.iconField || this.iconField;
        var nodesField = attrs.nodesField || this.nodesField;

        function parseNodes(nodes) {
            var data = [];

            for (var i = 0, l = nodes.length; i < l; i++) {
                var node = nodes[i];
                var cnodes = mini.getChildNodes(node);
                var nodeTitle = cnodes[0];
                var nodeChild = cnodes[1];

                if (!nodeTitle || !nodeChild) nodeTitle = node;
                var jqTitle = jQuery(nodeTitle);
                var o = {};
                var id = (o[idField] = nodeTitle.getAttribute('value'));

                o[iconField] = jqTitle.attr('iconCls');
                o[textField] = nodeTitle.innerHTML;
                data.add(o);

                var expanded = jqTitle.attr('expanded');
                if (expanded) {
                    o.expanded = expanded == 'false' ? false : true;
                }

                var allowSelect = jqTitle.attr('allowSelect');
                if (allowSelect) {
                    o.allowSelect = allowSelect == 'false' ? false : true;
                }

                if (!nodeChild) continue;
                var cs = mini.getChildNodes(nodeChild);
                var cdata = parseNodes(cs);
                if (cdata.length > 0) {
                    o[nodesField] = cdata;
                }
            }
            return data;
        }

        var data = parseNodes(mini.getChildNodes(el));
        if (data.length > 0) {
            attrs.data = data;
        }

        if (!attrs.idField && attrs.valueField) {
            attrs.idField = attrs.valueField;
        }

        return attrs;
    }
});
mini.regClass(mini.Tree, 'tree');

mini._TreeDragDrop = function (tree) {
    this.owner = tree;
    this.owner.on('NodeMouseDown', this.__OnTreeNodeMouseDown, this);
};
mini._TreeDragDrop.prototype = {
    __OnTreeNodeMouseDown: function (e) {
        var node = e.node;
        if (e.htmlEvent.button == mini.MouseButton.Right) return;

        var tree = this.owner;
        if (tree.isReadOnly() || tree.isAllowDrag(e.node) == false) return;

        if (tree.isEditingNode(node)) return;

        var ex = tree._OnDragStart(node);
        if (ex.cancel) return;
        this.dragText = ex.dragText;

        this.dragData = tree._getDragData();

        if (this.dragData.indexOf(node) == -1) {
            this.dragData.push(node);
        }
        var drag = this._getDrag();
        drag.start(e.htmlEvent);
    },
    _OnDragStart: function (drag) {
        var tree = this.owner;

        this.feedbackEl = mini.append(document.body, '<div class="mini-feedback"></div>');
        this.feedbackEl.innerHTML = this.dragText;
        this.lastFeedbackClass = '';

        this.enableHotTrack = tree.enableHotTrack;
        tree.setEnableHotTrack(false);
    },
    _getDropTree: function (event) {
        var dom = mini.findParent(event.target, 'mini-tree', 500);
        if (dom) {
            return mini.get(dom);
        }
    },
    _OnDragMove: function (drag) {
        var tree = this.owner;
        var dropTree = this._getDropTree(drag.event);

        var x = drag.now[0],
            y = drag.now[1];
        mini.setXY(this.feedbackEl, x + 15, y + 18);

        this.dragAction = 'no';

        if (dropTree) {
            var targetNode = dropTree._getNodeByEvent(drag.event);
            this.dropNode = targetNode;

            if (targetNode && dropTree.allowDrop == true) {
                if (!dropTree.isLeaf(targetNode)) {
                    var nodes = targetNode[dropTree.nodesField];
                    if (nodes && nodes.length > 0) {
                    } else {
                        if (tree.loadOnExpand && targetNode.asyncLoad !== false) {
                            dropTree.loadNode(targetNode);
                        } else {
                        }
                    }
                }

                this.dragAction = this.getFeedback(targetNode, y, 3, dropTree, tree);
            } else {
                this.dragAction = 'no';
            }
            if (
                tree &&
                dropTree &&
                tree != dropTree &&
                !targetNode &&
                dropTree.getChildNodes(dropTree.root).length == 0
            ) {
                targetNode = dropTree.getRootNode();
                this.dragAction = 'add';
                this.dropNode = targetNode;
            }
        }

        this.lastFeedbackClass = 'mini-feedback-' + this.dragAction;
        this.feedbackEl.className = 'mini-feedback ' + this.lastFeedbackClass;

        if (this.dragAction == 'no') targetNode = null;
        this.setRowFeedback(targetNode, this.dragAction, dropTree);
    },
    _OnDragStop: function (drag) {
        var tree = this.owner;
        var dropTree = this._getDropTree(drag.event);

        mini.removeNode(this.feedbackEl);

        this.feedbackEl = null;
        this.setRowFeedback(null);

        var dragNodes = [];
        for (var i = 0, l = this.dragData.length; i < l; i++) {
            var dragNode = this.dragData[i];

            var hasParent = false;
            for (var j = 0, k = this.dragData.length; j < k; j++) {
                var dr = this.dragData[j];
                if (dr != dragNode) {
                    hasParent = tree.isAncestor(dr, dragNode);
                    if (hasParent) break;
                }
            }

            if (!hasParent) {
                dragNodes.push(dragNode);
            }
        }
        this.dragData = dragNodes;

        if (this.dropNode && dropTree && this.dragAction != 'no') {
            var e = tree._OnDragDrop(this.dragData, this.dropNode, this.dragAction);

            if (!e.cancel) {
                var dragNodes = e.dragNodes,
                    targetNode = e.targetNode,
                    action = e.action;

                if (tree == dropTree) {
                    tree.moveNodes(dragNodes, targetNode, action);
                } else {
                    tree.removeNodes(dragNodes);
                    dropTree.addNodes(dragNodes, targetNode, action);
                }
            }
        }

        tree.setEnableHotTrack(this.enableHotTrack);

        var e = {
            dragNode: this.dragData[0],
            dropNode: this.dropNode,
            dragAction: this.dragAction
        };
        tree.fire('drop', e);

        this.dropNode = null;
        this.dragData = null;
    },
    setRowFeedback: function (node, feedback, tree) {
        if (this.lastAddDomNode) {
            mini.removeClass(this.lastAddDomNode, 'mini-tree-feedback-add');
        }
        if (node == null || this.dragAction == 'add') {
            mini.removeNode(this.feedbackLine);
            this.feedbackLine = null;
        }

        this.lastRowFeedback = node;

        if (node != null) {
            if (feedback == 'before' || feedback == 'after') {
                if (!this.feedbackLine) {
                    this.feedbackLine = mini.append(document.body, "<div class='mini-feedback-line'></div>");
                }
                this.feedbackLine.style.display = 'block';
                var rowBox = tree.getNodeBox(node);
                var x = rowBox.x,
                    y = rowBox.y - 1;
                if (feedback == 'after') {
                    y += rowBox.height;
                }
                mini.setXY(this.feedbackLine, x, y);

                var box = tree.getBox(true);
                mini.setWidth(this.feedbackLine, box.width);
            } else {
                var el = tree._getNodeTitleEl(node);
                mini.addClass(el, 'mini-tree-feedback-add');
                this.lastAddDomNode = el;
            }
        }
    },
    getFeedback: function (dropNode, y, way, tree, fromTree) {
        var rowBox = tree.getNodeBox(dropNode);

        var h = rowBox.height;
        var t = y - rowBox.y;

        var effect = null;

        if (this.dragData.indexOf(dropNode) != -1) return 'no';
        var IsLeaf = false;
        if (way == 3) {
            IsLeaf = tree.isLeaf(dropNode);

            for (var i = 0, l = this.dragData.length; i < l; i++) {
                var dragRecord = this.dragData[i];

                var isAncestor = tree.isAncestor(dragRecord, dropNode);
                if (isAncestor) {
                    effect = 'no';
                    break;
                }
            }
        }
        if (effect == null) {
            if (IsLeaf && tree.allowLeafDropIn == false) {
                if (t > h / 2) effect = 'after';
                else effect = 'before';
            } else {
                if (t > (h / 3) * 2) effect = 'after';
                else if (h / 3 <= t && t <= (h / 3) * 2) effect = 'add';
                else effect = 'before';
            }
        }
        var e = tree._OnGiveFeedback(effect, this.dragData, dropNode, fromTree);
        return e.effect;
    },
    _getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                capture: false,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    }
};

mini.Tree.NodeUID = 1;
var lastNodeLevel = [];
mini.TreeGrid = mini.Tree.extend({
    uiCls: 'mini-treegrid',

    props: {
        width: 300,
        height: 180,

        minWidth: 300,
        minHeight: 150,
        maxWidth: 5000,
        maxHeight: 3000,

        allowResize: false,

        treeColumn: '',

        columns: null,
        columnWidth: 80,

        allowResizeColumn: true,
        allowMoveColumn: true
    },

    _rowIdField: '_id',
    _doPositoin: true,

    headerCellCls: 'mini-treegrid-headerCell',
    cellCls: 'mini-treegrid-cell',

    borderCls: 'mini-treegrid-border',
    headerCls: 'mini-treegrid-header',
    bodyCls: 'mini-treegrid-body',

    nodeCls: 'mini-treegrid-node',
    nodesCls: 'mini-treegrid-nodes',
    selectedNodeCls: 'mini-treegrid-selectedNode',
    nodeHoverCls: 'mini-treegrid-hoverNode',

    expandNodeCls: 'mini-treegrid-expand',
    collapseNodeCls: 'mini-treegrid-collapse',
    eciconCls: 'mini-treegrid-ec-icon',
    inNodeCls: 'mini-treegrid-nodeTitle',

    initComponent: function () {
        this.columns = this.columns || [];
        this._bottomColumns = [];
        this._idColumns = {};
        this._nameColumns = {};

        this._cellErrors = [];
        this._cellMapErrors = {};

        this.callParent('initComponent');

        this._resizeEl.style.display = this.allowResize ? '' : 'none';
    },

    _getNodeHoverEl: function (node) {
        if (!node) return null;
        var el = this._getNodeTitleEl(node);
        return el;
    },

    _create: function () {
        mini.TreeGrid.superclass._create.call(this);

        this._resizeEl = mini.append(this._borderEl, '<div class="mini-resizer-trigger" style=""></div>');

        mini.on(this._bodyEl, 'scroll', this.__OnScroll, this);

        this._Resizer = new mini._Resizer(this);
        this._ColumnMove = new mini._ColumnMove(this);
        this._Splitter = new mini._ColumnSplitter(this);
        this._CellTip = new mini._CellToolTip(this);
    },
    _createColumnId: function (column) {
        return this.uid + '_column_' + column.id;
    },
    _getHeaderScrollEl: function () {
        return this._headerEl.firstChild;
    },
    _CreateTopTr: function (name) {
        var s = '';
        var columns = this.getBottomColumns();
        if (isIE) {
            if (isIE6 || isIE7 || (isIE8 && !jQuery.boxModel) || (isIE9 && !jQuery.boxModel)) {
                s += '<tr style="display:none;">';
            } else {
                s += '<tr >';
            }
        } else {
            s += '<tr>';
        }
        for (var i = 0, l = columns.length; i < l; i++) {
            var column = columns[i];
            var width = column.width;
            var id = this._createColumnId(column) + '_' + name;

            s += '<td id="' + id + '" style="padding:0;border:0;margin:0;height:0;';
            if (column.width) s += 'width:' + column.width;

            if (column.visible == false) {
                s += ';display:none;';
            }

            s += '" ></td>';
        }
        s += '</tr>';
        return s;
    },

    _doUpdateHeader: function () {
        var rows = this.getColumnRows();

        var bottomColumns = this.getBottomColumns();
        var columnLength = bottomColumns.length;

        var sb = [];
        sb[sb.length] =
            '<div class="mini-treegrid-headerInner"><table style="display:table" class="mini-treegrid-table" cellspacing="0" cellpadding="0">';
        sb[sb.length] = this._CreateTopTr('header');

        for (var j = 0, k = rows.length; j < k; j++) {
            var columns = rows[j];

            sb[sb.length] = '<tr >';
            for (var i = 0, l = columns.length; i < l; i++) {
                var column = columns[i];
                var header = column.header;
                if (typeof header == 'function') header = header.call(this, column);
                if (mini.isNull(header) || header === '') header = '&nbsp;';

                var columnId = this._createColumnId(column);

                sb[sb.length] = '<td id="';
                sb[sb.length] = columnId;
                sb[sb.length] = '" class="mini-treegrid-headerCell  ' + (column.headerCls || '') + ' ';

                sb[sb.length] = '" style="';
                var bottomIndex = bottomColumns.indexOf(column);
                if (column.visible == false) {
                    sb[sb.length] = ';display:none;';
                }

                if (column.columns && column.columns.length > 0 && column.colspan == 0) {
                    sb[sb.length] = ';display:none;';
                }

                if (column.headerStyle) {
                    sb[sb.length] = column.headerStyle + ';';
                }
                if (column.headerAlign) {
                    sb[sb.length] = 'text-align:' + column.headerAlign + ';';
                }

                sb[sb.length] = '" ';

                if (column.rowspan) {
                    sb[sb.length] = 'rowspan="' + column.rowspan + '" ';
                }
                if (column.colspan) {
                    sb[sb.length] = 'colspan="' + column.colspan + '" ';
                }

                sb[sb.length] = '>';

                sb[sb.length] = header;

                sb[sb.length] = '</td>';
            }
            sb[sb.length] = '</tr>';
        }
        sb[sb.length] = '</table><div class="mini-treegrid-topRightCell"></div></div>';

        var s = sb.join('');

        this._headerEl.innerHTML = s;

        this._headerInnerEl = this._headerEl.firstChild;
        this._topRightCellEl = this._headerInnerEl.lastChild;
    },
    _createNodeTitle: function (node, useEdit, sb) {
        var isReturn = !sb;
        if (!sb) sb = [];

        var text = node[this.textField];
        if (text === null || text === undefined) text = '';
        var isLeaf = this.isLeaf(node);
        var level = this.getLevel(node);

        var cls = '';
        if (!isLeaf) {
            cls = this.isExpandedNode(node) ? this.expandNodeCls : this.collapseNodeCls;
        }
        if (this._selectedNode == node) {
            cls += ' ' + this.selectedNodeCls;
        }

        var columns = this.getBottomColumns();

        sb[sb.length] = '<table class="mini-treegrid-nodeTitle ';
        sb[sb.length] = cls;
        sb[sb.length] = '" cellspacing="0" cellpadding="0">';
        sb[sb.length] = this._CreateTopTr();
        sb[sb.length] = '<tr>';
        for (var j = 0, k = columns.length; j < k; j++) {
            var column = columns[j];
            var cellId = this._createCellId(node, column);

            var e = this._OnDrawCell(node, column);

            var w = column.width;
            if (typeof w == 'number') w = w + 'px';

            sb[sb.length] = '<td id="';
            sb[sb.length] = cellId;
            sb[sb.length] = '" class="mini-treegrid-cell ';
            if (e.cellCls) sb[sb.length] = e.cellCls;
            sb[sb.length] = '" style="';
            if (e.cellStyle) {
                sb[sb.length] = e.cellStyle;
                sb[sb.length] = ';';
            }

            if (column.align) {
                sb[sb.length] = 'text-align:';
                sb[sb.length] = column.align;
                sb[sb.length] = ';';
            }
            if (column.visible == false) {
                sb[sb.length] = 'display:none;';
            }

            sb[sb.length] = '">';
            sb[sb.length] = e.cellHtml;
            sb[sb.length] = '</td>';

            if (e.rowCls) rowCls = e.rowCls;
            if (e.rowStyle) rowStyle = e.rowStyle;
        }
        sb[sb.length] = '</table>';

        if (isReturn) return sb.join('');
    },
    doUpdate: function () {
        if (!this._allowUpdate) return;

        this._doUpdateHeader();

        var sss = new Date();

        var nodes = this._getViewChildNodes(this.root);
        var sb = [];
        this._createNodes(nodes, this.root, sb);
        var s = sb.join('');

        this._bodyEl.innerHTML = s;
        this._deferLayout();
    },
    getScrollLeft: function () {
        return this._bodyEl.scrollLeft;
    },
    doLayout: function () {
        var autoHeight = this.isAutoHeight();
        var autoWidth = this.isAutoWidth();

        var width = this.getWidth(true);
        var height = this.getHeight(true);
        var headerHeight = this.getHeaderHeight();
        var bodyHeight = height - headerHeight;

        this._bodyEl.style.width = width + 'px';
        if (autoHeight) {
            this._bodyEl.style.height = 'auto';
        } else {
            this._bodyEl.style.height = bodyHeight + 'px';
        }

        this._doLayoutHeader();

        this._doLayoutTopRightCell();

        this.fire('layout');
    },
    _doLayoutTopRightCell: function () {
        var headerTable = this._headerInnerEl.firstChild;
        var width = headerTable.offsetWidth + 1;
        var height = headerTable.offsetHeight - 1;
        if (height < 0) height = 0;

        this._topRightCellEl.style.height = height + 'px';
    },
    _doLayoutHeader: function () {
        var bodyScrollHeight = this._bodyEl.scrollHeight;
        var bodyClientHeight = this._bodyEl.clientHeight;

        var elWidth = this.getWidth(true);

        var table1 = this._headerEl.firstChild.firstChild,
            table2 = this._bodyEl.firstChild;

        if (bodyClientHeight >= bodyScrollHeight) {
            if (table2) table2.style.width = '100%';
            if (table1) table1.style.width = '100%';
        } else {
            if (table2) {
                var w = parseInt(table2.parentNode.offsetWidth - 17) + 'px';
                table2.style.width = w;
            }

            if (table1) table1.style.width = w;
        }

        try {
            var w = this._headerEl.firstChild.firstChild.firstChild.offsetWidth;

            this._bodyEl.firstChild.style.width = w + 'px';
        } catch (e) {}

        this.__OnScroll();
    },
    getHeaderHeight: function () {
        return mini.getHeight(this._headerEl);
    },

    _OnDrawCell: function (record, column) {
        var showCheckBox = this.showCheckBox;
        if (showCheckBox && this.hasChildren(record)) {
            showCheckBox = this.showFolderCheckBox;
        }

        var value = mini._getMap(column.field, record);
        var e = {
            isLeaf: this.isLeaf(record),
            rowIndex: this.indexOf(record),
            showCheckBox: showCheckBox,
            iconCls: this.getNodeIcon(record),
            showTreeIcon: this.showTreeIcon,

            sender: this,
            record: record,
            row: record,
            node: record,
            column: column,
            field: column ? column.field : null,
            value: value,
            cellHtml: value,
            rowCls: null,
            cellCls: column ? column.cellCls || '' : '',
            rowStyle: null,
            cellStyle: column ? column.cellStyle || '' : ''
        };

        if (column.dateFormat) {
            if (mini.isDate(e.value)) e.cellHtml = mini.formatDate(value, column.dateFormat);
            else e.cellHtml = value;
        }

        var renderer = column.renderer;
        if (renderer) {
            fn = typeof renderer == 'function' ? renderer : window[renderer];
            if (fn) {
                e.cellHtml = fn.call(column, e);
            }
        }

        this.fire('drawcell', e);

        if (e.cellHtml === null || e.cellHtml === undefined || e.cellHtml === '') e.cellHtml = '&nbsp;';

        if (!this.treeColumn || this.treeColumn !== column.name) return e;

        this._doTreeColumn(e);
        return e;
    },
    _doTreeColumn: function (e) {
        var node = e.node;
        if (mini.isNull(e.showTreeIcon)) e.showTreeIcon = this.showTreeIcon;

        var cellHtml = e.cellHtml;

        var isLeaf = this.isLeaf(node);
        var left = this.getLevel(node) * 18;
        if (this.showExpandButtons == false) left -= 18;

        var cls = '';

        if (e.cellCls) {
            e.cellCls += ' mini-treegrid-treecolumn ';
        } else {
            e.cellCls = ' mini-treegrid-treecolumn ';
        }

        var s = '<div class="mini-treegrid-treecolumn-inner ' + cls + '">';

        if (!isLeaf) {
            var display = this.showExpandButtons ? '' : ';display:none';
            s +=
                '<a href="#" onclick="return false;"  hidefocus class="' +
                this.eciconCls +
                '" style="left:' +
                left +
                'px;' +
                display +
                '"></a>';
        }
        left += 18;

        if (e.showTreeIcon) {
            s += '<div class="' + e.iconCls + ' mini-treegrid-nodeicon" style="left:' + left + 'px;"></div>';
            left += 18;
        }

        cellHtml = '<span class="mini-tree-nodetext">' + cellHtml + '</span>';

        if (e.showCheckBox) {
            var ckid = this._createCheckNodeId(node);
            var checked = this.isCheckedNode(node);
            cellHtml =
                '<input type="checkbox" id="' +
                ckid +
                '" class="' +
                this._checkBoxCls +
                '" hidefocus ' +
                (checked ? 'checked' : '') +
                '/>' +
                cellHtml;
        }

        s += '<div class="mini-treegrid-nodeshow" style="margin-left:' + (left + 2) + 'px;">' + cellHtml + '</div>';
        s += '</div>';
        cellHtml = s;
        e.cellHtml = cellHtml;
    },

    setTreeColumn: function (value) {
        if (this.treeColumn != value) {
            this.treeColumn = value;
            this.doUpdate();
        }
    },
    getTreeColumn: function (node) {
        return this.treeColumn;
    },
    setAllowResizeColumn: function (value) {
        this.allowResizeColumn = value;
    },
    getAllowResizeColumn: function (node) {
        return this.allowResizeColumn;
    },
    setAllowMoveColumn: function (value) {
        this.allowMoveColumn = value;
    },
    getAllowMoveColumn: function (node) {
        return this.allowMoveColumn;
    },
    setAllowResize: function (value) {
        this.allowResize = value;

        this._resizeEl.style.display = this.allowResize ? '' : 'none';
    },
    getAllowResize: function () {
        return this.allowResize;
    },

    _createCellId: function (node, column) {
        return this.uid + '_' + node._id + '_' + column._id;
    },
    setColumnWidth: function (column, width) {
        column = this.getColumn(column);
        if (!column) return;
        if (mini.isNumber(width)) width += 'px';
        column.width = width;

        this.doUpdate();
    },
    getColumnWidth: function (column) {
        var box = this.getColumnBox(column);
        return box ? box.width : 0;
    },

    __OnScroll: function (e) {
        var scrollLeft = this._bodyEl.scrollLeft;
        this._headerEl.firstChild.scrollLeft = scrollLeft;
    },

    getAttrs: function (el) {
        var attrs = mini.TreeGrid.superclass.getAttrs.call(this, el);

        mini._ParseString(el, attrs, ['treeColumn', 'ondrawcell']);

        mini._ParseBool(el, attrs, ['allowResizeColumn', 'allowMoveColumn', 'allowResize']);

        var cs = mini.getChildNodes(el);
        for (var i = 0, l = cs.length; i < l; i++) {
            var node = cs[i];
            var property = jQuery(node).attr('property');
            if (!property) continue;
            property = property.toLowerCase();
            if (property == 'columns') {
                attrs.columns = mini._ParseColumns(node);
            }
        }

        delete attrs.data;

        return attrs;
    }
});

mini.copyTo(mini.TreeGrid.prototype, mini_Column_Prototype);
mini.copyTo(mini.TreeGrid.prototype, mini_CellValidator_Prototype);

mini.regClass(mini.TreeGrid, 'treegrid');
mini.SuperGrid = mini.Control.extend({
    type: 'supergrid',
    tag: 'mini-supergrid',

    props: {
        width: 300,
        height: 150,

        data: null,
        editOnDblClick: false,
        cellEditClicks: 1,

        multiSelect: false,
        allowRowSelect: true,
        allowCellSelect: true,
        allowAlternating: true,
        allowResizeColumn: true,
        allowMoveColumn: true,
        allowSortColumn: true,
        allowDragDrop: false,
        showDirty: true,
        allowUnselect: false,

        scrollLeft: 0,
        scrollTop: 0,
        scrollWidth: 0,
        scrollHeight: 0,
        headerHeight: 25,
        showHScroll: true,
        showVScroll: true,

        columnWidth: 100,
        rowHeight: 22,
        columnMinWidth: 10,
        columnMaxWidth: 800,

        scrollUnit: 'px',

        url: '',
        idField: 'id',
        autoLoad: false,

        enterEditAction: 'nextrowcell'
    },

    updateUrl: function (value) {
        if (value) this.store.setUrl(value);
    },
    updateIdField: function (value) {
        this.store.setIdField(value);
    },
    updateAutoLoad: function (value) {
        this.store.setAutoLoad(value);
    },

    _rowIdField: '_id',
    rowCls: 'mini-supergrid-row',
    cellCls: 'mini-supergrid-cell',
    rowSelectedCls: 'mini-supergrid-rowselected',
    cellSelectedCls: 'mini-supergrid-cellselected',
    alternatingCls: 'mini-supergrid-alternating',

    initComponent: function () {
        this.callParent('initComponent');

        this.setColumns(this.columns || []);

        delete this.data;
        this.setData([]);
    },

    scrollIntoView: function (record) {
        var index = this.store.indexOf(record);
        var top = this.getRowsOffset(0, index);
        this.setScrollTop(top);
    },

    scrollIntoCell: function (record, column) {
        var region = this.viewRegion;
        if (!region) return;

        if (record) {
            var rowIndex = this.store.indexOf(record);

            if (rowIndex != -1) {
                var top = this.getRowsOffset(0, rowIndex - 1);
                var bottom = top + this.getRowHeight(rowIndex);

                var scrollChanged = false;

                if (top < region.topOffset) {
                    this.setScrollTop(top);
                    scrollChanged = true;
                } else if (bottom > region.topOffset + region.viewHeight) {
                    this.setScrollTop(bottom - region.viewHeight);
                    scrollChanged = true;
                } else {
                }

                if (scrollChanged) {
                    this.fire('scroll', {
                        direction: 'vertical'
                    });
                }
            }
        }

        if (column) {
            var columnIndex = this.columns.indexOf(column);

            if (this.frozenStartColumn <= columnIndex && columnIndex <= this.frozenEndColumn) {
            } else {
                var left = this.getColumnsOffset(0, columnIndex - 1);
                if (this.isFrozen()) {
                    left -= this.getColumnsWidth(0, this.frozenEndColumn);
                }

                var right = left + column.width;

                if (left < region.leftOffset) {
                    this.setScrollLeft(left);
                } else if (right > region.leftOffset + region.viewWidth) {
                    this.setScrollLeft(right - region.viewWidth);
                } else {
                }
            }
        }
    },

    getBodyEl: function () {
        return this._viewportEl;
    },

    getHeaderEl: function () {
        return this._headerEl;
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-supergrid';

        var s =
            '<div class="mini-supergrid-border">' +
            '<div class="mini-supergrid-header"></div>' +
            '<div class="mini-supergrid-viewport">' +
            '<div class="mini-supergrid-cells"></div>' +
            '<div class="mini-supergrid-lockedcells"></div>' +
            '<div class="mini-supergrid-tooltip"></div>' +
            '</div>' +
            '<div class="mini-supergrid-hscroller" tabindex="-1"><div class="mini-supergrid-hscrollercontent"></div></div>' +
            '<div class="mini-supergrid-vscroller" tabindex="-1"><div class="mini-supergrid-vscrollercontent"></div></div>' +
            '</div>';
        this.el.innerHTML = s;

        this.el.tabIndex = 0;

        this._borderEl = this.el.firstChild;

        this._headerEl = this._borderEl.firstChild;

        this._viewportEl = this._borderEl.childNodes[1];
        this.cellsEl = this._viewportEl.childNodes[0];
        this.lockedcellsEl = this._viewportEl.childNodes[1];

        this.tooltipEl = this._viewportEl.childNodes[2];
        this.tooltipEl.style.display = 'none';
        var sf = this;

        this.hscrollerEl = this._borderEl.childNodes[2];
        this.vscrollerEl = this._borderEl.childNodes[3];
        this.hscrollerContentEl = this.hscrollerEl.firstChild;
        this.vscrollerContentEl = this.vscrollerEl.firstChild;

        this._Select = new mini._SuperGridSelect(this);
        this._Splitter = new mini._SuperGridSplitter(this);
        this._ColumnDragger = new mini._SuperGridColumnMove(this);
        this._Sort = new mini._SuperGridSort(this);
        this._DragDrop = new mini._GridDragDrop(this);

        if (mini.isTouch) {
            jQuery(this.el).addClass('touch');

            var me = this;
            var sf = this;
            var bodyEl = this._viewportEl;
            var bind = function (el, type, fn) {
                el.addEventListener(type, fn);
            };

            bodyEl.style['pointer-events'] = 'none';

            bind(this.el, 'tap', function (event) {
                alert(1);
            });

            var startEvent;
            var startScrollLeft, startScrollTop;
            var isPreventDefault;

            bind(this.el, 'touchstart', function (event) {
                startEvent = event;

                startScrollLeft = me.hscrollerEl.scrollLeft;
                startScrollTop = me.vscrollerEl.scrollTop;
            });
            bind(this.el, 'touchmove', function (event) {
                if (event.touches.length != 1) return;

                var delta = event.touches[0].pageY - startEvent.touches[0].pageY;

                var deltaX = event.touches[0].pageX - startEvent.touches[0].pageX;

                isPreventDefault = false;

                if (delta != 0) {
                    var el = me.vscrollerEl;
                    var scrollTop = el.scrollTop;

                    el.scrollTop = startScrollTop - delta;
                    if (scrollTop != el.scrollTop) {
                        isPreventDefault = true;

                        sf.refreshScrollComplete = false;
                        sf.setScrollTop(sf.vscrollerEl.scrollTop, true);
                        sf.fire('scroll', {
                            direction: 'vertical'
                        });
                    }
                }

                if (deltaX != 0) {
                    var el = me.hscrollerEl;
                    var scrollLeft = el.scrollLeft;

                    el.scrollLeft = startScrollLeft - deltaX;
                    if (scrollLeft != el.scrollLeft) {
                        isPreventDefault = true;
                    }
                }

                if (isPreventDefault) {
                    event.preventDefault();
                }
            });

            bind(this.el, 'touchend', function (event) {
                bodyEl.style['pointer-events'] = '';
                setTimeout(
                    function () {
                        bodyEl.style['pointer-events'] = 'none';
                    },
                    isPreventDefault ? 1 : 300
                );
                isPreventDefault = false;
            });
        }
    },

    _enableScroll: function () {
        if (this._scrollDisabled !== false) {
            this._scrollDisabled = false;
            var me = this;
            if (!this._bindScrollTimeout) {
                this._bindScrollTimeout = setTimeout(function () {
                    me._bindScrollTimeout = null;
                    mini.on(me.hscrollerEl, 'scroll', me.__onHScroll, me);
                    mini.on(me.vscrollerEl, 'scroll', me.__onVScroll, me);
                }, 1);
            }
        }
    },

    _disableScroll: function () {
        this._scrollDisabled = true;
        mini.un(this.hscrollerEl, 'scroll', this.__onHScroll, this);
        mini.un(this.vscrollerEl, 'scroll', this.__onVScroll, this);
        if (this._bindScrollTimeout) {
            clearTimeout(this._bindScrollTimeout);
            this._bindScrollTimeout = null;
        }
    },

    _initEvents: function () {
        mini.on(this.el, 'click', this.__OnClick, this);
        mini.on(this.el, 'dblclick', this.__OnDblClick, this);
        mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
        mini.on(this.el, 'mouseup', this.__OnMouseUp, this);
        mini.on(this.el, 'contextmenu', this.__OnContextMenu, this);
        mini.on(this.el, 'keydown', this.__OnKeyDown, this);

        mini.on(this.el, 'mousewheel', this.__OnMousewheel, this);

        mini.on(this.hscrollerEl, 'scroll', this.__onHScroll, this);
        mini.on(this.vscrollerEl, 'scroll', this.__onVScroll, this);

        if (mini.isFirefox) {
            var sf = this;

            function onmouseup() {
                jQuery(document).unbind('mouseup', onmouseup);

                sf.refreshScrollComplete = false;
                sf.scrollTop = -1;
                sf.setScrollTop(sf.vscrollerEl.scrollTop);

                sf.fire('scroll', {
                    direction: 'vertical'
                });
            }
            this.vscrollerEl.onmousedown = function (e) {
                sf.refreshScrollComplete = true;
                sf.tooltipEl.style.display = 'block';

                jQuery(document).bind('mouseup', onmouseup);
                sf.__onVScroll();
            };
        } else if (!mini.isOpera) {
            var sf = this;
            function onvscrollmousemove() {
                jQuery(document).unbind('mousemove', onvscrollmousemove);

                sf.refreshScrollComplete = false;

                sf.scrollTop = -1;
                sf.setScrollTop(sf.vscrollerEl.scrollTop);
                sf.fire('scroll', {
                    direction: 'vertical'
                });
            }
            this.vscrollerEl.onmousedown = function (e) {
                sf.refreshScrollComplete = true;
                sf.tooltipEl.style.display = 'block';

                jQuery(document).bind('mousemove', onvscrollmousemove);
                sf.__onVScroll();
            };
        }
    },

    isShowHScrollBar: function () {
        return this.hscrollerEl.firstChild.offsetHeight > this.hscrollerEl.clientHeight;
    },

    isShowVScrollBar: function () {
        return this.vscrollerEl.firstChild.offsetHeight > this.vscrollerEl.clientHeight;
    },

    getScrollbarSize: function () {
        return 18;
    },

    doLayout: function () {
        var h = this.getHeight(true);
        var w = this.getWidth(true);

        mini.setHeight(this._headerEl, this.headerHeight);

        var vh = this.getViewportHeight();
        mini.setHeight(this._viewportEl, vh);

        var viewportWidth = this.getViewportWidth();
        var viewportHeight = this.getViewportHeight();

        if (this.showHScroll) {
            this.hscrollerEl.style.bottom = 0;
        } else {
            this.hscrollerEl.style.bottom = '-2000px';
        }
        if (this.showVScroll) {
            this.vscrollerEl.style.right = 0;
        } else {
            this.vscrollerEl.style.right = '-2000px';
        }

        var hbarWidth = this._getHScrollBarWidth(),
            vbarHeight = this._getVScrolBarHeight();

        this.vscrollerEl.style.top = this.getHeaderHeight() + 'px';
        this.vscrollerEl.style.height = vbarHeight + 'px';
        this.hscrollerEl.style.width = hbarWidth + 'px';

        var scrollWidth = this._getScrollContentWidth();
        var scrollHeight = this._getScrollContentHeight();

        this.hscrollerContentEl.style.width = scrollWidth + 'px';
        this.vscrollerContentEl.style.height = scrollHeight + 'px';

        this.cellsEl.style.width = hbarWidth + 'px';
        this.cellsEl.style.height = vbarHeight + 'px';

        this.scrollLeft = this.hscrollerEl.scrollLeft;
        this.scrollTop = this.vscrollerEl.scrollTop;

        var aw = this.getAllFrozenColumnWidth();
        this.cellsEl.style.left = aw + 'px';
        this.lockedcellsEl.style.width = aw + 'px';
        this.lockedcellsEl.style.height = viewportHeight + 'px';

        var region = this.updateViewRegion();
        var last = this._lastViewRegion;
        if (last) {
            if (
                last.leftOffset != region.leftOffset ||
                last.topOffset != region.topOffset ||
                last.startColumn != region.startColumn ||
                last.endColumn < region.endColumn ||
                last.startRow != region.startRow ||
                last.endRow < region.endRow
            ) {
                this.invalidate();
            }
        }
    },

    setScrollLeft: function (value) {
        if (this.scrollLeft != value) {
            this._disableScroll();
            this.hscrollerEl.scrollLeft = value;
            this.scrollLeft = this.hscrollerEl.scrollLeft;
            this._enableScroll();
            this.invalidate();
        }
    },
    setScrollTop: function (value) {
        if (this.scrollTop != value) {
            this._disableScroll();
            this.vscrollerEl.scrollTop = value;
            this.scrollTop = this.vscrollerEl.scrollTop;
            this._enableScroll();
            this.invalidate();
        }
        this.tooltipEl.style.display = 'none';
    },
    getScrollTop: function () {
        return this.scrollTop;
    },
    getScrollLeft: function () {
        return this.scrollLeft;
    },

    setShowHScroll: function (value) {
        this.showHScroll = value;
        this.invalidateLayout();
    },
    setShowVScroll: function (value) {
        this.showVScroll = value;
        this.invalidateLayout();
    },

    setData: function (data) {
        if (this.store == data) return;
        if (typeof data == 'string') {
            data = mini.get(data);
        }
        if (!data) data = [];

        var store = this._getSource(data);

        store.sortMode = 'client';

        if (this.store) {
            this._unbindSource();
            this.store.destroy();
        }
        this.data = store;
        this.store = store;
        this._bindSource();

        this.fire('datachanged');

        this.__OnDataChanged();
    },

    getItems: function () {
        return this.store.getVisibleRows();
    },
    getVisibleRows: function () {
        return this.getItems();
    },

    getChildNodes: function (node) {
        return this.store.getChildNodes(node);
    },

    _getSource: function (data) {
        if (!mini.isArray(data)) return data;
        var store = new mini.Store();
        store.loadData(data);
        return store;
    },
    _bindSource: function () {
        this.store.on('datachanged', this.__OnDataChanged, this);
        this.store.on('SelectionChanged', this.__OnDataSelectionChanged, this);
        this.store.setMultiSelect(this.multiSelect);

        this.store.on('collapse', this.__OnTreeCollapse, this);
        this.store.on('expand', this.__OnTreeExpand, this);
    },
    _unbindSource: function () {
        this.store.un('datachanged', this.__OnDataChanged, this);
        this.store.un('SelectionChanged', this.__OnDataSelectionChanged, this);

        this.store.un('collapse', this.__OnTreeCollapse, this);
        this.store.un('expand', this.__OnTreeExpand, this);
    },

    __OnDataChanged: function (e) {
        if (this._commitEditing !== true) {
            this.cancelEdit();
        }

        this.invalidate();
    },
    __OnDataSelectionChanged: function (e) {
        var data = this.getItems();
        if (!this.viewRegion) return;

        var views = {};
        for (var i = this.viewRegion.startRow, l = this.viewRegion.endRow; i <= l; i++) {
            var record = data[i];
            if (!record) continue;
            views[record._id] = record;
        }

        var grid = this;
        var removes = [];

        var dataSource = this.store;
        var rows = e.records;
        for (var i = 0, l = rows.length; i < l; i++) {
            var record = rows[i];
            if (!views[record._id]) {
                continue;
            }

            if (e.select) {
                this.addRowCls(record, this.rowSelectedCls);
            } else {
                this.removeRowCls(record, this.rowSelectedCls);
            }
        }

        this.fire('selectionchanged', e);
        this.fire('selectionchange', e);
        var e = {
            sender: this,
            selecteds: this.getSelecteds(),
            selected: this.getSelected()
        };
        var bottomColumns = this.columns;
        for (var i = 0, l = bottomColumns.length; i < l; i++) {
            var column = bottomColumns[i];
            if (column.onselectionchanged) {
                column.onselectionchanged.call(this, e);
            }
        }
    },

    _createHeaderCell: function (col) {
        var s = col.header;
        if (typeof s == 'function') s = s.call(this, col);
        if (mini.isNull(s)) {
            s = '&nbsp;';
        }
        return s;
    },

    getLeftColumn: function () {
        return this.viewRegion.startColumn;
    },

    getTopRow: function () {
        return this.viewRegion.startRow;
    },

    invalidate: function () {
        if (this.store) this.updateViewRegion();
        this.callParent('invalidate');
    },

    refresh: function () {
        this._lastViewRegion = this.updateViewRegion();

        this.refreshHeader();
        this.refreshBody();
    },

    refreshHeader: function () {
        var sb = [];
        var columns = this.viewColumns;
        var left = 0;

        var region = this.updateViewRegion();
        var startRow = region.startRow,
            endRow = region.endRow,
            startColumn = region.startColumn,
            endColumn = region.endColumn;

        var grid = this;

        var leftOffset = region.xOffset - region.leftOffset;

        function drawColumn(column, index, isFrozen) {
            var html = this._createHeaderCell(column);

            var e = {
                column: column,
                index: index,
                cls: column.headerCls || '',
                style: column.headerStyle || '',
                html: html,
                align: column.headerAlign || 'left'
            };
            grid.fire('drawheadercell', e);

            var width = column.width;
            sb[sb.length] = '<div id="';
            sb[sb.length] = column._id;
            sb[sb.length] = '" class="mini-supergrid-headercell ';
            if (e.cls) sb[sb.length] = e.cls + ' ';

            if (index <= this.frozenEndColumn) {
                sb[sb.length] = 'mini-supergrid-frozencell ';
            }

            if (index == this.frozenEndColumn) {
                sb[sb.length] = 'mini-supergrid-frozencell-last ';
            }

            sb[sb.length] = '" style="left:';
            sb[sb.length] = left + (isFrozen ? 0 : leftOffset);
            sb[sb.length] = 'px;width:';
            sb[sb.length] = width;
            sb[sb.length] = 'px;height:';
            sb[sb.length] = this.headerHeight;
            sb[sb.length] = 'px;';

            if (e.align) {
                sb[sb.length] = 'text-align:';
                sb[sb.length] = e.align;
                sb[sb.length] = ';';
            }
            if (e.style) sb[sb.length] = e.style;

            sb[sb.length] =
                '"><div class="mini-supergrid-headercell-inner" style="line-height:' +
                this.headerHeight +
                'px;height:' +
                this.headerHeight +
                'px;">';
            sb[sb.length] = e.html;
            sb[sb.length] = '</div></div>';

            left += width;

            if (this.allowResizeColumn && column.allowResize) {
                sb[sb.length] = '<div cid="';
                sb[sb.length] = column._id;
                sb[sb.length] = '" class="mini-supergrid-splitter" style="left:';
                sb[sb.length] = left + (isFrozen ? 0 : leftOffset) - 3;
                sb[sb.length] = 'px;height:';
                sb[sb.length] = this.headerHeight;
                sb[sb.length] = 'px;top:0px;"></div>';
            }
        }

        if (this.isFrozen()) {
            for (var i = this.frozenStartColumn, l = this.frozenEndColumn; i <= l; i++) {
                var column = columns[i];
                if (column) {
                    drawColumn.call(this, column, i, true);
                }
            }
        }
        var append = false;
        for (var i = startColumn, l = endColumn; i <= l; i++) {
            var column = columns[i];
            if (column) {
                append = true;
                drawColumn.call(this, column, i);
            }
        }

        if (append) {
            sb[sb.length] =
                '<div class="mini-supergrid-headercell" style="display:none;left:' +
                left +
                'px;width:500px;height:' +
                this.headerHeight +
                'px;"></div>';
        }
        this._headerEl.innerHTML = sb.join('');
    },

    refreshBody: function (must) {
        var columnWidth = this.columnWidth;
        var data = this.getItems();
        var columns = this.viewColumns;
        var dataSource = this.store;
        var store = dataSource;
        var isGrouped = store.isGrouped();

        var region = this.updateViewRegion();
        this.viewRegion = region;

        var startRow = region.startRow,
            endRow = region.endRow,
            startColumn = region.startColumn,
            endColumn = region.endColumn;

        var currentRecord = this.currentCell ? this.currentCell.record : null;
        var currentColumn = this.currentCell ? this.currentCell.column : null;

        var treeColumn = this.getColumn(this.treeColumn);
        var treeColumnIndex = this.columns.indexOf(treeColumn);
        this.treeColumnIndex = treeColumnIndex;

        function drawRows(startColumn, endColumn, isFrozen) {
            var sb = [];
            var top = 0;

            var topOffset = region.yOffset - region.topOffset;

            var leftOffset = region.xOffset - region.leftOffset;
            if (isFrozen) leftOffset = 0;

            // 没有列信息时，不用渲染行
            if (endColumn < 0) return sb;
            for (var i = startRow, l = endRow; i <= l; i++) {
                var record = data[i];
                if (!record) continue;

                var h = this.getRowHeight(record);

                var rowClsIndex = -1;
                var rowCls = ' ';
                var rowStyleIndex = -1;
                var rowStyle = ' ';

                var cls = 'mini-supergrid-row';
                if (this.allowAlternating && i % 2 == 1) {
                    cls += ' ' + this.alternatingCls;
                }

                var isSelected = dataSource.isSelected(record);
                if (isSelected) cls += ' ' + this.rowSelectedCls;

                sb[sb.length] = '<div id="';
                sb[sb.length] = this._createRowId(record, isFrozen);
                sb[sb.length] = '" data-identifier-no="';
                sb[sb.length] = record.identifierNo;

                sb[sb.length] = '" class="';
                sb[sb.length] = cls;
                sb[sb.length] = ' ';

                rowClsIndex = sb.length;
                sb[rowClsIndex] = rowCls;

                sb[sb.length] = '" style="top:';
                sb[sb.length] = top + topOffset;
                sb[sb.length] = 'px;height:';
                sb[sb.length] = h;
                sb[sb.length] = 'px;';

                rowStyleIndex = sb.length;
                sb[rowStyleIndex] = rowStyle;

                sb[sb.length] = '">';

                // 保存取消按钮渲染
                // let cellIsModified = false;
                // let allFields = [];
                // for (let j = 3, k = columns.length - 1; j <= k; j++) {
                //     let column = columns[j];
                //     if (!column) continue;
                //     allFields.push(column.field);
                // }
                // cellIsModified = dataSource.cellIsModified(record, allFields);

                var left = 0;
                for (var j = startColumn, k = endColumn; j <= k; j++) {
                    var column = columns[j];
                    if (!column) continue;
                    var w = column.width;

                    // 保存取消按钮渲染
                    // if (j === 2 && cellIsModified) {
                    //     let nextCol = columns[j + 1];
                    //     let nextWidth = nextCol.width;
                    //     w = w + nextWidth;

                    //     sb[sb.length] = `
                    //         <div class="mini-supergrid-rowbtns mini-supergrid-cell" style="left: ${
                    //             left + leftOffset
                    //         }px; width: ${w}px;">
                    //             <span data-name="save" uid="${record.UID}">保存</span>
                    //             <span data-name="cancel" uid="${record.UID}">取消</span>
                    //         </div>
                    //     `;

                    //     left += w;
                    //     continue;
                    // }
                    // if (startColumn < 3 && j === 3 && cellIsModified) {
                    //     w = 0;
                    // }

                    var e = this._OnDrawCell(record, column, i, j);

                    if (isGrouped) {
                        if (store.isGroupItem(e.record) && e.columnIndex >= treeColumnIndex) {
                            var groupLevel = store.getGroupLevel(e.record);
                            var color = e.record.field.color || mini.Group.getColor(groupLevel + 4);
                            e.cellStyle = 'background:' + color + ';' + e.cellStyle;

                            var style = e.record.field.style;
                            if (style) {
                                e.cellStyle = style + ';' + e.cellStyle;
                            }
                        }

                        if (column.name && column.name == this.treeColumn) this.onDrawGroupHeaderCell(e);
                    }

                    sb[sb.length] = '<div  id="';
                    sb[sb.length] = this._createCellId(record, column);
                    sb[sb.length] = '" class="mini-supergrid-cell ';

                    if (j <= this.frozenEndColumn) {
                        sb[sb.length] = 'mini-supergrid-frozencell ';
                    }

                    if (isFrozen && j == this.frozenEndColumn) {
                        sb[sb.length] = 'mini-supergrid-frozencell-last ';
                    }

                    var dirty = this.showDirty ? dataSource.isModified(record, column.field) : false;
                    if (dirty) {
                        sb[sb.length] = 'mini-supergrid-cell-dirty ';
                    }

                    if (currentRecord == record && currentColumn == column) {
                        sb[sb.length] = this.cellSelectedCls + ' ';
                    }
                    if (e.cellCls) sb[sb.length] = e.cellCls;
                    sb[sb.length] = '" style="';

                    if (e.cellStyle) sb[sb.length] = e.cellStyle;

                    sb[sb.length] = ';left:';
                    sb[sb.length] = left + leftOffset;
                    sb[sb.length] = 'px;width:';
                    sb[sb.length] = w;
                    sb[sb.length] = 'px;height:';
                    sb[sb.length] = h;
                    sb[sb.length] = 'px;line-height:';
                    sb[sb.length] = h - 1;
                    sb[sb.length] = 'px;';

                    if (column.align) {
                        sb[sb.length] = 'text-align:';
                        sb[sb.length] = column.align || 'left';
                        sb[sb.length] = ';';
                    }

                    sb[sb.length] = '"><div class="mini-supergrid-cell-inner" >';

                    sb[sb.length] = e.cellHtml;

                    if (dataSource.isModified(record, column.field) && this.showDirty) {
                        sb[sb.length] = '</div><div class="mini-supergrid-cell-dirtytip"></div></div>';
                    } else {
                        sb[sb.length] = '</div></div>';
                    }

                    left += w;

                    if (e.rowCls !== null) {
                        rowCls = e.rowCls;
                    }
                    if (e.rowStyle !== null) {
                        rowStyle = e.rowStyle;
                    }
                }

                if (record._cls) rowCls += ' ' + record._cls;
                sb[rowClsIndex] = rowCls;
                sb[rowStyleIndex] = rowStyle;

                sb[sb.length] = '</div>';

                top += h;
            }
            return sb;
        }

        var x = this.scrollLeft,
            y = this.scrollTop;

        var sb = drawRows.call(this, startColumn, endColumn);
        this.cellsEl.innerHTML = sb.join('');

        var sb = drawRows.call(this, this.frozenStartColumn, this.frozenEndColumn, true);
        this.lockedcellsEl.innerHTML = sb.join('');

        var oldEl = this.cellsEl;
    },
    getHeaderHeight: function () {
        return mini.getHeight(this._headerEl);
    },

    getViewportHeight: function () {
        var h = this.getHeight(true) - this.getHeaderHeight();
        return h >= 0 ? h : 0;
    },
    getViewportWidth: function () {
        var v = this.getWidth(true);
        return v >= 0 ? v : 0;
    },
    getViewportBox: function () {
        return mini.getBox(this._viewportEl);
    },
    _getHScrollBarWidth: function () {
        var viewportWidth = this.getViewportWidth();
        var vwidth = viewportWidth;
        if (this.showVScroll) vwidth -= this.getScrollbarSize();
        if (vwidth < 0) vwidth = 0;
        return vwidth;
    },
    _getVScrolBarHeight: function () {
        var viewportHeight = this.getViewportHeight();
        var vheight = viewportHeight;
        if (this.showHScroll) vheight -= this.getScrollbarSize();
        if (vheight < 0) vheight = 0;
        return vheight;
    },

    getViewRegion: function () {
        if (!this.viewRegion) this.updateViewRegion();
        return this.viewRegion;
    },

    updateViewRegion: function () {
        this.viewRegion = this.createViewRegion();
        return this.viewRegion;
    },

    createViewRegion: function () {
        var x = this.getScrollLeft(),
            y = this.getScrollTop();

        var viewportWidth = this.getViewportWidth();
        var viewportHeight = this.getViewportHeight();

        var width = viewportWidth - this.getAllFrozenColumnWidth(),
            height = viewportHeight;

        if (this.isShowHScrollBar()) {
            width -= this.getScrollbarSize();
        }

        if (this.isShowVScrollBar()) {
            height -= this.getScrollbarSize();
        }

        var bottom = y + height,
            right = x + width;

        var columnWidth = this.columnWidth;
        var data = this.getItems();
        var columns = this.viewColumns;

        var startRow = 0,
            endRow = 0,
            startColumn = 0,
            endColumn = 0;

        var top = 0;
        var yOffset = 0;
        for (var i = 0, l = data.length; i < l; i++) {
            var r = data[i];
            var h = this.getRowHeight(r);
            top += h;
            if (top >= y) {
                startRow = i;
                yOffset = top - h;
                top = yOffset;

                break;
            }
        }

        for (var i = startRow, l = data.length; i < l; i++) {
            var r = data[i];
            var h = this.getRowHeight(r);
            if (top > bottom) {
                endRow = i;
                break;
            }
            top += h;
        }

        if (endRow == 0 || endRow > data.length - 1) endRow = data.length - 1;

        var xOffset = 0;

        var left = 0;
        var _start = 0;
        if (this.isFrozen()) _start = this.frozenEndColumn + 1;
        for (var i = _start, l = columns.length; i < l; i++) {
            var column = columns[i];
            var w = column.width;
            left += w;
            if (left > x) {
                startColumn = i;
                xOffset = left - w;
                left -= w;
                break;
            }
        }

        for (var i = startColumn, l = columns.length; i < l; i++) {
            var column = columns[i];
            var w = column.width;
            left += w;
            if (left >= right) {
                endColumn = i;
                break;
            }
        }

        if (endColumn == 0) endColumn = columns.length - 1;

        var region = {
            startRow: startRow,
            endRow: endRow,
            startColumn: startColumn,
            endColumn: endColumn,

            viewWidth: width,
            viewHeight: height,

            xOffset: xOffset,
            yOffset: yOffset,

            topOffset: y,
            leftOffset: x
        };

        return region;
    },
    getRecord: function (id) {
        if (typeof id == 'object') return id;
        if (mini.isNumber(id)) {
            return this.store.getAt(id);
        }
        return this.store.getByInternalId(id);
    },
    getRowHeight: function (row) {
        if (mini.isNumber(row)) row = this.store.getAt(row);

        if (mini.isNumber(row._height)) return row._height;
        if (this.store.isGroupItem(row)) return this.groupItemHeight || this.rowHeight;
        return this.rowHeight;
    },
    getRowBox: function (rowIndex) {
        var data = this.getItems();
        if (!mini.isNumber(rowIndex)) rowIndex = data.indexOf(rowIndex);

        var columnWidth = this.columnWidth;

        var columns = this.viewColumns;

        var top = 0,
            height = 0;
        for (var i = 0, l = rowIndex; i <= l; i++) {
            var r = data[i];

            var h = this.getRowHeight(r);
            top += h;
            if (i == l) {
                top -= h;
                height = h;
            }
        }
        top -= this.viewRegion.yOffset;

        var topOffset = this.viewRegion.yOffset - this.viewRegion.topOffset;
        top += topOffset;

        var box = this.getViewportBox();
        box.height = height;
        box.y += top;
        box.bottom = box.y + box.height;
        return box;
    },
    getColumnBox: function (columnIndex) {
        if (!mini.isNumber(columnIndex)) columnIndex = this.viewColumns.indexOf(columnIndex);

        var columnWidth = this.columnWidth;

        var columns = this.viewColumns;

        var left = 0,
            width = 0;
        var left = 0;
        for (var i = 0, l = columnIndex; i <= l; i++) {
            var column = columns[i];
            var w = column.width;
            left += w;
            if (i == l) {
                left -= w;
                width = w;
            }
        }

        left -= this.viewRegion.leftOffset;

        if (this.isFrozen()) {
            if (this.frozenStartColumn <= columnIndex && columnIndex <= this.frozenEndColumn) {
                var left = 0,
                    width = 0;
                var left = 0;
                for (var i = this.frozenStartColumn, l = columnIndex; i <= l; i++) {
                    var column = columns[i];
                    var w = column.width;
                    left += w;
                    if (i == l) {
                        left -= w;
                        width = w;
                    }
                }
            } else if (columnIndex > this.frozenEndColumn) {
                var w = this.getColumnsWidth(0, this.frozenStartColumn - 1);
                left -= w;
            }
        }

        var box = mini.getBox(this.el);
        box.width = width;
        box.x += left;
        box.right = box.x + box.width;

        box.height = this.getHeaderHeight();
        box.bottom = box.y + box.height;

        return box;
    },
    getCellBox: function (record, column) {
        var rowBox = this.getRowBox(record);
        var columnBox = this.getColumnBox(column);
        var box = {
            x: columnBox.x,
            y: rowBox.y,
            width: columnBox.width,
            height: rowBox.height
        };
        box.right = box.x + box.width;
        box.bottom = box.y + box.height;
        return box;
    },

    setTopRow: function (value) {
        var top = this.getRowsOffset(0, value - 1);
        this.setScrollTop(top);
    },

    setLeftColumn: function (value) {
        if (this.frozenStartColumn <= value && value <= this.frozenEndColumn) {
            return;
        }

        var left = this.getColumnsWidth(0, value - 1);

        if (this.isFrozen()) {
            left -= this.getColumnsWidth(0, this.frozenEndColumn);
        }

        this.setScrollLeft(left);
    },

    _frozenCellCls: 'mini-supergrid-frozenCell',
    frozenStartColumn: -1,
    frozenEndColumn: -1,
    isFrozen: function () {
        return this.frozenStartColumn >= 0 && this.frozenEndColumn >= this.frozenStartColumn;
    },
    frozenColumn: function (startColumn, endColumn) {
        if (typeof startColumn == 'object') startColumn = this.viewColumns.indexOf(startColumn);
        if (typeof endColumn == 'object') endColumn = this.viewColumns.indexOf(endColumn);
        if (
            !mini.isNumber(startColumn) ||
            !mini.isNumber(endColumn) ||
            startColumn == -1 ||
            endColumn == -1 ||
            endColumn == this.columns.length - 1
        )
            return;
        if (startColumn > endColumn) {
            var t = startColumn;
            startColumn = endColumn;
            endColumn = t;
        }
        this.frozenStartColumn = startColumn;
        this.frozenEndColumn = endColumn;
        this.setColumns(this.columns);

        this.setScrollLeft(0);
    },

    unfrozenColumn: function () {
        var leftColumn = this.frozenStartColumn;
        this.frozenStartColumn = this.frozenEndColumn = -1;
        this.setColumns(this.columns);
        this.setLeftColumn(leftColumn - 1);
    },

    getAllFrozenColumnWidth: function () {
        var w = 0;
        var columns = this.getViewColumns();
        for (var i = this.frozenStartColumn; i <= this.frozenEndColumn; i++) {
            var c = columns[i];
            if (c) {
                w += c.width;
            }
        }
        return w;
    },
    getColumnsWidth: function (start, end) {
        return this.getColumnsOffset(start, end);
    },
    _getScrollContentHeight: function () {
        return this.getRowsOffset(0, this.getItems().length);
    },
    _getScrollContentWidth: function () {
        var scrollWidth = this.getColumnsOffset(0, this.columns.length);
        if (this.isFrozen()) {
            var cw = this.getColumnsWidth(0, this.frozenStartColumn - 1);
            scrollWidth -= cw;
        }
        return scrollWidth;
    },
    getColumnsOffset: function (start, end) {
        var w = 0;
        var columns = this.getViewColumns();
        for (var i = start; i <= end; i++) {
            var c = columns[i];
            if (c && c.visible !== false) {
                w += c.width;
            }
        }
        return w;
    },
    getRowsOffset: function (start, end) {
        var store = this.store;
        var h = 0;
        for (var i = start; i <= end; i++) {
            var item = store.getAt(i);
            if (item && item.visible !== false) {
                h += this.getRowHeight(item);
            }
        }
        return h;
    },

    _vscrollTimer: null,
    _hscrollTimer: null,
    __onVScroll: function (e) {
        this.scrollTop = this.vscrollerEl.scrollTop;

        var sf = this;
        if (!this.tooltipShowTimer) {
            this.tooltipShowTimer = setTimeout(function () {
                var region = sf.updateViewRegion();
                if (sf.refreshScrollComplete) {
                    sf.tooltipEl.innerHTML = '行号：' + (region.startRow + 1);
                    sf.tooltipShowTimer = null;
                } else {
                    sf.scrollTop = sf.vscrollerEl.scrollTop;
                    sf.invalidate();
                }
            }, 30);
        }
    },

    _updateContent: function () {
        var me = this;

        me.scrollLeft = me.hscrollerEl.scrollLeft;
        me.scrollTop = me.vscrollerEl.scrollTop;

        me._refreshViewport();
    },

    __onHScroll: function (e) {
        var sf = this;
        if (this._hscrollTimer) return;
        this._hscrollTimer = setTimeout(function () {
            sf._hscrollTimer = null;
            sf.scrollLeft = sf.hscrollerEl.scrollLeft;

            sf.invalidate();

            sf.fire('scroll', {
                direction: 'horizontal'
            });
        }, 25);
    },
    __OnMousewheel: function (e, delta) {
        var oe = e;
        var e = e.wheelDelta ? e : e.originalEvent;

        var wheelDelta = e.wheelDelta || -e.detail * 24;
        var top = this.scrollTop;

        this.endEdit();

        top -= wheelDelta;
        this.setScrollTop(top);

        this.fire('scroll', {
            direction: 'vertical'
        });

        if (top == this.vscrollerEl.scrollTop) {
            oe.preventDefault();
        } else {
        }
    },

    setHeaderHeight: function (value) {
        this.headerHeight = value;
        mini.setHeight(this._headerEl, value);
        this.refreshHeader();
        this.invalidateLayout();
    },

    __OnClick: function (e) {
        this._fireChildEvent(e, 'Click');
    },
    __OnDblClick: function (e) {
        this._fireChildEvent(e, 'Dblclick');
    },
    __OnMouseDown: function (e) {
        this._fireChildEvent(e, 'MouseDown');
    },
    __OnMouseUp: function (e) {
        this._fireChildEvent(e, 'MouseUp');
    },
    __OnContextMenu: function (e) {
        this._fireChildEvent(e, 'ContextMenu');
    },
    __OnKeyDown: function (e) {
        this._fireChildEvent(e, 'KeyDown');
    },

    getAttrs: function (el) {
        var attrs = mini.SuperGrid.superclass.getAttrs.call(this, el);

        var cs = mini.getChildNodes(el);
        for (var i = 0, l = cs.length; i < l; i++) {
            var node = cs[i];
            var property = jQuery(node).attr('property');
            if (!property) continue;
            property = property.toLowerCase();
            if (property == 'columns') {
                attrs.columns = mini._ParseColumns(node);
            } else if (property == 'data') {
                attrs.data = node.innerHTML;
            }
        }

        return attrs;
    }
});

mini._SuperDataTableApplys = {
    load: function () {
        return this.store.load.apply(this.store, arguments);
    },

    clear: function () {
        this.store.clear();
    },
    loadData: function (data) {
        this.setData(data);
    },
    getCount: function () {
        return this.store.getCount();
    },
    getChanges: function () {
        return this.store.getChanges();
    },
    getData: function () {
        return this.store.getSource();
    },
    getList: function () {
        return this.store.getList();
    },

    updateRow: function (record, field, value) {
        this.store.updateRecord(record, field, value);
    },
    addRow: function (record) {
        return this.store.add(record);
    },
    insertRow: function (index, record) {
        return this.store.insert(index, record);
    },
    removeRow: function (record) {
        return this.store.remove(record);
    },
    removeRowAt: function (index) {
        return this.store.removeAt(index);
    },
    moveRow: function (row, index) {
        this.store.move(row, index);
    },
    indexOf: function (record) {
        return this.store.indexOf(record);
    },
    getAt: function (index) {
        return this.store.getAt(index);
    },
    findRows: function (field, value) {
        return this.findRecords(field, value);
    },
    findRecords: function (field, value) {
        return this.store.findRecords(field, value);
    },
    removeSelected: function (select) {
        var row = this.getSelected();
        var index = this.indexOf(row);
        this.removeRow(row);
        if (select !== false) {
            row = this.getAt(index);
            this.select(row ? index : index - 1);
        }
    },
    getSelected: function () {
        return this.store.getSelected();
    },
    getSelecteds: function () {
        return this.store.getSelecteds();
    },
    select: function (record) {
        this.store.select(record);
    },
    selects: function (records) {
        this.store.selects(records);
    },
    deselect: function (record) {
        this.store.deselect(record);
    },
    deselects: function (records) {
        this.store.deselects(records);
    },
    selectAll: function () {
        this.store.selectAll();
    },
    deselectAll: function () {
        this.store.deselectAll();
    },
    isSelected: function (record) {
        return this.store.isSelected(record);
    },

    filter: function (fn, scope) {
        this.store.filter(fn, scope);
    },
    clearFilter: function () {
        this.store.clearFilter();
    },
    sort: function (fn, scope) {
        this.store.sort(fn, scope);
    },
    clearSort: function () {
        this.store.clearSort();
    }
};

mini._SuperDataTreeApplys = {
    isLeaf: function (node) {
        return this.store.isLeaf(node);
    },
    getLevel: function (node) {
        return node ? this.store.getNodeLevel(node) : 0;
    },
    isExpanded: function (node) {
        return this.store.isExpandedNode(node);
    },
    getChildNodes: function (node) {
        return this.store.getChildNodes(node);
    },
    getParentNode: function (node) {
        return this.store.getParentNode(node);
    },
    isAncestor: function (pnode, node) {
        return this.store.isAncestor(pnode, node);
    },
    getAncestors: function (node) {
        return this.store.getAncestors(node);
    },
    getRootNode: function (node) {
        return this.store.getRootNode(node);
    },
    getAncestors: function (node) {
        return this.store.getAncestors(node);
    },
    hasChildNodes: function (node) {
        return this.store.hasChildNodes(node);
    },
    indexOfNode: function (node) {
        return this.store.indexOfNode(node);
    },
    updateNode: function (node, field, value) {
        this.store.updateRecord(node, field, value);
    },
    addNode: function (node, parentNode) {
        return this.store.addNode(node, parentNode);
    },
    insertNode: function (node, index, parentNode) {
        return this.store.insertNode(node, index, parentNode);
    },
    removeNodeAt: function (index, parentNode) {
        return this.store.removeNodeAt(index, parentNode);
    },
    removeNode: function (node) {
        return this.store.removeNode(node);
    },
    moveNode: function (node, action, targetNode) {
        this.store.moveNode(node, action, targetNode);
    },
    addNodes: function (nodes, parentNode) {
        return this.store.addNodes(nodes, parentNode);
    },
    insertNodes: function (nodes, index, parentNode) {
        return this.store.insertNodes(index, nodes, parentNode);
    },
    moveNodes: function (nodes, action, targetNode) {
        this.store.moveNodes(nodes, action, targetNode);
    },
    removeNodes: function (nodes) {
        return this.store.removeNodes(nodes);
    },
    findNodes: function (field, value) {
        return this.store.findRecords(field, value);
    },
    getChanges: function () {
        return this.store.getChanges();
    },
    getData: function () {
        return this.store.toTree();
    },
    bubbleParent: function (node, fn, scope) {
        this.store.bubbleParent(node, fn, scope);
    },
    cascadeChild: function (node, fn, scope) {
        this.store.cascadeChild(node, fn, scope);
    },
    eachChild: function (node, fn, scope) {
        this.store.eachChild(node, fn, scope);
    },
    collapseLevel: function (level, deep) {
        this.store.collapseLevel(level, deep);
    },
    expandLevel: function (level, deep) {
        this.store.expandLevel(level, deep);
    },
    collapse: function (node, deep) {
        this.store.collapse(node, deep);
    },
    expand: function (node, deep) {
        this.store.expand(node, deep);
    },
    toggle: function (node) {
        this.store.toggle(node);
    },
    collapseAll: function () {
        this.store.collapseAll();
    },
    expandAll: function () {
        this.store.expandAll();
    },
    filter: function (fn, scope) {
        this.store.filter(fn, scope);
    },
    clearFilter: function () {
        this.store.clearFilter();
    },
    sort: function (fn, scope) {
        this.store.sort(fn, scope);
    },
    clearSort: function () {
        this.store.clearSort();
    }
};

mini.copyTo(mini.SuperGrid.prototype, mini._SuperDataTableApplys);

mini.regClass(mini.SuperGrid, 'supergrid');

mini.GridColumnModel = {
    addColumn: function (column, index, targetColumn) {
        if (!column) return;
        targetColumn = this.getColumn(targetColumn);
        if (!targetColumn) {
            targetColumn = this;
            if (typeof action == 'string') action = 'append';
        }
        if (mini.isNull(index) || index < 0) index = 1000;

        switch (index) {
            case 'before':
                parentColumn = this.getParentColumn(targetColumn);
                index = parentColumn.columns.indexOf(targetColumn);
                parentColumn.columns.insert(index, column);
                break;
            case 'after':
                parentColumn = this.getParentColumn(targetColumn);
                index = parentColumn.columns.indexOf(targetColumn);
                parentColumn.columns.insert(index + 1, column);
                break;
            case 'append':
            case 'add':
                if (!targetColumn.columns) targetColumn.columns = [];
                targetColumn.columns.push(column);
                break;
            default:
                if (mini.isNumber(index)) {
                    if (!targetColumn.columns) targetColumn.columns = [];
                    targetColumn.columns.insert(index, column);
                }
                break;
        }
        this.setColumns(this.columns);
    },
    removeColumn: function (column) {
        column = this.getColumn(column);
        var pcolumn = this.getParentColumn(column);
        if (column && pcolumn) {
            pcolumn.columns.remove(column);
            this.setColumns(this.columns);
        }
        return column;
    },
    updateColumn: function (column, options) {
        column = this.getColumn(column);
        mini.copyTo(column, options);
        this.setColumns(this.columns);
    },
    moveColumn: function (column, targetColumn, action) {
        column = this.getColumn(column);
        targetColumn = this.getColumn(targetColumn);
        if (!column || !targetColumn || !action || column == targetColumn) return;

        if (this.isAncestorColumn(column, targetColumn)) {
            return;
        }

        var pcolumn = this.getParentColumn(column);
        if (pcolumn) {
            pcolumn.columns.remove(column);
        }

        var parentColumn = targetColumn;
        var index = action;
        if (index == 'before') {
            parentColumn = this.getParentColumn(targetColumn);
            index = parentColumn.columns.indexOf(targetColumn);
        } else if (index == 'after') {
            parentColumn = this.getParentColumn(targetColumn);
            index = parentColumn.columns.indexOf(targetColumn) + 1;
        } else if (index == 'add' || index == 'append') {
            if (!parentColumn.columns) parentColumn.columns = [];
            index = parentColumn.columns.length;
        } else if (!mini.isNumber(index)) {
            return;
        }

        parentColumn.columns.insert(index, column);

        this.setColumns(this.columns);
    },
    getColumn: function (name) {
        if (!name) return null;

        if (typeof name == 'object') return name;
        var column = this._nameColumns[name];
        if (!column) column = this._idColumns[name];

        if (!column) {
            column = this.getColumnByField(name);
        }

        return column;
    },

    getColumnByField: function (field) {
        if (!field) return null;
        function getColumn(field, columns) {
            for (var i = 0, l = columns.length; i < l; i++) {
                var column = columns[i];
                if (column.field == field) return column;
                if (column.columns) {
                    var child = getColumn(field, column.columns);
                    if (child) return child;
                }
            }
        }
        return getColumn(field, this.columns);
    },

    indexOfColumn: function (column) {
        var p = this.getParentColumn(column);
        return p.columns.indexOf(column);
    },
    getParentColumn: function (column) {
        column = this.getColumn(column);
        var pcolumn = column ? this._idColumns[column._pid] : null;
        if (column && !pcolumn) pcolumn = this;
        return pcolumn;
    },
    isAncestorColumn: function (parentNode, node) {
        if (parentNode == node) return true;
        if (!parentNode || !node) return false;
        var as = this.getAncestorColumns(node);
        for (var i = 0, l = as.length; i < l; i++) {
            if (as[i] == parentNode) return true;
        }
        return false;
    },
    getAncestorColumns: function (node) {
        var as = [];
        while (1) {
            var parentNode = this.getParentColumn(node);
            if (!parentNode || parentNode == this) break;
            as[as.length] = parentNode;
            node = parentNode;
        }
        as.reverse();
        return as;
    },

    getViewColumns: function () {
        return this.viewColumns;
    },

    getColumns: function (pcolumn) {
        pcolumn = this.getColumn(pcolumn);
        if (!pcolumn) pcolumn = this;
        return pcolumn.columns;
    },
    isVisibleColumn: function (column) {
        column = this.getColumn(column);
        if (!column.visible) return false;
        var pcolumn = this.getParentColumn(column);
        if (pcolumn == this) return true;
        return this.isVisibleColumn(pcolumn);
    },
    getDisplayColumns: function (pcolumn) {
        pcolumn = this.getColumn(pcolumn);
        if (!pcolumn) pcolumn = this;
        return pcolumn.displayColumns || [];
    },
    eachColumns: function (column, fn, scope) {
        var columns = this.getColumns(column);
        if (columns) {
            var list = mini.Array.clone(columns);
            for (var i = 0, l = list.length; i < l; i++) {
                var o = list[i];
                if (fn.call(scope, o, i, column) === false) break;
            }
        }
    },
    eachDisplayColumns: function (column, fn, scope) {
        var columns = this.getDisplayColumns(column);
        if (columns) {
            var list = mini.Array.clone(columns);
            for (var i = 0, l = list.length; i < l; i++) {
                var o = list[i];
                if (fn.call(scope, o, i, column) === false) break;
            }
        }
    },
    _columnId: 0,

    setColumns: function (columns) {
        if (!mini.isArray(columns)) columns = [];
        this.columns = columns;

        this.displayColumns = [];
        this.viewColumns = [];
        this._idColumns = {};
        this._nameColumns = {};

        var maxLevel = 0;
        var level = 0;
        function init(column, index, pcolumn) {
            this._initColumn(column);

            column.__id = this._columnId++;
            column._id = this.id + '_column_' + column.__id;
            column._pid = pcolumn._id;

            var cname = column.name;
            if (cname) {
                this._nameColumns[cname] = column;
            }

            this._idColumns[column._id] = column;

            column.level = level;
            level += 1;
            this.eachColumns(column, init, this);
            level -= 1;

            column.displayColumns = mini.Array.clone(column.columns || []);
            for (var i = column.displayColumns.length - 1; i >= 0; i--) {
                var c = column.displayColumns[i];
                if (c.visible == false) {
                    column.displayColumns.removeAt(i);
                }
            }

            if (column.displayColumns.length == 0 && this.isVisibleColumn(column)) {
                this.viewColumns.push(column);
            }

            if (column.level > maxLevel) maxLevel = column.level;
        }
        this.eachColumns(this, init, this);

        this.displayColumns = mini.Array.clone(columns);
        for (var i = this.displayColumns.length - 1; i >= 0; i--) {
            var c = this.displayColumns[i];
            if (c.visible == false) {
                this.displayColumns.removeAt(i);
            }
        }

        this.maxColumnLevel = maxLevel;

        this.invalidate();
    },
    _initColumn: function (column) {
        column._gridUID = this.id;
        column._rowIdField = this._rowIdField;
        if (column.type && column.inited != true) {
            column.typeInited = true;

            var col = mini._getColumn(column.type);
            var _column = mini.copyTo({}, column);
            mini.copyTo(column, col);
            mini.copyTo(column, _column);
        }

        column.width = parseInt(column.width);
        if (mini.isNull(column.width) || isNaN(column.width)) column.width = this.columnWidth;

        column.visible = column.visible !== false;
        column.allowResize = column.allowResize !== false;
        column.allowMove = column.allowMove !== false;
        column.allowSort = column.allowSort === true;
        column.allowDrag = !!column.allowDrag;
        column.readOnly = !!column.readOnly;

        if (column.editor) {
            if (typeof column.editor == 'string') {
                var cls = mini.getClass(column.editor);
                if (cls) {
                    column.editor = { type: column.editor };
                } else {
                    column.editor = eval('(' + column.editor + ')');
                }
            }

            if (column.editor && !mini.isControl(column.editor)) {
                column.editor = mini.create(column.editor);
            }
        }

        if (column.editor) {
            column.editor.setVisible(false);
        }

        if (typeof column.init == 'function' && column.inited != true) {
            column.init(this);
        }

        delete column.colspan;
        delete column.rowspan;

        column.inited = true;
    },

    getDisplayColumnRows: function () {
        var maxLevel = this.getMaxColumnLevel();

        var dcs = [];
        for (var i = 0, l = maxLevel; i <= l; i++) {
            dcs.push([]);
        }

        function getColSpan(col) {
            var subColumns = mini.treeToArray(col.displayColumns, 'displayColumns');
            var colSpan = 0;
            for (var i = 0, l = subColumns.length; i < l; i++) {
                var c = subColumns[i];
                if (c.displayColumns.length == 0) {
                    colSpan += 1;
                }
            }
            return colSpan;
        }

        var list = mini.treeToArray(this.displayColumns, 'displayColumns');

        for (var i = 0, l = list.length; i < l; i++) {
            var column = list[i];
            var cols = dcs[column.level];

            if (column.displayColumns.length > 0) {
                column.colspan = getColSpan(column);
            }
            if (column.displayColumns.length == 0 && column.level < maxLevel) {
                column.rowspan = maxLevel - column.level + 1;
            }

            cols.push(column);
        }

        return dcs;
    },
    getMaxColumnLevel: function () {
        return this.maxColumnLevel;
    },
    getAllColumnWidth: function () {
        var columns = this.getViewColumns();
        var all = 0;
        var columnWidth = this.columnWidth;
        for (var i = 0, l = columns.length; i < l; i++) {
            var col = columns[i];
            var w = mini.isNull(col.width) ? columnWidth : col.width;
            all += w;
        }
        return all;
    }
};

mini.copyTo(mini.SuperGrid.prototype, mini.GridColumnModel);

mini.GridCellEditModel = {
    addRowCls: function (record, cls) {
        record = this.getRecord(record);
        if (!record) return;

        var rowEl = this._getRowEl(record);
        if (rowEl) mini.addClass(rowEl, cls);

        var rowEl = this._getRowEl(record, true);
        if (rowEl) mini.addClass(rowEl, cls);
    },
    removeRowCls: function (record, cls) {
        record = this.getRecord(record);
        if (!record) return;
        if (record._cls == cls) delete record._cls;
        var rowEl = this._getRowEl(record);
        if (rowEl) mini.removeClass(rowEl, cls);

        var rowEl = this._getRowEl(record, true);
        if (rowEl) mini.removeClass(rowEl, cls);
    },
    _createRowId: function (record, isFrozen) {
        var id = typeof record == 'string' ? record : record._id;
        if (isFrozen) return this.id + '_locked_' + id;
        return this.id + '_' + id;
    },
    _createCellId: function (record, column) {
        return this.id + '_' + record._id + '_' + column.__id;
    },
    _getRowEl: function (row, isFrozen) {
        if (!row) return null;
        var id = this._createRowId(row, isFrozen);
        return document.getElementById(id);
    },
    _getHeaderCellEl: function (column) {
        return document.getElementById(column._id);
    },
    _getCellEl: function (record, column) {
        column = this.getColumn(column);
        if (!column) return null;
        var id = this._createCellId(record, column);
        return document.getElementById(id);
    },
    _getRecordByEvent: function (e) {
        var t = mini.findParent(e.target, this.rowCls);
        if (!t) return null;
        var ids = t.id.split('_');
        var rid = ids[ids.length - 1];
        return this.store.getByInternalId(rid);
    },
    getColumnByEvent: function (event) {
        return this._getColumnByEvent(event);
    },
    getCellByEvent: function (event) {
        return this._getCellByEvent(event);
    },
    _getColumnByEvent: function (e) {
        var t = mini.findParent(e.target, this.cellCls);
        if (t) {
            var ids = t.id.split('_');
            var column__id = parseInt(ids[ids.length - 1]);
            var column_id = this.id + '_column_' + column__id;
            return this.getColumn(column_id);
        } else {
            t = mini.findParent(e.target, 'mini-supergrid-headercell');
            if (t) {
                return this.getColumn(t.id);
            }
        }
        return null;
    },
    _getCellByEvent: function (e) {
        var record = this._getRecordByEvent(e);
        var column = this._getColumnByEvent(e);
        return {
            record: record,
            column: column
        };
    },
    _fireChildEvent: function (e, name) {
        if (this.disabled) return;
        var cell = this._getCellByEvent(e);
        var record = cell.record,
            column = cell.column;
        if (record) {
            var fn = this['_OnRow' + name];
            if (fn) {
                fn.call(this, record, e);
            } else {
                var eve = {
                    record: record,
                    htmlEvent: e
                };
                this.fire('row' + name, eve);
            }
        }
        if (column) {
            var fn = this['_OnColumn' + name];
            if (fn) {
                fn.call(this, column, e);
            } else {
                var eve = {
                    column: column,
                    field: column.field,
                    htmlEvent: e
                };
                this.fire('column' + name, eve);
            }
        }

        if (record && column) {
            var fn = this['_OnCell' + name];
            if (fn) {
                fn.call(this, record, column, e);
            } else {
                var eve = {
                    record: record,
                    column: column,
                    field: column.field,
                    htmlEvent: e
                };
                this.fire('cell' + name, eve);
            }
        }
        if (!record && column) {
            var fn = this['_OnHeaderCell' + name];
            if (fn) {
                fn.call(this, column, e);
            } else {
                var eve = {
                    sender: this,
                    column: column,
                    htmlEvent: e
                };
                var evName = 'onHeaderCell' + name;
                if (column[evName]) {
                    eve.sender = this;
                    column[evName](eve);
                }

                this.fire('headercell' + name, eve);
            }
        }
    },

    currentCell: null,
    editingCell: null,
    editControl: null,
    editWrap: null,
    _doCurrentCell: function (select) {
        if (this.currentCell) {
            var record = this.currentCell.record,
                column = this.currentCell.column;
            var cellId = this._createCellId(record, column);
            var cellEl = document.getElementById(cellId);
            if (cellEl) {
                if (select) {
                    mini.addClass(cellEl, this.cellSelectedCls);
                } else {
                    mini.removeClass(cellEl, this.cellSelectedCls);
                }
            }
        }
    },
    setCurrentCell: function (cell, autoScrollInto) {
        if (this.currentCell != cell) {
            this._doCurrentCell(false);
            this.currentCell = cell;
            this._doCurrentCell(true);

            if (cell && autoScrollInto !== false) {
                this.scrollIntoCell(cell.record, cell.column);
            }

            this.fire('currentcellchanged');
            this.fire('currentcellchange');
        }
    },
    getCurrentCell: function () {
        var cc = this.currentCell;
        if (cc) {
            if (!this.store.hasRecord(cc.record)) {
                this.currentCell = null;
                cc = null;
            }
        }
        return cc;
    },
    allowCellEdit: true,
    allowCellSelect: true,
    beginEdit: function (selectAll) {
        if (this.editingCell) this.endEdit();
        var cell = this.getCurrentCell();
        if (cell) {
            var canEdit = this._OnCellBeginEdit(cell.record, cell.column);
            if (canEdit !== false) {
                this.editingCell = cell;
                this._OnCellShowingEdit(cell.record, cell.column);
            }
        }
    },
    commitEdit: function (value) {
        var cell = this.editingCell;
        if (cell) {
            this._commitEditing = true;
            this._OnCellCommitEdit(cell.record, cell.column, value);
            this._commitEditing = false;
        }
    },
    endEdit: function () {
        var cell = this.editingCell;
        if (cell) {
            this.commitEdit();
            this.editingCell = null;
            this._OnCellEndEdit(cell.record, cell.column);
        }
    },
    cancelEdit: function () {
        var cell = this.editingCell;
        if (cell) {
            this.editingCell = null;
            this._OnCellEndEdit(cell.record, cell.column);
        }
    },
    focus: function () {
        var me = this;
        setTimeout(function () {
            try {
                me.el.focus();
            } catch (e) {}
        }, 10);
    },
    getEditWrap: function (box, placeholder) {
        if (!this.editWrap) {
            this.editWrap = mini.append(
                document.body,
                '<div class="mini-supergrid-editwrap" style="position:absolute;"></div>'
            );

            mini.on(this.editWrap, 'keydown', this.___OnEditControlKeyDown, this);
        }

        if (placeholder) {
            let placeholderHtml = `
            <div id="ppm-gantt-tooltip" class="el-tooltip__popper is-dark" x-placement="top-end" style="position: absolute; right: 0; top: -36px; transform-origin: center bottom; z-index: 1; max-width: 100%; font-size: 12px;">
                ${placeholder}
                <div class="popper__arrow" style="right: 4px"></div>
            </div>`;

            mini.append(this.editWrap, placeholderHtml);

            // 位置计算处理
            let $tooltip = $('#ppm-gantt-tooltip');
            $tooltip.css({ visibility: 'hidden' });
            setTimeout(() => {
                let tooltipHeight = $tooltip.height();
                let editorHeight = box.height;
                let top = -14 - tooltipHeight;
                if (tooltipHeight >= box.y) {
                    $tooltip.attr('x-placement', 'bottom-end');
                    top = editorHeight;
                }

                $tooltip.css({
                    top: top + 'px',
                    visibility: 'visible'
                });
            });
        }
        this.editWrap.style.zIndex = 1000000000;
        this.editWrap.style.display = 'block';
        mini.setXY(this.editWrap, box.x, box.y);

        mini.setWidth(this.editWrap, box.width);

        this.editWrap.style.zIndex = mini.getMaxZIndex();

        return this.editWrap;
    },

    _startEditNextRowCell: function (next) {
        var me = this;

        var currentCell = me.getCurrentCell();
        if (!currentCell) return;

        var column = currentCell.column;
        var record = currentCell.record;

        var rowIndex = me.indexOf(record) + (next ? 1 : -1);
        var nextRecord = me.getAt(rowIndex);

        if (this.viewRegion) {
            if (rowIndex < this.viewRegion.startRow || rowIndex >= this.viewRegion.endRow) {
                nextRecord = null;
            }
        }

        if (nextRecord) {
            currentCell = { record: nextRecord, column: column };
            me.setCurrentCell(currentCell);

            if (this.store.isGroupItem(nextRecord)) {
            } else {
                me.beginEdit();
            }

            me.data.deselectAll();
            me.data.select(nextRecord);
        }
    },

    _startEditNextColumnCell: function (next) {
        var me = this;

        var currentCell = me.getCurrentCell();
        if (!currentCell) return;

        var column = currentCell.column;
        var record = currentCell.record;

        var columns = me.getViewColumns();
        var columnIndex = columns.indexOf(column) + (next ? 1 : -1);

        if (columnIndex < this.frozenStartColumn) return;

        var nextColumn = columns[columnIndex];

        if (nextColumn) {
            currentCell = { record: record, column: nextColumn };
            me.setCurrentCell(currentCell);
            me.beginEdit();
        }
    },

    ___OnEditControlKeyDown: function (e) {
        var me = this;

        if (e.keyCode == 13) {
            var cell = this.editingCell;
            if (cell && cell.column && cell.column.enterCommit === false) return;
            this.endEdit();
            this.focus();

            if (me.enterEditAction == 'nextrowcell') {
                me._startEditNextRowCell(e.shiftKey == false);
            } else if (me.enterEditAction == 'nextcolumncell') {
                me._startEditNextColumnCell(e.shiftKey == false);
            }
        } else if (e.keyCode == 27) {
            this.cancelEdit();
            this.focus();
        } else if (e.keyCode == 9) {
            this.endEdit();

            e.preventDefault();
            me._startEditNextColumnCell(e.shiftKey == false);
        }
    },
    __OnBodyMouseDown: function (e) {
        if (this.editingControl) {
            var within = this.editingControl.within(e);
            if (within == false) {
                var sf = this;

                sf.endEdit();

                mini.un(document, 'mousedown', this.__OnBodyMouseDown, this);
            }
        }
    },
    _OnCellBeginEdit: function (record, column) {
        var e = {
            sender: this,
            source: this,
            record: record,
            column: column,
            field: column.field,
            editor: column.editor,
            value: record[column.field],
            cancel: false
        };
        if (column.oncellbeginedit) {
            column.oncellbeginedit(e);
        }
        this.fire('cellbeginedit', e);
        if (e.cancel) {
            return false;
        }

        if (!e.editor) return false;
        var editor = (this.editingControl = e.editor);
        if (editor.setValue) {
            editor.setValue(e.value);
        }

        if (column.displayField && editor.setText) {
            var text = record[column.displayField];
            editor.setText(text);
        }

        return true;
    },
    _OnCellShowingEdit: function (record, column) {
        if (!this.editingControl) return false;

        var cellBox = this.getCellBox(record, column);
        var e = {
            sender: this,
            source: this,
            record: record,
            column: column,
            field: column.field,
            cellBox: cellBox,
            editor: this.editingControl
        };
        if (column.oncellshowingedit) {
            column.oncellshowingedit(e);
        }
        this.fire('cellshowingedit', e);

        var editWrap = this.getEditWrap(cellBox, column.placeholder);
        var editor = e.editor;
        if (editor.render) {
            editor.render(this.editWrap);
            editor.focus();
            setTimeout(function () {
                editor.focus();
                if (editor.selectText) editor.selectText();
            }, 10);
            editor.setVisible(true);
        } else if (editor.el) {
            this.editWrap.appendChild(editor.el);
            try {
                editor.el.focus();
            } catch (e) {}
            setTimeout(function () {
                try {
                    editor.el.focus();
                } catch (e) {}
            }, 10);
        }

        if (editor.setWidth) {
            var width = cellBox.width;
            if (mini.isNumber(editor.minWidth)) {
                if (width < editor.minWidth) width = editor.minWidth;
            }
            editor.setWidth(width);
        }

        mini.on(document, 'mousedown', this.__OnBodyMouseDown, this);

        if (column.autoShowPopup && editor.showPopup) {
            editor.showPopup();
        }
    },
    _OnCellCommitEdit: function (record, column, value) {
        var e = {
            sender: this,
            source: this,
            record: record,
            column: column,
            field: column.field,
            editor: this.editingControl,
            value: value,
            cancel: false
        };

        if (e.editor && e.editor.getValue && value === undefined) {
            try {
                e.editor.blur();
            } catch (ex) {
                try {
                    e.editor.el.blur();
                } catch (e) {}
            }

            if (e.editor.__OnInputTextChanged) e.editor.__OnInputTextChanged();

            e.value = e.editor.getValue();

            if (e.editor.getText) {
                e.text = e.editor.getText();
            }
        }
        if (column.oncellcommitedit) {
            column.oncellcommitedit(e);
        }
        this.fire('cellcommitedit', e);
        if (e.cancel == false) {
            if (column.displayField) {
                var o = {};
                o[column.field] = e.value;
                o[column.displayField] = e.text;
                this.store.updateRecord(record, o);
            } else {
                this.store.updateRecord(record, column.field, e.value);
            }
        }
    },
    _OnCellEndEdit: function (record, column) {
        var e = {
            sender: this,
            source: this,
            record: record,
            column: column,
            field: column.field,
            editor: this.editingControl,
            value: record[column.field]
        };
        if (column.oncellendedit) {
            column.oncellendedit(e);
        }
        this.fire('cellendedit', e);
        if (this.editWrap) this.editWrap.style.display = 'none';
        var childNodes = this.editWrap.childNodes;
        for (var i = childNodes.length - 1; i >= 0; i--) {
            var el = childNodes[i];
            this.editWrap.removeChild(el);
        }

        var editor = e.editor;
        if (editor && editor.hidePopup) {
            editor.hidePopup();
        }
        if (editor && editor.clearValue) {
            editor.clearValue();
        }
        this.editingControl = null;
    },

    groupHeaderDateFormat: 'yyyy-MM-dd',
    groupHeaderFormatter: function (value) {
        if (value instanceof Date) {
            value = mini.formatDate(value, this.groupHeaderDateFormat);
        }
        return value;
    },

    treeIndent: 18,

    onDrawGroupHeaderCell: function (e) {
        var store = this.store,
            item = e.record,
            column = e.column,
            html = e.cellHtml,
            isGroupItem = store.isGroupItem(item),
            groupLevel = store.getGroupLevel(item);

        var cls = '';
        if (isGroupItem) {
            cls = item.expanded ? 'mini-supertree-expand' : 'mini-supertree-collapse';
        }

        var s = '';

        var left = 0;

        for (var i = 0, l = groupLevel; i < l; i++) {
            var color = store.groupFields[i].color || mini.Group.getColor(i);
            s +=
                '<div class="mini-supertree-indent ' +
                i +
                '" style="left:' +
                left +
                'px;width:' +
                this.treeIndent +
                'px;background:' +
                color +
                '"></div>';
            left += this.treeIndent;
        }

        if (isGroupItem) {
            s +=
                '<a onclick="return false;"  hidefocus class="mini-supertree-ec-icon" style="left:' +
                left +
                'px;"></a>';
        }

        left += this.treeIndent;

        s += '<div class="mini-supertree-nodetext" style="padding-left:' + (left + 2) + 'px;">' + html + '</div>';

        e.cellHtml = '<div class="mini-supertree-node ' + cls + '">' + s + '</div>';
    },

    _OnDrawCell: function (record, column, rowIndex, columnIndex) {
        var value = record[column.field];

        var e = {
            sender: this,
            source: this,
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            record: record,
            column: column,
            field: column.field,
            value: value,
            cellHtml: value,
            rowCls: '',
            cellCls: column.cellCls || '',
            rowStyle: '',
            cellStyle: column.cellStyle || '',
            autoEscape: column.autoEscape
        };

        if (column.dateFormat) {
            if (mini.isDate(e.value)) e.cellHtml = mini.formatDate(value, column.dateFormat);
            else e.cellHtml = '';
        }

        if (column.displayField) {
            e.cellHtml = record[column.displayField];
        }

        var renderer = column.renderer;
        if (renderer) {
            fn = typeof renderer == 'function' ? renderer : window[renderer];
            if (fn) {
                e.cellHtml = fn.call(column, e);
            }
        }

        if (this.store.isGroupItem(record)) {
            if (column.name && column.name == this.treeColumn) {
                e.cellHtml = this.groupHeaderFormatter(record.value);
            }
            e.cellCls += ' mini-supergrid-groupcell ';
        }

        if (e.autoEscape == true) {
            e.cellHtml = mini.htmlEncode(e.cellHtml);
        }

        this.fire('drawcell', e);

        if (e.cellHtml === null || e.cellHtml === undefined) e.cellHtml = '';

        return e;
    },
    setRowHeight: function (value) {
        if (value != this.rowHeight) {
            this.rowHeight = value;
            this.invalidate();
        }
    },

    getMultiSelect: function () {
        return this.multiSelect;
    },
    setMultiSelect: function (value) {
        this.multiSelect = value;
        if (this.store.setMultiSelect) this.store.setMultiSelect(value);
    },
    setAllowUnselect: function (value) {
        this.allowUnselect = value;
    },
    getAllowUnselect: function (value) {
        return this.allowUnselect;
    },
    setAllowCellSelect: function (value) {
        this.allowCellSelect = value;
    },
    setAllowRowSelect: function (value) {
        this.allowRowSelect = value;
    },
    setAllowAlternating: function (value) {
        this.allowAlternating = value;
        this.invalidate();
    },
    setAllowResizeColumn: function (value) {
        this.allowResizeColumn = value;
        this.invalidate();
    },

    setAllowDragDrop: function (value) {
        this.allowDragDrop = value;
        this.invalidate();
    },
    setShowDirty: function (value) {
        this.showDirty = value;
        this.invalidate();
    },

    _getDragData: function () {
        return mini.Array.clone(this.store.getSelecteds());
    },
    _getDragText: function (dragRecords) {
        return 'Rows ' + dragRecords.length;
    },
    _OnRowDragStart: function (record, column) {
        var e = {
            record: record,
            column: column,
            cancel: false
        };
        this.fire('RowDragStart', e);
        return e;
    },
    _OnRowDragDrop: function (dragRecords, dropRecord, dragAction) {
        dragRecords = mini.Array.clone(dragRecords);
        var e = {
            records: dragRecords,
            targetRecord: dropRecord,
            action: dragAction,
            cancel: false
        };
        this.fire('RowDragDrop', e);
        return e;
    },
    _OnGiveFeedback: function (effect, dragRecords, dropRecord) {
        var e = {};
        e.effect = effect;
        e.records = dragRecords;
        e.targetRecord = dropRecord;
        this.fire('GiveFeedback', e);
        return e;
    },
    isAllowDragDrop: function (record, column) {
        if (!this.allowDragDrop) return false;
        if (column.allowDrag !== true) return false;
        var e = this._OnRowDragStart(record, column);
        return !e.cancel;
    }
};

mini.copyTo(mini.SuperGrid.prototype, mini.GridCellEditModel);

mini._SuperGridSort = mini.Base.extend({
    constructor: function (grid) {
        this.grid = grid;
        this.grid.on('headercellclick', this.__onGridHeaderCellClick, this);
        this.grid.on('headercellmousedown', this.__OnGridHeaderCellMouseDown, this);

        mini.on(grid._headerEl, 'mousemove', this.__OnGridHeaderMouseMove, this);
        mini.on(grid._headerEl, 'mouseout', this.__OnGridHeaderMouseOut, this);
    },
    __OnGridHeaderMouseOut: function (e) {
        if (this._focusedColumnEl) {
            mini.removeClass(this._focusedColumnEl, 'mini-supergrid-headercell-hover');
        }
    },
    __OnGridHeaderMouseMove: function (e) {
        var t = mini.findParent(e.target, 'mini-supergrid-headercell');
        if (t) {
            mini.addClass(t, 'mini-supergrid-headercell-hover');
            this._focusedColumnEl = t;
        }
    },
    __onGridHeaderCellClick: function (e) {
        var grid = this.grid;

        var t = mini.findParent(e.target, 'mini-supergrid-headercell');
        if (t) {
            var column = grid.getColumn(t.id.split('_')[2]);
            if (grid.allowMoveColumn && column && column.allowDrag) {
                this.dragColumn = column;
                this._columnEl = t;
                this.getDrag().start(e);
            }
        }
    }
});

mini._SuperGridSelect = mini.Base.extend({
    constructor: function (grid) {
        this.grid = grid;
        this.grid.on('cellmousedown', this.__onGridCellMouseDown, this);

        this.grid.on('cellmouseup', this.__onGridCellClick, this);
        this.grid.on('celldblclick', this.__onGridCellDblClick, this);

        mini.on(this.grid.el, 'keydown', this.__OnGridKeyDown, this);
    },
    __OnGridKeyDown: function (e) {
        var grid = this.grid;
        var currentCell = grid.getCurrentCell();

        if (e.shiftKey || e.ctrlKey || e.altKey) {
            return;
        }

        if (!currentCell) return;
        if (e.keyCode == 37 || e.keyCode == 38 || e.keyCode == 39 || e.keyCode == 40) {
            e.preventDefault();
        }

        var columns = grid.getViewColumns();
        var column = currentCell.column,
            record = currentCell.record;
        var columnIndex = columns.indexOf(column);
        var rowIndex = grid.indexOf(record);
        var count = grid.getCount();

        switch (e.keyCode) {
            case 9:
                break;
            case 27:
                break;
            case 13:
                if (column.readOnly != true) {
                    if (!grid.store.isGroupItem(record)) {
                        grid.beginEdit();
                    }
                }
                break;
            case 37:
                if (columnIndex > 0) {
                    columnIndex -= 1;
                }
                break;
            case 38:
                if (rowIndex > 0) rowIndex -= 1;
                break;
            case 39:
                if (columnIndex < columns.length - 1) {
                    columnIndex += 1;
                }
                break;
            case 40:
                if (rowIndex < count - 1) rowIndex += 1;
                break;
            default:
                return;
        }

        if (columnIndex < grid.frozenStartColumn) return;

        column = columns[columnIndex];
        record = grid.getAt(rowIndex);

        if (column && record && grid.allowCellSelect) {
            var currentCell = { record: record, column: column };
            grid.setCurrentCell(currentCell);
        }

        if (record && grid.allowRowSelect) {
            grid.deselectAll();
            grid.select(record);
        }
    },
    __onGridCellClick: function (e) {
        if (e.htmlEvent.button == 2) return;

        var record = e.record,
            column = e.column;

        if (this.grid.store.isGroupItem(record)) {
            return;
        }

        var lastCurrentCell = this.lastCurrentCell;
        var currentCell = this.grid.getCurrentCell();
        var allowEdit = false;
        if (this.grid.cellEditClicks == 2 && lastCurrentCell && currentCell) {
            if (lastCurrentCell.record == currentCell.record && lastCurrentCell.column == currentCell.column) {
                allowEdit = true;
            }
        }
        this.lastCurrentCell = currentCell;

        if (!column.readOnly && !this.grid.isReadOnly()) {
            if (e.htmlEvent.shiftKey || e.htmlEvent.ctrlKey) {
            } else {
                if ((!this.grid.editOnDblClick && this.grid.cellEditClicks == 1) || allowEdit) {
                    this.grid.beginEdit();
                }
            }
        }
    },
    __onGridCellDblClick: function (e) {
        var record = e.record,
            column = e.column;

        if (this.grid.store.isGroupItem(record)) return;

        if (!column.readOnly && !this.grid.isReadOnly()) {
            if (e.htmlEvent.shiftKey || e.htmlEvent.ctrlKey) {
            } else {
                if (this.grid.editOnDblClick && this.grid.cellEditClicks == 1) {
                    this.grid.beginEdit();
                }
            }
        }
    },
    selectRange: function (start, end) {
        var store = this.grid.store;
        if (!mini.isNumber(start)) start = store.indexOf(start);
        if (!mini.isNumber(end)) end = store.indexOf(end);
        if (mini.isNull(start) || mini.isNull(end)) return;

        if (start > end) {
            var temp = start;
            start = end;
            end = temp;
        }

        var items = store.getVisibleRows().slice(start, end + 1);
        store.selects(items);
    },
    __onGridCellMouseDown: function (e) {
        var record = e.record,
            column = e.column;

        if (this.grid.store.isGroupItem(record)) {
            var event = e.htmlEvent;
            if (mini.findParent(event.target, 'mini-supertree-ec-icon')) {
                if (e.button != 2) {
                    this.grid.store.toggleGroupItem(record);
                    event.stopPropagation();
                    return;
                }
            }
        }

        if (this.grid.allowCellSelect) {
            var cell = {
                record: record,
                column: column
            };

            this.grid.setCurrentCell(cell);
        }

        if (!this.grid.allowRowSelect) return;

        var ex = {
            record: record,
            column: column,
            cancel: false
        };
        this.grid.fire('beforeselect', ex);
        if (ex.cancel == true) return;
        var grid = this.grid;

        if (this.grid.getMultiSelect()) {
            this.grid.el.onselectstart = function () {};

            if (e.htmlEvent.shiftKey) {
                this.grid.el.onselectstart = function () {
                    return false;
                };
                e.htmlEvent.preventDefault();

                if (!this.currentRecord) {
                    this.grid.store.select(record);
                    this.currentRecord = this.grid.getSelected();
                } else {
                    this.grid.deselectAll();
                    this.selectRange(this.currentRecord, record);
                }
            } else {
                this.grid.el.onselectstart = function () {};
                if (e.htmlEvent.ctrlKey) {
                    this.grid.el.onselectstart = function () {
                        return false;
                    };
                    e.htmlEvent.preventDefault();
                }

                if (column._multiRowSelect || e.htmlEvent.ctrlKey || grid.allowUnselect) {
                    if (this.grid.store.isSelected(record) && (column._multiRowSelect || e.htmlEvent.ctrlKey)) {
                        if (e.htmlEvent.button != 2) {
                            this.grid.store.deselect(record);

                            this.grid.setCurrentCell(null);
                        }
                    } else {
                        this.grid.store.select(record);
                    }
                } else {
                    if (this.grid.store.isSelected(record)) {
                    } else {
                        this.grid.store.deselectAll();
                        this.grid.store.select(record);
                    }
                }

                this.currentRecord = this.grid.getSelected();
            }
        } else {
            if (!this.grid.store.isSelected(record)) {
                this.grid.store.select(record);
            }
        }
    }
});

mini._SuperGridSplitter = mini.Base.extend({
    constructor: function (grid) {
        this.grid = grid;
        mini.on(this.grid.el, 'mousedown', this.__onGridMouseDown, this);
    },
    __onGridMouseDown: function (e) {
        var grid = this.grid;
        var t = e.target;
        if (mini.hasClass(t, 'mini-supergrid-splitter')) {
            var cid = mini.getAttr(t, 'cid');

            var column = grid.getColumn(cid);
            if (grid.allowResizeColumn && column) {
                this.splitterColumn = column;
                this.getDrag().start(e);
            }
        }
    },
    getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                capture: true,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    },
    _OnDragStart: function (drag) {
        var grid = this.grid;
        var columnBox = grid.getColumnBox(this.splitterColumn);
        this.columnBox = columnBox;
        this._dragProxy = mini.append(document.body, '<div class="mini-supergrid-proxy"></div>');

        var box = grid.getBox(true);
        box.x = columnBox.x;
        box.width = columnBox.width;
        box.right = columnBox.right;
        mini.setBox(this._dragProxy, box);
    },
    _OnDragMove: function (drag) {
        var grid = this.grid;
        var box = mini.copyTo({}, this.columnBox);
        var width = box.width + (drag.now[0] - drag.init[0]);
        if (width < grid.columnMinWidth) width = grid.columnMinWidth;
        if (width > grid.columnMaxWidth) width = grid.columnMaxWidth;

        mini.setWidth(this._dragProxy, width);
    },
    _OnDragStop: function (drag) {
        var grid = this.grid;
        var box = mini.getBox(this._dragProxy);
        jQuery(this._dragProxy).remove();
        this._dragProxy = null;

        var e = { column: this.splitterColumn, width: box.width };
        grid.fire('beforecolumnresize', e);
        if (e.cancel !== true) {
            grid.updateColumn(this.splitterColumn, { width: box.width });
        }
    }
});

mini._SuperGridColumnMove = mini.Base.extend({
    constructor: function (grid, headerCellCls, splitterCls) {
        this.grid = grid;
        this.headerCellCls = headerCellCls;
        this.splitterCls = splitterCls;
        mini.on(this.grid.el, 'mousedown', this.__onGridMouseDown, this);
    },
    __onGridMouseDown: function (e) {
        var grid = this.grid;
        if (mini.hasClass(e.target, 'mini-supergrid-splitter')) return;

        if (e.button == mini.MouseButton.Right) return;

        var t = mini.findParent(e.target, 'mini-supergrid-headercell');
        if (t) {
            var column = grid.getColumn(t.id);
            if (grid.allowMoveColumn && column && column.allowMove) {
                this.dragColumn = column;
                this._columnEl = t;
                this.getDrag().start(e);
            }
        }
    },
    getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    },
    _OnDragStart: function (drag) {
        var grid = this.grid;
        this._dragProxy = mini.append(document.body, '<div class="mini-supergrid-columnproxy"></div>');
        this._dragProxy.innerHTML =
            '<div class="mini-supergrid-columnproxy-inner">' + grid._createHeaderCell(this.dragColumn) + '</div>';
        mini.setXY(this._dragProxy, drag.now[0] + 15, drag.now[1] + 18);
        mini.addClass(this._dragProxy, 'mini-supergrid-no');

        this.moveTop = mini.append(document.body, '<div class="mini-supergrid-movetop"></div>');
        this.moveBottom = mini.append(document.body, '<div class="mini-supergrid-movebottom"></div>');
    },
    _OnDragMove: function (drag) {
        var grid = this.grid;
        var x = drag.now[0];
        mini.setXY(this._dragProxy, x + 15, drag.now[1] + 18);

        this.targetColumn = this.insertAction = null;
        var t = mini.findParent(drag.event.target, 'mini-supergrid-headercell');

        if (t) {
            var column = grid.getColumn(t.id);
            if (column && column != this.dragColumn && !grid.isAncestorColumn(this.dragColumn, column)) {
                this.targetColumn = column;
                this.insertAction = 'before';
                var columnBox = grid.getColumnBox(this.targetColumn);

                if (x > columnBox.x + columnBox.width / 2) {
                    this.insertAction = 'after';
                }
            }
        }

        if (this.targetColumn) {
            mini.addClass(this._dragProxy, 'mini-supergrid-ok');
            mini.removeClass(this._dragProxy, 'mini-supergrid-no');

            var box = grid.getColumnBox(this.targetColumn);

            this.moveTop.style.display = 'block';
            this.moveBottom.style.display = 'block';
            if (this.insertAction == 'before') {
                mini.setXY(this.moveTop, box.x - 4, box.y - 9);
                mini.setXY(this.moveBottom, box.x - 4, box.bottom);
            } else {
                mini.setXY(this.moveTop, box.right - 4, box.y - 9);
                mini.setXY(this.moveBottom, box.right - 4, box.bottom);
            }
        } else {
            mini.removeClass(this._dragProxy, 'mini-supergrid-ok');
            mini.addClass(this._dragProxy, 'mini-supergrid-no');

            this.moveTop.style.display = 'none';
            this.moveBottom.style.display = 'none';
        }
    },
    _OnDragStop: function (drag) {
        var grid = this.grid;
        mini.removeNode(this._dragProxy);
        mini.removeNode(this.moveTop);
        mini.removeNode(this.moveBottom);

        var e = { column: this.dragColumn, targetColumn: this.targetColumn, action: this.insertAction };
        grid.fire('beforecolumnmove', e);
        if (e.cancel !== true) {
            grid.moveColumn(this.dragColumn, this.targetColumn, this.insertAction);
        }

        this._dragProxy = this.moveTop = this.moveBottom = this.dragColumn = this.targetColumn = null;
    }
});

mini._GridDragDrop = mini.Base.extend({
    constructor: function (grid) {
        this.owner = grid;
        this.owner.on('CellMouseDown', this.__OnGridCellMouseDown, this);
    },
    __OnGridCellMouseDown: function (e) {
        if (e.htmlEvent.button == mini.MouseButton.Right) return;
        var grid = this.owner;
        if (grid.isReadOnly() || grid.isAllowDragDrop(e.record, e.column) == false) return;
        var record = e.record;

        this.isTree = grid.store.isTree;
        this.dragData = grid._getDragData();

        if (this.dragData.indexOf(record) == -1) {
            this.dragData.push(record);
        }

        var drag = this._getDrag();
        drag.start(e.htmlEvent);
    },
    _OnDragStart: function (drag) {
        var grid = this.owner;

        this.feedbackEl = mini.append(document.body, '<div class="mini-feedback"></div>');
        this.feedbackEl.innerHTML = grid._getDragText(this.dragData);
        this.lastFeedbackClass = '';
    },
    _OnDragMove: function (drag) {
        var grid = this.owner;

        var x = drag.now[0],
            y = drag.now[1];
        mini.setXY(this.feedbackEl, x + 15, y + 18);

        var targetRecord = grid._getRecordByEvent(drag.event);
        this.dropRecord = targetRecord;

        if (targetRecord) {
            if (this.isTree) {
                this.dragAction = this.getFeedback(targetRecord, y, 3);
            } else {
                this.dragAction = this.getFeedback(targetRecord, y, 2);
            }
        } else {
            this.dragAction = 'no';
        }

        this.lastFeedbackClass = 'mini-feedback-' + this.dragAction;
        this.feedbackEl.className = 'mini-feedback ' + this.lastFeedbackClass;

        if (this.dragAction == 'no') targetRecord = null;
        this.setRowFeedback(targetRecord, this.dragAction);
    },
    _OnDragStop: function (drag) {
        var grid = this.owner;
        mini.removeNode(this.feedbackEl);

        this.feedbackEl = null;
        this.setRowFeedback(null);

        if (this.isTree) {
            var dragRecords = [];
            for (var i = 0, l = this.dragData.length; i < l; i++) {
                var dragRecord = this.dragData[i];

                var hasParent = false;
                for (var j = 0, k = this.dragData.length; j < k; j++) {
                    var dr = this.dragData[j];
                    if (dr != dragRecord) {
                        hasParent = grid.store.isAncestor(dr, dragRecord);
                        if (hasParent) break;
                    }
                }

                if (!hasParent) {
                    dragRecords.push(dragRecord);
                }
            }
            this.dragData = dragRecords;
        }

        if (this.dropRecord && this.dragAction != 'no') {
            var e = grid._OnRowDragDrop(this.dragData, this.dropRecord, this.dragAction);

            if (!e.cancel) {
                var dragRecords = e.records,
                    targetRecord = e.targetRecord,
                    action = e.action;
                if (grid.store.isTree) {
                    grid.store.moveNodes(dragRecords, targetRecord, action);
                } else {
                    var index = grid.store.indexOf(targetRecord);
                    if (action == 'after') index += 1;
                    grid.store.move(dragRecords, index);
                }
            }
        }
        this.dropRecord = null;
        this.dragData = null;
    },
    setRowFeedback: function (record, feedback) {
        var grid = this.owner;
        if (this.lastAddDomRow) {
            grid.removeRowCls(this.lastAddDomRow, 'mini-supergrid-feedback-add');
        }
        if (record == null || this.dragAction == 'add') {
            mini.removeNode(this.feedbackLine);
            this.feedbackLine = null;
        }

        this.lastRowFeedback = record;

        if (record != null) {
            if (feedback == 'before' || feedback == 'after') {
                if (!this.feedbackLine) {
                    this.feedbackLine = mini.append(document.body, "<div class='mini-feedback-line'></div>");
                }
                this.feedbackLine.style.display = 'block';
                var rowBox = grid.getRowBox(record);
                var x = rowBox.x,
                    y = rowBox.y - 1;
                if (feedback == 'after') {
                    y += rowBox.height;
                }
                mini.setXY(this.feedbackLine, x, y);

                var box = grid.getBox(true);
                mini.setWidth(this.feedbackLine, box.width);
            } else {
                grid.addRowCls(record, 'mini-supergrid-feedback-add');
                this.lastAddDomRow = record;
            }
        }
    },
    getFeedback: function (dropRecord, y, way) {
        var grid = this.owner;

        var rowBox = grid.getRowBox(dropRecord);

        var h = rowBox.height;
        var t = y - rowBox.y;

        var effect = null;

        if (this.dragData.indexOf(dropRecord) != -1) return 'no';
        var IsLeaf = false;
        if (way == 3) {
            IsLeaf = grid.isLeaf(dropRecord);

            for (var i = 0, l = this.dragData.length; i < l; i++) {
                var dragRecord = this.dragData[i];

                var isAncestor = grid.isAncestor(dragRecord, dropRecord);
                if (isAncestor) {
                    effect = 'no';
                    break;
                }
            }
        }
        if (effect == null) {
            if (way == 2) {
                if (t > h / 2) effect = 'after';
                else effect = 'before';
            } else {
                if (IsLeaf) {
                    if (t > h / 2) effect = 'after';
                    else effect = 'before';
                } else {
                    if (t > (h / 3) * 2) effect = 'after';
                    else if (h / 3 <= t && t <= (h / 3) * 2) effect = 'add';
                    else effect = 'before';
                }
            }
        }
        var e = grid._OnGiveFeedback(effect, this.dragData, dropRecord);
        return e.effect;
    },
    _getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                capture: false,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    }
});

mini.SuperTree = mini.SuperGrid.extend({
    type: 'supertree',
    tag: 'mini-supertree',

    props: {
        treeColumn: null,
        showTreeIcon: false,
        allowColumnSort: false,

        leafIcon: 'mini-supertree-leaf',
        folderIcon: 'mini-supertree-folder'
    },

    _create: function () {
        mini.SuperTree.superclass._create.call(this);
        this.addCls('mini-supergrid');
    },
    _initEvents: function () {
        mini.SuperTree.superclass._initEvents.call(this);
    },
    _getSource: function (data) {
        if (!mini.isArray(data)) return data;
        var store = new mini.TreeStore();
        store.loadData(data);
        return store;
    },
    __OnTreeCollapse: function (e) {
        this.fire('collapse', e);
    },
    __OnTreeExpand: function (e) {
        this.fire('expand', e);
    },

    isLeafNode: function (node) {
        return this.store.isLeafNode(node);
    },
    getNodeLevel: function (node) {
        return node ? this.store.getNodeLevel(node) : 0;
    },
    isExpanded: function (node) {
        return this.store.isExpanded(node);
    },
    isAncestor: function (p, n) {
        return this.store.isAncestor(p, n);
    },
    treeIndent: 18,

    _OnDrawCell: function (record, column, rowIndex, columnIndex) {
        var e = mini.SuperTree.superclass._OnDrawCell.call(this, record, column, rowIndex, columnIndex);
        if (this.treeColumn !== column.name) return e;

        if (this.store.isGrouped()) return e;

        var node = record;
        if (!node) return e;

        var treeIndent = this.treeIndent;

        var cellHtml = e.cellHtml;

        var columnWidth = column.width;
        var isLeaf = this.isLeafNode(node);

        var left = this.getLevel(node) * treeIndent;

        var cls = '';
        if (!isLeaf) {
            cls = this.isExpanded(node) ? 'mini-supertree-expand' : 'mini-supertree-collapse';
        }

        var s = '<div class="mini-supertree-node ' + cls + '">';

        if (!isLeaf) {
            s +=
                '<a onclick="return false;"  hidefocus class="mini-supertree-ec-icon" style="left:' +
                left +
                'px;"></a>';
        }
        left += treeIndent;

        if (this.showTreeIcon) {
            var icon = this.getIcon(node);

            s += '<div class="' + icon + ' mini-supertree-nodeicon" style="left:' + left + 'px;"></div>';
            left += treeIndent;
        }

        s += '<div class="mini-supertree-nodetext" style="padding-left:' + (left + 2) + 'px;">' + cellHtml + '</div>';
        s += '</div>';
        cellHtml = s;
        e.cellHtml = cellHtml;
        return e;
    },
    getIcon: function (node) {
        var icon = node[this.iconField];
        if (!icon) {
            if (this.isLeafNode(node)) icon = this.leafIcon;
            else icon = this.folderIcon;
        }
        return icon;
    },
    setTreeColumn: function (value) {
        this.treeColumn = value;
        this.invalidate();
    },
    setShowTreeIcon: function (value) {
        this.showTreeIcon = value;
        this.invalidate();
    },

    _OnCellMouseDown: function (record, column, e) {
        if (mini.findParent(e.target, 'mini-supertree-ec-icon')) {
            if (e.button != 2) {
                this.store.toggle(record);
                e.stopPropagation();
            }
        } else {
            var eve = {
                record: record,
                column: column,
                field: column.field,
                htmlEvent: e
            };
            this.fire('cellmousedown', eve);
        }
    },
    _OnCellMouseUp: function (record, column, e) {
        if (mini.findParent(e.target, 'mini-supertree-ec-icon')) {
            e.stopPropagation();
        } else {
            var eve = {
                record: record,
                column: column,
                field: column.field,
                htmlEvent: e
            };
            this.fire('cellmouseup', eve);
        }
    },
    _OnCellClick: function (record, column, e) {
        if (mini.findParent(e.target, 'mini-supertree-ec-icon')) {
            e.stopPropagation();
        } else {
            var eve = {
                record: record,
                column: column,
                field: column.field,
                htmlEvent: e
            };
            this.fire('cellclick', eve);
        }
    },
    addNodeCls: function (node, cls) {
        this.addRowCls(node, cls);
    },
    removeNodeCls: function (node, cls) {
        this.removeRowCls(node, cls);
    },

    getAttrs: function (el) {
        var attrs = mini.SuperTree.superclass.getAttrs.call(this, el);
        var jq = jQuery(el);

        var treeColumn = jq.attr('treeColumn');
        if (treeColumn) {
            attrs.treeColumn = treeColumn;
        }
        var iconField = jq.attr('iconField');
        if (iconField) {
            attrs.iconField = iconField;
        }
        var nodesField = jq.attr('nodesField');
        if (nodesField) {
            attrs.nodesField = nodesField;
        }
        var useArrows = jq.attr('useArrows');
        if (useArrows) {
            attrs.useArrows = useArrows == 'false' ? false : true;
        }
        var showTreeIcon = jq.attr('showTreeIcon');
        if (showTreeIcon) {
            attrs.showTreeIcon = showTreeIcon == 'false' ? false : true;
        }

        return attrs;
    }
});

mini.copyTo(mini.SuperTree.prototype, mini._SuperDataTreeApplys);

mini.regClass(mini.SuperTree, 'supertree');
mini.GanttView = function () {
    mini.GanttView.superclass.constructor.call(this);

    this._TaskUIDs = {};
    this._TaskIndexs = {};
    this._linkHashed = {};
    this._TaskTops = null;

    this.topTimeScale = mini.GanttView.getTimeScale('week');
    this.middleTimeScale = mini.GanttView.getTimeScale('week');
    this.bottomTimeScale = mini.GanttView.getTimeScale('day');

    this.middleTimeScale.visible = false;

    this.zoomTimeScales = mini.GanttView.createZoomTimeScales();

    var d = new Date();
    this.startDate = new Date(d?.getFullYear(), d?.getMonth(), d?.getDate());
    this.finishDate = new Date(d?.getFullYear(), d?.getMonth() + 1, d?.getDate());
    this.setDateRange(this.startDate, this.finishDate);
    this.setData([]);
};
mini.extend(mini.GanttView, mini.Control, {
    allowDrawBar: true,

    timeScaleHeight: 18,

    refreshOnScroll: false,
    showScrollTip: true,

    viewModel: 'gantt',
    setViewModel: function (value) {
        this.viewModel = value;
        this.invalidate();
    },
    isTrackModel: function () {
        return this.viewModel == 'track';
    },
    baselineIndex: 0,
    getBaseline: function (item) {
        var bls = item.Baseline;
        return bls ? bls[this.baselineIndex] : null;
    },

    allowTouchEvent: true,

    startDate: null,
    finishDate: null,
    weekStartDay: 0,

    rowHeight: 22,
    showGridLines: true,
    showLinkLines: true,
    showSummary: true,
    showCriticalPath: false,

    bottomTimeScaleFormatter: null,

    showLabel: true,
    labelField: 'Name',
    labelAlign: 'right',

    allowDrag: true,

    scrollLeft: 0,
    scrollTop: 0,
    scrollWidth: 0,
    scrollHeight: 0,

    timelineRatio: 1,

    setTimelineRatio: function (value) {
        this.timelineRatio = value;
        this.invalidate();
    },

    getBodyEl: function () {
        return this.viewportEl;
    },

    getHeaderEl: function () {
        return this.headerEl;
    },

    _create: function () {
        this.el = document.createElement('div');
        this.el.className = 'mini-ganttview';

        this.el.innerHTML =
            '<div class="mini-ganttview-header"></div>' +
            '<div class="mini-ganttview-viewport">' +
            '<div class="mini-ganttview-gridlines"></div>' +
            '<div class="mini-ganttview-cells"><div class="mini-ganttview-bars"></div><div class="mini-ganttview-linklines"></div></div>' +
            '</div>' +
            '<div class="mini-supergrid-hscroller" tabindex="-1"><div class="mini-supergrid-hscrollercontent"></div></div>' +
            '<div class="mini-supergrid-vscroller" tabindex="-1"><div class="mini-supergrid-vscrollercontent"></div></div>';

        this.headerEl = this.el.firstChild;
        this.viewportEl = this.el.childNodes[1];
        this.cellsEl = this.viewportEl.childNodes[1];
        this.gridlinesEl = this.viewportEl.childNodes[0];

        this.barsEl = this.cellsEl.childNodes[0];
        this.linklinesEl = this.cellsEl.childNodes[1];

        this.hscrollerEl = this.el.childNodes[2];
        this.vscrollerEl = this.el.childNodes[3];
        this.hscrollerContentEl = this.hscrollerEl.firstChild;
        this.vscrollerContentEl = this.vscrollerEl.firstChild;

        if (mini.isTouch && this.allowTouchEvent) {
            this.showScrollTip = false;
            jQuery(this.el).addClass('touch');

            var me = this;
            var bodyEl = this.viewportEl;
            var bind = function (el, type, fn) {
                el.addEventListener(type, fn);
            };

            bodyEl.style['pointer-events'] = 'none';

            var startEvent;
            var startScrollLeft, startScrollTop;
            var isPreventDefault;

            bind(this.el, 'touchstart', function (event) {
                startEvent = event;
                startScrollLeft = me.hscrollerEl.scrollLeft;
                startScrollTop = me.vscrollerEl.scrollTop;
            });
            bind(this.el, 'touchmove', function (event) {
                if (event.touches.length != 1) return;

                var delta = event.touches[0].pageY - startEvent.touches[0].pageY;

                var deltaX = event.touches[0].pageX - startEvent.touches[0].pageX;

                isPreventDefault = false;

                if (delta != 0) {
                    var el = me.vscrollerEl;
                    var scrollTop = el.scrollTop;

                    el.scrollTop = startScrollTop - delta;
                    if (scrollTop != el.scrollTop) {
                        isPreventDefault = true;
                    }
                }
                if (deltaX != 0) {
                    var el = me.hscrollerEl;
                    var scrollLeft = el.scrollLeft;

                    el.scrollLeft = startScrollLeft - deltaX;
                    if (scrollLeft != el.scrollLeft) {
                        isPreventDefault = true;
                    }
                }
                if (isPreventDefault) {
                    event.preventDefault();
                }
            });

            bind(this.el, 'touchend', function (event) {
                bodyEl.style['pointer-events'] = '';
                setTimeout(
                    function () {
                        bodyEl.style['pointer-events'] = 'none';
                    },
                    isPreventDefault ? 1 : 300
                );
                isPreventDefault = false;
            });
        }
    },

    _enableScroll: function () {
        if (this._scrollDisabled !== false) {
            this._scrollDisabled = false;
            var me = this;
            if (!this._bindScrollTimeout) {
                this._bindScrollTimeout = setTimeout(function () {
                    me._bindScrollTimeout = null;
                    mini.on(me.hscrollerEl, 'scroll', me.__onHScroll, me);
                    mini.on(me.vscrollerEl, 'scroll', me.__onVScroll, me);
                }, 1);
            }
        }
    },

    _disableScroll: function () {
        this._scrollDisabled = true;
        mini.un(this.hscrollerEl, 'scroll', this.__onHScroll, this);
        mini.un(this.vscrollerEl, 'scroll', this.__onVScroll, this);
        if (this._bindScrollTimeout) {
            clearTimeout(this._bindScrollTimeout);
            this._bindScrollTimeout = null;
        }
    },

    refreshScrollComplete: false,

    _initEvents: function () {
        mini.on(this.hscrollerEl, 'scroll', this.__onHScroll, this);
        mini.on(this.vscrollerEl, 'scroll', this.__onVScroll, this);

        if (mini.isFirefox) {
            var sf = this;
            function onmouseup() {
                jQuery(document).unbind('mouseup', onmouseup);

                sf.refreshScrollComplete = false;
                sf.scrollTop = -1;
                sf.setScrollTop(sf.vscrollerEl.scrollTop);

                sf.fire('scroll', {
                    direction: 'vertical'
                });
            }
            this.vscrollerEl.onmousedown = function (e) {
                sf.refreshScrollComplete = true;

                jQuery(document).bind('mouseup', onmouseup);
                sf.__onVScroll();
            };
        } else if (!mini.isOpera) {
            var sf = this;
            function onvscrollmousemove() {
                jQuery(document).unbind('mousemove', onvscrollmousemove);

                sf.refreshScrollComplete = false;
                sf.scrollTop = -1;
                sf.setScrollTop(sf.vscrollerEl.scrollTop);
                sf.fire('scroll', {
                    direction: 'vertical'
                });
            }
            this.vscrollerEl.onmousedown = function (e) {
                sf.refreshScrollComplete = true;

                jQuery(document).bind('mousemove', onvscrollmousemove);
                sf.__onVScroll();
            };
        }

        mini.on(this.el, 'mousewheel', this.__OnMousewheel, this);
        mini.on(this.el, 'click', this.__OnClick, this);
        mini.on(this.el, 'dblclick', this.__OnDblClick, this);
        mini.on(this.el, 'mousedown', this.__OnMouseDown, this);
        mini.on(this.el, 'contextmenu', this.__OnContextMenu, this);

        this._initPlugins();
    },
    _initPlugins: function () {
        this._ToolTip = new mini._GanttViewToolTip(this);
        this._DragDrop = new mini._GanttViewDragDrop(this);
    },

    doLayout: function () {
        mini.setHeight(this.headerEl, this.getHeaderHeight());

        var vh = this.getViewportHeight();
        mini.setHeight(this.viewportEl, vh);

        var viewportWidth = this.getViewportWidth();
        var viewportHeight = this.getViewportHeight();

        var vheight = viewportHeight - 18;
        if (vheight < 0) vheight = 0;
        var vwidth = viewportWidth - 18;
        if (vwidth < 0) vwidth = 0;

        this.vscrollerEl.style.top = this.getHeaderHeight() + 'px';
        this.vscrollerEl.style.height = vheight + 'px';
        this.hscrollerEl.style.width = vwidth + 'px';

        this.hscrollerContentEl.style.width = this.scrollWidth + 'px';
        this.vscrollerContentEl.style.height = this.scrollHeight + 'px';

        this.cellsEl.style.width = vwidth + 'px';
        this.cellsEl.style.height = vheight + 'px';

        this.gridlinesEl.style.width = vwidth + 'px';
        this.gridlinesEl.style.height = vheight + 'px';

        var region = this.updateViewRegion();
        var last = this._lastViewRegion;
        if (last) {
            if (
                last.scrollLeft != region.scrollLeft ||
                last.topOffset != region.topOffset ||
                last.startDate?.getTime() != region.startDate?.getTime() ||
                last.endDate?.getTime() < region.endDate?.getTime() ||
                last.startRow != region.startRow ||
                last.endRow < region.endRow
            ) {
                this.invalidate();
            }
        }
    },

    getHeaderHeight: function () {
        var h = 0;
        if (this.topTimeScale && this.topTimeScale.visible !== false)
            h += this.topTimeScale.height || this.timeScaleHeight;
        if (this.middleTimeScale && this.middleTimeScale.visible !== false)
            h += this.middleTimeScale.height || this.timeScaleHeight;
        if (this.bottomTimeScale && this.bottomTimeScale.visible !== false)
            h += this.bottomTimeScale.height || this.timeScaleHeight;
        return h;
    },

    getViewportHeight: function () {
        var h = this.getHeight(true) - this.getHeaderHeight();
        return h;
    },
    getViewportWidth: function () {
        return this.getWidth(true);
    },

    setShowLabel: function (value) {
        this.showLabel = value;
        this.invalidate();
    },
    setShowCriticalPath: function (value) {
        this.showCriticalPath = value;
        this.invalidate();
    },
    setShowGridLines: function (value) {
        this.showGridLines = value;
        this.invalidate();
    },
    setTimeLines: function (value) {
        this.timeLines = value;
        this.invalidate();
    },
    setRowHeight: function (value) {
        value = parseInt(value);
        if (isNaN(value)) return;
        this.rowHeight = value;
        this.__OnDataChanged();
        this.invalidate();
    },

    setLeftDate: function (date) {
        var left = this.getXByDate(date);
        this.setScrollLeft(left);
    },

    setScrollLeft: function (value) {
        if (this.scrollLeft != value) {
            this._disableScroll();
            this.hscrollerEl.scrollLeft = value;
            this.scrollLeft = this.hscrollerEl.scrollLeft;
            this._enableScroll();
            this.invalidate();
        }
    },
    setScrollTop: function (value) {
        if (this.scrollTop != value) {
            this._disableScroll();
            this.vscrollerEl.scrollTop = value;
            this.scrollTop = this.vscrollerEl.scrollTop;
            this._enableScroll();
            this.invalidate();
        }
    },
    getScrollTop: function () {
        return this.scrollTop;
    },
    getScrollLeft: function () {
        return this.scrollLeft;
    },

    setHeaderHeight: function (value) {
        var num = 2;
        if (this.middleTimeScale.visible) {
            num = 3;
        }
        var h = value / num;
        this.topTimeScale.height = h;
        this.bottomTimeScale.height = h;
        if (this.middleTimeScale.visible) {
            this.middleTimeScale.height = h;
        }

        this.invalidate();
    },
    setTopTimeScale: function (value) {
        var old = this.bottomTimeScale;
        var ts = mini.GanttView.getTimeScale(value);

        this.topTimeScale = ts;

        if (old && typeof value == 'string') ts.height = old.height;

        this.setDateRange(this._startDate, this._finishDate);

        this.invalidate();
    },
    setBottomTimeScale: function (value) {
        var old = this.bottomTimeScale;
        var ts = mini.GanttView.getTimeScale(value);

        if (old && typeof value == 'string') ts.height = old.height;

        this.bottomTimeScale = ts;

        this.setDateRange(this._startDate, this._finishDate);
        this.invalidate();
    },
    setMiddleTimeScale: function (value) {
        var ts = mini.GanttView.getTimeScale(value);

        this.middleTimeScale = ts;
        this.setDateRange(this._startDate, this._finishDate);
        this.invalidate();
    },
    isSummary: function (task) {
        if (this.isMilestone(task)) return false;

        if (this.showSummary) {
            return task.Summary || task.isLeaf === false || (task.children && task.children.length > 0) || task.TaskType == 1;
        } else {
            return false;
        }
    },
    isCritical: function (task) {
        if (this.showCriticalPath) {
            return task.Critical || task.Critical2;
        } else {
            return false;
        }
    },
    isMilestone: function (task) {
        return task.Milestone;
    },
    isWorking: function (date, timescale) {
        if (!timescale) return true;
        if (timescale.type == 'day' && timescale.number == 1) {
            var day = date?.getDay();
            if (day == 0 || day == 6) return false;
        }
        return true;
    },
    setDateRange: function (start, finish) {
        var sss = new Date();
        if (!mini.isDate(start)) throw new Error('start must be date type');
        if (!mini.isDate(finish)) throw new Error('finish must be date type');
        if (start?.getTime() >= finish?.getTime()) {
            finish = new Date(start?.getFullYear(), start?.getMonth(), start?.getDate() + 1);
        }
        if (start < new Date(1900, 0, 1)) throw new Error('date 1900 error ');

        var bType = this.bottomTimeScale.type,
            bNumber = this.bottomTimeScale.number,
            bWidth = this.bottomTimeScale.width;

        this._startDate = this._clearDate(start);
        this._finishDate = this._clearDate(finish);

        this.startDate = this.getTimeScaleStartDate(this._startDate, bType, bNumber);
        this.finishDate = this.getTimeScaleNextDate(this._finishDate, bType, 1);

        var gap = 10;
        if (bType == 'hour') gap = 20;
        if (bType == 'minutes') gap = 20;
        if (bType == 'seconds') gap = 20;

        this.finishDate = this._addDate(this.finishDate, bType, gap * bNumber);

        var scrollWidth = 0;

        var finishTime = this.finishDate?.getTime();

        if (bType == 'hour') {
            bWidth = (bWidth / bNumber) * 24;
            bType = 'day';
            bNumber = 1;
        }
        if (bType == 'minutes') {
            bWidth = (bWidth / bNumber) * 60 * 24;
            bType = 'day';
            bNumber = 1;
        }
        if (bType == 'seconds') {
            bWidth = (bWidth / bNumber) * 60 * 60 * 24;
            bType = 'day';
            bNumber = 1;
        }

        for (var d = this._cloneDate(this.startDate); d?.getTime() <= finishTime; ) {
            scrollWidth += bWidth * this.timelineRatio;

            d = this.getTimeScaleNextDate(d, bType, bNumber);
        }

        this.scrollWidth = scrollWidth;
    },

    setData: function (data) {
        if (this.store == data) return;
        if (typeof data == 'string') {
            data = mini.get(data);
        }
        if (!data) data = [];
        if (data instanceof Array) {
            data = this._getSourceFromArray(data);
        }

        if (this.store) {
            this._unbindSource();
            this.store.destroy();
        }

        this.store = data;
        this.data = this.store;
        this._bindSource();

        this.fire('datachanged');

        this.__OnDataChanged();
    },

    getItems: function () {
        return this.store.getVisibleRows();
    },

    _getSourceFromArray: function (data) {
        if (!mini.isArray(data)) return data;
        var store = new mini.TreeStore();
        store.loadData(data);
        return store;
    },
    _bindSource: function () {
        this.store.on('datachanged', this.__OnDataChanged, this);
    },
    _unbindSource: function () {
        this.store.un('datachanged', this.__OnDataChanged, this);
    },
    showed: false,

    _updateItemsInfo: function () {
        if (this._TaskTops) return;

        var taskUIDs = (this._TaskUIDs = {});
        var indexs = (this._TaskIndexs = {});
        var tops = (this._TaskTops = {});

        var data = this.getItems();
        var scrollHeight = 0;

        for (var i = 0, l = data.length; i < l; i++) {
            var r = data[i];
            var h = mini.isNumber(r._height) ? r._height : this.rowHeight;

            taskUIDs[r.UID] = r;
            indexs[r._id] = i;
            tops[r._id] = scrollHeight;

            scrollHeight += h;
        }

        this.scrollHeight = scrollHeight;
    },

    __OnDataChanged: function (e) {
        this._TaskTops = null;
        this.invalidate();
    },

    invalidate: function () {
        this.updateViewRegion();
        this.callParent('invalidate');
    },

    refresh: function () {
        var sss = new Date();

        var region = this.updateViewRegion();
        this._lastViewRegion = region;

        this.refreshHeader(region);

        this.refreshBody(region);

        this.refreshGridLines(region);

        if (this.refreshOnScroll) {
            this.refreshLinkLines(region);
        } else {
            this.linklinesEl.innerHTML = '';
            this.refreshLinkLines(region);
        }
    },

    refreshHeader: function (region) {
        var startDate = region.startDate,
            endDate = region.endDate;
        var endTime = endDate?.getTime();
        var renderer = this.headerCellRenderer;
        var event = {};
        var me = this;
        var sb = [];
        var top = 0;

        function drawTimeScale(timescale, position) {
            if (timescale.visible == false) return;
            var height = timescale.height || me.timeScaleHeight;

            if (timescale.index > me.bottomTimeScale.index) {
                top += height;
                return;
            }

            sb[sb.length] =
                '<div style="top:' +
                top +
                'px;height:' +
                height +
                'px;" class="mini-ganttview-' +
                position +
                'timescale">';
            top += height;

            var left = me.getOffsetByDate(startDate);

            event.timescale = timescale;
            event.position = position;

            timescale.ganttView = me;

            for (var date = startDate; date?.getTime() <= endTime; ) {
                var next = me.getTimeScaleNextDate(date, timescale.type, timescale.number);

                var topLeft = me.getOffsetByDate(date);
                var topRight = me.getOffsetByDate(next);
                var offset = topLeft - left;
                var w = topRight - topLeft;

                var v =
                    typeof timescale.formatter == 'string'
                        ? mini.formatDate(date, timescale.formatter)
                        : timescale.formatter(date, position);

                event.date = date;
                event.html = v;
                event.tooltip =
                    typeof timescale.tooltip == 'string'
                        ? mini.formatDate(date, timescale.tooltip)
                        : timescale.tooltip(date, position);
                event.cls = '';
                event.style = '';
                if (renderer) renderer(event);

                me.fireEvent('drawheadercell', event);

                sb[sb.length] = '<div time="';
                sb[sb.length] = date?.getTime();
                sb[sb.length] = '" title="';
                sb[sb.length] = event.tooltip;
                sb[sb.length] = '" class="mini-ganttview-headercell ';
                sb[sb.length] = event.cls;
                sb[sb.length] = '" style="';

                sb[sb.length] = 'text-align:' + event.timescale.align + ';';

                sb[sb.length] = event.style;
                sb[sb.length] = ';left:';
                sb[sb.length] = offset;
                sb[sb.length] = 'px;width:';
                sb[sb.length] = w;
                sb[sb.length] = 'px;height:';
                sb[sb.length] = height;
                sb[sb.length] = 'px;top:0px;line-height:';
                sb[sb.length] = height - 1;
                sb[sb.length] = 'px;">';
                sb[sb.length] = event.html;
                sb[sb.length] = '</div>';

                date = next;
            }
            sb[sb.length] = '</div>';
        }

        drawTimeScale(this.topTimeScale, 'top');
        drawTimeScale(this.middleTimeScale, 'middle');
        drawTimeScale(this.bottomTimeScale, 'bottom');

        this.headerEl.innerHTML = sb.join('');
    },

    refreshBody: function (region, returns) {
        var rowHeight = this.rowHeight;
        var tType = this.topTimeScale.type,
            bType = this.bottomTimeScale.type;
        var data = this.getItems();
        var startRow = region.startRow,
            endRow = region.endRow;
        var offset = this.getOffsetByDate(region.startDate);
        this._readOnly = this.isReadOnly();

        var viewBox = this.getViewportBounds(region);
        var VLeft = viewBox.left,
            VTop = viewBox.top,
            VWidth = viewBox.width,
            VHeight = viewBox.height;

        var sb = [];

        var isTrack = this.isTrackModel();
        var isBaseline = false;

        var refreshItemID = this._refreshItem ? this._refreshItem._id : null;
        for (var i = startRow, l = endRow; i <= l; i++) {
            var record = data[i];
            if (!record) continue;
            if (
                !mini.isDate(record.Start) ||
                !mini.isDate(record.Finish) ||
                (refreshItemID && refreshItemID != record._id)
            ) {
                continue;
            }

            if (record.Finish < region.startDate || record.Start > region.endDate) continue;

            var itemBox = this.getItemBox(record, VLeft, VTop);
            this.createItem(record, itemBox, sb, refreshItemID, isTrack, false);
        }

        if (isTrack) {
            for (var i = startRow, l = endRow; i <= l; i++) {
                var record = data[i];
                if (!record) continue;
                var baseline = this.getBaseline(record);
                if (!baseline || !baseline.Start || !baseline.Finish) continue;

                if (baseline.Finish < region.startDate || baseline.Start > region.endDate) continue;

                var itemBox = this.getItemBox(record, VLeft, VTop, baseline);
                this.createItem(record, itemBox, sb, refreshItemID, isTrack, true);
            }
        }

        this.refreshTimelines(region, sb);

        if (returns) return sb.join('');

        this.barsEl.innerHTML = sb.join('');
    },

    refreshTimelines: function (region, sb) {
        if (this.timeLines) {
            var vwidth = this.getViewportWidth(),
                vheight = this.getViewportHeight();

            var LEFT = this.getOffsetByDate(region.startDate);
            for (var i = 0, l = this.timeLines.length; i < l; i++) {
                var tline = this.timeLines[i];
                var lineDate = tline.date;
                if (lineDate) {
                    var dateTitle = mini.formatDate(tline.date, 'yyyy-MM-dd');
                    var title = tline.text || dateTitle;
                    var style = tline.style || '';
                    var left = this.getOffsetByDate(lineDate) - LEFT;
                    var html = tline.html || '';
                    var width = tline.width || 1;
                    var color = tline.color || 'red';
                    sb[sb.length] =
                        '<div index="' +
                        i +
                        '" title="' +
                        title +
                        '" style="background:' +
                        color +
                        ';width:' +
                        width +
                        'px;' +
                        style +
                        ';left:' +
                        left +
                        'px;height:' +
                        (vheight - 18) +
                        'px;" class="mini-gantt-timeline">' +
                        html +
                        '</div>';

                    var css = tline.position == 'top' ? 'top: 2px;' : 'top:' + (vheight - 42) + 'px;';
                    if (tline.position == 'center') css = 'top:' + (vheight / 2 - 25) + 'px;';

                    sb[sb.length] =
                        '<div style="' +
                        css +
                        'left:' +
                        (left + 4) +
                        'px;position:absolute;z-index:200;white-space:nowrap;border:solid 1px ' +
                        color +
                        ';" class="mini-gantt-timeline-label">' +
                        title +
                        '</div>';
                }
            }
        }
    },

    isHideBar: function (item, isBaseline) {
        if (!isBaseline && item.HideBar === true) return true;
        return false;
    },

    createItem: function (record, itemBox, sb, refreshItemID, isTrack, isBaseLine) {
        if (this.isHideBar(record, isBaseLine)) return;

        var h = itemBox.height;
        var top = itemBox.top;
        var left = itemBox.left;
        var right = itemBox.right;
        var w = right - left;
        if (w < 0) {
            return;
        }
        if (w < 2) w = 2;

        var percentComplete = record.PercentComplete || 0;
        var percentWidth = parseInt((w * percentComplete) / 100);
        if (isBaseLine) percentWidth = 0;

        var isMilestone = this.isMilestone(record);

        var cls = 'mini-gantt-item ';
        if (this.isCritical(record)) cls += ' mini-gantt-critical ';
        var ex = this._OnItemDragStart(record, 'move');
        if (!isBaseLine && !this._readOnly && !ex.cancel) cls += ' mini-gantt-move ';
        if (isBaseLine) cls += ' mini-gantt-baseline ';
        if (isTrack == true) cls += ' mini-gantt-track ';

        var e = this._OnDrawItem(record, itemBox, isBaseLine);

        if (e.itemCls) {
            cls += ' ' + e.itemCls + ' ';
        }

        if (e.extraHtml) {
            sb[sb.length] = e.extraHtml;
        }

        if (e.itemHtml === null) {
            if (this.isSummary(record) && !isBaseLine) {
                sb[sb.length] = '<div id="';
                sb[sb.length] = record._id;
                sb[sb.length] = '" data-identifier-no="';
                sb[sb.length] = record.identifierNo;
                sb[sb.length] = '" class="';
                sb[sb.length] = cls;
                sb[sb.length] = ' mini-gantt-summary" style="left:';
                sb[sb.length] = left;
                sb[sb.length] = 'px;top:';
                sb[sb.length] = top;
                sb[sb.length] = 'px;width:';
                sb[sb.length] = w;
                sb[sb.length] =
                    'px;"><div class="mini-gantt-summary-left"></div><div class="mini-gantt-summary-right"></div></div>';
            } else if (isMilestone) {
                if (isBaseLine) cls += ' mini-gantt-baselinemilestone ';
                sb[sb.length] = '<div id="';
                sb[sb.length] = record._id;
                sb[sb.length] = '" data-identifier-no="';
                sb[sb.length] = record.identifierNo;
                sb[sb.length] = '" class="';
                sb[sb.length] = cls;
                sb[sb.length] = ' mini-gantt-milestone" style="left:';
                sb[sb.length] = left;
                sb[sb.length] = 'px;top:';
                sb[sb.length] = top;
                sb[sb.length] = 'px;"></div>';
            } else {
                sb[sb.length] = '<div id="';
                sb[sb.length] = record._id;
                sb[sb.length] = '" data-identifier-no="';
                sb[sb.length] = record.identifierNo;
                sb[sb.length] = '" class="';
                sb[sb.length] = cls;
                sb[sb.length] = '" style="left:';
                sb[sb.length] = left;
                sb[sb.length] = 'px;top:';
                sb[sb.length] = top;
                sb[sb.length] = 'px;height:';

                sb[sb.length] = h;
                sb[sb.length] = 'px;width:';

                sb[sb.length] = w;
                sb[sb.length] = 'px;"><div class="mini-gantt-percentcomplete-text">';
                sb[sb.length] = percentComplete + '%';
                sb[sb.length] = '</div><div class="mini-gantt-percentcomplete" style="width:';
                sb[sb.length] = percentWidth;
                sb[sb.length] = 'px;"></div></div>';
            }
        } else {
            sb[sb.length] = e.itemHtml;
        }

        if (!isBaseLine && e.showLabel && !refreshItemID) {
            var label = mini.htmlEncode(e.label);
            var identifierNo = e?.item?.identifierNo || ''
            var labelLeft = right + 5;
            if (isMilestone) {
                labelLeft += 10;
            }

            sb[sb.length] = '<div id="';
            sb[sb.length] = record._id;
            if (e.labelAlign == 'left') {
                sb[sb.length] = '" class="mini-gantt-label" style="text-align:right;width:250px;left:';
                var labelRight = left - 255;
                sb[sb.length] = labelRight;
            } else {
                sb[sb.length] = '" class="mini-gantt-label" style="left:';
                sb[sb.length] = labelLeft;
            }

            sb[sb.length] = 'px;top:';
            sb[sb.length] = top - 4;
            sb[sb.length] = 'px;">';
            sb[sb.length] = label + ' ' +　identifierNo;
            sb[sb.length] = '</div>';

            if (e.label2) {
                sb[sb.length] = '<div id="';
                sb[sb.length] = record._id;
                if (e.label2Align == 'left') {
                    sb[sb.length] = '" class="mini-gantt-label" style="text-align:right;width:250px;left:';
                    var labelRight = left - 255;
                    sb[sb.length] = labelRight;
                } else {
                    sb[sb.length] = '" class="mini-gantt-label" style="left:';
                    sb[sb.length] = labelLeft;
                }

                sb[sb.length] = 'px;top:';
                sb[sb.length] = top - 4;
                sb[sb.length] = 'px;">';
                sb[sb.length] = mini.htmlEncode(e.label2);
                sb[sb.length] = '</div>';
            }
        }
    },

    refreshItem: function (item) {
        item = this.getItem(item);
        if (!item) return;
        this._refreshItem = item;
        var id = item._id;

        var region = this.updateViewRegion();
        var doms = this.barsEl.getElementsByTagName('div');
        for (var i = 0, l = doms.length; i < l; i++) {
            var dom = doms[i];
            if (dom && (dom.id == this.id + '_' + id || dom.id == id)) {
                mini.removeNode(dom);
            }
        }

        var html = this.refreshBody(region, true);
        mini.append(this.barsEl, html);

        this.refreshLinkLines(region);

        this._refreshItem = null;
    },

    refreshGridLines: function (region) {
        var sss = new Date();
        var sb = [];
        var tType = this.topTimeScale.type,
            bType = this.bottomTimeScale.type,
            bNumber = this.bottomTimeScale.number;
        var rowHeight = this.rowHeight;
        var data = this.getItems();

        var startRow = region.startRow,
            endRow = region.endRow;

        var vwidth = region.width,
            vheight = region.height;

        var viewportHeight = this.getViewportHeight();

        var flag = true;

        if (flag) {
            var topOffset = region.yOffset - region.topOffset;

            var top = 0;
            for (var i = startRow, l = endRow; i <= l; i++) {
                var record = data[i];
                if (!record) continue;
                var h = record._height ? record._height : rowHeight;

                if (this.showGridLines) {
                    var e = { row: record, cls: '' };
                    var isSelected = this.store.isSelected(record); // 是否选中了行数据
                    if (isSelected) e.cls += ' mini-gantt-rowselected';
                    this.fire('drawrow', e);
                    sb[sb.length] = '<div id="';
                    sb[sb.length] = record._id + 'row';
                    sb[sb.length] = '" class="mini-gantt-row ';
                    sb[sb.length] = e.cls;
                    sb[sb.length] = '" data-identifier-no="';
                    sb[sb.length] = record.identifierNo;
                    sb[sb.length] = '" style="top:';
                    sb[sb.length] = top + topOffset;
                    sb[sb.length] = 'px;height:';

                    sb[sb.length] = h;
                    sb[sb.length] = 'px;width:';
                    sb[sb.length] = vwidth;
                    sb[sb.length] = 'px;"></div>';
                }

                top += h;
            }

            var startDate = region.startDate,
                endDate = region.endDate;

            var endTime = endDate?.getTime();
            var left = this.getOffsetByDate(region.startDate);
            for (var date = startDate; date?.getTime() <= endTime; ) {
                var next = this.getTimeScaleNextDate(date, bType, bNumber);

                var topLeft = this.getOffsetByDate(date);
                var topRight = this.getOffsetByDate(next);
                var offset = topLeft - left;
                var w = topRight - topLeft;

                var cls = 'mini-gantt-column ';
                var isWorking = this.isWorking(date, this.bottomTimeScale);
                if (!isWorking) {
                    cls += 'mini-gantt-offday ';
                }

                if (this.showGridLines || !isWorking) {
                    var e = { date: date, cls: '' };
                    this.fire('drawcolumn', e);

                    sb[sb.length] = '<div class="';
                    sb[sb.length] = cls;
                    sb[sb.length] = e.cls;
                    sb[sb.length] = '" style="left:';
                    sb[sb.length] = offset;
                    sb[sb.length] = 'px;width:';

                    sb[sb.length] = w;
                    sb[sb.length] = 'px;height:';
                    sb[sb.length] = 100;
                    sb[sb.length] = '%;" ></div>';
                }

                date = next;
            }

            var left = this.getOffsetByDate(region.startDate);
            var top = 0;
            for (var i = startRow, l = endRow; i <= l; i++) {
                var record = data[i];
                if (!record) continue;
                var h = record._height ? record._height : rowHeight;

                for (var date = startDate; date?.getTime() <= endTime; ) {
                    var next = this.getTimeScaleNextDate(date, bType, bNumber);

                    var topLeft = this.getOffsetByDate(date);
                    var topRight = this.getOffsetByDate(next);
                    var offset = topLeft - left;
                    var w = topRight - topLeft;

                    var e = { row: record, date: date, cls: '', html: '' };
                    this.fire('drawcell', e);

                    if (e.cls || e.html) {
                        sb[sb.length] = '<div class="mini-gantt-cell ';
                        sb[sb.length] = e.cls;
                        sb[sb.length] = '" style="left:';
                        sb[sb.length] = offset;
                        sb[sb.length] = 'px;top:';
                        sb[sb.length] = top;
                        sb[sb.length] = 'px;height:';
                        sb[sb.length] = h;
                        sb[sb.length] = 'px;width:';
                        sb[sb.length] = w;
                        sb[sb.length] = 'px;">';
                        sb[sb.length] = e.html;
                        sb[sb.length] = '</div>';
                    }

                    date = next;
                }

                top += h;
            }
        }

        this.gridlinesEl.innerHTML = sb.join('');
    },

    getXByDate: function (date) {
        this.updateViewRegion();
        var x = this.getOffsetByDate(date) - this._viewLeftOffset;

        return x;
    },

    getViewRegion: function () {
        this._updateItemsInfo();
        if (!this.viewRegion) this.updateViewRegion();
        return this.viewRegion;
    },

    updateViewRegion: function () {
        this._updateItemsInfo();
        this.viewRegion = this.createViewRegion();
        return this.viewRegion;
    },

    createViewRegion: function () {
        this._updateItemsInfo();
        var x = this.scrollLeft,
            y = this.scrollTop;

        var viewportWidth = this.getViewportWidth();
        var viewportHeight = this.getViewportHeight();
        var width = viewportWidth,
            height = viewportHeight;
        var bottom = y + height,
            right = x + width;

        var rowHeight = this.rowHeight,
            timeScaleWidth = this.getBottomTimeScaleWidth();
        var tType = this.topTimeScale.type,
            bType = this.bottomTimeScale.type;
        var data = this.getItems();

        var startRow = 0,
            endRow = 0;

        var top = 0;
        var yOffset = 0;
        for (var i = 0, l = data.length; i < l; i++) {
            var r = data[i];
            var h = r._height ? r._height : rowHeight;
            top += h;
            if (top >= y) {
                startRow = i;
                yOffset = top - h;
                top = yOffset;

                break;
            }
        }

        for (var i = startRow, l = data.length; i < l; i++) {
            var r = data[i];
            var h = r._height ? r._height : rowHeight;
            if (top > bottom) {
                endRow = i;
                break;
            }
            top += h;
        }
        if (endRow == 0) endRow = data.length - 1;

        var startDate = this.getTimeScaleStartDate(this.getDateByOffset(x), bType, this.bottomTimeScale.number);
        var endDate = this.getTimeScaleStartDate(this.getDateByOffset(x + width), bType);

        var region = {
            width: viewportWidth,
            height: viewportHeight,
            startRow: startRow,
            endRow: endRow,

            startDate: startDate,
            endDate: endDate,

            yOffset: yOffset,
            topOffset: y,

            scrollLeft: this.scrollLeft
        };

        this.viewRegion = region;

        this._viewLeftOffset = this.getOffsetByDate(region.startDate);

        return region;
    },

    _vscrollTimer: null,
    _hscrollTimer: null,
    __onVScroll: function (e) {
        var sf = this;
        if (this._vscrollTimer) return;
        this._vscrollTimer = setTimeout(function () {
            var scrollTop = sf.vscrollerEl.scrollTop;

            if (!sf.refreshScrollComplete) {
                sf.scrollTop = scrollTop;
                sf.invalidate();
            } else {
                sf.scrollTop = scrollTop;
                sf.updateViewRegion();
            }

            sf._vscrollTimer = null;

            sf.fire('scroll', {
                direction: 'vertical'
            });
        }, 30);
    },
    __onHScroll: function (e) {
        var sf = this;
        if (this._hscrollTimer) return;
        this._hscrollTimer = setTimeout(function () {
            sf.scrollLeft = sf.hscrollerEl.scrollLeft;
            sf.invalidate();

            sf._hscrollTimer = null;

            sf.fire('scroll', {
                direction: 'horizontal'
            });
        }, 30);
    },
    __OnMousewheel: function (e, delta) {
        var oe = e;
        var e = e.wheelDelta ? e : e.originalEvent;

        var wheelDelta = e.wheelDelta || -e.detail * 24;
        var top = this.vscrollerEl.scrollTop;

        top -= wheelDelta;

        this.vscrollerEl.scrollTop = top;

        if (top == this.vscrollerEl.scrollTop) {
            oe.preventDefault();
        } else {
        }
    },

    getHeaderCellByEvent: function (event) {
        var t = mini.findParent(event.target, 'mini-ganttview-headercell');
        if (!t) return null;

        var position = mini.findParent(event.target, 'mini-ganttview-toptimescale') ? 'top' : 'bottom';
        var timescale = position == 'top' ? this.topTimeScale : this.bottomTimeScale;
        var date = new Date(parseInt($(t).attr('time')));
        return {
            position: position,
            timescale: timescale,
            date: date
        };
    },

    __OnClick: function (e) {
        var item = this.getItemByEvent(e);
        if (item) this._OnItemClick(item, e);

        var headerCell = this.getHeaderCellByEvent(e);
        if (headerCell) {
            if (this.headerCellClick) this.headerCellClick(headerCell);
        }

        if (mini.isAncestor(this.viewportEl, e.target) && !mini.findParent(e.target, 'mini-gantt-item')) {
            var date = this.getDateByPageX(e.pageX);

            var row = this.getRowByPageY(e.pageY);

            this.fire('cellclick', { date: date, row: row });
        }
    },

    removeLinkOnDblClick: true,

    __OnDblClick: function (e) {
        if (this.owner.readOnly) return false;
        var item = this.getItemByEvent(e);
        if (item) this._OnItemDblClick(item, e);

        var link = this.getLinkByEvent(e);
        if (link) {
            var e = { cancel: false, link: link };
            this.owner.fire('beforelinkremove', e);
            if (e.cancel) return;

            if (this.removeLinkOnDblClick) {
                if (confirm(mini.Gantt.DeleteLink)) {
                    this.owner.removeLink(link);
                    this.owner.fire('linkremove', { link: link });
                } else {
                }
            }
            return;
        }

        if (mini.isAncestor(this.viewportEl, e.target) && !mini.findParent(e.target, 'mini-gantt-item')) {
            var date = this.getDateByPageX(e.pageX);

            var row = this.getRowByPageY(e.pageY);

            this.fire('celldblclick', { date: date, row: row });
        }
    },
    __OnMouseDown: function (e) {
        var item = this.getItemByEvent(e);
        if (item) this._OnItemMouseDown(item, e);
    },

    stopContextMenu: true,
    __OnContextMenu: function (e) {
        e.preventDefault();
        if (this.stopContextMenu) e.stopPropagation();

        var item = this.getItemByEvent(e);
        if (item) this._OnItemContextMenu(item, e);
    },

    getRowByPageY: function (y) {
        return this.getDragRecord(y);
    },

    getBottomTimeScaleWidth: function () {
        return this.bottomTimeScale.width;
    },

    getDateByPageX: function (x) {
        var region = this.viewRegion;
        var viewBox = this.getViewportBounds(region);
        var bodyBox = this.getViewportBox(region);
        var offset = x - bodyBox.x + viewBox.left;
        return this.getDateByOffset(offset);
    },
    getDragRecord: function (y) {
        this._updateItemsInfo();
        var ganttview = this;
        var region = ganttview.updateViewRegion();
        var viewBox = ganttview.getViewportBounds(region);
        var VLeft = viewBox.left,
            VTop = viewBox.top,
            VWidth = viewBox.width,
            VHeight = viewBox.height;

        var viewportBox = ganttview.getViewportBox();

        if (y < viewportBox.y || y > viewportBox.bottom) return null;
        var y = y - viewportBox.y;

        y -= region.yOffset - region.topOffset;

        var dropNode = null;

        var data = ganttview.getItems();
        for (var i = region.startRow, l = region.endRow; i <= l; i++) {
            var node = data[i];
            if (!node) continue;

            var top = ganttview._TaskTops[node._id] - VTop;
            var height = mini.isNumber(node._height) ? node._height : ganttview.rowHeight;

            if (top <= y && y <= top + height) {
                dropNode = node;
                break;
            }
        }
        return dropNode;
    },
    getDateByOffset: function (offset) {
        var start = new Date(1900, 0, 1),
            finish = new Date(5000, 0, 1);

        var bType = this.bottomTimeScale.type;
        var sf = this;

        var width = (this.bottomTimeScale.width / this.bottomTimeScale.number) * this.timelineRatio;

        function findDate() {
            var halfDate = new Date(start?.getTime() + (finish - start) / 2);
            var nowOffset = sf.getOffsetByDate(halfDate);
            var jian = nowOffset - offset;
            if (Math.abs(jian) <= width) {
                switch (bType) {
                    case 'year':
                        halfDate?.setMonth(halfDate?.getMonth() + -(12 / width) * jian);
                        break;
                    case 'halfyear':
                        halfDate?.setMonth(halfDate?.getMonth() + -(6 / width) * jian);
                        break;
                    case 'quarter':
                        halfDate?.setMonth(halfDate?.getMonth() + -(4 / width) * jian);
                        break;
                    case 'month':
                        halfDate?.setDate(halfDate?.getDate() + -(30 / width) * jian);
                        break;
                    case 'tendays':
                        halfDate?.setDate(halfDate?.getDate() + -(10 / width) * jian);
                        break;
                    case 'week':
                        halfDate?.setDate(halfDate?.getDate() + -(7 / width) * jian);
                        break;
                    case 'day':
                        halfDate?.setHours(halfDate?.getHours() + -(24 / width) * jian);
                        break;
                    case 'hour':
                        halfDate?.setMinutes(halfDate?.getMinutes() + -(60 / width) * jian);
                        break;
                    case 'minutes':
                        halfDate?.setSeconds(halfDate?.getSeconds() + -(60 / width) * jian);
                        break;
                    case 'seconds':
                        halfDate?.setSeconds(halfDate?.getSeconds() + -jian / width);
                        break;
                }
                return halfDate;
            } else if (jian > 0) {
                finish = halfDate;
            } else if (jian < 0) {
                start = halfDate;
            }
            return findDate();
        }
        var date = findDate();
        return date;
    },

    getOffsetByDate: function (date) {
        var time = date - this.startDate;
        var oneWidth = (this.bottomTimeScale.width / this.bottomTimeScale.number) * this.timelineRatio;
        switch (this.bottomTimeScale.type) {
            case 'year':
                var Year = time / (1000 * 60 * 60 * 24 * 365);
                sw = oneWidth * Year;
                break;
            case 'halfyear':
                var HalfYear = time / ((1000 * 60 * 60 * 24 * 365) / 2);
                sw = oneWidth * HalfYear;
                break;
            case 'quarter':
                var Quarter = time / ((1000 * 60 * 60 * 24 * 365) / 4);
                sw = oneWidth * Quarter;
                break;
            case 'month':
                var Month = time / (1000 * 60 * 60 * 24 * 30);
                sw = oneWidth * Month;
                break;
            case 'tendays':
                var TenDays = time / (1000 * 60 * 60 * 24 * 10);
                sw = oneWidth * TenDays;
                break;
            case 'week':
                var Week = time / (1000 * 60 * 60 * 24 * 7);
                sw = oneWidth * Week;
                break;
            case 'day':
                var Day = time / (1000 * 60 * 60 * 24);
                sw = oneWidth * Day;
                break;
            case 'hour':
                var Hour = time / (1000 * 60 * 60);
                sw = oneWidth * Hour;
                break;
            case 'minutes':
                var Minutes = time / (1000 * 60);
                sw = oneWidth * Minutes;
                break;
            case 'seconds':
                var Seconds = time / 1000;
                sw = oneWidth * Seconds;
                break;
        }

        return parseInt(sw);
    },
    _cloneDate: function (date) {
        return new Date(date?.getTime());
    },
    _clearDate: function (date) {
        return new Date(date?.getFullYear(), date?.getMonth(), date?.getDate());
    },
    _addDate: function (date, type, num) {
        date = new Date(date?.getTime());
        switch (type.toLowerCase()) {
            case 'year':
                date?.setFullYear(date?.getFullYear() + num);
                break;

            case 'month':
                date?.setMonth(date?.getMonth() + num);
                break;
            case 'week':
                date?.setDate(date?.getDate() + num * 7);
                break;
            case 'day':
                date?.setDate(date?.getDate() + num);
                break;
            case 'hour':
                date?.setHours(date?.getHours() + num);
                break;
            case 'minutes':
                date?.setMinutes(date?.getMinutes() + num);
                break;
            case 'seconds':
                date?.setSeconds(date?.getSeconds() + num);
                break;
        }
        return date;
    },
    getViewportBox: function () {
        var box = this.getBox(true);
        var headerHeight = this.getHeaderHeight();
        box.y += headerHeight;
        box.height -= headerHeight;
        box.bottom = box.y + box.height;
        return box;
    },
    getViewportBounds: function (region) {
        this._updateItemsInfo();
        var row = this.getItems()[region.startRow];
        var box = {
            left: this.getOffsetByDate(region.startDate),
            top: row ? this._TaskTops[row._id] : 0,
            width: region.width,
            height: region.height
        };
        box.right = box.left + box.width;
        box.bottom = box.top + box.height;
        return box;
    },
    getItemTop: function (item) {
        this._updateItemsInfo();
        return this._TaskTops[item._id];
    },
    getItemHeight: function (item) {
        var h = mini.isNumber(item._height) ? item._height : this.rowHeight;
        return h;
    },

    topOffset: 4,
    baselinePosition: 'bottom',

    baseLineBarHeight: 7,

    barHeight: 14,

    getItemBox: function (item, leftOffset, topOffset, baseline) {
        var region = this.viewRegion;
        topOffset = topOffset || 0;
        topOffset -= region.yOffset - region.topOffset;

        var start = baseline ? baseline.Start : item.Start;
        var finish = baseline ? baseline.Finish : item.Finish;

        var left = this.getOffsetByDate(start);

        if (this.isMilestone(item) && finish) {
        }
        var right = this.getOffsetByDate(finish);
        var width = right - left;

        var height = this.getItemHeight(item);
        var top = this.getItemTop(item);

        leftOffset = leftOffset || 0;
        topOffset = topOffset || 0;
        left -= leftOffset;
        top -= topOffset;
        var box = {
            left: left,

            top: top + (this.rowHeight - this.barHeight) / 2,
            width: width,
            height: this.barHeight
        };
        box.right = box.left + box.width;
        box.bottom = box.top + box.height;
        if (this.isMilestone(item) && !this.isSummary(item)) {
            box.width = 12;

            box.left = box.left - box.width / 2;

            if (this.bottomTimeScale.type == 'month') {
                box.left = box.right - box.width / 2;
            }

            box.top = box.top - 3;
            box.height = 18;
            box.bottom = box.top + box.height;
        } else {
            if (this.isTrackModel()) {
                var barHeight = this.baseLineBarHeight;

                if (this.baselinePosition == 'bottom') {
                    if (baseline) {
                        box.top = top + height / 2 + 1;
                        box.height = barHeight;
                        box.bottom = box.top + box.height;
                    } else {
                        box.top = top + 2;
                        box.height = barHeight;
                        box.bottom = box.top + box.height;
                    }
                } else {
                    if (!baseline) {
                        box.top = top + height / 2 + 1;
                        box.height = barHeight;
                        box.bottom = box.top + box.height;
                    } else {
                        box.top = top + 2;
                        box.height = barHeight;
                        box.bottom = box.top + box.height;
                    }
                }
            }
        }
        box.x = box.left;
        box.y = box.top;

        return box;
    },
    getViewStartItem: function () {
        this.updateViewRegion();

        return this.getItems()[this.viewRegion.startRow];
    },
    getViewStartDate: function () {
        return this.viewRegion.startDate;
    },

    getItem: function (id) {
        if (typeof id == 'object') id = id._id;
        return this.store.getByInternalId(id);
    },
    getLink: function (item, preItem) {
        item = this.getItem(item);
        preItem = this.getItem(preItem);
        var link = this._linkHashed[item._id + '__' + preItem._id];
        if (link) link.TaskUID = item.UID;
        if (!link) {
            link = this._linkHashed[preItem._id + '__' + item._id];
            if (link) link.TaskUID = preItem.UID;
        }
        return link;
    },
    getItemByEvent: function (event) {
        var t = mini.findParent(event.target, 'mini-gantt-item');
        var id = t ? t.id : event.target.id;
        if (t) {
            var ids = id.split('_');
            id = ids[ids.length - 1];
        }
        var item = this.getItem(id);
        if (!item) {
            var t = mini.findParent(event.target, 'mini-gantt-item');
            if (t) {
                id = t.id;
                item = this.getItem(id);
            }
        }
        return item;
    },
    getLinkByEvent: function (event) {
        if (!mini.findParent(event.target, 'mini-gantt-line')) return;

        var id = event.target.id;
        var ids = id.split('__');

        var link = this.getLink(ids[0], ids[1]);

        return link;
    },

    refreshLinkLines: function (region) {
        if (!this.showLinkLines) return;
        var data = this.getItems();
        if (data.length == 0) return;
        var w = this.getBottomTimeScaleWidth();
        var rowHeight = this.rowHeight;
        var startRow = region.startRow,
            endRow = region.endRow;
        var startDate = region.startDate,
            endDate = region.endDate;
        var startTime = startDate?.getTime(),
            endTime = endDate?.getTime();

        var taskUIDs = this._TaskUIDs,
            indexs = this._TaskIndexs;
        var drawLinks = [];
        var linkHashed = (this._linkHashed = {});
        var refreshItemId = this._refreshItem ? this._refreshItem._id : null;

        for (var i = 0, l = data.length; i < l; i++) {
            var task = data[i];
            var taskUID = task.UID;
            if (!task.Start || !task.Finish) continue;

            var start1 = task.Start?.getTime(),
                finish1 = task.Finish?.getTime();

            var index1 = indexs[task._id];
            var links = task.PredecessorLink;
            if (!links || links.length == 0) continue;

            for (var j = 0, k = links.length; j < k; j++) {
                var link = links[j];
                var preTask = taskUIDs[link.PredecessorUID];
                if (!preTask) continue;

                linkHashed[task._id + '__' + preTask._id] = link;

                if (!preTask.Start || !preTask.Finish) continue;
                var start2 = preTask.Start?.getTime(),
                    finish2 = preTask.Finish?.getTime();
                var index2 = indexs[preTask._id];

                if (
                    (index1 >= startRow && index1 <= endRow) ||
                    (index2 >= startRow && index2 <= endRow) ||
                    (index1 < startRow && index2 > endRow) ||
                    (index2 < startRow && index1 > endRow)
                ) {
                    if (start1 > endTime && start2 > endTime) {
                    } else if (finish1 < startTime && finish2 < startTime) {
                    } else {
                        link.TaskUID = task.UID;
                        drawLinks.push(link);
                    }
                }
            }
        }

        this._doDrawLinks(drawLinks, region);
    },
    getFromTo: function (link) {
        this._updateItemsInfo();
        var from = this._TaskUIDs[link.PredecessorUID];
        var to = this._TaskUIDs[link.TaskUID];
        return [from, to];
    },
    getLinkType: function (link) {
        return link.Type;
    },

    _doDrawLinks: function (drawLinks, region) {
        var data = this.getItems();
        if (data.length == 0) return;
        var timeWidth = this.getBottomTimeScaleWidth();
        var rowHeight = this.rowHeight;
        var startRow = region.startRow,
            endRow = region.endRow;
        var startDate = region.startDate,
            endDate = region.endDate;
        var startTime = startDate?.getTime(),
            endTime = endDate?.getTime();
        var taskUIDs = this._TaskUIDs,
            indexs = this._TaskIndexs;

        var viewBox = this.getViewportBounds(region);
        var VLeft = viewBox.left,
            VTop = viewBox.top,
            VWidth = viewBox.width,
            VHeight = viewBox.height;

        var drawLines = [];
        for (var i = 0, l = drawLinks.length; i < l; i++) {
            var link = drawLinks[i];
            var fromTo = this.getFromTo(link);
            var from = fromTo[0];
            var to = fromTo[1];

            if (!from || !to) continue;
            if (!from.Start || !from.Finish) continue;
            if (!to.Start || !to.Finish) continue;
            var fromBox = this.getItemBox(from, VLeft, VTop);
            var toBox = this.getItemBox(to, VLeft, VTop);

            if (fromBox.right < 0 && toBox.right < 0) continue;
            if (fromBox.bottom < 0 && toBox.bottom < 0) continue;
            if (fromBox.left > VWidth && toBox.left > VWidth) continue;

            if (fromBox.top > VHeight && toBox.top < VHeight && fromBox.top < VHeight && toBox.top > VHeight) continue;

            var drawLine = [];
            drawLine.id = from._id + '__' + to._id;

            switch (parseInt(this.getLinkType(link))) {
                case 0:
                    if (fromBox.right < toBox.right) {
                        var fromTop = fromBox.top + fromBox.height / 2;
                        var toTop = toBox.top;
                        drawLine.arrowType = 'bottom';
                        if (fromBox.top > toBox.top) {
                            toTop = toBox.bottom;
                            drawLine.arrowType = 'top';
                        }

                        var p1 = [fromBox.right, fromTop];
                        var p2 = [toBox.right, fromTop];
                        var p3 = [toBox.right, toTop];
                        drawLine.push([p1, p2]);
                        drawLine.push([p2, p3]);
                    } else {
                        var fromTop = fromBox.top + fromBox.height / 2;
                        var toTop = toBox.top + toBox.height / 2;
                        drawLine.arrowType = 'left';

                        var p1 = [fromBox.right, fromTop];
                        var p2 = [fromBox.right + 6, fromTop];
                        var p3 = [fromBox.right + 6, toTop];
                        var p4 = [toBox.right, toTop];
                        drawLine.push([p1, p2]);
                        drawLine.push([p2, p3]);
                        drawLine.push([p3, p4]);
                    }
                    break;
                case 1:
                    if (fromBox.right <= toBox.left) {
                        var fromTop = fromBox.top + fromBox.height / 2;
                        var fromLeft = fromBox.right;
                        var toTop = toBox.top;
                        var toLeft = toBox.left;
                        drawLine.arrowType = 'bottom';
                        if (fromBox.top > toBox.top) {
                            toTop = toBox.bottom;
                            drawLine.arrowType = 'top';
                        }
                        var p1 = [fromLeft, fromTop];
                        var p2 = [toLeft, fromTop];
                        var p3 = [toLeft, toTop];

                        if (fromBox.right == toBox.left) {
                            p1 = [fromLeft, fromTop];
                            p2 = [toLeft + 2, fromTop];
                            p3 = [toLeft + 2, toTop];
                        }

                        drawLine.push([p1, p2]);
                        drawLine.push([p2, p3]);
                    } else {
                        var fromTop = fromBox.top + fromBox.height / 2;
                        var fromLeft = fromBox.right;
                        var toTop = toBox.top + toBox.height / 2;
                        var toLeft = toBox.left;
                        var toTop2 = toBox.top - 4;
                        drawLine.arrowType = 'right';
                        if (fromBox.top > toBox.top) {
                            toTop2 = toBox.bottom + 4;
                        }

                        var p1 = [fromLeft, fromTop];
                        var p2 = [fromLeft + 6, fromTop];
                        var p3 = [fromLeft + 6, toTop2];
                        var p4 = [toLeft - 10, toTop2];
                        var p5 = [toLeft - 10, toTop];
                        var p6 = [toLeft, toTop];
                        drawLine.push([p1, p2]);
                        drawLine.push([p2, p3]);
                        drawLine.push([p3, p4]);
                        drawLine.push([p4, p5]);
                        drawLine.push([p5, p6]);
                    }
                    break;
                case 3:
                    if (fromBox.left < toBox.left) {
                        var fromTop = fromBox.top + fromBox.height / 2;
                        var fromLeft = fromBox.left;
                        var toTop = toBox.top + toBox.height / 2;
                        var toLeft = toBox.left;
                        drawLine.arrowType = 'right';

                        var p1 = [fromLeft, fromTop];
                        var p2 = [fromLeft - 6, fromTop];
                        var p3 = [fromLeft - 6, toTop];
                        var p4 = [toLeft, toTop];
                        drawLine.push([p1, p2]);
                        drawLine.push([p2, p3]);
                        drawLine.push([p3, p4]);
                    } else {
                        var fromTop = fromBox.top + fromBox.height / 2;
                        var fromLeft = fromBox.left;
                        var toTop = toBox.top;
                        var toLeft = toBox.left;
                        drawLine.arrowType = 'bottom';
                        if (fromBox.top > toBox.top) {
                            toTop = toBox.bottom;
                            drawLine.arrowType = 'top';
                        }

                        var p1 = [fromLeft, fromTop];
                        var p2 = [toLeft, fromTop];
                        var p3 = [toLeft, toTop];
                        drawLine.push([p1, p2]);
                        drawLine.push([p2, p3]);
                    }
                    break;
                case 2:
                    if (fromBox.left < toBox.right) {
                        var fromTop = fromBox.top + fromBox.height / 2;
                        var fromLeft = fromBox.left;
                        var toTop = toBox.top + toBox.height / 2;
                        var toLeft = toBox.right;
                        var toTop2 = toBox.top - 4;
                        drawLine.arrowType = 'left';
                        if (fromBox.top > toBox.top) {
                            toTop2 = toBox.bottom + 4;
                        }

                        var p1 = [fromLeft, fromTop];
                        var p2 = [fromLeft - 6, fromTop];
                        var p3 = [fromLeft - 6, toTop2];
                        var p4 = [toLeft + 10, toTop2];
                        var p5 = [toLeft + 10, toTop];
                        var p6 = [toLeft, toTop];
                        drawLine.push([p1, p2]);
                        drawLine.push([p2, p3]);
                        drawLine.push([p3, p4]);
                        drawLine.push([p4, p5]);
                        drawLine.push([p5, p6]);
                    } else {
                        var fromTop = fromBox.top + fromBox.height / 2;
                        var fromLeft = fromBox.left;
                        var toTop = toBox.top;
                        var toLeft = toBox.right;
                        drawLine.arrowType = 'bottom';
                        if (fromBox.top > toBox.top) {
                            toTop = toBox.bottom;
                            drawLine.arrowType = 'top';
                        }
                        var p1 = [fromLeft, fromTop];
                        var p2 = [toLeft, fromTop];
                        var p3 = [toLeft, toTop];
                        drawLine.push([p1, p2]);
                        drawLine.push([p2, p3]);
                    }
                    break;
                default:
                    throw new Error('');
                    break;
            }
            drawLine.Critical = this.isCritical(from) && this.isCritical(to);

            drawLine.Cls = link.Cls || '';
            drawLines.push(drawLine);

            if (this.events.drawlink) {
                var e = { from: from, to: to, cls: '' };
                this.fireEvent('drawlink', e);
                if (e.cls) drawLine.Cls += ' ' + e.cls;
            }

            if (this.isCriticalLine && this.isCriticalLine(from, to, link)) {
                drawLine.Critical = true;
            }
        }

        this._doDrawLines(drawLines);
    },
    _doDrawLines: function (drawLines) {
        var region = this.getViewRegion();
        var Width = region.width,
            Height = region.height;
        var sb = [];
        for (var i = 0, l = drawLines.length; i < l; i++) {
            var lines = drawLines[i];
            var from = null;
            var to = null;
            var critical = lines.Critical;

            var cls = critical ? 'mini-gantt-line-critical' : '';
            if (lines.Cls) cls += ' ' + lines.Cls;

            var id = lines.id;
            for (var j = 0, k = lines.length; j < k; j++) {
                var line = lines[j];
                from = line[0];
                to = line[1];
                var left = from[0] < to[0] ? from[0] : to[0];
                var top = from[1] < to[1] ? from[1] : to[1];
                var width = Math.abs(to[0] - from[0]) + 1;
                var height = Math.abs(to[1] - from[1]) + 1;

                if (left > Width || left + width < 0) continue;
                if (top > Height || top + height < 0) continue;

                if (from[1] == to[1]) {
                    if (left < 0) {
                        width -= Math.abs(left);
                        left = 0;
                    }
                    if (width + left > Width) width = Width - left;

                    sb[sb.length] = '<div id="';
                    sb[sb.length] = id;
                    sb[sb.length] = '" style="left:';
                    sb[sb.length] = left;
                    sb[sb.length] = 'px;top:';
                    sb[sb.length] = top;
                    sb[sb.length] = 'px;width:';
                    sb[sb.length] = width;
                    sb[sb.length] = 'px;" class="mini-gantt-line mini-gantt-line-h ';
                    sb[sb.length] = cls;
                    sb[sb.length] = '"></div>';
                } else {
                    if (top < 0) {
                        height -= Math.abs(top);
                        top = 0;
                    }
                    if (height + top > Height) height = Height - top;

                    sb[sb.length] = '<div id="';
                    sb[sb.length] = id;
                    sb[sb.length] = '" style="left:';
                    sb[sb.length] = left;
                    sb[sb.length] = 'px;top:';
                    sb[sb.length] = top;
                    sb[sb.length] = 'px;height:';
                    sb[sb.length] = height;
                    sb[sb.length] = 'px;" class="mini-gantt-line mini-gantt-line-v ';
                    sb[sb.length] = cls;
                    sb[sb.length] = '"></div>';
                }
            }
            sb[sb.length] = '<div id="';
            sb[sb.length] = id;
            sb[sb.length] = '" style="left:';
            sb[sb.length] = to[0];
            sb[sb.length] = 'px;top:';
            sb[sb.length] = to[1];
            sb[sb.length] = 'px;" class="mini-gantt-line mini-gantt-arrow-';
            sb[sb.length] = lines.arrowType;
            sb[sb.length] = critical ? ' mini-gantt-arrow-' + lines.arrowType + '-critical' : '';
            sb[sb.length] = ' ' + cls;
            sb[sb.length] = '"></div>';
        }
        var lineString = sb.join('');

        this.linklinesEl.innerHTML = lineString;
    },

    findZoomTimeScale: function (type, topType) {
        var zoomTimeScales = this.zoomTimeScales;
        for (var i = 0, l = zoomTimeScales.length; i < l; i++) {
            var z = zoomTimeScales[i];
            var zt = z[0],
                zb = z[1];
            if (type == zb.type) {
                if (topType && zt.type != topType) continue;
                return z;
            }
        }
    },

    getZoomTimeScale: function (noNumber) {
        var zoomTimeScales = this.zoomTimeScales;
        var zts = null;
        for (var i = 0, l = zoomTimeScales.length; i < l; i++) {
            var z = zoomTimeScales[i];
            var zt = z[0],
                zb = z[1];
            if (
                zt.type == this.topTimeScale.type &&
                zt.number == this.topTimeScale.number &&
                zb.type == this.bottomTimeScale.type &&
                zb.number == this.bottomTimeScale.number
            ) {
                zts = z;
                break;
            }
            if (zb.type == this.bottomTimeScale.type && noNumber) {
                zts = z;
                break;
            }
        }
        if (!zts && noNumber) {
            zts = zoomTimeScales[6];
        }
        return zts;
    },
    zoomIn: function () {
        var ts = this.getZoomTimeScale();
        if (!ts) ts = this.getZoomTimeScale(true);
        var index = this.zoomTimeScales.indexOf(ts);
        index += 1;
        if (index >= this.zoomTimeScales.length) index = this.zoomTimeScales.length - 1;
        ts = this.zoomTimeScales[index];

        var data = {
            topTimeScale: ts[0],
            bottomTimeScale: ts[1],
            middleTimeScale: $.extend({}, ts[0], { visible: this.middleTimeScale.visible }),
            timelineRatio: this.timelineRatio
        };

        var project = this.owner;
        if (project.executeAction && PlusProject.ChangeTimeScaleAction) {
            var action = new PlusProject.ChangeTimeScaleAction(project, data);
            project.executeAction(action);
        } else {
            this.topTimeScale = ts[0];
            this.bottomTimeScale = ts[1];
            this.setDateRange(this._startDate, this._finishDate);
        }

        this.invalidate();
    },
    zoomOut: function () {
        var ts = this.getZoomTimeScale();
        if (!ts) ts = this.getZoomTimeScale(true);
        var index = this.zoomTimeScales.indexOf(ts);
        index -= 1;
        if (index < 0) index = 0;
        ts = this.zoomTimeScales[index];

        var data = {
            topTimeScale: ts[0],
            bottomTimeScale: ts[1],
            middleTimeScale: $.extend({}, ts[0], { visible: this.middleTimeScale.visible }),
            timelineRatio: this.timelineRatio
        };

        var project = this.owner;
        if (project.executeAction && PlusProject.ChangeTimeScaleAction) {
            var action = new PlusProject.ChangeTimeScaleAction(project, data);
            project.executeAction(action);
        } else {
            this.topTimeScale = ts[0];
            this.bottomTimeScale = ts[1];
            this.setDateRange(this._startDate, this._finishDate);
        }

        this.invalidate();
    },

    zoomFit: function () {
        var start = this._startDate,
            finish = this._finishDate,
            vwidth = this.getViewportWidth() - 18 - 50;

        var oldBottomTimeScale = this.bottomTimeScale;

        var timescales = ['hour', 'day', 'week', 'month', 'quarter', 'halfyear', 'year'];
        var numbers = { hour: 12, day: 7, week: 4, month: 3, quarter: 4, halfyear: 2, year: 2 };
        var timescale = null,
            number,
            timelineRatio;

        var ganttView = this;

        function fit(type) {
            var maxNumber = numbers[type];
            for (var i = 1; i < maxNumber; i++) {
                var bt = mini.GanttView.getTimeScale(type);
                bt.number = i;
                ganttView.setBottomTimeScale(bt);
                ganttView.setTimelineRatio(1);

                var left = ganttView.getXByDate(start),
                    right = ganttView.getXByDate(finish),
                    width = right - left;

                if (width < vwidth) {
                    timescale = type;
                    number = i;

                    timelineRatio = parseFloat((vwidth / width).toFixed(2));

                    return true;
                }
            }
        }

        for (var i = 0, l = timescales.length; i < l; i++) {
            var type = timescales[i];
            if (fit(type)) {
                break;
            }
        }

        if (!timescale) throw new Error('zoomFit error');

        var topscale;
        if (timescale == 'day') topscale = 'week';

        var ts = ganttView.findZoomTimeScale(timescale, topscale);

        var bt = mini.GanttView.getTimeScale(timescale);
        bt.number = number;

        var data = {
            topTimeScale: ts[0],
            bottomTimeScale: bt,
            middleTimeScale: $.extend({}, ts[0], { visible: ganttView.middleTimeScale.visible }),
            timelineRatio: timelineRatio
        };

        ganttView.setBottomTimeScale(oldBottomTimeScale);

        var project = this.owner;
        if (project.executeAction && PlusProject.ChangeTimeScaleAction) {
            var action = new PlusProject.ChangeTimeScaleAction(project, data);
            project.executeAction(action);
        } else {
            ganttView.setTopTimeScale(ts[0]);
            ganttView.setBottomTimeScale(bt);
            ganttView.setTimelineRatio(timelineRatio);
        }

        ganttView.doLayout();
        ganttView.setLeftDate(start);
    },

    scrollIntoView: function (record, toFinish) {
        if (!record) return;
        var date = mini.isDate(record) ? record : record.Start;
        if (toFinish && !mini.isDate(record)) {
            date = record.Finish;
        }
        if (!date) return;

        this.updateViewRegion();

        var offset = this.getOffsetByDate(date);
        var width = mini.getWidth(this.el, true);
        if (toFinish) {
            this.setScrollLeft(offset - width / 2);
        } else {
            if (this.scrollLeft < offset && offset < this.scrollLeft + width) {
            } else {
                this.setScrollLeft(offset - width / 2);
            }
        }
    },
    scrollToDate: function (date, toFinish) {
        if (!mini.isDate(date)) return;
        var offset = this.getOffsetByDate(date);
        var width = mini.getWidth(this.el, true);

        if (toFinish == 'start') {
            this.setScrollLeft(offset);
        } else {
            if (toFinish) {
                this.setScrollLeft(offset - width / 2);
            } else {
                if (this.scrollLeft < offset && offset < this.scrollLeft + width) {
                } else {
                    this.setScrollLeft(offset - width / 2);
                }
            }
        }
    },

    _OnItemDragTipNeeded: function (item) {
        var e = {
            item: item,
            tooltip: '',
            cls: ''
        };

        this.fire('ItemDragTipNeeded', e);

        return e;
    },
    _OnScrollToolTipNeeded: function (item) {
        var e = {
            item: item,
            tooltip: item ? item.Name : '',
            cls: ''
        };
        if (e.item) {
            this.fire('ScrollToolTipNeeded', e);
        }
        return e;
    },
    _OnDateToolTipNeeded: function (date) {
        var tip = this.bottomTimeScale.tooltip(date, 'bottom', this.bottomTimeScale.type);
        var e = { date: date, tooltip: tip, cls: '' };
        this.fire('DateToolTipNeeded', e);
        return e;
    },
    _OnItemToolTipNeeded: function (item) {
        var baseline = item.isBaseline ? this.getBaseline(item) : null;
        delete item.isBaseline;

        var tip = item.Name;
        var e = { item: item, tooltip: tip, cls: '', baseline: baseline };
        this.fire('ItemToolTipNeeded', e);
        return e;
    },
    _OnLinkToolTipNeeded: function (link) {
        var fromItem = this._TaskUIDs[link.PredecessorUID];
        var toItem = this._TaskUIDs[link.TaskUID];
        var e = { link: link, tooltip: '', cls: '', fromItem: fromItem, toItem: toItem };
        this.fire('LinkToolTipNeeded', e);
        return e;
    },
    _OnItemMouseDown: function (item, event) {
        var e = { item: item, htmlEvent: event };
        this.fire('ItemMouseDown', e);
    },
    _OnItemClick: function (item, event) {
        var e = { item: item, htmlEvent: event };
        this.fire('ItemClick', e);
    },
    _OnItemDblClick: function (item, event) {
        var e = { item: item, htmlEvent: event };
        this.fire('ItemDblClick', e);
    },
    _OnItemContextMenu: function (item, event) {
        var e = { item: item, htmlEvent: event };
        this.fire('ItemContextMenu', e);
    },

    _OnDrawItem: function (item, itemBox, isBaseLine) {
        var e = {
            baseline: isBaseLine,
            item: item,
            itemBox: itemBox,
            itemCls: '',
            itemStyle: '',
            itemHtml: null,
            showLabel: this.showLabel,
            labelField: this.labelField,
            label: item[this.labelField],
            labelAlign: 'right',
            extraHtml: ''
        };

        this.fire('DrawItem', e);
        return e;
    },

    _OnItemDragStart: function (item, action) {
        var cancel = false;
        action = action.toLowerCase();
        if (action == 'start') {
            cancel = this.isSummary(item) || this.isMilestone(item);
        }
        if (action == 'finish') {
            cancel = this.isSummary(item) || this.isMilestone(item);
        }
        if (action == 'percentcomplete') {
            cancel = this.isSummary(item) || this.isMilestone(item);
        }

        if (action == 'move') {
            var isManual = item.Manual == 1;

            if (!isManual || item.Manual == null) {
                cancel = this.isSummary(item);
            }
        }
        var e = {
            item: item,
            action: action,
            cancel: cancel,
            dragUpdown: false
        };
        this.fire('ItemDragStart', e);
        return e;
    },
    _OnItemDragMove: function (item, drag, action) {
        var e = {
            item: item,
            drag: drag,
            action: action
        };
        this.fire('ItemDragMove', e);
        return e;
    },
    _OnItemDragDrop: function (item, dropNode) {
        var e = {
            item: item,
            dropNode: dropNode,
            cancel: false
        };
        this.fire('ItemDragDrop', e);
        return e;
    },
    _OnItemDragComplete: function (item, action, value, dropNode) {
        var e = {
            item: item,
            action: action.toLowerCase(),
            value: value,
            dropNode: dropNode
        };
        this.fire('ItemDragComplete', e);
        return e;
    }
});

mini.GanttView.prototype.getViewRange = mini.GanttView.prototype.getViewRegion;
mini.GanttView.prototype.getVisibleRows = mini.GanttView.prototype.getItems;

mini.GanttView.prototype.getTimeScaleStartDate = function (date, type, number) {
    if (!number) number = 1;

    var y = date?.getFullYear(),
        mo = date?.getMonth(),
        d = date?.getDate(),
        h = date?.getHours(),
        m = date?.getMinutes(),
        s = date?.getSeconds();
    switch (type) {
        case 'year':
            date = new Date(y, 0, 1);
            break;
        case 'halfyear':
            if (mo < 6) {
                date = new Date(y, 0, 1);
            } else {
                date = new Date(y, 6, 1);
            }
            break;
        case 'quarter':
            if (mo < 3) {
                date = new Date(y, 0, 1);
            } else if (mo < 6) {
                date = new Date(y, 3, 1);
            } else if (mo < 9) {
                date = new Date(y, 6, 1);
            } else {
                date = new Date(y, 9, 1);
            }
            break;
        case 'month':
            date = new Date(y, mo, 1);
            break;
        case 'tendays':
            if (d <= 10) {
                date = new Date(y, mo, 1);
            } else if (d <= 20) {
                date = new Date(y, mo, 11);
            } else {
                date = new Date(y, mo, 21);
            }
            break;
        case 'week':
            date = mini.getWeekStartDate(date, this.weekStartDay);
            break;
        case 'day':
            if (number > 1) {
                d = parseInt(d / number) * number;
            }

            date = new Date(y, mo, d);
            break;
        case 'hour':
            if (number > 1) {
                h = parseInt(h / number) * number;
            }

            date = new Date(y, mo, d, h);

            break;
        case 'minutes':
            if (number > 1) {
                m = parseInt(m / number) * number;
            }

            date = new Date(y, mo, d, h, m);
            break;
        case 'seconds':
            if (number > 1) {
                s = parseInt(s / number) * number;
            }

            date = new Date(y, mo, d, h, m, s);
            break;
    }
    return date;
};
mini.GanttView.prototype.getTimeScaleNextDate = function (date, type, number) {
    var number = number || 1;
    var weekStartDay = this.weekStartDay;
    var next;
    for (var i = 0; i < number; i++) {
        var y = date?.getFullYear(),
            mo = date?.getMonth(),
            d = date?.getDate(),
            h = date?.getHours(),
            m = date?.getMinutes(),
            s = date?.getSeconds();
        switch (type) {
            case 'year':
                next = new Date(y + 1, 0, 1);
                break;
            case 'halfyear':
                if (mo < 6) {
                    next = new Date(y, 6, 1);
                } else {
                    next = new Date(y + 1, 0, 1);
                }
                break;
            case 'quarter':
                if (mo < 3) {
                    next = new Date(y, 3, 1);
                } else if (mo < 6) {
                    next = new Date(y, 6, 1);
                } else if (mo < 9) {
                    next = new Date(y, 9, 1);
                } else {
                    next = new Date(y + 1, 0, 1);
                }
                break;
            case 'month':
                next = new Date(y, mo + 1, 1);
                break;
            case 'tendays':
                if (d <= 10) {
                    next = new Date(y, mo, 11);
                } else if (d <= 20) {
                    next = new Date(y, mo, 21);
                } else {
                    next = new Date(y, mo + 1, 1);
                }
                break;
            case 'week':
                next = mini.getNextWeekStartDate(date, weekStartDay);
                break;
            case 'day':
                next = new Date(y, mo, d + 1);
                break;
            case 'hour':
                next = new Date(y, mo, d, h + 1);
                break;
            case 'minutes':
                next = new Date(y, mo, d, h, m + 1);
                break;
            case 'seconds':
                next = new Date(y, mo, d, h, m, s + 1);
                break;
        }
        date = next;
    }
    return next;
};

mini.getNextWeekStartDate = function (date, weekStartDay) {
    var d = mini.getWeekStartDate(date, weekStartDay);
    d?.setDate(d?.getDate() + 7);
    return d;
};

String.leftPad = function (val, size, ch) {
    size = size || 2;
    ch = ch || '0';
    var result = new String(val);
    if (ch == null || ch == undefined) {
        ch = ' ';
    }
    while (result.length < size) {
        result = ch + result;
    }
    return result.toString();
};

mini.GanttView.TimeScale = {
    year: {
        type: 'year',
        width: 40,
        number: 1,
        align: 'left',
        index: 0,

        tooltip: function (date, position) {
            return date?.getFullYear();
        },
        formatter: function (date, position) {
            return date?.getFullYear();
        }
    },
    halfyear: {
        type: 'halfyear',
        width: 24,
        number: 1,
        align: 'left',
        index: 1,
        tooltip: function (date, position) {
            return date?.getFullYear() + '-' + String.leftPad(date?.getMonth() + 1);
        },
        formatter: function (date, position) {
            var s = '';
            var m = date?.getMonth();
            if (m < 6) s += 'H' + 1;
            else s += 'H' + 2;

            return s;
        }
    },
    quarter: {
        type: 'quarter',
        width: 24,
        number: 1,
        align: 'left',
        index: 3,
        tooltip: function (date, position) {
            return date?.getFullYear() + '-' + String.leftPad(date?.getMonth() + 1);
        },
        formatter: function (date, position) {
            var s = '';
            var m = date?.getMonth();
            if (m < 3) s += 'Q' + 1;
            else if (m < 6) s += 'Q' + 2;
            else if (m < 9) s += 'Q' + 3;
            else s += 'Q' + 4;

            if (position == 'top') s = date?.getFullYear() + '' + s;
            return s;
        }
    },
    month: {
        type: 'month',
        width: 24,
        number: 1,
        align: 'left',
        index: 4,
        tooltip: function (date, position) {
            return date?.getFullYear() + '-' + String.leftPad(date?.getMonth() + 1);
        },
        formatter: function (date, position) {
            var s = date?.getMonth() + 1;
            if (position == 'top') s = date?.getFullYear() + '-' + String.leftPad(s);
            return s;
        }
    },
    tendays: {
        type: 'tendays',
        width: 24,
        number: 1,
        align: 'left',
        index: 5,
        tooltip: function (date, position) {
            var s =
                date?.getFullYear() +
                '-' +
                String.leftPad(date?.getMonth() + 1) +
                '-' +
                String.leftPad(date?.getDate());
            var next = new Date(date?.getTime());

            if (next?.getDate() >= 20) {
                next = new Date(next?.getFullYear(), next?.getMonth() + 1, 0);
            } else {
                next?.setDate(next?.getDate() + 9);
            }
            s += ' ~ ';
            s +=
                next?.getFullYear() +
                '-' +
                String.leftPad(next?.getMonth() + 1) +
                '-' +
                String.leftPad(next?.getDate());
            return s;
        },
        formatter: function (date, position) {
            var d = date?.getDate();
            if (d < 10) {
                return mini.dateInfo.ten.Early;
            } else if (d < 20) {
                return mini.dateInfo.ten.Mid;
            } else {
                return mini.dateInfo.ten.Late;
            }
        }
    },
    week: {
        type: 'week',
        width: 24,
        number: 1,
        align: 'left',
        index: 6,
        tooltip: function (date, position) {
            var s =
                date?.getFullYear() +
                '-' +
                String.leftPad(date?.getMonth() + 1) +
                '-' +
                String.leftPad(date?.getDate());
            var next = new Date(date?.getTime());
            next?.setDate(next?.getDate() + 6);
            s += ' ~ ';
            s +=
                next?.getFullYear() +
                '-' +
                String.leftPad(next?.getMonth() + 1) +
                '-' +
                String.leftPad(next?.getDate());
            return s;
        },
        formatter: function (date, position) {
            if (position != 'bottom') {
                return (
                    date?.getFullYear() +
                    '-' +
                    String.leftPad(date?.getMonth() + 1) +
                    '-' +
                    String.leftPad(date?.getDate())
                );
            } else {
                return date?.getDate();
            }
        }
    },
    day: {
        type: 'day',
        width: 24,
        number: 1,
        align: 'center',
        index: 7,
        tooltip: function (date, position) {
            return (
                date?.getFullYear() +
                '-' +
                String.leftPad(date?.getMonth() + 1) +
                '-' +
                String.leftPad(date?.getDate()) +
                ' ' +
                mini.GanttView.LongWeeks[date?.getDay()]
            );
        },
        formatter: function (date, position) {
            return mini.GanttView.ShortWeeks[date?.getDay()];
        }
    },
    hour: {
        type: 'hour',
        width: 20,
        number: 1,
        align: 'center',
        index: 8,
        tooltip: function (date, position) {
            return (
                date?.getFullYear() +
                '-' +
                String.leftPad(date?.getMonth() + 1) +
                '-' +
                String.leftPad(date?.getDate()) +
                ' ' +
                String.leftPad(date?.getHours())
            );
        },
        formatter: function (date, position) {
            if (position == 'top') {
                return (
                    date?.getFullYear() +
                    '-' +
                    String.leftPad(date?.getMonth() + 1) +
                    '-' +
                    String.leftPad(date?.getDate()) +
                    ' ' +
                    String.leftPad(date?.getHours())
                );
            } else {
                return String.leftPad(date?.getHours());
            }
        }
    },
    minutes: {
        type: 'minutes',
        width: 20,
        number: 1,
        align: 'center',
        index: 9,
        tooltip: function (date, position) {
            return (
                date?.getFullYear() +
                '-' +
                String.leftPad(date?.getMonth() + 1) +
                '-' +
                String.leftPad(date?.getDate()) +
                ' ' +
                String.leftPad(date?.getHours()) +
                ':' +
                String.leftPad(date?.getMinutes())
            );
        },
        formatter: function (date, position) {
            if (position == 'top') {
                return (
                    date?.getFullYear() +
                    '-' +
                    String.leftPad(date?.getMonth() + 1) +
                    '-' +
                    String.leftPad(date?.getDate()) +
                    ' ' +
                    String.leftPad(date?.getHours()) +
                    ':' +
                    String.leftPad(date?.getMinutes())
                );
            } else {
                return String.leftPad(date?.getMinutes());
            }
        }
    },
    seconds: {
        type: 'seconds',
        width: 20,
        number: 1,
        align: 'center',
        index: 10,
        tooltip: function (date, position) {
            return (
                date?.getFullYear() +
                '-' +
                String.leftPad(date?.getMonth() + 1) +
                '-' +
                String.leftPad(date?.getDate()) +
                ' ' +
                String.leftPad(date?.getHours()) +
                ':' +
                String.leftPad(date?.getMinutes()) +
                ':' +
                String.leftPad(date?.getSeconds())
            );
        },
        formatter: function (date, position) {
            if (position == 'top') {
                return date?.getDate() + ' ' + date?.getHours() + ':' + date?.getMinutes() + ':' + date?.getSeconds();
            } else {
                return String.leftPad(date?.getSeconds());
            }
        }
    }
};

mini.GanttView.ShortWeeks = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
mini.GanttView.LongWeeks = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
mini.GanttView.getTimeScale = function (timescale) {
    var type = typeof timescale == 'string' ? timescale : timescale.type;
    var o = mini.GanttView.TimeScale[type.toLowerCase()];
    if (o) {
        o = mini.copyTo({}, o);
    }
    if (o && typeof timescale != 'string') {
        o = mini.copyTo(o, timescale);
    }

    return o;
};
mini.GanttView.createZoomTimeScales = function () {
    var zoomTimeScales = [];

    var top = mini.GanttView.getTimeScale('year');
    top.number = 5;
    var bottom = mini.GanttView.getTimeScale('year');
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('year');
    var bottom = mini.GanttView.getTimeScale('halfyear');
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('year');
    var bottom = mini.GanttView.getTimeScale('quarter');
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('year');
    var bottom = mini.GanttView.getTimeScale('month');
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('quarter');
    var bottom = mini.GanttView.getTimeScale('month');
    bottom.width = 24;
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('month');
    var bottom = mini.GanttView.getTimeScale('tendays');
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('month');
    var bottom = mini.GanttView.getTimeScale('week');
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('month');
    var bottom = mini.GanttView.getTimeScale('day');
    bottom.number = 3;
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('week');
    var bottom = mini.GanttView.getTimeScale('day');
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('day');
    var bottom = mini.GanttView.getTimeScale('hour');
    bottom.number = 6;
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('day');
    var bottom = mini.GanttView.getTimeScale('hour');
    bottom.number = 2;
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    var top = mini.GanttView.getTimeScale('day');
    var bottom = mini.GanttView.getTimeScale('hour');
    bottom.number = 1;
    bottom.align = 'center';
    zoomTimeScales.push([top, bottom]);

    return zoomTimeScales;
};

mini._GanttViewToolTip = mini.Base.extend({
    constructor: function (gantt) {
        this.gantt = gantt;
        mini.on(document.body, 'mousemove', this.__OnGanttMouseMove, this);

        this.gantt.on('ItemDragMove', this.__OnItemDragMove, this);
        this.gantt.on('ItemDragComplete', this.__OnItemDragComplete, this);

        this.gantt.on('scroll', this.__OnScroll, this);

        this.gantt.on(
            'refresh',
            function (e) {
                this.draging = false;
                this.hideTip();
            },
            this
        );
    },

    __OnScroll: function (e) {
        if (!this.gantt.showScrollTip) return;
        if (!this.gantt.isDisplay()) return;
        if (e.direction == 'vertical') {
            this.toolTipEvent = '_OnScrollToolTipNeeded';
            var x = 0,
                y = 0;

            if (this.tooltipTimer) {
                clearTimeout(this.tooltipTimer);
                this.tooltipTimer = null;
            }
            var sf = this;
            var time = 30;
            if (mini.isFirefox) {
                var item = sf.gantt.getViewStartItem();
                sf.showTip(item, 'right', 'top', -1);
                sf.tooltipTimer = null;
                time = 0;
            } else {
                this.tooltipTimer = setTimeout(function () {
                    var item = sf.gantt.getViewStartItem();
                    sf.showTip(item, 'right', 'top', 0);
                    sf.tooltipTimer = null;
                }, time);
            }
        } else {
            this.toolTipEvent = '_OnDateToolTipNeeded';
            var x = 0,
                y = 0;
            if (this.gantt.viewRegion) {
                var date = this.gantt.getViewStartDate();
                this.showTip(date, 'left', 'bottom', 0);
            }
        }
    },

    __OnItemDragMove: function (e) {
        this.toolTipEvent = '_OnItemDragTipNeeded';
        this.draging = true;
        var x = e.drag.init[0],
            y = e.drag.init[1];

        this.showTip(e.item, x, y + 10, 0, true);
    },
    __OnItemDragComplete: function (sender, e) {
        this.draging = false;
        this.hideTip();
    },

    __OnGanttMouseMove: function (e) {
        if (this.draging === true) return;
        var t = e.target,
            gantt = this.gantt;

        if (gantt.refreshScrollComplete == true) return;

        if (!gantt.within(e)) {
            this.hideTip();
            return;
        }

        var item = gantt.getItemByEvent(e);
        if (item) {
            $(`#ppm-gantt-content .mini-supergrid-cells [data-identifier-no='${item.identifierNo}']`).addClass('mini-supergrid-row-hover');
            var isBaseline = !!mini.findParent(t, 'mini-gantt-baseline');
            item.isBaseline = isBaseline;

            this.toolTipEvent = '_OnItemToolTipNeeded';
            this.toolTipItem = item;

            this.showTip(item, e.pageX + 8, e.pageY + 15, this.showTipDelay);
        } else {
            var link = gantt.getLinkByEvent(e);
            if (link) {
                this.toolTipEvent = '_OnLinkToolTipNeeded';
                this.toolTipItem = link;

                this.showTip(link, e.pageX + 5, e.pageY + 8, this.showTipDelay);
            } else {
                this.hideTip();
                $(`#ppm-gantt-content .mini-supergrid-row`).removeClass('mini-supergrid-row-hover');
            }
        }
    },
    showTipDelay: 700,
    showTip: function (item, x, y, delay, auto) {
        if (this._lastShowItem == item && delay != 0) {
            this._showXY = [x, y];
            return;
        }

        this.hideTip(false);
        if (this.hideTimer) {
            clearInterval(this.hideTimer);
            this.hideTimer = null;
        }

        var gantt = this.gantt;
        this._lastShowItem = item;
        var sf = this;
        this._showXY = [x, y];
        if (delay <= 0 && mini.isFirefox) {
            sf._showTipCore(item, auto);
        } else {
            this._showTipTimer = setTimeout(function () {
                sf._showTipCore(item, auto);
            }, delay);
        }
    },
    _showTipCore: function (item, auto) {
        var gantt = this.gantt;
        if (!this._tipEl) {
            this._tipEl = mini.append(
                document.body,
                '<div class="mini-ganttview-tooltip" style="display:none;"></div>'
            );
        }
        if (auto == true) this._tipEl.style.width = 'auto';

        var e = gantt[this.toolTipEvent](item);
        this._tipEl.innerHTML = e.tooltip;
        this._tipEl.style.display = 'block';
        var x = this._showXY[0],
            y = this._showXY[1];

        mini.setXY(this._tipEl, -1000, -1000);
        var size = mini.getSize(this._tipEl);

        var ganttBox = this.gantt.getViewportBox();
        if (x == 'left') {
            x = ganttBox.x + 5;
        } else if (x == 'right') {
            x = ganttBox.right - 20 - size.width;
        }
        if (y == 'top') {
            y = ganttBox.y + 5;
        } else if (y == 'bottom') {
            y = ganttBox.bottom - 20 - size.height;
        }

        var vbox = mini.getViewportBox();
        if (x + size.width > vbox.right) x = vbox.right - size.width;
        if (y + size.height > vbox.bottom) y = vbox.bottom - size.height;

        mini.setXY(this._tipEl, x, y);
    },
    hideTip: function (remove, clearShow) {
        var sf = this;

        if (sf._tipEl && remove !== false) {
            mini.removeNode(sf._tipEl);
            sf._tipEl = null;
        }

        sf._lastShowItem = null;
        clearInterval(sf._showTipTimer);
    }
});

mini._GanttViewDragDrop = mini.Base.extend({
    constructor: function (gantt) {
        this.owner = gantt;
        this.owner.on('refresh', this.__OnGanttRefresh, this);
        mini.on(this.owner.el, 'mousedown', this.__OnGanttMouseDown, this);
    },

    isDraging: function () {
        return !!this.dragAction;
    },
    originalItem: null,
    dragItem: null,
    dragAction: null,

    __OnGanttMouseDown: function (e) {
        var t = e.target,
            ganttview = this.owner;
        if (ganttview.isReadOnly()) return;

        if (!ganttview.allowDrag) return;

        var item = ganttview.getItemByEvent(e);

        if (!item) {
            return;
        }
        if (mini.findParent(t, 'mini-gantt-baseline')) return;

        this.createLink = false;

        if (mini.MouseButton.Left == e.button) {
            this.dragItem = item;
            this.originalItem = mini.copyTo({}, item);
            if (mini.hasClass(t, 'mini-gantt-resize-start')) {
                this.dragAction = 'start';

                var ex = ganttview._OnItemDragStart(item, 'start');
                if (!ex.cancel) {
                    this.getDrag().start(e);
                    ganttview.fire('bardragstart', { item: item, action: 'start' });
                }
            } else if (mini.hasClass(t, 'mini-gantt-resize-finish')) {
                this.dragAction = 'finish';

                var ex = ganttview._OnItemDragStart(item, 'finish');
                if (!ex.cancel) {
                    this.getDrag().start(e);
                    ganttview.fire('bardragstart', { item: item, action: 'finish' });
                }
            } else if (mini.hasClass(t, 'mini-gantt-resize-percentcomplete')) {
                this.dragAction = 'percentcomplete';
                var ex = ganttview._OnItemDragStart(item, 'percentcomplete');
                if (!ex.cancel) {
                    this.getDrag().start(e);
                    ganttview.fire('bardragstart', { item: item, action: 'percentcomplete' });
                }
            } else if (mini.findParent(t, 'mini-gantt-item')) {
                this.dragAction = 'move';
                this._BeforeDragMove(item, e);

                this.startCreateLink(item, e);
            }
        }
    },

    startCreateLink: function (item, clickEvent) {
        var me = this,
            ganttview = this.owner,
            gantt = ganttview.owner;

        if (!gantt.allowLinkBars) return;

        var ganttBox = mini.getBox(gantt.el);

        me.canLink = true;

        var suppertSVG = !!document.createElementNS;
        me.canLink = suppertSVG;

        var ns = 'http://www.w3.org/2000/svg';
        var svg;

        if (!suppertSVG) return;

        var htmlOffset = jQuery('html').offset();
        var bodyOffset = htmlOffset.left > 0 || htmlOffset.top > 0 ? jQuery('body').offset() : { left: 0, top: 0 };

        if (suppertSVG) {
            svg = document.createElementNS(ns, 'svg');

            svg.style.cssText =
                'position:absolute;left:0;top:0;display:none;width:100%;height:' +
                ganttBox.bottom +
                'px;z-index:100000;pointer-events: none;';
            document.body.appendChild(svg);
            var line = document.createElementNS(ns, 'line');
            svg.appendChild(line);

            line.setAttribute('stroke', 'rgb(0,0, 0)');
            line.setAttribute('stroke-width', 1);
            line.setAttribute('x1', clickEvent.pageX - bodyOffset.left);
            line.setAttribute('y1', clickEvent.pageY - bodyOffset.top);
        }

        var endTask;

        var scrollLeft = ganttview.getScrollLeft();
        var scrollTop = ganttview.getScrollTop();

        function onMouseMove(event) {
            var xOffset = event.pageX - clickEvent.pageX,
                yOffset = event.pageY - clickEvent.pageY;

            var inX = Math.abs(xOffset) > 4,
                inY = gantt.allowLinkBars && Math.abs(yOffset) > 6;

            if (!moved && inY && me.canLink) {
                moved = true;
                me.createLink = true;

                ganttview.createLinking = true;

                $(document.body).addClass('mini-gantt-createlink');
            }

            if (!moved && inX && !me.createLink) {
                moved = true;

                if (me._drag) {
                    me._drag.disabled = false;

                    var ex = me.owner._OnItemDragStart(item, 'move');
                    if (!ex.cancel) {
                        me._drag.move(event);
                    }
                }
            }

            if (me.createLink) {
                if (suppertSVG) {
                    svg.style.display = '';

                    line.setAttribute('x2', event.pageX - bodyOffset.left);
                    line.setAttribute('y2', event.pageY - bodyOffset.top);
                }

                endTask = null;

                if (event.target) {
                    if ($(event.target).closest('.mini-gantt-item')[0]) {
                        endTask = ganttview.getItemByEvent(event);
                        if (endTask == item) {
                            endTask = null;
                        }
                    }
                }
            }
        }

        function onMouseUp(event) {
            clearTimeout(timer);
            mini.un(document, 'mousemove', onMouseMove);
            mini.un(document, 'mouseup', onMouseUp);
            if (svg) $(svg).remove();
            $(document.body).removeClass('mini-gantt-createlink');

            ganttview.createLinking = false;

            if (moved) {
                if (me.createLink) {
                    if (endTask) {
                        var link = gantt.getPredecessorLink(item, endTask);
                        if (!link) link = gantt.getPredecessorLink(endTask, item);

                        if (link) {
                            alert('已经存在Link关系');
                        } else {
                            var link = { PredecessorUID: item.UID, Type: 1, TaskUID: endTask.UID, LinkLag: 0 };

                            try {
                                var e = { link: link, cancel: false };

                                gantt.fire('beforelinkcreate', e);
                                if (e.cancel == false) {
                                    gantt.addLink(endTask, link);

                                    gantt.fire('linkcreate', { link: link });
                                }
                            } catch (ex) {
                                alert(ex.message);
                            }
                        }
                    } else {
                    }
                }
            }

            me.canLink = false;
            me.createLink = false;
            if (me._drag) me._drag.disabled = false;
        }

        var moved = false;

        var timer = setTimeout(function () {
            mini.on(document, 'mousemove', onMouseMove);
        }, 1);
        mini.on(document, 'mouseup', onMouseUp);
    },

    _BeforeDragMove: function (item, e) {
        var me = this;

        var ex = me.owner._OnItemDragStart(item, 'move');
        if (!ex.cancel) {
            this._drag = me.getDrag();
            this._drag.disabled = true;
            this._drag.delay = 0;
            this._drag.start(e);
        }
    },

    getDrag: function () {
        if (!this.drag) {
            this.drag = new mini.Drag({
                delay: 30,
                capture: false,
                context: this.owner.viewportEl,
                onStart: mini.createDelegate(this._OnDragStart, this),
                onMove: mini.createDelegate(this._OnDragMove, this),
                onStop: mini.createDelegate(this._OnDragStop, this)
            });
        }
        return this.drag;
    },
    _GetCursor: function () {
        switch (this.dragAction) {
            case 'start':
                return 'w-resize';
                break;
            case 'finish':
                return 'w-resize';
                break;
            case 'percentcomplete':
                return 'row-resize';
                break;
            case 'move':
                return 'move';
                break;
            case 'link':
                return 'move';
                break;
        }
    },
    _OnDragStart: function (drag) {
        if (this.createLink) return;

        var ganttview = this.owner,
            item = this.dragItem;
        this.viewBox = ganttview.getViewportBounds(ganttview.viewRegion);
        var itemBox = ganttview.getItemBox(item);
        this.MoveOffset = itemBox.left - drag.init[0];
        this.timeSpan = item.Finish - item.Start;
        this.itemBox = itemBox;

        this._scrollLeft = ganttview.getScrollLeft();
        this._scrollTop = ganttview.getScrollTop();
    },
    _OnDragMove: function (drag) {
        if (this.createLink) return;

        this.canLink = false;

        var ganttview = this.owner,
            item = this.dragItem;
        var viewBox = this.viewBox;
        var bodyBox = ganttview.getViewportBox();

        switch (this.dragAction) {
            case 'start':
                var date = ganttview.getDateByPageX(drag.now[0]);

                item.Start = date;
                if (item.Start > item.Finish) item.Start = item.Finish;
                setTimeout(function () {
                    ganttview.refreshItem(item);
                }, 10);
                break;
            case 'finish':
                var date = ganttview.getDateByPageX(drag.now[0]);
                item.Finish = date;
                if (item.Start > item.Finish) item.Finish = item.Start;
                setTimeout(function () {
                    ganttview.refreshItem(item);
                }, 1);

                break;
            case 'percentcomplete':
                var itemWidth = this.itemBox.width;
                var offset = drag.now[0] - bodyBox.x + viewBox.left - this.itemBox.x;

                var percentComplete = parseInt((offset * 100) / itemWidth);

                if (percentComplete < 0) percentComplete = 0;
                if (percentComplete > 100) percentComplete = 100;

                item.PercentComplete = percentComplete;
                setTimeout(function () {
                    ganttview.refreshItem(item, false);
                }, 10);

                break;
            case 'move':
                var offset = drag.now[0] + this.MoveOffset;

                offset -= this._scrollLeft - ganttview.getScrollLeft();

                var date = ganttview.getDateByOffset(offset);
                item.Start = date;
                item.Finish = new Date(date?.getTime() + this.timeSpan);
                setTimeout(function () {
                    ganttview.refreshItem(item);
                }, 10);
                break;
            case 'link':
                break;
        }

        ganttview._OnItemDragMove(item, drag, this.dragAction);
    },
    dropNode: null,
    _OnDragStop: function (drag, success) {
        if (this.createLink) return;

        var ganttview = this.owner,
            item = this.dragItem;
        if (success == false) {
            mini.copyTo(this.dragItem, this.originalItem);
        } else {
            var value = this.dragItem['Start'];
            switch (this.dragAction) {
                case 'move':
                    this.dropNode = ganttview.getDragRecord(drag.now[1]);
                    var e = ganttview._OnItemDragDrop(this.dragItem, this.dropNode);
                    if (e.cancel) success = false;
                    break;
                case 'start':
                    break;
                case 'finish':
                    value = this.dragItem['Finish'];
                    break;
                case 'percentcomplete':
                    value = this.dragItem['PercentComplete'];
                    break;
                case 'link':
                    break;
            }
            mini.copyTo(this.dragItem, this.originalItem);

            if (success) {
                this._OnItemDragComplete(value);
            }
        }
        if (success == false) {
            drag.event.stopPropagation();
        }
        this.stopDrag(success);
    },
    _OnItemDragComplete: function (value) {
        if (this.createLink) return;

        var ganttview = this.owner,
            item = this.dragItem;
        ganttview._OnItemDragComplete(this.dragItem, this.dragAction, value, this.dropNode);
    },
    stopDrag: function (complete) {
        var ganttview = this.owner,
            item = this.dragItem;

        ganttview.invalidate();

        this.dragItem = this.originalItem = this.dragAction = this.dropNode = null;
    },

    __OnGanttRefresh: function (e) {
        if (this.___dragProxyTimer) {
            clearTimeout(this.___dragProxyTimer);
        }
        var sf = this;
        this.___dragProxyTimer = setTimeout(function () {
            sf.render_dragProxy();
            sf.___dragProxyTimer = null;
        }, 300);
    },

    renderItem_dragProxy: function (item, box, sb, id) {
        var ganttview = this.owner;

        var id = item._id;
        var ex = ganttview._OnItemDragStart(item, 'start');
        if (!ex.cancel) {
            sb[sb.length] = '<div id="';
            sb[sb.length] = id;
            sb[sb.length] = '" class="mini-gantt-resize-start" style="left:';
            sb[sb.length] = box.x - 5;
            sb[sb.length] = 'px;top:';
            sb[sb.length] = box.y;
            sb[sb.length] = 'px;width:';
            sb[sb.length] = 10;
            sb[sb.length] = 'px;height:';
            sb[sb.length] = box.height;
            sb[sb.length] = 'px;"></div>';
        }
        var ex = ganttview._OnItemDragStart(item, 'finish');
        if (!ex.cancel) {
            sb[sb.length] = '<div id="';
            sb[sb.length] = id;
            sb[sb.length] = '" class="mini-gantt-resize-finish" style="left:';
            sb[sb.length] = box.right - 5;
            sb[sb.length] = 'px;top:';
            sb[sb.length] = box.y;
            sb[sb.length] = 'px;width:';
            sb[sb.length] = 10;
            sb[sb.length] = 'px;height:';
            sb[sb.length] = box.height;
            sb[sb.length] = 'px;"></div>';
        }
        var ex = ganttview._OnItemDragStart(item, 'percentcomplete');
        if (!ex.cancel) {
            var percentComplete = item.PercentComplete || 0;
            var percentWidth = parseInt(((box.right - box.x) * percentComplete) / 100);
            /* start 非甘特图原来的源码，已修改 */
            var width = 12;
            var height = 12;
            var right = box.x + percentWidth - width / 2;
            var top = box.y + 8;
            if (percentComplete == 0) {
                right += 1;
            } else if (percentComplete == 100) {
                right += 0;
            } else {
                right += 0;
            }
            /* end 非甘特图原来的源码，已修改 */
            sb[sb.length] = '<div id="';
            sb[sb.length] = id;
            sb[sb.length] = '" class="mini-gantt-resize-percentcomplete" style="left:';
            sb[sb.length] = right;
            sb[sb.length] = 'px;top:';
            sb[sb.length] = top;
            sb[sb.length] = 'px;width:';
            sb[sb.length] = width;
            sb[sb.length] = 'px;height:';
            sb[sb.length] = height;
            sb[sb.length] = 'px;"></div>';
        }
    },

    render_dragProxy: function () {
        var ganttview = this.owner;
        if (!ganttview.allowDrag || ganttview.isReadOnly()) return;

        var region = ganttview.viewRegion;
        var viewBox = ganttview.getViewportBounds(region);
        var VLeft = viewBox.left,
            VTop = viewBox.top,
            VWidth = viewBox.width,
            VHeight = viewBox.height;

        var data = ganttview.getItems();
        var startRow = region.startRow,
            endRow = region.endRow;

        var sb = [];
        for (var i = startRow, l = endRow; i <= l; i++) {
            var item = data[i];
            if (!item) continue;
            var box = ganttview.getItemBox(item, VLeft, VTop);
            this.renderItem_dragProxy(item, box, sb);
        }
        var s = '<div>' + sb.join('') + '</div>';
        mini.append(ganttview.barsEl, s);
    }
});

mini.Gantt = function (options) {
    mini.Gantt.superclass.constructor.call(this);

    this.newProject();

    this.ganttView.showCriticalPath = this.showCriticalPath;

    if (options) this.set(options);
};
mini.extend(mini.Gantt, mini.Splitter, {
    allowLinkBars: true,

    setAllowLinkBars: function (value) {
        this.allowLinkBars = value;
    },

    width: 450,
    height: 200,

    expandOnLoad: true,
    baselinePosition: 'bottom',

    baselineIndex: 0,
    viewModel: 'gantt',

    getDefaultTimeScales: function () {
        var topTimeScale = this.ganttView.topTimeScale;
        var bottomTimeScale = this.ganttView.bottomTimeScale;
        var middleTimeScale = this.ganttView.middleTimeScale;

        if (!this.defaultTimeScales) {
            this.defaultTimeScales = {
                topTimeScale: mini.apply({}, topTimeScale),
                bottomTimeScale: mini.apply({}, bottomTimeScale),
                middleTimeScale: mini.apply({}, middleTimeScale),
                timelineRatio: this.timelineRatio
            };
        }
        return this.defaultTimeScales;
    },

    setShowLinkLines: function (value) {
        this.ganttView.showLinkLines = value;
    },
    setViewModel: function (value) {
        this.viewModel = value;
        this.ganttView.setViewModel(value);
    },
    setBaselineIndex: function (value) {
        this.baselineIndex = value;
        this.ganttView.baselineIndex = value;
        this.ganttView.invalidate();
        this.tableView.invalidate();
    },
    setBaselinePosition: function (value) {
        this.baselinePosition = value;
        this.ganttView.baselinePosition = value;
        this.ganttView.invalidate();
    },

    editOnDblClick: false,
    setEditOnDblClick: function (value) {
        this.tableView.editOnDblClick = value;
    },

    data: null,

    headerHeight: 36,
    rowHeight: 22,
    columnWidth: 100,

    tableWidth: '50%',
    splitWidth: 4,
    minViewWidth: 100,

    treeColumn: null,
    columns: null,

    readOnly: false,
    allowDragDrop: false,
    multiSelect: false,

    showDirty: true,

    showGridLines: false,
    timeLines: null,

    showTableView: true,
    showGanttView: true,
    tableViewExpanded: true,
    ganttViewExpanded: true,

    timelineRatio: 1,
    setTimelineRatio: function (value) {
        this.timelineRatio = value;
        this.ganttView.setTimelineRatio(value);
    },

    allowResize: true,
    setAllowResize: function (value) {
        this.allowResize = value;
        this._resizeEl.style.display = this.allowResize ? '' : 'none';
    },

    uiCls: 'mini-gantt',
    _create: function () {
        mini.Gantt.superclass._create.call(this);
        this._createGanttView();

        this._createTableView();

        this.pane1.showCollapseButton = true;
        this.pane2.showCollapseButton = true;

        this.syncTableHeaderHeight();

        this._resizeEl = mini.append(this._borderEl, '<div class="mini-resizer-trigger" style=""></div>');
        this._Resizer = new mini._Resizer(this);
    },
    tableViewType: 'SuperTree',
    _createTableView: function () {
        this.tableView = new mini[this.tableViewType]();
        this.tableView.set({
            rowHeight: this.rowHeight,
            columnWidth: this.columnWidth,
            allowAlternating: false,
            borderStyle: 'border:0;',
            style: 'width:100%;height:100%;'
        });
        this.tableView.owner = this;
        this.tableView.render(this.getPaneEl(1));

        var me = this;
        this.tableView.on('drawheadercell', function (e) {
            var field = me.getSortField(e.column.field);
            if (field) {
                var sortCls = field.direction == 'asc' ? 'mini-grid-asc' : 'mini-grid-desc';
                e.html = e.html + '<span class="mini-grid-sortIcon" style="margin-left:2px;"></span>';
                e.cls += ' ' + sortCls;
            }

            var field = me.getFilterField(e.column.field);
            if (field) {
                e.cls += ' mini-grid-header-filtered';
            }
        });
    },
    ganttViewType: 'GanttView',
    _createGanttView: function () {
        this.ganttView = new mini[this.ganttViewType]();

        this.ganttView.set({
            rowHeight: this.rowHeight,
            showGridLines: this.showGridLines,
            style: 'width:100%;height:100%'
        });
        this.ganttView.isWorking = mini.createDelegate(this.isWorking, this);
        this.ganttView.owner = this;
        this.ganttView.render(this.getPaneEl(2));
    },

    highlightCls: 'mini-gantt-highlight',

    _initEvents: function () {
        mini.Gantt.superclass._initEvents.call(this);
        var sf = this;
        var me = this;

        this.tableView.on('scroll', this.__OnTableViewScroll, this);
        this.ganttView.on('scroll', this.__OnGanttViewScroll, this);

        this.tableView.on(
            'beforeselect',
            function (e) {
                e.task = e.record;
                this.fire('beforeselect', e);
            },
            this
        );

        this.tableView.on(
            'drawcell',
            function (e) {
                e.task = e.record;

                this.fire('drawcell', e);

                if (this._highlightCache && this._highlightCache[e.task.UID]) {
                    if (!e.rowCls) e.rowCls = '';
                    e.rowCls += ' ' + this.highlightCls;

                    if (e.columnIndex >= this.tableView.treeColumnIndex) {
                        e.cellCls += ' mini-gantt-highlight-cell ';
                    }
                }

                if (e.task.Summary) {
                    e.cellCls += ' mini-gantt-summary-cell ';
                }
            },
            this
        );

        this.ganttView.on(
            'drawitem',
            function (e) {
                e.task = e.item;
                this.fire('drawitem', e);
            },
            this
        );

        this.tableView.on('cellbeginedit', this.__OnTableViewCellBeginEdit, this);
        this.tableView.on('cellcommitedit', this.__OnTableViewCellCommitEdit, this);
        this.ganttView.on('itemdragstart', this.__OnGanttViewItemDragStart, this);
        this.ganttView.on('itemdragcomplete', this.__OnGanttViewItemDragComplete, this);

        this.ganttView.on('ScrollToolTipNeeded', this.__OnGanttViewScrollToolTipNeeded, this);
        this.ganttView.on('itemtooltipneeded', this.__OnGanttViewItemToolTipNeeded, this);
        this.ganttView.on('LinkToolTipNeeded', this.__OnGanttViewLinkToolTipNeeded, this);
        this.ganttView.on('ItemDragTipNeeded', this.__OnGanttViewItemDragTipNeeded, this);

        this.tableView.on(
            'cellmousedown',
            function (e) {
                e.task = e.record;
                this.fire('taskmousedown', e);
            },
            this
        );
        this.tableView.on(
            'cellclick',
            function (e) {
                e.task = e.record;
                this.fire('taskclick', e);
            },
            this
        );
        this.tableView.on(
            'celldblclick',
            function (e) {
                e.item = e.task = e.record;
                this.fire('taskdblclick', e);
            },
            this
        );

        this.ganttView.on(
            'itemmousedown',
            function (e) {
                e.task = e.item;

                if (this.multiSelect) {
                    if (this.isSelected(e.item)) {
                    } else {
                        this.deselectAll();
                    }
                    this.select(e.item, true, true);
                } else {
                    this.deselectAll();
                    this.select(e.item, true, true);
                }
                this.fire('taskmousedown', e);
            },
            this
        );
        this.ganttView.on(
            'itemclick',
            function (e) {
                e.task = e.item;
                this.fire('taskclick', e);
            },
            this
        );
        this.ganttView.on(
            'itemdblclick',
            function (e) {
                e.task = e.item;
                this.fire('taskdblclick', e);
            },
            this
        );

        this.tableView.on(
            'expand',
            function (e) {
                e.task = e.node;
                this.fire('expandtask', e);
            },
            this
        );
        this.tableView.on(
            'collapse',
            function (e) {
                e.task = e.node;
                this.fire('collapsetask', e);
            },
            this
        );

        this.tableView.on(
            'RowDragStart',
            function (e) {
                e.task = e.record;
                this.fire('taskdragstart', e);
            },
            this
        );
        this.tableView.on(
            'rowdragdrop',
            function (e) {
                e.tasks = e.records;
                e.targetTask = e.targetRecord;
                this.fire('taskdragdrop', e);

                if (e.cancel == false) {
                    this.fire('dodragdrop', e);
                }
                e.cancel = true;
            },
            this
        );

        this.on('beforecollapse', this.__OnBeforeCollapse, this);
        this.on('beforeexpand', this.__OnBeforeExpand, this);
    },
    __OnTableViewScroll: function (e) {
        var me = this;
        if (e.direction == 'vertical') {
            if (me._ganttScrollTimer) return;
            if (me._tableScrollTimer) clearTimeout(me._tableScrollTimer);
            me._tableScrollTimer = setTimeout(function () {
                me._tableScrollTimer = null;
            }, 50);

            if (this.showGanttView == true && this.ganttViewExpanded == true) {
                if (me.ganttView.scrollTop != me.tableView.scrollTop) {
                    this.ganttView.setScrollTop(this.tableView.scrollTop, true);
                }
            }
        }
    },
    __OnGanttViewScroll: function (e) {
        if (e.direction == 'vertical') {
            var me = this;

            if (this.ganttView.refreshScrollComplete && !this.ganttView.refreshOnScroll) {
            } else {
                if (this.showTableView == true && this.tableViewExpanded == true) {
                    if (me._tableScrollTimer) return;
                    if (me._ganttScrollTimer) clearTimeout(me._ganttScrollTimer);
                    me._ganttScrollTimer = setTimeout(function () {
                        me._ganttScrollTimer = null;
                    }, 50);

                    if (me.ganttView.scrollTop != me.tableView.scrollTop) {
                        me.tableView.setScrollTop(me.ganttView.scrollTop);
                    }
                }
            }
        }
    },
    __OnTableViewCellBeginEdit: function (e) {
        e.task = e.record;
        this.fire('cellbeginedit', e);
    },
    __OnTableViewCellCommitEdit: function (e) {
        e.task = e.record;
        this.fire('cellcommitedit', e);

        if (e.cancel == false) {
            this.fire('aftercellcommitedit', e);
        }
    },
    __OnGanttViewItemDragStart: function (e) {
        this.fire('itemdragstart', e);
    },
    __OnGanttViewItemDragComplete: function (e) {
        this.fire('itemdragcomplete', e);
    },
    __OnGanttViewScrollToolTipNeeded: function (e) {
        e.tooltip = mini.Gantt.ID_Text + '：' + e.item.ID + '<br/>' + mini.Gantt.Name_Text + '：' + e.item.Name;
    },
    __OnGanttViewItemToolTipNeeded: function (e) {
        e.task = e.item;
        var task = e.item;
        function format(date) {
            if (mini.isDate(date)) {
                return mini.formatDate(date, 'yyyy-MM-dd');
            } else {
                return '';
            }
        }
        e.tooltip = '';

        var start = task.Start,
            finish = task.Finish,
            duration = task.Duration;
        if (e.baseline) {
            e.tooltip += "<div style='text-align:center;'><b >" + mini.Gantt.Baseline_Text + '</b></div>';
            start = e.baseline.Start;
            finish = e.baseline.Finish;

            if (!mini.isNull(e.baseline.Duration)) {
                duration = e.baseline.Duration;
            }
        } else if (task.Summary) {
            e.tooltip += "<div style='text-align:center;'><b >" + mini.Gantt.Summary_Text + '</b></div>';
        } else if (task.Critical) {
            e.tooltip += "<div style='text-align:center;'><b >" + mini.Gantt.Critical_Text + '</b></div>';
        } else {
            e.tooltip += "<div style='text-align:center;'><b >" + mini.Gantt.Task_Text + '</b></div>';
        }
        e.tooltip +=
            '<div>' +
            mini.Gantt.Name_Text +
            '：' +
            task.Name +
            '</div>' +
            "<div ><div>" +
            mini.Gantt.PercentComplete_Text +
            '：<b>' +
            task.PercentComplete +
            '%</b></div>' +
            "<div>" +
            mini.Gantt.Duration_Text +
            '：' +
            duration +
            '</div></div>' +
            "<div style='clear:both;'>" +
            mini.Gantt.Start_Text +
            '：' +
            format(start) +
            '</div>' +
            '<div>' +
            mini.Gantt.Finish_Text +
            '：' +
            format(finish) +
            '</div>';
        this.fire('itemtooltipneeded', e);
    },
    __OnGanttViewLinkToolTipNeeded: function (e) {
        var fromItem = e.fromItem,
            toItem = e.toItem,
            link = e.link;
        var tip =
            '' +
            mini.Gantt.LinkType_Text +
            '：' +
            mini.Gantt.PredecessorLinkType[link.Type].Name +
            '<br/>' +
            mini.Gantt.LinkLag_Text +
            '：' +
            (link.LinkLag || 0) +
            '' +
            '<br/>' +
            mini.Gantt.From_Text +
            '：' +
            fromItem.Name +
            '' +
            '<br/>' +
            mini.Gantt.To_Text +
            '：' +
            toItem.Name +
            '';
        e.tooltip = tip;
        this.fire('linktooltipneeded', e);
    },
    __OnGanttViewItemDragTipNeeded: function (e) {
        var tip = '';
        var item = e.item;
        e.task = item;
        if (!item || !item.Start || !item.Finish) {
        } else {
            var d1 = this.ganttView.bottomTimeScale.tooltip(item.Start, 'bottom', this.ganttView.bottomTimeScale.type);
            var d2 = this.ganttView.bottomTimeScale.tooltip(item.Finish, 'bottom', this.ganttView.bottomTimeScale.type);
            tip =
                mini.Gantt.Name_Text +
                '：' +
                item.Name +
                '<br/>' +
                mini.Gantt.PercentComplete_Text +
                '：<b>' +
                item.PercentComplete +
                '%</b>' +
                '<br/>' +
                mini.Gantt.Start_Text +
                '：<b>' +
                d1 +
                '</b>' +
                '<br/>' +
                mini.Gantt.Finish_Text +
                '：<b>' +
                d2 +
                '</b>';
        }
        e.tooltip = tip;
        this.fire('TaskDragTipNeeded', e);
    },

    isWorking: function (date, timescale) {
        if (!this.data) return true;
        var type = timescale.type;
        if (
            (type == 'day' && timescale.number > 1) ||
            type == 'week' ||
            type == 'month' ||
            type == 'quarter' ||
            type == 'halfyear' ||
            type == 'tendays'
        )
            return true;

        var dayOfWeek = date?.getDay(),
            dateTime = date?.getTime();
        if (dayOfWeek == 6 || dayOfWeek == 0) return false;
        return true;
    },

    syncTableHeaderHeight: function () {
        this.headerHeight = this.ganttView.getHeaderHeight();
        if (this.headerHeight != this.tableView.headerHeight) {
            this.tableView.setHeaderHeight(this.headerHeight);
        }
    },

    doLayout: function () {
        mini.Gantt.superclass.doLayout.call(this);

        if (this.ganttViewExpanded == false || this.showGanttView == false) {
            this.tableView.setShowVScroll(true);
        } else {
            this.tableView.setShowVScroll(false);
        }
    },
    __OnBeforeExpand: function (e) {
        e.cancel = true;
        if (e.paneIndex == 1) {
            this.setTableViewExpanded(true);
        } else {
            this.setGanttViewExpanded(true);
        }
    },
    __OnBeforeCollapse: function (e) {
        e.cancel = true;
        if (e.paneIndex == 1) {
            this.setTableViewExpanded(false);
        } else {
            this.setGanttViewExpanded(false);
        }
    },
    setShowGanttView: function (value) {
        if (this.showGanttView != value) {
            this.showGanttView = value;
            this._allowLayout = false;
            if (value) {
                this.showPane(2);
            } else {
                this.hidePane(2);
            }

            this._doShow();
            this.ganttView.setScrollTop(this.tableView.getScrollTop());
        }
    },
    setShowTableView: function (value) {
        if (this.showTableView != value) {
            this.showTableView = value;
            this._allowLayout = false;
            if (value) {
                this.showPane(1);
            } else {
                this.hidePane(1);
            }
            this._doShow();
            this.tableView.setScrollTop(this.ganttView.getScrollTop());
        }
    },
    setGanttViewExpanded: function (value) {
        if (this.ganttViewExpanded != value) {
            this.ganttViewExpanded = value;
            this._allowLayout = false;
            if (value) {
                this.expandPane(2);
            } else {
                this.collapsePane(2);
            }

            this._doShow();
            this.ganttView.setScrollTop(this.tableView.getScrollTop());
        }
    },
    setTableViewExpanded: function (value) {
        if (this.tableViewExpanded != value) {
            this.tableViewExpanded = value;
            this._allowLayout = false;
            if (value) {
                this.expandPane(1);
            } else {
                this.collapsePane(1);
            }
            this._doShow();
            this.tableView.setScrollTop(this.ganttView.getScrollTop());
        }
    },
    _doShow: function () {
        this.tableViewExpanded = this.pane1.expanded;
        this.ganttViewExpanded = this.pane2.expanded;

        this.showTableView = this.pane1.visible;
        this.showGanttView = this.pane2.visible;

        this._allowLayout = true;

        this.invalidateLayout();

        this.ganttView.invalidate();
    },
    setTableViewWidth: function (value) {
        this.updatePane(1, { size: value });
    },
    setGanttViewWidth: function (value) {
        this.updatePane(2, { size: value });
    },

    setShowDirty: function (value) {
        this.showDirty = value;
        this.tableView.setShowDirty(value);
    },
    setShowCriticalPath: function (value) {
        this.showCriticalPath = value;
        this.ganttView.setShowCriticalPath(value);
    },
    setShowGridLines: function (value) {
        this.showGridLines = value;
        this.ganttView.setShowGridLines(value);
    },
    showLabel: true,
    setShowLabel: function (value) {
        this.showLabel = value;
        this.ganttView.setShowLabel(value);
    },
    setTimeLines: function (value) {
        this.timeLines = value;
        this.ganttView.setTimeLines(value);
    },
    setRowHeight: function (value) {
        value = parseInt(value);
        if (isNaN(value)) return;
        if (value != this.rowHeight) {
            this.rowHeight = value;
            this.tableView.setRowHeight(value);
            this.ganttView.setRowHeight(value);
        }
    },
    setMultiSelect: function (value) {
        if (this.multiSelect != value) {
            this.multiSelect = value;
            this.tableView.setMultiSelect(value);
        }
    },
    allowUnselect: false,
    setAllowUnselect: function (value) {
        this.allowUnselect = value;
        this.tableView.setAllowUnselect(value);
    },
    getAllowUnselect: function (value) {
        return this.allowUnselect;
    },
    setAllowDragDrop: function (value) {
        if (this.allowDragDrop != value) {
            this.allowDragDrop = value;
            this.tableView.setAllowDragDrop(value);
        }
    },
    scrollIntoView: function (task, toFinish, toTop) {
        this.ganttView.scrollIntoView(task, toFinish);
        if (toTop) {
            this.tableView.scrollIntoView(task);

            this.ganttView.setScrollTop(this.tableView.getScrollTop(), true);
        }
    },
    scrollToDate: function (date, toFinish) {
        this.ganttView.scrollToDate(date, toFinish);
    },
    zoomIn: function () {
        this.ganttView.zoomIn();
        var task = this.getSelected();
        if (task) {
            this.scrollIntoView(task);
        }
    },
    zoomOut: function () {
        this.ganttView.zoomOut();
        var task = this.getSelected();
        if (task) {
            this.scrollIntoView(task);
        }
    },
    zoomFit: function () {
        this.ganttView.zoomFit();
    },
    setTopTimeScale: function (value) {
        this.ganttView.setTopTimeScale(value);
        this.syncTableHeaderHeight();
    },
    setBottomTimeScale: function (value) {
        this.ganttView.setBottomTimeScale(value);
        this.syncTableHeaderHeight();
    },
    setMiddleTimeScale: function (value) {
        this.ganttView.setMiddleTimeScale(value);
        this.syncTableHeaderHeight();
    },

    frozenColumn: function (start, end) {
        this.tableView.frozenColumn(start, end);
    },
    unfrozenColumn: function () {
        this.tableView.unfrozenColumn();
    },
    getViewStartColumn: function () {
        return this.tableView.viewRegion.startColumn;
    },
    getViewEndColumn: function () {
        return this.tableView.viewRegion.endColumn;
    },

    getCurrentCell: function () {
        return this.tableView.getCurrentCell();
    },

    setCurrentCell: function (cell) {
        this.tableView.setCurrentCell(cell);
    },

    getSelectedColumn: function () {
        var cell = this.tableView.getCurrentCell();
        return cell ? cell.column : null;
    },
    indexOfColumn: function (column) {
        column = this.tableView.getColumn(column);
        return this.tableView.viewColumns.indexOf(column);
    },

    setColumnWidth: function (column, value) {
        this.tableView.updateColumn(column, { width: value });
    },

    moveColumn: function (column, targetColumn, insertAction) {
        this.tableView.moveColumn(column, targetColumn, insertAction);
    },

    setColumns: function (value) {
        this.tableView.setColumns(value);
    },
    getColumns: function () {
        return this.tableView.getColumns();
    },
    updateColumn: function (column, options) {
        this.tableView.updateColumn(column, options);
    },
    getColumn: function (name) {
        return this.tableView.getColumn(name);
    },
    getColumnAt: function (index) {
        return this.tableView.getColumnAt(index);
    },
    setTreeColumn: function (value) {
        this.tableView.setTreeColumn(value);
    },
    setRowHeight: function (value) {
        if (this.rowHeight != value) {
            this.rowHeight = value;
            this.tableView.setRowHeight(value);
            this.ganttView.setRowHeight(value);
        }
    },
    allowProjectDateRange: false,
    getDateRange: function () {
        var start = this.getStartDate(),
            finish = this.getFinishDate();
        if (finish <= start) {
            finish = new Date(start?.getTime());
            finish?.setDate(finish?.getDate() + 1);
        }

        if (this.allowProjectDateRange == false) {
            var start = null,
                finish = null;
        }
        var tasks = this.getTaskList();
        for (var i = 0, l = tasks.length; i < l; i++) {
            var node = tasks[i];
            if (node.Start) {
                if (!start || start > node.Start) start = node.Start;
            }
            if (node.Finish) {
                if (!finish || finish < node.Finish) finish = node.Finish;
            }
            if (this.viewModel != 'gantt') {
                var bl = this.ganttView.getBaseline(node);
                if (bl) {
                    if (bl.Start) {
                        if (!start || start > bl.Start) start = bl.Start;
                    }
                    if (bl.Finish) {
                        if (!finish || finish < bl.Finish) finish = bl.Finish;
                    }
                }
            }
        }
        if (!start || !finish) return null;

        return [start, finish];
    },
    createDefaultCalendars: function () {
        return eval(
            "[{UID: 1,IsBaseCalendar: 1,BaseCalendarUID:-1,Name: '标准',WeekDays: [{DayType: 1,DayWorking: 0},{DayType: 2,DayWorking: 1},{DayType: 3,DayWorking: 1},{DayType: 4,DayWorking: 1},{DayType: 5,DayWorking: 1},{DayType: 6,DayWorking: 1},{DayType: 7,DayWorking: 0}],Exceptions:[]}]"
        );
    },
    getTask: function (uid) {
        if (uid === null || uid === undefined) return null;
        uid = typeof uid == 'object' ? uid.UID : uid;
        return this._TaskUIDs[uid];
    },
    getTaskAt: function (index) {
        return this.store.getAt(index);
    },
    getTaskByID: function (taskID) {
        taskID = parseInt(taskID) - 1;

        return this.getTaskList()[taskID];
    },
    getTaskByCode: function (taskCode) {
        return this.getTaskList().find((item) => item.identifierNo === taskCode);
    },
    findTasks: function (field, value) {
        return this.store.findRecords(field, value);
    },

    indexOfParent: function (task) {
        return this.store.indexOfParent(task);
    },
    indexOfList: function (task) {
        return this.store.indexOf(task);
    },

    eachChild: function (task, fn, scope) {
        this.store.eachChild(task, fn, scope);
    },
    cascadeChild: function (task, fn, scope) {
        this.store.cascadeChild(task, fn, scope);
    },
    bubbleParent: function (task, fn, scope) {
        this.store.bubbleParent(task, fn, scope);
    },

    collapseLevel: function (level, deep) {
        this.store.collapseLevel(level, deep);
    },
    expandLevel: function (level, deep) {
        this.store.expandLevel(level, deep);
    },
    isExpanded: function (task) {
        if (!task || this.store.hasChildNodes(task) == false) return false;
        return this.store.isExpandedNode(task);
    },
    collapse: function (node, deep) {
        this.store.collapse(node, deep);
    },
    expand: function (node, deep) {
        this.store.expand(node, deep);
    },
    toggle: function (node) {
        this.store.toggle(node);
    },
    collapseAll: function () {
        this.store.collapseAll();
        this.tableView.setScrollTop(0);
        this.ganttView.setScrollTop(0);
    },
    expandAll: function () {
        this.store.expandAll();
    },
    newProject: function () {
        var d = new Date();
        var startDate = new Date(d?.getFullYear(), d?.getMonth(), d?.getDate());
        var finishDate = new Date(d?.getFullYear(), d?.getMonth() + 3, d?.getDate());

        this.data = {
            Name: '',
            StartDate: startDate,
            FinishDate: finishDate,
            CalendarUID: '1',
            Calendars: this.createDefaultCalendars(),
            Tasks: [],
            Resources: []
        };
        this._initProject(this.data);
        this.loadTasks([]);
    },
    _initProject: function (project) {
        if (!mini.isDate(project.StartDate)) throw new Error('StartDate must be Date type');
        if (!mini.isDate(project.FinishDate)) throw new Error('FinishDate must be Date type');

        if (!project.CalendarUID || !project.Calendars) {
            project.CalendarUID = '1';
            project.Calendars = this.createDefaultCalendars();
        }
        this.startDate = project.StartDate;
        this.finishDate = project.FinishDate;

        this.rootTaskUID = -1;
        this._TaskUIDs = {};

        this._initResources();

        if (!this._Validator) this._Validator = new MyProjectSchedule.Validator(this);
        if (!this._Critical) this._Critical = new MyProjectSchedule.Critical(this);

        if (!project.Status) project.Status = 1;
    },

    _initResources: function () {
        var me = this,
            project = me.data;

        this._ResourceUIDs = {};
        var res = project.Resources || [];
        project.Resources = res;
        for (var i = 0, l = res.length; i < l; i++) {
            var re = res[i];

            if (!re.UID) re.UID = UUID();
            if (re.Type == null) re.Type = 1;
            if (re.Cost == null) re.Cost = 0;
            if (re.StandardRate == null) re.StandardRate = 0;
            if (re.OvertimeRate == null) re.OvertimeRate = 0;

            this._ResourceUIDs[re.UID] = re;
        }

        function eachAssignments(task) {
            if (!task.Assignments) return;
            for (var i = task.Assignments.length - 1; i >= 0; i--) {
                var o = task.Assignments[i];
                if (!o.Units) o.Units = 1;
                if (!o.Cost) o.Cost = 0;
                if (!o.Work) o.Work = 0;

                var re = me.getResource(o.ResourceUID);
                if (re) {
                } else {
                    task.Assignments.removeAt(i);
                }
            }
        }

        var tasks = project.Tasks;
        function each(tasks) {
            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];
                if (task.children) each(task.children);

                eachAssignments(task);
            }
        }
        each(tasks);
    },

    getRemovedTasks: function () {
        var tasks = this.store.getChanges('removed');
        for (var i = 0, l = tasks.length; i < l; i++) {
            delete tasks[i].children;
        }
        return tasks;
    },
    isChanged: function () {
        var list = this.getTaskList();
        for (var i = 0, l = list.length; i < l; i++) {
            var t = list[i];
            if (t._state) {
                return true;
            }
        }
        var removed = this.getRemovedTasks();
        if (removed.length > 0) return true;
        return false;
    },

    getTaskTree: function () {
        return this.store.root.children;
    },
    getTaskList: function () {
        return this.store.getList();
    },
    getChangedTasks: function (rowState, onlyField) {
        var tasks = this.store.getChanges(rowState, onlyField);
        return tasks;
    },
    acceptChanges: function () {
        var list = this.getTaskList();
        for (var i = 0, l = list.length; i < l; i++) {
            var task = list[i];
            task._x = task.ID + ':' + task.OutlineNumber;
        }
        this.store.accept();
        this.lastScheduleDate = this.firstScheduleDate = new Date();
    },
    parseTasks: function (tasks, taskmap) {
        return tasks;
    },

    _taskParseDate: function (task) {
        if (task.Start && !mini.isDate(task.Start)) {
            task.Start = mini.parseDate(task.Start);
        }
        if (task.Finish && !mini.isDate(task.Finish)) {
            task.Finish = mini.parseDate(task.Finish);
        }

        if (!mini.isDate(task.Start)) {
            task.Start = null;
        }
        if (!mini.isDate(task.Finish)) {
            task.Finish = null;
        }

        var baseline = task.Baseline && task.Baseline[0];
        if (baseline) {
            if (baseline.Start && !mini.isDate(baseline.Start)) {
                baseline.Start = mini.parseDate(baseline.Start);
            }
            if (baseline.Finish && !mini.isDate(baseline.Finish)) {
                baseline.Finish = mini.parseDate(baseline.Finish);
            }
        }
    },
    showProjectSummary: false,

    loadTasks: function (tasks) {
        this._initTasks = true;

        if (!mini.isArray(tasks)) tasks = [];

        this.parseTasks(tasks, this.data.TASKMAP);
        delete this.data.TASKMAP;

        this.allowTaskModified = false;

        this.data.Tasks = tasks;

        this.store = new mini.TreeStore();
        this.tasks = this.store;

        this.store.expandOnLoad = this.expandOnLoad;
        this.store.idField = 'UID';
        this.store.parentField = 'ParentTaskUID';
        this.store.setRootVisible(this.showProjectSummary);

        this.store.loadData(tasks);
        this.store.getRootNode().UID = this.rootTaskUID;

        var tasks = this.getTaskList();
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            this._taskParseDate(task);
        }

        this.tableView.setData(this.store);
        this.ganttView.setData(this.store);

        this.allowTaskModified = true;

        this._allowModifiedButId = true;

        if (this.beforeFirstSchedule) this.beforeFirstSchedule();

        this.orderProject();

        this._allowModifiedButId = false;

        var tasks = this.getTaskList();
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            task._x = task.ID + ':' + task.OutlineNumber;
        }

        this.store.on(
            'selectionchanged',
            function (e) {
                this.fire('selectionchanged', e);
            },
            this
        );
        this.store.on('datachanged', this.onStoreDataChanged, this);
        this.store.on('refresh', this.onStoreRefresh, this);

        this._initTasks = false;
    },

    onStoreDataChanged: function (e) {
        this._updateHighlight();
        this.fire('datachanged', e);
    },

    onStoreRefresh: function (e) {},

    _syncTasks2: function () {
        var nodesField = this.store.nodesField;
        var nodes = this.store.getRootNode()[nodesField];

        var uids = (this._TaskUIDs = {});

        var __TaskID = 1;

        function eachTasks(nodes, parentTaskUID) {
            if (!nodes) return;
            for (var i = 0, l = nodes.length; i < l; i++) {
                var task = nodes[i];

                task['ID'] = __TaskID++;

                task['ParentTaskUID'] = parentTaskUID;

                uids[task.UID] = task;
                var childNodes = task[nodesField];
                if (childNodes != null && childNodes.length > 0) {
                    eachTasks(childNodes, task.UID);
                } else {
                }
            }
        }

        eachTasks(nodes, this.rootTaskUID);
    },
    syncTasks: function (allowRange) {
        var tasks = this.getTaskList();
        this._TaskUIDs = {};
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            this._TaskUIDs[task.UID] = task;
        }

        var rootNodes = this.store.getRootNode()[this.store.nodesField];

        var sss = new Date();

        this._syncTaskNodes(rootNodes, 1, '', this.rootTaskUID);

        if (this._Validator && allowRange !== false) this._Validator.valid();

        if (allowRange !== false) {
            var dr = this.getDateRange();
            if (dr) {
                this.ganttView.setDateRange(dr[0], dr[1]);

                this.ganttView.invalidateLayout(true);
            }
        }

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            if (task._x != task.ID + ':' + task.OutlineNumber && !this._initTasks) {
                this.setTaskModified(task, 'ID', task._x);
            }
        }
    },
    __TaskID: 1,
    autoSyncSummary: true,
    allowSummaryLink: true,
    _syncTaskNodes: function (nodes, outlineLevel, outlineNumber, parentTaskUID) {
        if (parentTaskUID == this.rootTaskUID) {
            this.__TaskID = 1;
        }

        var event = {},
            nodesField = this.store.nodesField;

        var start = null,
            finish = null,
            work = 0;
        for (var i = 0, l = nodes.length; i < l; i++) {
            var task = nodes[i];

            task['ID'] = this.__TaskID++;
            task['OutlineLevel'] = outlineLevel;
            task['OutlineNumber'] = outlineNumber + (i + 1);
            task['ParentTaskUID'] = parentTaskUID;

            event.task = task;

            var childNodes = task[nodesField];
            if (childNodes != null && childNodes.length > 0) {
                if (task.Summary != 1) this.setTaskModified(task, 'Summary');

                task.Summary = 1;

                var dd = this._syncTaskNodes(childNodes, outlineLevel + 1, task.OutlineNumber + '.', task.UID);
                if (this.autoSyncSummary) {
                    if (dd[0]) task.Start = dd[0];
                    if (dd[1]) {
                        task.Finish = dd[1];
                    }
                }

                this.fire('tasksync', event);
            } else {
                if (task.isLeaf === false) {
                } else {
                    if (task.Summary != 0) this.setTaskModified(task, 'Summary');

                    task.Summary = 0;
                }

                this.fire('tasksync', event);
            }

            if ((task.Summary == 1 && this.allowSummaryLink == false) || !task.PredecessorLink) {
                task.PredecessorLink = [];
            }
            var links = task.PredecessorLink;

            for (var j = links.length - 1; j >= 0; j--) {
                var link = links[j];
                var preTask = this._TaskUIDs[link.PredecessorUID];

                if (preTask == null) {
                    mini.Array.removeAt(links, j);
                    this.setTaskModified(task, 'PredecessorLink');
                } else if (this.store.isAncestor(task, preTask) || this.store.isAncestor(preTask, task)) {
                    if (this.enableValidTasks !== false) {
                        mini.Array.removeAt(links, j);
                        this.setTaskModified(task, 'PredecessorLink');
                    }
                }
            }

            if (this.autoSyncSummary) {
                if (task.Start && (!start || start?.getTime() > task.Start?.getTime())) {
                    start = new Date(task.Start?.getTime());
                }
                if (task.Finish && (!finish || finish?.getTime() < task.Finish?.getTime())) {
                    finish = new Date(task.Finish?.getTime());
                }
            }
        }
        return this.autoSyncSummary ? [start, finish, work] : null;
    },

    getNextTask: function (task) {
        task = this.getTask(task);
        return this.store.getNextNode(task);
    },
    getPrevTask: function (task) {
        task = this.getTask(task);
        return this.store.getPrevNode(task);
    },
    getFirstTask: function (parentTask) {
        parentTask = this.getTask(parentTask);
        return this.store.getFirstNode(parentTask);
    },
    getLastTask: function (parentTask) {
        parentTask = this.getTask(parentTask);
        return this.store.getLastNode(parentTask);
    },
    getParentTask: function (task) {
        task = this.getTask(task);
        if (!task) return null;
        var parentTask = this.store.getParentNode(task);
        if (parentTask == this.store.getRootNode()) return null;
        return parentTask;
    },
    getChildTasks: function (task, all) {
        return this.store.getChildNodes(task, all, false);
    },
    getRoot: function () {
        return this.store.getRootNode();
    },
    getAllChildTasks: function (task) {
        return this.getChildTasks(task, true);
    },
    getAncestorTasks: function (task) {
        return this.store.getAncestors(task);
    },
    isAncestor: function (parentTask, task) {
        parentTask = this.getTask(parentTask);
        task = this.getTask(task);
        return this.store.isAncestor(parentTask, task);
    },
    getViewStartDate: function () {
        return this.ganttView.startDate;
    },
    getViewFinishDate: function () {
        return this.ganttView.finishDate;
    },
    getStartDate: function () {
        return this.data.StartDate;
    },
    getFinishDate: function () {
        return this.data.FinishDate;
    },

    newTask: function () {
        task = {};
        task.UID = UUID();
        task.Name = '';
        task.PercentComplete = 0;
        task.Work = 0;
        task.Weight = 0;
        task.ConstraintType = 0;

        var d = this.ganttView.startDate;
        task.Start = new Date(d?.getFullYear(), d?.getMonth(), d?.getDate());
        task.Finish = new Date(d?.getFullYear(), d?.getMonth(), d?.getDate(), 23, 59, 59);
        task.Duration = 1;
        task.Work = 0;
        var e = { task: task };
        this.fire('taskcreated', e);
        return e.task;
    },

    addTask: function (task, index, targetTask) {
        if (!task || typeof task != 'object') return;
        if (index == 'add') index = 'append';
        if (!index && index !== 0) index = -1;
        targetTask = this.getTask(targetTask);
        if (!targetTask) targetTask = this.store.getRootNode();
        if (targetTask == this.store.getRootNode() && typeof index == 'string') {
            index = 'append';
        }

        this._taskParseDate(task);

        var _newTask = this.newTask();
        mini.copyTo(task, mini.copyTo(_newTask, task));

        if (!mini.isNull(task.UID)) this._TaskUIDs[task.UID] = task;

        this.store.beginChange();
        this.beginOrder();
        switch (index) {
            case 'before':
                index = this.store.indexOfParent(targetTask);
                var parentTask = this.store.getParentNode(targetTask);
                this.store.insertNode(task, index, parentTask);
                break;
            case 'after':
                index = this.store.indexOfParent(targetTask);
                var parentTask = this.store.getParentNode(targetTask);
                this.store.insertNode(task, index + 1, parentTask);
                break;
            case 'append':
            case 'add':
                this.store.addNode(task, targetTask);
                break;
            default:
                if (mini.isNumber(index)) {
                    this.store.insertNode(task, index, targetTask);
                }
                break;
        }

        this.endOrder();
        this.store.endChange();

        this.fireEvent('taskadded', { tasks: [task] });
    },
    acceptTask: function (task) {
        if (!task) return;
        this.store.beginChange();
        this.store.acceptRecord(task);
        this.cascadeChild(
            task,
            function (t) {
                this.store.acceptRecord(t);
            },
            this
        );
        this.store.endChange();
    },
    addTasks: function (tasks, index, targetTasks) {
        if (!mini.isArray(targetTasks)) {
            targetTasks = [targetTasks];
        }
        if (!mini.isArray(targetTasks) || !mini.isArray(tasks)) return;
        this.store.beginChange();

        this.beginOrder();

        if (index == 'after') tasks = tasks.reverse();

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            for (var j = 0, k = targetTasks.length; j < k; j++) {
                var targetTask = targetTasks[j];
                targetTask = this.getTask(targetTask);

                task = mini.clone(task);
                this.addTask(task, index, targetTask);
            }
        }

        this.endOrder();

        this.store.endChange();

        this.fireEvent('taskadded', { tasks: tasks });
    },
    removeTask: function (task) {
        task = this.getTask(task);
        if (!task) return null;
        if (task.UID == this.rootTaskUID) {
            this.clearTasks();
            return task;
        }

        this.store.beginChange();

        var parentTasks = this._getParentTasks([task]);
        this.store.removeNode(task);
        this._changeSummaryTaskToNormalTask(parentTasks);

        this.orderProject();
        this.store.endChange();

        this.fireEvent('taskremoved', { tasks: [task] });
    },

    _changeSummaryTaskToNormalTask: function (tasks) {},
    _getParentTasks: function (tasks) {
        var list = [];
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = this.getTask(tasks[i]);
            if (!task) continue;
            var parent = this.getParentTask(task);
            if (parent) {
                list.push(parent);
            }
        }
        return list;
    },

    clearTasks: function () {
        this.store.beginChange();
        var tasks = this.getTaskList();
        this.data.Tasks = [];
        this.store.clear();
        this.syncTasks();
        this.store.endChange();
        this.fireEvent('taskremoved', { tasks: tasks });
    },
    isModifiedField: function (task, field) {
        var task = this.getTask(task);
        if (!task || !field) return;
        return this.store.isModified(task, field);
    },
    updateTask: function (task, field, value) {
        var task = this.getTask(task);
        if (!task || !field) return;

        this.store.beginChange();

        this.store.updateRecord(task, field, value);

        this.orderProject();
        this.store.endChange();

        var e = { task: task, field: field, value: value };
        this.fireEvent('taskupdated', e);
    },
    updateTasks: function (tasks, newTask) {
        if (!mini.isArray(tasks) || typeof newTask != 'object') return;
        this.store.beginChange();
        this.beginOrder();
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            task = this.getTask(task);
            var keyValue = mini.clone(newTask);
            this.store.updateRecord(task, keyValue);

            var e = { task: task, field: newTask };
            this.fireEvent('taskupdated', e);
        }
        this.endOrder();
        this.store.endChange();
    },
    moveTask: function (task, targetTask, action) {
        task = this.getTask(task);
        targetTask = this.getTask(targetTask);
        if (!task || !targetTask || mini.isNull(action)) return;
        this.store.beginChange();

        var parentTasks = this._getParentTasks([task]);
        this.store.moveNode(task, targetTask, action);
        this._changeSummaryTaskToNormalTask(parentTasks);

        this.store.endChange();
        this.orderProject();

        this.fireEvent('taskmoved', { tasks: [task] });
    },
    moveTasks: function (tasks, targetTask, action) {
        targetTask = this.getTask(targetTask);
        if (!tasks || tasks.length == 0 || !targetTask || mini.isNull(action)) return;
        this.store.beginChange();

        for (var i = 0, l = tasks.length; i < l; i++) {
            tasks[i] = this.getTask(tasks[i]);
        }

        var parentTasks = this._getParentTasks(tasks);
        this.store.moveNodes(tasks, targetTask, action);
        this._changeSummaryTaskToNormalTask(parentTasks);

        this.store.endChange();
        this.orderProject();

        this.fireEvent('taskmoved', { tasks: tasks });
    },

    _makeTasks: function (tasks) {
        tasks = jQuery.makeArray(tasks);
        for (var i = tasks.length - 1; i >= 0; i--) {
            var task = tasks[i];
            task = this.getTask(task);
            if (!task) {
                tasks.removeAt(i);
            }
        }

        tasks.sort(function (a, b) {
            return a.ID > b.ID ? 1 : -1;
        });
        return tasks;
    },

    _removeChildFromArray: function (tasks) {
        var store = this.store;
        function fn(child, index) {
            for (var i = tasks.length - 1; i >= 0; i--) {
                var parent = tasks[i];
                if (parent != child) {
                    if (store.isAncestor(parent, child)) {
                        return true;
                    }
                }
            }
        }

        for (var i = tasks.length - 1; i >= 0; i--) {
            if (fn(tasks[i], i)) {
                tasks.removeAt(i);
            }
        }

        return tasks;
    },

    upgradeTask: function (tasks) {
        tasks = this._makeTasks(tasks);
        tasks = this._removeChildFromArray(tasks);
        if (tasks.length == 0) return;
        this.store.beginChange();

        var parentTasks = this._getParentTasks(tasks);

        for (var i = tasks.length - 1; i >= 0; i--) {
            var task = tasks[i];
            this.store.upGrade(task);
        }

        this._changeSummaryTaskToNormalTask(parentTasks);

        this.orderProject();

        this.store.endChange();

        this.fireEvent('taskupgraded', { task: tasks[0], tasks: tasks });
    },
    downgradeTask: function (tasks) {
        tasks = this._makeTasks(tasks);
        tasks = this._removeChildFromArray(tasks);
        if (tasks.length == 0) return;
        this.store.beginChange();

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            this.store.downGrade(task);
        }

        this.orderProject();
        this.store.endChange();
        this.fireEvent('taskdowngraded', { task: tasks[0], tasks: tasks });
    },

    moveUpTask: function (task) {
        var parentTask = this.getParentTask(task);
        var prevTask = this.getPrevTask(task);
        if (prevTask) {
            this.moveTask(task, prevTask, 'before');
        }
    },
    moveDownTask: function (task) {
        var parentTask = this.getParentTask(task);
        var nextTask = this.getNextTask(task);
        if (nextTask) {
            this.moveTask(task, nextTask, 'after');
        }
    },

    removeTasks: function (tasks) {
        if (!mini.isArray(tasks)) return;

        for (var i = 0, l = tasks.length; i < l; i++) {
            tasks[i] = this.getTask(tasks[i]);
        }

        this.store.beginChange();

        var parentTasks = this._getParentTasks(tasks);
        this.store.removeNodes(tasks);
        this._changeSummaryTaskToNormalTask(parentTasks);

        this.orderProject();
        this.store.endChange();

        this.fireEvent('taskremoved', { tasks: tasks });
    },
    setScrollTop: function (value, must) {
        this.tableView.setScrollTop(value, must);
        this.ganttView.setScrollTop(value, must);
    },

    allowLinkLimit: false,
    getPredecessorLink: function (task, preTask) {
        task = this.getTask(task);
        preTask = this.getTask(preTask);
        if (task == null || !preTask) return null;
        var links = task.PredecessorLink;
        if (links != null && links.length > 0) {
            for (var i = 0, l = links.length; i < l; i++) {
                var link = links[i];
                if (link.PredecessorUID == preTask.UID) return link;
            }
        }
        return null;
    },
    getLinkString: function (links) {
        if (typeof links == 'string') return links;
        if (!links) links = [];
        var sb = [];
        for (var i = 0, l = links.length; i < l; i++) {
            var link = links[i];
            if (!link.LinkLag) link.LinkLag = 0;
            var preTask = this.getTask(link.PredecessorUID);
            if (!preTask) continue;
            var s = link.code || preTask.identifierNo;
            // if (link.Type != 1 || link.LinkLag != 0) {
            s += mini.Gantt.PredecessorLinkType[link.Type].Short;
            // }
            // if (link.LinkLag != 0) {
            //     if (link.LinkLag > 0) {
            s += '+';
            // }
            s += link.LinkLag;
            // }

            if (this.allowLinkLimit) {
                if (!link.Limit) {
                    s = '~' + s;
                }
            }

            sb.push(s);
        }
        return sb.join(',');
    },
    getLinksByString: function (linkString) {
        var links = [];

        if (mini.isArray(linkString)) links = linkString;
        if (typeof linkString == 'string') {
            var lss = linkString.split(',');
            for (var i = 0, l = lss.length; i < l; i++) {
                var ls = lss[i];
                try {
                    var code = -1;
                    var linkType = -1;
                    var limit = true;
                    var linkLag = 0;

                    var s = ls.trim().toUpperCase();

                    if (s.substring(0, 1) == '~') {
                        limit = false;
                        s = s.substring(1);
                    }

                    if (['FF', 'FS', 'SF', 'SS'].some((type) => s.includes(type))) {
                        const reg = /^([\w|\s|-]+)(FF|FS|SF|SS)(\s*[+|-]\s*\d+)?$/g;
                        if (!reg.test(s)) {
                            window.$message.info('格式错误');
                            continue;
                        }
                        reg.lastIndex = 0;
                        let [matchData] = [...s.matchAll(reg)];
                        code = matchData[1];
                    } else {
                        code = s;
                    }

                    if (code <= 0 || !code) continue;

                    var preTask = this.getTaskByCode(code);

                    if (!preTask) {
                        window.$message.info(`任务【${code}】未匹配到，请输入正确的编码`);
                        continue;
                    }

                    s = s.substring(code.toString().length);

                    if (s.indexOf('+') != -1) {
                        var ss = s.split('+');
                        s = ss[0];
                        if (ss.length > 1) {
                            linkLag = this.parseLinkLag(ss[1]);
                        }
                    } else if (s.indexOf('-') != -1) {
                        var ss = s.split('-');
                        s = ss[0];
                        if (ss.length > 1) {
                            linkLag = -this.parseLinkLag(ss[1]);
                        }
                    }

                    if (s == 'FF') linkType = 0;
                    if (s == 'FS' || s == '') linkType = 1;
                    if (s == 'SF') linkType = 2;
                    if (s == 'SS') linkType = 3;
                    if (linkType == -1) continue;

                    var link = {};
                    link['PredecessorUID'] = preTask['UID'];
                    link['Type'] = linkType;
                    link['LinkLag'] = linkLag;
                    link['Limit'] = limit;
                    link['code'] = code;

                    links.push(link);
                } catch (ex) {
                    console.error(ex);
                }
            }
        }
        return links;
    },

    parseLinkLag: function (s) {
        return parseInt(s);
    },

    removeLink: function (task, preTask) {
        if (!task) return;
        if (task.TaskUID) {
            preTask = task.PredecessorUID;
            task = task.TaskUID;
        }

        task = this.getTask(task);
        preTask = this.getTask(preTask);
        if (!task || !preTask) return;
        var links = task.PredecessorLink;
        if (links != null) {
            for (var i = links.length - 1; i >= 0; i--) {
                var link = links[i];
                if (link.PredecessorUID == preTask.UID) {
                    links.removeAt(i);
                }
            }
        }

        this._Validator.valid();
        this.setTaskModified(task, 'PredecessorLink');
        this.orderProject();
    },

    _checkLinks: function (links, task) {
        for (var i = links.length - 1; i >= 0; i--) {
            var link = links[i];

            var preTask = this.getTask(link.PredecessorUID);
            if (preTask == null) {
                links.removeAt(i);
                continue;
            }

            if (link.Type == null) link.Type = 1;
            if (link.LinkLag == null) link.LinkLag = 0;
            link.TaskUID = task.UID;
        }
    },

    addLink: function (task, link) {
        task = this.getTask(task);
        if (!task || !link) return;

        var oldLinks = task.PredecessorLink;

        try {
            var oldLink = this.getPredecessorLink(task, link.PredecessorUID);
            if (oldLink) throw new Error('不能加入相同的前置关系');

            var links = oldLinks ? oldLinks.clone() : [];
            links.push(link);
            this._checkLinks(links, task);

            task.PredecessorLink = links;
            this._Validator.valid();
            this.setTaskModified(task, 'PredecessorLink');
            this.orderProject();
        } catch (ex) {
            task.PredecessorLink = oldLinks;
            throw ex;
        }
    },

    setLinks: function (task, links) {
        task = this.getTask(task);
        links = this.getLinksByString(links);
        if (task == null) return;

        var hashed = {},
            _LINKS = [];
        for (var i = 0, l = links.length; i < l; i++) {
            var link = links[i];

            var preTask = this.getTask(link.PredecessorUID);
            if (!preTask && link.PredecessorID) {
                preTask = this.getTaskByID(link.PredecessorID);
            }

            if (!preTask || mini.isNull(link.Type)) continue;

            var preUID = preTask.UID;
            if (hashed[preUID]) continue;

            if (!link.LinkLag) link.LinkLag = 0;

            _LINKS.push(link);
            hashed[preUID] = link;
        }

        links = task.PredecessorLink;

        var s1 = this.getLinkString(links);
        var s2 = this.getLinkString(_LINKS);
        if (s1 == s2) return;
        try {
            task.PredecessorLink = _LINKS;
            this._Validator.valid();

            this.setTaskModified(task, 'PredecessorLink');
            this.orderProject();
        } catch (ex) {
            task.PredecessorLink = links;
            throw ex;
        }
    },
    setAssignments: function (task, assignments) {
        task = this.getTask(task);
        if (task == null) return;
        if (!mini.isArray(assignments)) assignments = [];
        for (var i = assignments.length - 1; i >= 0; i--) {
            var ass = assignments[i];
            var resourceUID = ass.ResourceUID;
            var resource = this.getResource(resourceUID);
            if (resource == null) {
                assignments.removeAt(i);
            } else {
                ass.TaskUID = task.UID;
            }
        }

        assignments = assignments.clone();
        this.store.updateRecord(task, 'Assignments', assignments);
        this.onSetAssignments(task);
        this.orderProject();
    },
    onSetAssignments: function (task) {},

    getSuccessorLinks: function (task) {
        var links = [];
        var tasks = this.getTaskList();

        function each(preLinks, succTask) {
            for (var i = 0, l = preLinks.length; i < l; i++) {
                var link = preLinks[i];
                link.TaskUID = succTask.UID;
                if (link.PredecessorUID == task.UID) links.push(link);
            }
        }

        for (var i = 0, l = tasks.length; i < l; i++) {
            var t = tasks[i];
            if (t.PredecessorLink) {
                each(t.PredecessorLink, t);
            }
        }
        return links;
    },

    showCriticalPath: true,
    clearCriticalPath: function () {},
    createCriticalPath: function () {},

    beginUpdate: function () {
        this.store.beginChange();
        this.beginOrder();
    },
    endUpdate: function () {
        this.endOrder();
        this.store.endChange();
    },

    _orderCount: 0,
    allowOrderProject: false,
    beginOrder: function () {
        this._orderCount++;
    },
    endOrder: function (raise) {
        this._orderCount--;
        if (this._orderCount < 0) this._orderCount = 0;
        if ((raise !== false && this._orderCount == 0) || raise == true) {
            this._orderCount = 0;

            var tasks = null;
            if (raise && raise !== true) {
                tasks = raise;
            }
            this.orderProject(tasks);
        }
    },
    orderProject: function () {
        this.store.beginChange();

        this.syncTasks(false);
        if (this._orderCount == 0) {
            this.createCriticalPath();

            var dr = this.getDateRange();
            if (dr) {
                this.ganttView.setDateRange(dr[0], dr[1]);
            }
        }
        this.store.endChange();

        this.invalidateLayout();
    },

    setTaskModified: function (task, field, oldValue) {
        if (this.allowTaskModified == false) return;

        if (field && mini.isNull(oldValue)) {
            oldValue = null;
        }
        this.store._setModified(task, field, oldValue);
    },

    getSelected: function () {
        var cell = this.tableView.getCurrentCell();
        if (cell) {
            return cell.record;
        } else {
            return this.store.getSelected();
        }
        return null;
    },
    getSelecteds: function () {
        return this.store.getSelecteds();
    },
    isSelected: function (id) {
        return this.store.isSelected(id);
    },
    select: function (record, currentCell, selectRecord) {
        if (!record) return;
        if (typeof record == 'number') record = this.store.getAt(record);
        if (currentCell) {
            var table = this.tableView;
            var cell = table.getCurrentCell();
            var column = table.getViewColumns()[table.isFrozen() ? table.frozenStartColumn : 0];
            if (cell) {
                column = cell.column;
            }
            cell = { record: record, column: column };
            table.setCurrentCell(cell, false);
        }
        if (selectRecord !== false) {
            this.store.select(record);
        }
    },
    deselect: function (record) {
        this.store.deselect(record);
    },
    selectAll: function (fireEvent) {
        this.store.selectAll(fireEvent);
    },
    deselectAll: function (fireEvent) {
        this.store.deselectAll(fireEvent);
    },
    selects: function (records, fireEvent) {
        this.store.selects(records, fireEvent);
    },
    deselects: function (records, fireEvent) {
        this.store.deselects(records, fireEvent);
    },

    sortFields: null,
    filterFields: null,
    groupFields: null,

    highlight: function (fn) {
        this.highlightFields = fn instanceof Array ? fn : null;
        fn = this.highlightFields ? null : fn;
        this.highlightFn = fn;

        this._updateHighlight();

        this.tableView.invalidate();
    },

    _updateHighlight: function () {
        var fn = this.highlightFn;
        if (!fn && this.highlightFields) {
            fn = PlusGantt._createFilterFn(this.highlightFields, this);
        }
        this._highlightCache = {};

        if (fn) {
            var list = this.getTaskList();
            for (var i = 0, l = list.length; i < l; i++) {
                var task = list[i];
                var highlight = fn ? fn(task) : false;
                if (highlight) this._highlightCache[task.UID] = true;
            }
        }
    },

    isFiltered: function () {
        return this.filterFields && this.filterFields.length > 0;
    },
    isSorted: function () {
        return this.sortFields && this.sortFields.length > 0;
    },
    isGrouped: function () {
        return this.groupFields && this.groupFields.length > 0;
    },
    isHighlighted: function () {
        return this.highlightFields && this.highlightFields.length > 0;
    },

    filter: function (fn, scope) {
        if (!fn) return this.clearFilter();

        var fields = fn;
        if (fields instanceof Array) {
            if (fields.length == 0) {
                return this.clearFilter();
            }
            this.filterFields = fields;
            fn = PlusGantt._createFilterFn(fields, this);
        }

        this.store.filter(fn, scope);
        var me = this;
        setTimeout(function () {
            me.setScrollTop(0);
        }, 50);
    },

    clearFilter: function () {
        this.filterFields = [];
        this.store.clearFilter();
    },

    getFilterField: function (property) {
        if (!this.filterFields) return null;
        for (var i = 0, l = this.filterFields.length; i < l; i++) {
            var item = this.filterFields[i];
            if (item.property == property) return item;
        }
    },

    getSortField: function (property) {
        if (!this.sortFields) return null;
        for (var i = 0, l = this.sortFields.length; i < l; i++) {
            var item = this.sortFields[i];
            if (item.property == property) return item;
        }
    },

    sort: function (fn) {
        if (!fn) return this.clearSort();

        var fields = fn;
        if (fields instanceof Array) {
            if (fields.length == 0) {
                return this.clearSort();
            }
            this.sortFields = fields;
            fn = PlusGantt._createSortFn(fields);
        }

        this.store.sort(fn);
    },
    clearSort: function () {
        this.sortFields = [];
        this.store.clearSort();
    },

    group: function (fields) {
        if (!fields || fields.length == 0) {
            return this.clearGroup();
        }
        this.groupFields = fields;
        this.store.group(fields);
    },

    clearGroup: function () {
        this.groupFields = [];
        this.store.clearGroup();
    },

    addTaskCls: function (task, cls) {
        if (!task._cls) task._cls = '';
        var sb = task._cls.split(' ');
        if (sb.indexOf(cls) == -1) {
            sb.push(cls);
            task._cls = sb.join(' ');
            this.tableView.addNodeCls(task, cls);
        }
    },

    removeTaskCls: function (task, cls) {
        if (!task._cls) task._cls = '';
        var sb = task._cls.split(' ');
        var index = sb.indexOf(cls);
        if (index != -1) {
            sb.splice(index, 1);
            task._cls = sb.join(' ');
        }
        this.tableView.removeNodeCls(task, cls);
    },

    setTableHeaderMenu: function (menu) {
        menu = mini.getAndCreate(menu);
        this.tableHeaderMenu = menu;
        menu.owner = this;
        mini.on(
            this.tableView._headerEl,
            'contextmenu',
            function (e) {
                var ev = {
                    htmlEvent: e,
                    cancel: false
                };
                menu.fire('BeforeOpen', ev);
                if (ev.cancel) return false;

                menu.showAtPos(e.pageX, e.pageY);
                return false;
            },
            this
        );
    },
    setTableBodyMenu: function (menu) {
        menu = mini.getAndCreate(menu);
        this.tableBodyMenu = menu;
        menu.owner = this;
        mini.on(
            this.tableView._viewportEl,
            'contextmenu',
            function (e) {
                var ev = {
                    htmlEvent: e,
                    cancel: false
                };
                menu.fire('BeforeOpen', ev);
                if (ev.cancel) return false;
                menu.showAtPos(e.pageX, e.pageY);
                return false;
            },
            this
        );
    },
    setGanttHeaderMenu: function (menu) {
        menu = mini.getAndCreate(menu);
        this.ganttHeaderMenu = menu;
        menu.owner = this;
        mini.on(
            this.ganttView.headerEl,
            'contextmenu',
            function (e) {
                var ev = {
                    htmlEvent: e,
                    cancel: false
                };
                menu.fire('BeforeOpen', ev);
                if (ev.cancel) return false;
                menu.showAtPos(e.pageX, e.pageY);
                return false;
            },
            this
        );
    },
    setGanttBodyMenu: function (menu) {
        menu = mini.getAndCreate(menu);
        this.ganttBodyMenu = menu;
        menu.owner = this;
        mini.on(
            this.ganttView.viewportEl,
            'contextmenu',
            function (e) {
                var ev = {
                    htmlEvent: e,
                    cancel: false
                };
                menu.fire('BeforeOpen', ev);
                if (ev.cancel) return false;
                menu.showAtPos(e.pageX, e.pageY);
                return false;
            },
            this
        );
    },

    getHtmlCallback: function (callback) {
        var that = this,
            options = options || {},
            oldWidth = this.el.style.width,
            oldHeight = this.el.style.height,
            topTimeScale = that.ganttView.topTimeScale,
            bottomTimeScale = that.ganttView.bottomTimeScale;

        var headerHeight = that.tableView.getHeaderHeight(),
            rowsHeight = that.rowHeight * that.getTaskList().length,
            height = headerHeight + rowsHeight + 25,
            scrollTop = that.tableView.getScrollTop(),
            _tableWidth = that.pane1.size,
            tableWidth = that._pane1El.offsetWidth,
            width = tableWidth + that.ganttView.scrollWidth + 50;

        if (!this.ganttViewExpanded || !this.showGanttView) width = width - that.ganttView.scrollWidth + 50;
        if (!this.tableViewExpanded || !this.showTableView) {
            width = width - tableWidth;
            tableWidth = 0;
        }

        that.setTableViewWidth(tableWidth);

        that.setWidth(width);
        that.setHeight(height);

        setTimeout(function () {
            var html = jQuery(that.el).html();

            that.setWidth(oldWidth);
            that.setHeight(oldHeight);
            that.setTableViewWidth(_tableWidth);

            setTimeout(function () {
                that.setScrollTop(scrollTop, true);
            }, 50);

            if (callback) callback(html);
        }, 1000);
    },

    printServer: '',
    printCSS: '',
    print: function (options) {
        if (!this.printServer) {
            alert('printServer is error');
            return;
        }
        if (!this.printCSS) {
            alert('printCSS is error');
            return;
        }

        var that = this,
            options = options || {},
            oldWidth = this.el.style.width,
            oldHeight = this.el.style.height,
            topTimeScale = that.ganttView.topTimeScale,
            bottomTimeScale = that.ganttView.bottomTimeScale;

        var headerHeight = that.tableView.getHeaderHeight(),
            rowsHeight = that.rowHeight * that.tasks.getVisibleRows().length,
            height = headerHeight + rowsHeight + 25,
            scrollTop = that.tableView.getScrollTop(),
            _tableWidth = that.pane1.size,
            tableWidth = that._pane1El.offsetWidth,
            width = tableWidth + that.ganttView.scrollWidth + 50;

        if (!this.ganttViewExpanded || !this.showGanttView) width = width - that.ganttView.scrollWidth + 50;
        if (!this.tableViewExpanded || !this.showTableView) {
            width = width - tableWidth;
            tableWidth = 0;
        }

        that.setTableViewWidth(tableWidth);

        that.setWidth(width);
        that.setHeight(height);

        function submitForm(options) {
            var html =
                '<form target="_blank"  action="' +
                options.url +
                '" method="' +
                options.type +
                '" style="display:none;">';
            if (options.data) {
                for (var name in options.data) {
                    var value = options.data[name];
                    html += '<input type="hidden" name=\'' + name + "' value='" + value + "'/>";
                }
            }
            html += '</form>';

            var jq = $(html).appendTo(document.body);

            jq.submit();

            if (options.complete)
                setTimeout(function () {
                    options.complete();
                }, 3000);
        }

        var imgType = options.type || 'png';
        var url = this.printServer;
        var path = this.printServer.split('snapshot.')[0];

        var msgid = mini.loading(mini.Gantt.Printing_Wait, mini.Gantt.Printing_Text);

        var css = '<meta content="text/html; charset=gb2312" http-equiv="Content-Type" />';
        var cssArr = mini.isArray(this.printCSS) ? this.printCSS : [this.printCSS];
        for (var i = 0, l = cssArr.length; i < l; i++) {
            css += ' <link href="' + cssArr[i] + '" rel="stylesheet" type="te' + 'xt/css" />';
        }

        setTimeout(function () {
            var html = jQuery(that.el).html();
            html = '<!DOCTYPE html><html><head>' + css + '</head><body style="margin:0;">' + html + '</body></html>';

            html = html.replace(/\'/g, '');

            submitForm({
                url: url,
                data: { html: html, width: width, height: height, type: imgType },
                type: 'post',
                complete: function () {
                    mini.hideMessageBox(msgid);
                }
            });

            that.setWidth(oldWidth);
            that.setHeight(oldHeight);
            that.setTableViewWidth(_tableWidth);

            setTimeout(function () {
                that.setScrollTop(scrollTop, true);
            }, 50);
        }, 1000);
    },

    getDateByPageX: function (x) {
        return this.ganttView.getDateByPageX(x);
    },

    getXByDate: function (date) {
        return this.ganttView.getXByDate(date);
    },

    getRowByPageY: function (y) {
        return this.ganttView.getRowByPageY(y);
    },

    getYByRow: function (row) {
        var rows = this.store.getVisibleRows();
        if (typeof row == 'number') row = rows[row];

        var region = this.ganttView.getViewRange();
        var topOffset = this.ganttView.getItemTop(rows[region.startRow]);
        topOffset -= region.yOffset - region.topOffset;

        return this.ganttView.getItemTop(row) - topOffset;
    },

    getRowHeight: function (row) {
        if (typeof row == 'number') row = this.store.getVisibleRows()[row];
        return this.ganttView.getItemHeight(row);
    },

    parseDuration: function (value) {
        return value;
    },

    parseStartDate: function (value) {
        return value;
    },

    parseFinishDate: function (value) {
        return value;
    }
});
mini.regClass(mini.Gantt, 'gantt');

mini.Gantt.PredecessorLinkType = [
    { ID: 0, Name: 'Finish-Finish(FF)', Short: 'FF' },
    { ID: 1, Name: 'Finish-Start(FS)', Short: 'FS' },
    { ID: 2, Name: 'Start-Finish(SF)', Short: 'SF' },
    { ID: 3, Name: 'Start-Start(SS)', Short: 'SS' }
];

mini.Gantt.ConstraintType = [
    { ID: 0, Name: 'The sooner the better' },
    { ID: 1, Name: 'The later the better' },
    { ID: 2, Name: 'Must be begin in' },
    { ID: 3, Name: 'Must be completed in' },
    { ID: 4, Name: 'Beginning no earlier than ...' },
    { ID: 5, Name: 'Beginning no later than ...' },
    { ID: 6, Name: 'Completed no earlier than ...' },
    { ID: 7, Name: 'Completed no later than ...' }
];

mini.Gantt.Manual = [
    { ID: 1, Name: 'Manual' },
    { ID: 0, Name: 'Automatic' }
];

mini.copyTo(mini.Gantt, {
    ID_Text: 'ID',
    Name_Text: 'Name',
    PercentComplete_Text: 'Progress',
    Duration_Text: 'Duration',
    Start_Text: 'Start',
    Finish_Text: 'Finish',
    Critical_Text: 'Critical',

    PredecessorLink_Text: 'PredecessorLink',
    Work_Text: 'Work',
    Priority_Text: 'Priority',
    Weight_Text: 'Weight',
    OutlineNumber_Text: 'OutlineNumber',
    OutlineLevel_Text: 'OutlineLevel',
    ActualStart_Text: 'ActualStart',
    ActualFinish_Text: 'ActualFinish',

    EarlyStart_Text: 'EarlyStart',
    EarlyFinish_Text: 'EarlyFinish',
    LateStart_Text: 'LateStart',
    LateFinish_Text: 'LateFinish',

    WBS_Text: 'WBS',
    ConstraintType_Text: 'ConstraintType',
    ConstraintDate_Text: 'ConstraintDate',
    Department_Text: 'Department',
    Principal_Text: 'Principal',
    Assignments_Text: 'Assignments',

    DeleteLink: 'Whether or not to delete this link?',

    Summary_Text: 'Summary',
    Task_Text: 'Task',
    Baseline_Text: 'Baseline',
    LinkType_Text: 'LinkType',
    LinkLag_Text: 'LinkLag',
    From_Text: 'From',
    To_Text: 'To',

    Goto_Text: 'Goto',
    UpGrade_Text: 'UpGrade',
    DownGrade_Text: 'DownGrade',
    Add_Text: 'Add Task',
    Edit_Text: 'Edit Task',
    Remove_Text: 'Remove Task',
    ZoomIn_Text: 'ZoomIn',
    ZoomOut_Text: 'ZoomOut',
    Deselect_Text: 'Un Select',
    Split_Text: 'Split Task',

    NoCalendarID: 'No calendar UID.',
    WeekDayError: 'WeekDay error',
    ExceptionsError: 'Exception date error',
    PredecessorError: 'The relationship between task loop',
    SummaryPredecessorError: 'The pre task of a summary task ({0}) "{1}" must be SS or FS',
    ManualCritical_Text: 'Critical tasks (manual)',
    NoCalendar: 'No project calendar was found.',
    NoCurrentCalendar: 'Must have current project calendar',
    Printing_Wait: 'Please print the Gantt chart, later...',
    Printing_Text: 'Print Gantt chart',

    Manual_Text: 'Task Mode'
});

PlusGantt = mini.Gantt;
window['PlusG' + 'antt'] = PlusGantt;

PlusGantt._createSortFn = function (sorters) {
    var out = 0;

    var comparer = function (first, second) {
        var s1, s2;
        for (var i = 0, l = sorters.length; i < l; i++) {
            var sorter = sorters[i],
                v1 = first[sorter.property],
                v2 = second[sorter.property];

            if (v1 instanceof Date) v1 = v1?.getTime();
            if (v2 instanceof Date) v2 = v2?.getTime();

            if (v1 !== v1) v1 = null;
            if (v2 !== v2) v2 = null;
            if (typeof v1 == 'string' && typeof v2 == 'string') {
                s1 = v1.toLowerCase();
                s2 = v2.toLowerCase();
                if (s1 != s2) {
                    v1 = s1;
                    v2 = s2;
                }
            }

            if (v1 === v2) return 0;

            if (v1 != null && v2 == null) return -1;

            if (v1 == null && v2 != null) return 1;

            out = v1 < v2 ? -1 : v1 > v2 ? 1 : 0;

            if (out != 0) return sorter.direction == 'asc' ? +out : -out;
        }
        return 0;
    };

    return comparer;
};

PlusGantt._createFilterFn = function (fields, project) {
    function filterByField(item, field) {
        var itemValue = item[field.property];
        var value = field.value;

        var filterField = PlusProject.getFilterTaskField(field.property);

        if (filterField && filterField.type == 'boolean') {
            if (value == 'Y' || value == 'y' || value == 'true' || value == '1' || value == '是' || value == '真')
                value = 1;
            else value = 0;
        }

        if (itemValue instanceof Date) {
            value = mini.parseDate(value);
        } else if (field.property == 'PredecessorLink') {
            itemValue = project.getLinkString(itemValue);
        } else if (field.property == 'Assignments') {
            itemValue = project.getAssignmentsName(itemValue);
        } else if (field.property == 'Department') {
            itemValue = project.getDepartmentName(itemValue);
        } else if (field.property == 'Principal') {
            itemValue = project.getPrincipalName(itemValue);
        } else if (field.property == 'TaskStatus') {
            itemValue = project.getTaskStatusName(itemValue);
        }

        var flag = false;

        switch (field.operator) {
            case '!=':
                flag = !mini.isEquals(itemValue, value);
                break;
            case '==':
                flag = mini.isEquals(itemValue, value);
                break;
            case '>':
                flag = itemValue > value;
                break;
            case '>=':
                flag = itemValue >= value;
                break;
            case '<':
                flag = itemValue < value;
                break;
            case '<=':
                flag = itemValue <= value;
                break;
            case 'like':
                flag = String(itemValue).indexOf(value) != -1;
                break;
            case 'notlike':
                flag = String(itemValue).indexOf(value) == -1;
                break;
            default:
                throw new Error('operator error');
                break;
        }

        return flag;
    }

    var fn = function (item) {
        var results = [];
        var sb = [];
        for (var i = 0, l = fields.length; i < l; i++) {
            var field = fields[i];
            var result = filterByField(item, field);

            if (field.relation == 'and' && results.length > 0) {
                var prevResult = results[results.length - 1];
                results[results.length - 1] = prevResult && result;
            } else {
                results.push(result);
            }
        }

        var result = false;
        for (var i = 0, l = fields.length; i < l; i++) {
            if (results[i] === true) {
                result = true;
            }
        }
        return result;
    };

    return fn;
};

MyProjectSchedule = mini.Base.extend({
    constructor: function (project) {
        this.project = project;
        var tableView = project.tableView,
            ganttView = project.ganttView;

        project.on('cellbeginedit', this.__OnCellBeginEdit, this);
        project.on('aftercellcommitedit', this.__OnCellCommitEdit, this);
        project.on('itemdragstart', this.__OnItemDragStart, this);
        project.on('itemdragcomplete', this.__OnItemDragComplete, this);
        project.on('dodragdrop', this.__OnDoTaskDragDrop, this);
        project.set({
            readOnly: false,
            allowDragDrop: true
        });

        project.tableView.on('beforecolumnresize', function (e) {
            if (project.undoManager) {
                var action = new PlusProject.ChangeColumnWidthAction(project, e.column, e.width);
                project.undoManager.execute(action);
                e.cancel = true;
            }
        });

        project.tableView.on('beforecolumnmove', function (e) {
            if (project.undoManager) {
                var action = new PlusProject.ReorderColumnAction(project, e.column, e.targetColumn, e.action);
                project.undoManager.execute(action);
                e.cancel = true;
            }
        });

        project.tableView.on('drawcell', this.onDrawGroupCell, this);
        project.on(
            'taskdragstart',
            function (e) {
                if (project.store.isGrouped()) {
                    e.cancel = true;
                }
            },
            this
        );

        project.ganttView.on(
            'drawitem',
            function (e) {
                var item = e.item,
                    itemBox = e.itemBox;

                if (project.showDelayedTask && project.isDelayedTask(item)) {
                    e.itemCls += ' mini-gantt-delayedtask';
                }

                if (project.showTotalSlack && item.TotalSlack > 0) {
                    var finish = item.Finish;
                    if (finish?.getTime() == mini.maxTime(finish)?.getTime()) {
                        finish = mini.addDate(finish, 1, 'S');
                    }
                    var date = project.getFinishByCalendar(finish, item.TotalSlack, item);
                    var x = project.ganttView.getXByDate(date);
                    var width = x - itemBox.right;
                    e.extraHtml +=
                        '<div class="mini-gantt-slacktime-line" style="left:' +
                        itemBox.right +
                        'px;top:' +
                        itemBox.bottom +
                        'px;width:' +
                        width +
                        'px;"></div>';
                }

                if (project.ganttView.isMilestone(item)) {
                    e.label = project.getMilestoneLabel(item);
                }
            },
            this
        );

        project.ganttView.on(
            'drawlink',
            function (e) {
                if (project.showDelayedTask && (project.isDelayedTask(e.from) || project.isDelayedTask(e.to))) {
                    e.cls += ' mini-gantt-delayedlink';
                }
            },
            this
        );

        project.ganttView.on(
            'refresh',
            function (e) {
                var viewRegion = ganttView.getViewRegion();
                var bars = $(ganttView.el).find('.mini-ganttview-bars');

                var tasks = project.getTaskList();
                for (var i = viewRegion.startRow, l = viewRegion.endRow; i < l; i++) {
                    var task = tasks[i];

                    if (task.Deadline) {
                        var jq = $('<div class="mini-gantt-deadline"></div>').appendTo(bars);

                        var top = project.getYByRow(i) + tableView.getRowHeight(i) / 2;
                        jq.css('top', top + 'px');
                        var left = project.getXByDate(task.Deadline);
                        jq.css('left', left + 'px');
                    }
                }
            },
            this
        );
    },

    onDrawGroupCell: function (e) {
        var grid = e.sender,
            item = e.record,
            column = e.column;

        if (column.allowDrag && grid.store.isGrouped()) {
            e.cellStyle += ';cursor:default;';
        }

        if (!grid.store.isGroupItem(item)) return;

        if (column.name == grid.treeColumn) {
            var property = item.field.property;
            var text = PlusGantt[property + '_Text'] || PlusGantt[property + 'Text'] || property;

            e.cellHtml = text + '：' + e.cellHtml;
        }
    },

    __OnDoTaskDragDrop: function (e) {
        if (this.project.scheduleEnabled === false) return;

        var dragRecords = e.tasks,
            targetRecord = e.targetTask,
            action = e.action;

        var project = this.project;
        var action = new PlusProject.MoveTaskAction(project, dragRecords, targetRecord, action);
        try {
            project.executeAction(action);
        } catch (ex) {
            action.restore();
            alert(ex.message);
        }
    },
    __OnCellBeginEdit: function (e) {
        if (this.project.scheduleEnabled === false) return;
        var project = this.project;

        if (e.record == project.tasks.root) {
            e.cancel = true;
            return;
        }

        var task = e.record,
            field = e.field;

        if (task.Summary) {
            if (field == 'ActualStart' || field == 'ActualFinish') {
                e.cancel = true;
            }
        }

        if (task.Summary && task.FixedDate != 1 && !task.Manual) {
            if (field == 'Start' || field == 'Finish' || field == 'Duration' || field == 'Work') {
                e.cancel = true;
            }
        }
        if (
            field == 'Start' ||
            field == 'Finish' ||
            field == 'ActualStart' ||
            field == 'ActualFinish' ||
            field == 'ConstraintDate'
        ) {
            if (!mini.isDate(e.value) && e.editor) {
                e.editor.setViewDate(e.sender.getStartDate());
            }

            var dateFormat = project.enableHalfDay ? project.dateFormatHalfDay : project.dateFormat;
            e.editor.format = dateFormat;
        }
    },
    __OnCellCommitEdit: function (e) {
        if (this.project.scheduleEnabled === false) return;

        e.cancel = true;
        var task = e.record,
            field = e.field,
            value = e.value,
            oldValue = task[field],
            column = e.column;
        var project = this.project;

        if (project.enableHalfDay && value) {
            if (field == 'Start' || field == 'Finish' || field == 'ActualStart' || field == 'ActualFinish') {
                if (field == 'Start' || field == 'ActualStart') {
                    value = project._Calendar._parseStartDate(value);
                } else {
                    if (value?.getHours() == 0) {
                        value = new Date(value?.getTime());
                        value?.setHours(23);
                    }
                    value = project._Calendar._parseFinishDate(value);
                }
            }
        }

        if (field == 'PredecessorLink' && oldValue) {
            oldValue = project.getLinkString(oldValue);
        }

        if (mini.isEquals(oldValue, value)) return;

        if (field == 'Finish' || field == 'ActualFinish' || field == 'Start' || field == 'ActualStart') {
            var s1 = oldValue ? mini.formatDate(oldValue, 'yyyy-MM-dd HH') : '';
            var s2 = value ? mini.formatDate(value, 'yyyy-MM-dd HH') : '';
            if (s1 == s2) return;
        }

        try {
            if (column.displayField) {
                var o = {};
                o[column.field] = e.value;
                o[column.displayField] = e.text;
                project.updateTask(task, o);
            } else {
                var action = new PlusProject.UpdateTaskAction(project, task, field, value);
                project.executeAction(action);
            }
        } catch (ex) {
            alert(ex.message);
        }
    },
    __OnItemDragStart: function (e) {
        if (this.project.scheduleEnabled === false) return;

        if (e.action == 'start') {
            e.cancel = true;
        }
    },
    __OnItemDragComplete: function (e) {
        if (this.project.scheduleEnabled === false) return;

        var action = e.action,
            value = e.value,
            task = e.item;
        var sss = new Date();
        var field;
        if (action == 'finish') {
            field = 'Finish';
        }
        if (action == 'percentcomplete') {
            field = 'PercentComplete';
        }
        if (action == 'move') {
            field = 'Start';
        }

        var project = this.project;
        var action = new PlusProject.UpdateTaskAction(project, task, field, value);
        project.executeAction(action);
    }
});

MyProjectSchedule.Calendar = mini.Base.extend({
    constructor: function (project, calendar) {
        this.project = project;

        this.data = calendar || project._getCalendarData(project.data.CalendarUID);

        this.hoursPerDay = project.hoursPerDay;
        this.enableHalfDay = project.enableHalfDay;

        this.validCalendar(this.data);

        this.WeekDays = this.data.WeekDays;
        this.Exceptions = this.data.Exceptions;

        mini.sort(this.WeekDays, function (a, b) {
            return a.DayType > b.DayType;
        });

        this.refresh();
    },
    refresh: function () {
        this._cache = {};
        var me = this;

        function find(ex) {
            var ex_tp = ex.TimePeriod;
            for (var i = 0, l = me.Exceptions.length; i < l; i++) {
                var item = me.Exceptions[i];
                if (ex == item) continue;
                var tp = item.TimePeriod;
                if (
                    (tp.FromDate <= ex_tp.FromDate && ex_tp.FromDate <= tp.ToDate) ||
                    (tp.FromDate <= ex_tp.ToDate && ex_tp.ToDate <= tp.ToDate)
                ) {
                    return true;
                }
            }
        }

        for (var i = this.Exceptions.length - 1; i >= 0; i--) {
            var ex = this.Exceptions[i];
            if (find(ex)) {
                this.Exceptions.removeAt(i);
            }
        }

        this._repeatExceptions = [];
        for (var i = 0, l = this.Exceptions.length; i < l; i++) {
            var ex = this.Exceptions[i];
            var repeatType = ex.RepeatType;
            if (repeatType != 'month' && repeatType != 'year') {
                this._repeatExceptions.push(ex);
            }
        }
    },

    validCalendar: function (calendar) {
        if (calendar.UID == null) {
            throw new Error(mini.Gantt.NoCalendarID);
        }
        var weekDays = calendar.WeekDays;
        var exceptions = calendar.Exceptions;
        if (weekDays == null || weekDays.length != 7) {
            throw new Error(mini.Gantt.WeekDayError);
        }
        if (exceptions == null) {
            calendar.Exceptions = exceptions = [];
        }

        var workingDay = false;
        for (var i = 0; i < 7; i++) {
            var weekday = weekDays[i];
            var dayType = parseInt(weekday.DayType);
            var dayWorking = parseInt(weekday.DayWorking);
            if ((dayWorking != 0 && dayWorking != 1) || dayType < 1 || dayType > 7) {
                throw new Error(mini.Gantt.WeekDayError);
            }
            if (dayWorking == 1) {
                workingDay = true;
            }
        }

        if (workingDay == false) throw new Error(mini.Gantt.WeekDayError);
        for (var i = 0, l = exceptions.length; i < l; i++) {
            var ex = exceptions[i];

            var dayWorking = parseInt(ex.DayWorking);
            if (dayWorking != 0 && dayWorking != 1) {
                throw new Error(mini.Gantt.ExceptionsError);
            }
            if (dayWorking == 1) {
                var tp = ex.TimePeriod;
                if (tp == null || !mini.isDate(tp.FromDate) || !mini.isDate(tp.ToDate)) {
                    throw new Error(mini.Gantt.ExceptionsError);
                }
                var fd = tp.FromDate;
                var td = tp.ToDate;
                tp.FromDate = mini.clearTime(fd);
                tp.ToDate = mini.maxTime(td);
            }

            if (this.project.enableCycleCalendar) {
                var remove = false;
                var from = ex.TimePeriod.FromDate;
                var to = ex.TimePeriod.ToDate;

                if (ex.RepeatType == 'month') {
                    if (from?.getFullYear() != to?.getFullYear() || from?.getMonth() != to?.getMonth()) {
                        remove = true;
                    }
                }

                if (ex.RepeatType == 'year') {
                    if (from?.getFullYear() != to?.getFullYear()) {
                        remove = true;
                    }
                }

                if (remove) {
                    exceptions.removeAt(i);
                    i--;
                    l--;
                }
            }
        }
    },

    _isWorkingDate: function (date) {
        // 原有判断是否工作日
        //   var weekday = this.__getWeekDay(date?.getDay(), date);
        // 客制化判断是否工作日
        var weekday = this._customGetWeekDay(date?.getDay(), date);
        return weekday.DayWorking == 1;
    },

    //客制化根据项目日历规则设置工作日
    _customGetWeekDay: function (dayOfWeek, date, _time) {
        // 日期判空处理
        if (!this.WeekDays[dayOfWeek]) {
            return { DayWorking: 1 };
        }
        let weekday = JSON.parse(JSON.stringify(this.WeekDays[dayOfWeek]));
        // 例外周期开始时间
        let startDate = new Date(this.data?.startTime);
        // 例外周期结束时间
        let finishDate = new Date(this.data?.finishTime);
        // 按周或月设置列外工作时间  0代表周 1代表月
        let repeatMode = this.data?.repeatMode;
        // 重复频率间隔周期
        let lastMonth = this.data?.lastMonth;
        // 第几周
        let fewWeeks = this.data?.fewWeeks;
        // 周几
        let weeks = this.data?.weeks;
        // 是否重复 1代表重复 0 代表不限
        let isRepetition = this.data?.isRepetition;
        // 节假日
        let systemCalendarHolidayList = this.data?.systemCalendarHolidayList;
        // 是否存在例外工作时间配置 isIncludeException
        if (
            startDate &&
            finishDate &&
            new Date(date).getTime() >= new Date(startDate).getTime() &&
            new Date(finishDate).getTime() >= new Date(date).getTime() &&
            repeatMode &&
            lastMonth &&
            weeks &&
            isRepetition
        ) {
            // 判断重复频率是按月还是按周(repeatMode: 0代表周 1代表月)
            if (repeatMode == '1' && fewWeeks) {
                weekday.DayWorking = this._customCheckMonth(dayOfWeek == 0 ? 7 : dayOfWeek, date)
                    ? 1
                    : weekday.DayWorking;
            } else if (repeatMode == '0') {
                weekday.DayWorking = this._customCheckWeek(dayOfWeek == 0 ? 7 : dayOfWeek, date)
                    ? 1
                    : weekday.DayWorking;
            }
        }
        // 节假日
        if (systemCalendarHolidayList && systemCalendarHolidayList?.length > 0) {
            let systemCalendarHoliday = systemCalendarHolidayList.find((item) => {
                // 假节日开始时间
                let sDate = new Date(item.startTime).getTime();
                // 节假日结束时间
                let fDate = new Date(item.finishTime).getTime();
                // 当前选中时间
                let cDate = new Date(date).getTime();
                return cDate >= sDate && cDate <= fDate;
            });
            systemCalendarHoliday ? (weekday.DayWorking = systemCalendarHoliday?.dayType || 1) : '';
        }
        return weekday;
    },

    //判断当前日期是否在 按月例外工作时间配置内
    _customCheckMonth: function (dayOfWeek, date) {
        let isWorking = false;
        // 例外周期开始时间
        let startDate = new Date(this.data?.startTime);
        // 重复频率间隔周期
        let lastMonth = this.data?.lastMonth;
        // 第几周
        let fewWeeks = this.data?.fewWeeks;
        // 代表周几
        let weeks = this.data?.weeks;
        // 是否重复 1代表重复 0 代表不限
        let isRepetition = this.data?.isRepetition;
        // 重复次数
        let repetitions = this.data?.repetitions;
        // 计算当前日期与例外周期开始时间月份差
        let sumMonth =
            (parseInt(date.getFullYear()) - parseInt(startDate.getFullYear())) * 12 +
            (parseInt(date.getMonth()) - parseInt(startDate.getMonth()) + 1);
        // 重复且有次数
        if (isRepetition === '1' && repetitions) {
            // 判断当前日期是否在月重复频率中且小于重复次数
            if (
                sumMonth % parseInt(lastMonth) == 0 &&
                Math.ceil(sumMonth / parseInt(lastMonth)) <= repetitions &&
                // 判断当前日期是本月的第几周
                this._getMonthWeek(date, fewWeeks == -1).includes(fewWeeks) &&
                dayOfWeek == weeks
            ) {
                isWorking = true;
            }
            // 不限次数
        } else if (isRepetition === '0') {
            // 判断当前日期是否在月重复频率中
            if (
                sumMonth % parseInt(lastMonth) == 0 &&
                // 判断当前日期是本月的第几周
                this._getMonthWeek(date, fewWeeks == -1).includes(fewWeeks) &&
                dayOfWeek == weeks
            ) {
                isWorking = true;
            }
        }
        return isWorking;
    },

    //判断当前日期是否在 按周例外工作时间配置内
    _customCheckWeek: function (dayOfWeek, date) {
        let isWorking = false;
        // 例外周期开始时间
        let startDate = new Date(this.data?.startTime);
        // 重复频率间隔周期
        let lastMonth = this.data?.lastMonth;
        // 代表周几
        let weeks = this.data?.weeks;
        // 是否重复 1代表重复 0 代表不限
        let isRepetition = this.data?.isRepetition;
        // 重复次数
        let repetitions = this.data?.repetitions;
        // 计算当前日期与例外周期开始时间共差几周
        let sumWeek = this._getSumWeek(date, startDate);
        // 重复且有次数
        if (this.data?.isRepetition == '1' && repetitions) {
            // 判断当前日期是否在周重复频率中、且在设置重复次数内、且等于日历设置周几
            if (
                sumWeek % parseInt(lastMonth) == 0 &&
                Math.ceil(sumWeek / parseInt(lastMonth)) <= repetitions &&
                dayOfWeek == weeks
            ) {
                isWorking = true;
            }
            // 不限
        } else if (this.data?.isRepetition == '0') {
            // 判断当前日期是否在周重复频率中 且等于日历设置周几
            if (sumWeek % parseInt(lastMonth) == 0 && dayOfWeek == weeks) {
                isWorking = true;
            }
        }
        return isWorking;
    },

    // 计算当前日期是本月的第几周
    _getMonthWeek: function (a, flag) {
        /**
         * a = d = 当前日期
         * b = 6 - w = 当前周的还有几天过完(不算今天)
         * a + b 的和在除以7 就是当天是当前月份的第几周
         */
        let weeks = [];
        let date = new Date(a);
        let w = date.getDay();
        let d = date.getDate();
        let currentWeek = Math.ceil((d + 6 - w) / 7);
        weeks.push(currentWeek);
        // 计算当前日期是否是本月最后一周
        if (flag) {
            // 计算本月最后一天
            let endDay =
                new Date(date.getFullYear() + '-' + (date.getMonth() + 2) + '-' + '01').valueOf() - 24 * 60 * 60 * 1000;
            let date1 = new Date(endDay);
            let w1 = date1.getDay();
            let d1 = date1.getDate();
            let endWeek = Math.ceil((d1 + 6 - w1) / 7);
            // 判断当前周是否是本月最后一周
            currentWeek == endWeek && weeks.push(-1);
        }
        return weeks;
    },

    // 计算两个日期之间共有多少周
    _getSumWeek: function (a, b) {
        /*
    date1是当前日期
    date2是开始日期
    d是当前日期距开始日期第多少天
    用d + 开始日期周差距的和再除以7就是距开始日期第几周
    */
        var date1 = new Date(a.getFullYear(), a.getMonth(), a.getDate()),
            date2 = new Date(b.getFullYear(), b.getMonth(), b.getDate()),
            d = Math.round((date1.valueOf() - date2.valueOf()) / 86400000);
        return Math.ceil((d + (date2.getDay() + 1)) / 7);
    },

    __getWeekDay: function (dayOfWeek, date, _time) {
        var cacheid = 'getDay_' + (_time || date?.getTime());
        var cache = this._cache[cacheid];
        if (cache) {
            return cache || { DayWorking: 1 };
        }

        var weekday = this.WeekDays[dayOfWeek];

        var enableCycleCalendar = this.project.enableCycleCalendar;

        if (enableCycleCalendar && this._repeatExceptions.length > 0) {
            var time = _time || date?.getTime();
            for (var i = 0, l = this._repeatExceptions.length; i < l; i++) {
                var ex = this._repeatExceptions[i];
                var repeatType = ex.RepeatType;
                if (repeatType != 'month' && repeatType != 'year') continue;
                var tp = ex['TimePeriod'];
                var from = tp.FromDate;
                var to = tp.ToDate;

                if (repeatType == 'month') {
                    from = new Date(date?.getFullYear(), date?.getMonth(), from?.getDate());
                    to = new Date(date?.getFullYear(), date?.getMonth(), to?.getDate());
                    if (from?.getMonth() > date?.getMonth()) from?.setDate(from?.getDate() - 1);
                    if (to?.getMonth() > date?.getMonth()) to?.setDate(to?.getDate() - 1);
                } else if (repeatType == 'year') {
                    from = new Date(date?.getFullYear(), from?.getMonth(), from?.getDate());
                    to = new Date(date?.getFullYear(), to?.getMonth(), to?.getDate());
                    if (from?.getFullYear() > date?.getFullYear()) from?.setDate(from?.getDate() - 1);
                    if (to?.getFullYear() > date?.getFullYear()) to?.setDate(to?.getDate() - 1);
                }

                var fromtime = from?.getTime();
                var totime = to?.getTime();

                if (fromtime <= time && time <= totime) {
                    weekday = ex;
                    break;
                }
            }
        }

        if (!this._cache.exceptions) {
            var hash = (this._cache.exceptions = {});

            function each(from, to, ex) {
                from = mini.clearTime(from);
                to = mini.clearTime(to);
                while (from <= to) {
                    hash[from?.getTime()] = ex;
                    hash[mini.addDate(from, 12, 'H')?.getTime()] = ex;
                    hash[mini.maxTime(from)?.getTime()] = ex;
                    from = mini.addDate(from, 1, 'D');
                }
            }

            for (var i = 0, l = this.Exceptions.length; i < l; i++) {
                var ex = this.Exceptions[i];
                var repeatType = ex.RepeatType;
                if (repeatType == 'month' || repeatType == 'year') continue;

                var tp = ex.TimePeriod;
                var from = tp.FromDate;
                var to = tp.ToDate;
                each(from, to, ex);
            }
        }

        var id = _time || date?.getTime();

        var ex = this._cache.exceptions[id];
        if (ex) weekday = ex;

        this._cache[cacheid] = weekday;
        return weekday || { DayWorking: 1 };
    },

    _getStart: function (finish, workingDays) {
        workingDays = this._parseDuration(workingDays);
        if (workingDays <= 0) return new Date(finish?.getTime());

        var date = this._parseFinishDate(finish);

        var cacheid = 'getStart_' + date?.getTime() + workingDays;
        var cache = this._cache[cacheid];
        if (cache) {
            return new Date(cache);
        }

        var dayAdd = 1;

        if (this.enableHalfDay) {
            dayAdd = 0.5;
        }

        var duration;
        var weekday;
        while (workingDays > 0) {
            //   weekday = this.__getWeekDay(date?.getDay(), date);
            weekday = this._customGetWeekDay(date?.getDay(), date);

            if (weekday.DayWorking == 1) {
                duration = dayAdd;

                if (date?.getSeconds() == 59 && dayAdd > 1) {
                    duration = 1;
                }

                workingDays -= duration;
                if (workingDays == 0) break;

                if (duration != 1 && this.enableHalfDay) {
                    date?.setHours(date?.getHours() - dayAdd * 24);
                    if (date?.getHours() == 0) {
                        date?.setSeconds(date?.getSeconds() - 1);
                    } else {
                        date?.setSeconds(date?.getSeconds() + 1);
                    }
                } else {
                    date?.setDate(date?.getDate() - dayAdd);
                }
            } else {
                date = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate() - 1, 23, 59, 59);
            }
        }

        var start = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate());

        if (this.enableHalfDay) {
            if (date?.getHours() == 23) {
                start = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate(), 12);
            }
        }

        this._cache[cacheid] = start?.getTime();

        return start;
    },

    _parseDuration: function (value) {
        var isNeg = value < 0;
        if (isNeg) value = -value;

        var num = parseInt(value);
        if (this.enableHalfDay) {
            if (value == num) value = num;
            else if (value <= num + 0.5) value = num + 0.5;
            else value = num + 1;
        } else {
            value = num;
        }

        if (isNeg) value = -value;
        return value;
    },

    _parseStartDate: function (start) {
        var date = new Date(start?.getFullYear(), start?.getMonth(), start?.getDate());
        if (this.enableHalfDay) {
            if (start?.getHours() >= 12) {
                date?.setHours(12);
            }
        }
        return date;
    },

    _parseFinishDate: function (start) {
        var date = new Date(start?.getFullYear(), start?.getMonth(), start?.getDate(), 23, 59, 59);
        if (this.enableHalfDay) {
            if (start?.getHours() <= 12) {
                date = new Date(start?.getFullYear(), start?.getMonth(), start?.getDate(), 12);
            }
        }
        return date;
    },

    _getFinish: function (start, workingDays) {
        workingDays = this._parseDuration(workingDays);
        if (workingDays <= 0) return new Date(start?.getTime());

        var date = this._parseStartDate(start);

        var cacheid = 'getFinish_' + date?.getTime() + workingDays;
        var cache = this._cache[cacheid];
        if (cache) {
            return new Date(cache);
        }

        var dayAdd = 1;

        if (this.enableHalfDay) {
            dayAdd = 0.5;
        }

        var duration;
        var weekday;

        var oneDayTime = 60 * 60 * 24 * 1000;
        var _day = date?.getDay();
        if (date?.getHours() == 12) {
            _day += 0.5;
        }
        var _time = date?.getTime();
        var _int_day = 0;

        while (workingDays > 0) {
            _int_day = parseInt(_day);
            //   weekday = this.__getWeekDay(_int_day, null, _time);
            weekday = this._customGetWeekDay(_int_day, new Date(_time));

            duration = dayAdd;
            if (_int_day == _day && workingDays > 1) {
                duration = 1;
            }

            if (weekday.DayWorking == 1) {
                workingDays -= duration;
                if (workingDays == 0) break;
            }

            _time += duration * oneDayTime;
            _day += duration;
            if (_day > 6.5) _day = 0;
        }

        date = new Date(_time);

        var finish = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate(), 23, 59, 59);
        if (this.enableHalfDay) {
            if (date?.getHours() == 0) {
                finish = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate(), 12);
            }
        }

        this._cache[cacheid] = finish?.getTime();

        return finish;
    },

    _getDuration: function (start, finish) {
        if (start?.getTime() == finish?.getTime()) return 0;

        var isF = start > finish;
        if (isF) {
            var t = start;
            start = finish;
            finish = start;
        }

        if (start?.getTime() == mini.maxTime(start)?.getTime()) {
            start = mini.addDate(start, 1, 'S');
        }

        if (finish?.getTime() == mini.clearTime(finish)?.getTime()) {
            finish = mini.addDate(finish, -1, 'S');
        }

        start = this._parseStartDate(start);
        finish = this._parseFinishDate(finish);

        var cacheid = 'getDuration_' + start?.getTime() + finish?.getTime();
        var cache = this._cache[cacheid];
        if (cache !== undefined) {
            return cache;
        }

        var dayAdd = 1;
        if (this.enableHalfDay) {
            dayAdd = 0.5;
        }

        var days = 0;
        var finishTime = finish?.getTime();
        var duration;
        var weekday;

        var oneDayTime = 60 * 60 * 24 * 1000;

        var _day = start?.getDay();
        if (start?.getHours() == 12) {
            _day += 0.5;
        }
        var _time = start?.getTime();
        var _int_day = 0;

        for (; _time < finishTime; ) {
            _int_day = parseInt(_day);

            //   weekday = this.__getWeekDay(_int_day, null, _time);
            weekday = this._customGetWeekDay(_int_day, new Date(_time));

            duration = dayAdd;

            if (_int_day == _day) {
                duration = 1;
            }

            if (weekday.DayWorking == 1) {
                days += duration;
            }

            _time += duration * oneDayTime;
            _day += duration;
            if (_day > 6.5) _day = 0;
        }

        var date = new Date(_time);

        if (this.enableHalfDay && this._isWorkingDate(finish)) {
            if (
                (finish?.getHours() == 23 && date?.getHours() == 12) ||
                (finish?.getHours() == 12 && date?.getHours() == 0)
            ) {
                days -= 0.5;
            }
        }

        this._cache[cacheid] = days;
        return isF ? -days : days;
    },

    _getNextWorkingStart: function (date) {
        return date
        // return this.__getWorkingDate(date, true);
    },

    _getPreviousWorkingFinish: function (date) {
        return this.__getWorkingDate(date, false);
    },

    __getWorkingDate: function (date, isBack) {
        if (this.enableHalfDay) {
            if (this._isWorkingDate(date)) {
                var hours = date?.getHours();
                date = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate());
                if (isBack) {
                    if (hours < 12) date?.setHours(0);
                    else date?.setHours(12);
                } else {
                    if (hours <= 12) date?.setHours(12);
                    else date = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate(), 23, 59, 59);
                }

                return date;
            }
        }

        date = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate());
        var day = isBack ? 1 : -1;
        while (true) {
            var isWorking = this._isWorkingDate(date);
            if (isWorking) {
                break;
            }
            date = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate() + day);
        }
        date = isBack ? date : new Date(date?.getFullYear(), date?.getMonth(), date?.getDate(), 23, 59, 59);

        return date;
    },

    _getWorkingStartDate: function (date, days) {
        if (date instanceof Date && isNaN(date.valueOf())) return null;
        days = this._parseDuration(days);
        if (days == 0) return new Date(date?.getTime());

        if (!this.enableHalfDay) {
            date = new Date(date?.getFullYear(), date?.getMonth(), date?.getDate());
        }

        var hours = date?.getHours();
        if (hours != 0 && hours != 12 && hours != 23) {
            throw new Error('_getWorkingStartDate error');
        }

        if (days > 0) {
            date = this._getFinish(date, days);
            if (date?.getHours() == 23) {
                date?.setSeconds(60);
                date = this._getNextWorkingStart(date);
            }
        } else {
            if (date?.getHours() == 0) {
                date = new Date(date?.getTime());
                date?.setHours(date?.getHours() - 1);
                date = this._getPreviousWorkingFinish(date);
            }
            date = this._getStart(date, -days);
        }

        return date;
    }
});

MyProjectSchedule.Validator = mini.Base.extend({
    constructor: function (project) {
        this.project = project;
    },
    createSuccessorTasks: function () {
        var tasks = this.project.getTaskList();
        if (tasks == null) return;
        for (var i = 0, l = tasks.length; i < l; i++) {
            var t = tasks[i];
            t.SuccessorTasks = [];
        }
        for (var i = 0, l = tasks.length; i < l; i++) {
            var t = tasks[i];
            var lks = t.PredecessorLink;
            if (lks != null && lks.length > 0) {
                for (var j = 0, k = lks.length; j < k; j++) {
                    var lk = lks[j];
                    var task = this.project.getTask(lk.PredecessorUID);
                    if (task != null) {
                        task.SuccessorTasks.push(t);
                    }
                }
            }
        }
    },
    clearSuccessorTasks: function () {
        var tasks = this.project.getTaskList();
        for (var i = 0, l = tasks.length; i < l; i++) {
            var t = tasks[i];
            delete t.SuccessorTasks;
        }
    },

    validResources: function (resources) {
        for (var i = 0, l = resources.length; i < l; i++) {
            var o = resources[i];
            if (!o.StandardRate) o.StandardRate = 0;
            if (!o.OvertimeRate) o.OvertimeRate = 0;

            if (mini.isNull(o.CalendarUID) || !this.project._getCalendarData(o.CalendarUID)) o.CalendarUID = -1;
        }
    },

    valid: function () {
        if (!this.project.allowOrderProject) return;

        this.validProject(this.project.data);

        var tasks = this.project.getTaskList();
        this.validTasks(tasks);

        this.validResources(this.project.data.Resources);

        if (!this.project.data.CurrentDate) {
            this.project.data.CurrentDate = new Date();
        }
    },

    validProject: function (project) {
        project.MultipleCriticalPaths = !!project.MultipleCriticalPaths;
    },

    validTasks: function (tasks) {
        if (this.project.enableValidTasks === false) return;

        this.validedTasks = {};

        tasks = mini.Array.clone(tasks);

        this.createSuccessorTasks();

        try {
            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];

                var linkChains = {};
                this.validTask(task, linkChains);

                this.validTaskProperties(task);
            }
        } finally {
            this.clearSuccessorTasks();
        }
    },
    validTask: function (task, linkChains) {
        var taskUID = task.UID;

        if (linkChains[taskUID] != null) {
            if (this.project.customError) {
                this.project.customError(mini.Gantt.PredecessorError);
                return false;
            } else {
                throw new Error(mini.Gantt.PredecessorError);
            }
        }

        if (this.validedTasks[taskUID] != null) return;

        linkChains[taskUID] = task;

        linkChains[taskUID + 'toSuccessor'] = task;
        var SuccessorTasks = task.SuccessorTasks;
        if (SuccessorTasks != null && SuccessorTasks.length > 0) {
            for (var i = 0, l = SuccessorTasks.length; i < l; i++) {
                var t = SuccessorTasks[i];
                this.validTask(t, linkChains);
                delete linkChains[t.UID];
            }
        }
        delete linkChains[taskUID + 'toSuccessor'];

        linkChains[taskUID + 'toParent'] = task;
        var parentTask = this.project.getParentTask(taskUID);
        if (parentTask && parentTask.UID != this.project.rootTaskUID) {
            if (!linkChains[parentTask.UID + 'toChildren']) {
                this.validTask(parentTask, linkChains);
                delete linkChains[parentTask.UID];
            }
        }
        delete linkChains[taskUID + 'toParent'];

        linkChains[taskUID + 'toChildren'] = task;
        var children = task[this.project.tasks.nodesField];
        if (children && children.length > 0) {
            var isChildrenUp = false;
            for (var i = 0, l = children.length; i < l; i++) {
                var childTask = children[i];
                if (linkChains[childTask.UID + 'toParent']) {
                    isChildrenUp = true;
                    break;
                }
            }

            if (!isChildrenUp) {
                for (var i = 0, l = children.length; i < l; i++) {
                    var childTask = children[i];
                    this.validTask(childTask, linkChains, false);
                    delete linkChains[childTask.UID];
                }
            }
        }
        delete linkChains[taskUID + 'toChildren'];

        this.validedTasks[taskUID] = task;
    },

    validTaskProperties: function (task) {
        if (task.Name === null || task.Name === undefined) task.Name = '';

        var project = this.project;

        if (!task.Assignments) task.Assignments = [];

        if (mini.isNull(task.Duration)) task.Duration = 0;
        if (mini.isNull(task.PercentComplete)) task.PercentComplete = 0;
        if (mini.isNull(task.Work)) task.Work = 0;

        task.Duration = project._Calendar._parseDuration(task.Duration);
        task.PercentComplete = parseFloat(task.PercentComplete);

        if (task.PercentComplete < 0) task.PercentComplete = 0;
        if (task.PercentComplete > 100) task.PercentComplete = 100;

        if (task.Manual == null || task.Manual == '0' || task.Manual === false) task.Manual = 0;
        else task.Manual = 1;

        if (mini.isNull(task.Type)) task.Type = 0;
        if (mini.isNull(task.IgnoreResourceCalendar)) task.IgnoreResourceCalendar = 0;
        if (mini.isNull(task.EffortDriven)) task.EffortDriven = 1;
        if (mini.isNull(task.EarnedValueMethod)) task.EarnedValueMethod = 0;
        if (mini.isNull(task.Active)) task.Active = 1;
        if (mini.isNull(task.Recurring)) task.Recurring = 0;
        if (mini.isNull(task.CalendarUID)) task.CalendarUID = -1;

        task.HideBar = task.HideBar === true;
        task.Rollup = task.Rollup === true;

        if (isNaN(task.Critical)) task.Critical = 0;
        if (this.project.keeyConstraint) {
            if (isNaN(task.ConstraintType)) task.ConstraintType = 0;
        } else {
            if (isNaN(task.ConstraintType) || !task.ConstraintDate) task.ConstraintType = 0;
        }

        if (task.ConstraintDate) {
            var cd = task.ConstraintDate;
            task.ConstraintDate = new Date(cd?.getFullYear(), cd?.getMonth(), cd?.getDate());

            if (project.enableHalfDay) {
                if (task.ConstraintType == 2 || task.ConstraintType == 4 || task.ConstraintType == 5) {
                    task.ConstraintDate = project._Calendar._parseStartDate(cd);
                } else {
                    task.ConstraintDate = project._Calendar._parseFinishDate(cd);
                }
            }
        }

        if (!mini.isDate(task.Start)) task.Start = null;
        if (!mini.isDate(task.Finish)) task.Finish = null;

        if (!mini.isDate(task.ActualStart)) task.ActualStart = null;
        if (!mini.isDate(task.ActualFinish)) task.ActualFinish = null;

        task.FixedDate = parseInt(task.FixedDate);
        if (isNaN(task.FixedDate)) task.FixedDate = 0;

        if (project.enableActualState) {
            if (task.PercentComplete > 0 && !task.ActualStart && task.Start) {
                task.ActualStart = mini.cloneDate(task.Start);
            }
            if (task.PercentComplete == 100 && !task.ActualFinish && task.Finish) {
                task.ActualFinish = mini.cloneDate(task.Finish);
            }
        }

        var children = task[this.project.tasks.nodesField];

        var hoursPerDay = project.getHoursPerDay();

        if (task.Assignments) {
            for (var i = task.Assignments.length - 1; i >= 0; i--) {
                var o = task.Assignments[i];

                if (!o.Work) o.Work = 0;

                var re = project.getResource(o.ResourceUID);
                if (re.Type == 1 && mini.isNull(o.Duration)) {
                    var calendar = project._getResourceCalendar(o.ResourceUID);
                    var duration = calendar._parseDuration(o.Work / (hoursPerDay * o.Units));
                    o.Duration = duration;
                }
            }
        }

        var links = task.PredecessorLink;
        if (links && links.length > 0) {
            var taskUID = task.UID;

            for (var i = links.length - 1; i >= 0; i--) {
                var link = links[i];
                link.Type = parseInt(link.Type);
                link.LinkLag = project._Calendar._parseDuration(link.LinkLag);
                if (isNaN(link.LinkLag)) link.LinkLag = 0;

                link.TaskUID = task.UID;

                var preTaskUID = link.PredecessorUID;

                var preTask = this.project.getTask(preTaskUID);
                if (!preTask) {
                    links.removeAt(i);
                    continue;
                }

                if (this.project.isAncestor(taskUID, preTaskUID) || this.project.isAncestor(preTaskUID, taskUID)) {
                    links.removeAt(i);
                    continue;
                }

                // if (task.Summary && (link.Type == 0 || link.Type == 2)) {
                //     alert(String.format(mini.Gantt.SummaryPredecessorError, task.ID, task.Name));
                //     links.removeAt(i);
                // }
            }
        }

        if (task.children && task.children.length > 0) {
            task.Summary = 1;
            task.Milestone = 0;
        } else {
            if (task.Milestone) {
            } else {
                if (task.Start) task.Start = project._Calendar._parseStartDate(task.Start);
                if (task.Finish) task.Finish = project._Calendar._parseFinishDate(task.Finish);

                if (task.ActualStart) task.ActualStart = project._Calendar._parseStartDate(task.ActualStart);
                if (task.ActualFinish) task.ActualFinish = project._Calendar._parseFinishDate(task.ActualFinish);
            }
        }
    },

    isFixedTask: function (task) {
        return !!task.Summary && !!task.FixedDate;
    },
    isLimitTask: function (task) {
        return !(task.ConstraintType == 0 || task.ConstraintType == 1 || !task.ConstraintDate);
    },
    validLimit: function (task) {
        var fixed = this.isFixedTask(task),
            limit = this.isLimitTask(task);
        if (!fixed && !limit) return;

        if (fixed) {
        }

        if (limit) {
        }
    }
});

MyProjectSchedule.PercentComplete = mini.Base.extend({
    constructor: function (project) {
        this.project = project;
    },
    syncComplete: function (task) {
        if (this.project.syncParentPercentComplete) {
            this.syncParentComplete(task);
        }

        if (this.project.syncChildrenPercentComplete) {
            this.syncChildrenComplete(task);
        }
    },
    syncParentComplete: function (task) {
        var percentCompleteProperty = 'Duration';

        var taskUID = task.UID;
        var parentTask = this.project.getParentTask(taskUID);
        if (parentTask != null && parentTask.UID != this.project.rootTaskUID) {
            var _PercentComplete = parentTask.PercentComplete;

            var cs = this.getChildrenAll(parentTask);
            var allDuration = 0,
                completeDuration = 0;
            for (var i = 0, l = cs.length; i < l; i++) {
                var c = cs[i];

                var duration = parseInt(c[percentCompleteProperty]);
                if (isNaN(duration)) duration = 0;
                var percentComplete = parseFloat(c['PercentComplete']);
                if (isNaN(percentComplete)) percentComplete = 0;

                allDuration += duration;
                completeDuration += (duration * percentComplete) / 100;
            }
            parentTask['PercentComplete'] = parseInt((completeDuration / allDuration) * 100);
            if (isNaN(parentTask['PercentComplete'])) parentTask['PercentComplete'] = 0;
            this.syncParentComplete(parentTask);

            if (_PercentComplete != parentTask.PercentComplete) {
                this.project.setTaskModified(parentTask, 'PercentComplete');
            }
        }
    },
    syncChildrenComplete: function (task) {
        var percentCompleteProperty = 'Duration';
        var children = this.getChildrenAll(task);

        if (task.Duration == 0) return;

        var allDuration = 0,
            completeDuration = 0;
        for (var i = 0, l = children.length; i < l; i++) {
            var c = children[i];

            var duration = c[percentCompleteProperty];
            allDuration += duration;
        }
        completeDuration = (allDuration * parseInt(task['PercentComplete'])) / 100;

        var isCompleteAll = allDuration == completeDuration;

        for (var i = 0, l = children.length; i < l; i++) {
            var c = children[i];
            var _PercentComplete = c.PercentComplete;

            if (c.Duration == 0) continue;

            var duration = c[percentCompleteProperty];

            if (completeDuration <= 0) {
                c['PercentComplete'] = 0;
            } else {
                var d = completeDuration - duration;
                if (d >= 0) c['PercentComplete'] = 100;
                else {
                    c['PercentComplete'] = parseInt((completeDuration / duration) * 100);

                    if (isNaN(c['PercentComplete'])) c['PercentComplete'] = 0;
                }
                completeDuration = d;
            }

            if (isCompleteAll) {
                c['PercentComplete'] = 100;
            }

            if (_PercentComplete != c.PercentComplete) {
                this.project.setTaskModified(c, 'PercentComplete');
            }

            if (this.project.enableActualState && !c.Summary) {
                if (c.PercentComplete > 0) {
                    if (!c.ActualStart) c.ActualStart = mini.cloneDate(c.Start);
                } else {
                    c.ActualStart = null;
                }
                if (c.PercentComplete == 100) {
                    if (!c.ActualFinish) c.ActualFinish = mini.cloneDate(c.Finish);
                } else {
                    c.ActualFinish = null;
                }
            }
        }

        for (var i = 0, l = children.length; i < l; i++) {
            var c = children[i];
            this.syncParentComplete(c);
        }
    },

    getChildrenAll: function (task) {
        var children = this.project.getChildTasks(task, true);
        var nodes = [];
        for (var i = 0, l = children.length; i < l; i++) {
            var c = children[i];
            if (c.Summary == 0) {
                nodes.push(c);
            }
        }
        return nodes;
    }
});

MyProjectSchedule.Critical = mini.Base.extend({
    constructor: function (project) {
        this.project = project;
    },
    clearCritical: function () {
        this.Tasks = this.project.getTaskList();
        this.clearCriticalTasks(this.Tasks);
    },
    createCritical: function () {
        this.nodesField = this.project.tasks.nodesField;
        this.Tasks = this.project.getTaskList();
        this.StartDate = this.project.getStartDate();
        this.FinishDate = this.project.getFinishDate();

        var tasks = this.Tasks;

        var olds = {};
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            olds[task.UID] = task.Critical;
        }

        this.doCreateCritical();

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            if (olds[task.UID] !== task.Critical) {
                this.project.setTaskModified(task, 'Critical');
            }
        }
    },

    doCreateCritical: function () {
        var me = this,
            project = me.project;

        if (!this.project.allowOrderProject && !this.project.customConfig.allowCritical) return;

        var tasks = this.Tasks;
        this.clearCriticalTasks(tasks);

        if (tasks.length == 0) return;

        me.taskHash = {};
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            me.taskHash[task.UID] = task;
        }

        me.successors = {};

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            if (!me.successors[task.UID]) {
                me.successors[task.UID] = [];
            }

            var links = task.PredecessorLink;
            if (links != null && links.length > 0) {
                for (var j = 0, k = links.length; j < k; j++) {
                    var link = links[j];
                    var preTask = me.taskHash[link.PredecessorUID];
                    if (preTask != null) {
                        var successors = me.successors[preTask.UID];
                        if (!successors) {
                            successors = me.successors[preTask.UID] = [];
                        }

                        link.TaskUID = task.UID;
                        successors.push(link);
                    }
                }
            }
        }

        function addParentSuccessors(task) {
            var successors = me.successors[task.UID];
            while (true) {
                var parentTask = project.getParentTask(task);
                if (!parentTask) break;

                var parentSuccessors = me.successors[parentTask.UID];
                if (parentSuccessors) {
                    mini.Array.addRange(successors, parentSuccessors);
                }

                task = parentTask;
            }
        }

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            if (!task.Summary) {
                addParentSuccessors(task);
            }
        }

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            if (task.Start && task.Finish) {
                task.EarlyStart = task.Start;
                task.EarlyFinish = task.Finish;
            }
        }

        var lastTasks = this.getLastTasksByParent(project.store.root);
        this.lastFinishDate = lastTasks[0]?.Finish;
        if (project.data.MustFinishByDate && project.data.MustFinishByDate < this.lastFinishDate) {
            this.lastFinishDate = project.data.MustFinishByDate;
        }

        project.data.LastTaskFinishDate = this.lastFinishDate;

        this.orderByFinishHash = {};

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            this.orderLateByFinish(task);
        }

        var CriticalSlackLimit = project.data.CriticalSlackLimit || 0;

        function isZeroDifference(task) {
            return task.TotalSlack <= CriticalSlackLimit;
        }

        function fn(task) {
            if (task.Critical) return;
            // 原始代码
            // if (isZeroDifference(task) && task.PercentComplete < 100) {
            //     task.Critical = 1;
            // } else {
            //     return;
            // }
            // 优化代码
            if (task.PercentComplete < 100) {
                task.Critical = 1;
            } else {
                return;
            }

            var links = task.PredecessorLink;
            if (links != null && links.length > 0) {
                for (var i = 0, l = links.length; i < l; i++) {
                    var link = links[i];
                    var preTask = project.getTask(link.PredecessorUID);
                    fn(preTask);
                }
            }

            var parentTask = project.getParentTask(task);
            if (parentTask) {
                fn(parentTask);
            }

            if (task.Summary) {
                var lastTasks = me.getLastTasksByParent(task);
                for (var i = 0, l = lastTasks.length; i < l; i++) {
                    fn(lastTasks[i]);
                }
            }
        }

        var criticalFinish = project.getStartByCalendar(this.lastFinishDate, CriticalSlackLimit + 1, tasks[0]);
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            if (project.data.MultipleCriticalPaths) {
                fn(task);
            } else {
                if (task.Finish >= criticalFinish) {
                    var days = project.getDurationByCalendar(task.Finish, this.lastFinishDate, task);
                    if (days <= CriticalSlackLimit) {
                        fn(task);
                    }
                }
            }
        }
    },

    orderLateSummaryTask: function (task) {
        if (!task.Summary) throw new Error('This task is must a summary task.');
        var calendar = this.project._getTaskCalendar(task);

        var lateStart, lateFinish;

        var children = task.children || [];
        for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            this.orderLateByFinish(child);

            if (!lateStart || child.LateStart < lateStart) {
                lateStart = child.LateStart;
            }
            if (!lateFinish || child.LateFinish > lateFinish) {
                lateFinish = child.LateFinish;
            }
        }

        if (!lateFinish) {
            lateFinish = this.lastFinishDate;
            lateStart = calendar._getStart(lateFinish, task.Duration);
        }

        task.LateFinish = new Date(lateFinish?.getTime());
        task.LateStart = new Date(lateStart?.getTime());
    },

    orderWorkResourceAssignment: function (task, item) {
        var calendar = this.project._getResourceCalendar(item.ResourceUID);

        var lateFinish = this.getLateFinishBySuccessor(task, item);
        if (!lateFinish) lateFinish = this.lastFinishDate;

        item.LateFinish = new Date(lateFinish?.getTime());
        item.LateStart = calendar._getStart(item.LateFinish, item.Duration);

        project._Order.limitTaskByStart(task, false, true, item);
    },

    orderTaskByWorkResource: function (task) {
        var lateStart, lateFinish;
        for (var i = 0, l = task.Assignments.length; i < l; i++) {
            var item = task.Assignments[i];

            this.orderWorkResourceAssignment(task, item);

            if (!lateStart || lateStart > item.LateStart) {
                lateStart = item.LateStart;
            }
            if (!lateFinish || lateFinish < item.LateFinish) {
                lateFinish = item.LateFinish;
            }
        }

        task.LateStart = lateStart;
        task.LateFinish = lateFinish;
    },

    orderLateByFinish: function (task) {
        if (this.orderByFinishHash[task.UID]) return;
        this.orderByFinishHash[task.UID] = task;

        var project = this.project;
        var calendar = this.project._getTaskCalendar(task);

        if (task.Summary) {
            this.orderLateSummaryTask(task);
        } else {
            if (project._Order._useResourceCalendar(task)) {
                this.orderTaskByWorkResource(task);
            } else {
                var lateFinish = this.getLateFinishBySuccessor(task);
                if (!lateFinish) {
                    if (project.data.MultipleCriticalPaths) {
                        lateFinish = new Date(task.EarlyFinish);
                    } else {
                        lateFinish = this.lastFinishDate;
                    }
                }

                task.LateFinish = new Date(lateFinish?.getTime());

                task.LateStart = calendar._getStart(task.LateFinish, task.Duration);

                project._Order.limitTaskByStart(task, false, true);
            }
        }

        var lateStart = task.LateStart;
        var days = project.getDurationByCalendar(task.EarlyStart, lateStart, task);

        var earlyFinish = task.EarlyFinish;
        var days2 = project.getDurationByCalendar(earlyFinish, task.LateFinish, task);

        if (days2 < days) days = days2;

        task.TotalSlack = days;
    },

    getLateFinishBySuccessor: function (task, _assignment) {
        var me = this,
            successors = me.successors[task.UID],
            lateFinish;

        var taskDays = task.Duration;

        if (successors) {
            var calendar = this.project._getTaskCalendar(task);

            if (_assignment) {
                taskDays = _assignment.Duration;
                calendar = this.project._getResourceCalendar(_assignment.ResourceUID);
            }

            for (var i = 0, l = successors.length; i < l; i++) {
                var link = successors[i];
                var succTask = this.taskHash[link.TaskUID];

                this.orderLateByFinish(succTask);

                if (succTask.PercentComplete == 100) continue;

                var start = succTask.LateStart,
                    finish = succTask.LateFinish;

                var isZERO = this.project.enableZeroDuration && succTask.Duration == 0;

                if (succTask.PercentComplete > 0 && !isZERO) {
                    var offsetDay = (succTask.Duration * succTask.PercentComplete) / 100;
                    start = calendar._getWorkingStartDate(start, offsetDay);
                }

                if (isZERO) {
                    switch (link.Type) {
                        case 0:
                            finish = finish;
                            break;
                        case 1:
                            finish = start;

                            break;
                        case 2:
                            finish = calendar._getFinish(start, taskDays);

                            break;
                        case 3:
                            finish = calendar._getFinish(start, taskDays);
                            break;
                    }
                } else {
                    switch (link.Type) {
                        case 0:
                            finish = finish;
                            break;
                        case 1:
                            start = new Date(start?.getTime());

                            start?.setHours(start?.getHours() - 1);
                            finish = calendar._getPreviousWorkingFinish(start);

                            break;
                        case 2:
                            finish = new Date(finish?.getTime());

                            finish?.setHours(finish?.getHours() + 1);
                            start = calendar._getNextWorkingStart(finish);
                            finish = calendar._getFinish(start, taskDays);
                            break;
                        case 3:
                            finish = calendar._getFinish(start, taskDays);
                            break;
                    }
                }

                var linkLag = link.LinkLag || 0;
                if (linkLag != 0) {
                    finish = calendar._getWorkingStartDate(finish, -linkLag);

                    if (this.project.enableHalfDay) {
                        if (finish?.getHours() == 0) {
                            finish?.setHours(-1);
                            finish = calendar._getPreviousWorkingFinish(finish);
                        }
                    }
                }

                finish = calendar._getPreviousWorkingFinish(finish);

                if (lateFinish == null || finish?.getTime() < lateFinish?.getTime()) {
                    lateFinish = finish;
                }
            }
        }

        if (lateFinish > this.lastFinishDate) {
            lateFinish = new Date(this.lastFinishDate?.getTime());
        }

        return lateFinish;
    },

    addDate: function (date, dayAdd) {
        return new Date(
            date?.getFullYear(),
            date?.getMonth(),
            date?.getDate(),
            date?.getHours() + dayAdd,
            date?.getMinutes(),
            date?.getSeconds()
        );
    },

    clearCriticalTasks: function (tasks) {
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            delete task.EarlyStart;
            delete task.EarlyFinish;
            delete task.LateStart;
            delete task.LateFinish;
            task.Critical = 0;
        }
    },

    getLastTasksByParent: function (parentTask) {
        var lastTasks = [];

        var tasks = mini.treeToArray(parentTask.children, 'children');

        var lastTime = -1;
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            if (task == null || task.Finish == null || task.Summary) continue;
            var time = task.Finish?.getTime();

            if (time > lastTime) {
                lastTime = time;
            }
        }

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            if (task == null || task.Finish == null || task.Summary) continue;
            var time = task.Finish?.getTime();

            if (time == lastTime) {
                lastTasks.push(task);
            }
        }

        return lastTasks;
    }
});

PlusGantt.Window = mini.Window.extend({
    props: {
        width: 500,
        height: 350,
        closeAction: 'destroy',
        showFooter: true,
        footerStyle: 'padding:8px;padding-right:10px;text-align:right;',
        footer: '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>'
    },

    project: null,

    setData: function (data) {},

    getData: function () {},

    onOkClick: function (event) {
        this.close('ok');
    },

    onCancelClick: function (event) {
        this.close('cancel');
    }
});
PlusGantt.PrintGanttWindow = PlusGantt.Window.extend({
    props: {
        title: '甘特图打印',
        width: 350,
        height: 'auto'
    },

    footer: '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">打印</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>',

    content:
        '<div style="padding:10px;">' +
        '<div><label><input @change="handleChange" type="radio" name="view" ref="current" checked/> 当前视图</label></div>' +
        '<div><label><input @change="handleChange" type="radio" name="view" ref="full"/> 完整视图</label></div>' +
        '<div style="padding-left:15px;">' +
        '<mini-checkbox ref="gantt" checked="true" enabled="false">甘特图完整视图</mini-checkbox><br/>' +
        '<mini-checkbox ref="table" checked="false" enabled="false">表格完整视图</mini-checkbox>' +
        '</div>' +
        '</div>',

    setData: function () {
        this.refresh();
    },

    handleChange: function () {
        this.refresh();
    },

    refresh: function () {
        var isFull = this.refs.full[0].checked;

        this.refs.table.setEnabled(isFull);
    },

    onOkClick: function (e) {
        var me = this;
        var project = this.project;

        var isFull = this.refs.full[0].checked;
        var ganttFull = this.refs.gantt.getChecked();
        var tableFull = this.refs.table.getChecked();

        var name = 'plusgantt.png';

        mini.mask({
            el: document.body,
            cls: 'mini-mask-loading',
            html: '甘特图打印中...'
        });

        PlusGantt.__printProject({
            project: project,
            name: name,
            full: isFull,
            ganttFull: ganttFull,
            tableFull: tableFull,
            callback: function (el) {
                mini.unmask();
                me.close('ok');
            }
        });
    }
});

PlusGantt.__printProject = function (options) {
    var project = options.project;

    var ghost;

    function print() {
        mini.__printElement(project.el, options.name, function () {
            if (ghost) {
                $(project.el).insertBefore(ghost);
                $(ghost).remove();

                gantt.setWidth(cache.width);
                gantt.setHeight(cache.height);
                gantt.setTableViewWidth(cache.pane1Width);

                gantt.setScrollTop(cache.scrollTop, true);
                gantt.tableView.setScrollLeft(cache.tableScrollLeft);
                gantt.ganttView.setScrollLeft(cache.ganttScrollLeft);

                gantt.setShowGridLines(cache.showGridLines);

                ct.remove();
            }

            if (options.callback) options.callback();
        });
    }

    if (!options.full) {
        print();
        return;
    }

    var ghost = project.el.cloneNode(true);
    $(ghost).insertBefore(project.el);

    var ct = $('<div style="position:absolute;top:-1000000px;left:-1000000px;"></div>').appendTo('body');
    ct.append(project.el);
    var gantt = project;

    var cache = {
        width: project.el.style.width,
        height: project.el.style.height,
        pane1Width: project.pane1.size,

        scrollTop: project.tableView.getScrollTop(),
        ganttScrollLeft: project.ganttView.getScrollLeft(),
        tableScrollLeft: project.tableView.getScrollLeft(),
        showGridLines: project.showGridLines
    };

    $('.mini-ganttview .mini-supergrid-vscroller', ghost)[0].scrollTop = cache.scrollTop;
    $('.mini-ganttview .mini-supergrid-hscroller', ghost)[0].scrollLeft = cache.ganttScrollLeft;
    $('.mini-supergrid .mini-supergrid-hscroller', ghost)[0].scrollLeft = cache.tableScrollLeft;

    var headerHeight = gantt.tableView.getHeaderHeight(),
        rowsHeight = gantt.rowHeight * gantt.store.getVisibleRows().length,
        height = headerHeight + rowsHeight + 25;

    var tableWidth = gantt.getPaneEl(1).offsetWidth;

    if (options.tableFull) tableWidth = gantt.tableView.getAllColumnWidth();

    var width = tableWidth + gantt.ganttView.scrollWidth;

    if (!gantt.ganttViewExpanded || !gantt.showGanttView) width = width - gantt.ganttView.scrollWidth;
    if (!gantt.tableViewExpanded || !gantt.showTableView) {
        width = width - tableWidth;
        tableWidth = 0;
    }

    gantt.setTableViewWidth(tableWidth);

    gantt.setWidth(width);
    gantt.setHeight(height);
    gantt.refresh();

    gantt.setScrollTop(0);
    gantt.tableView.setScrollLeft(0);
    gantt.ganttView.setScrollLeft(0);
    gantt.setShowGridLines(false);

    setTimeout(function () {
        print();
    }, 300);
};

mini.__printElement = function (el, name, callback) {
    domtoimage.toPng(el).then(function (dataUrl) {
        clearTimeout(timeout);
        var a = document.createElement('a');
        a.download = name;
        a.href = dataUrl;
        a.dispatchEvent(new MouseEvent('click'));

        callback();
    });

    var timeout = setTimeout(function () {
        alert('图片过大，打印失败。\n请适当减少列数、行数、时间跨度。');
        callback();
    }, 10000);
};

mini.Project = function () {
    mini.Project.superclass.constructor.call(this);

    new MyProjectSchedule(this);

    this.setTreeColumn('Name');

    if (!this.plugins) this.plugins = {};

    this.progressLine = { visible: false, date: null, type: 'customDate' };

    var project = this;
    this.plugins.progressLine = new ProgressLine(this, {
        visible: false,
        mode: 2,

        getProjectDate: function () {
            var config = this.project.progressLine;
            if (!config.visible) return null;
            if (config.type == 'currentDate') return mini.clearTime(new Date());
            return config.date;
        },
        getTaskDate: function (task) {
            if (task.PercentComplete == 100) return null;
            var baseDate = this.getProjectDate();
            if (task.Start && task.Finish) {
                if (task.Start >= baseDate) return null;
                var time = task.Finish - task.Start;
                time = (time * task.PercentComplete) / 100;
                var date = new Date(task.Start?.getTime() + time);
                return date;
            }
        }
    });

    this.lastScheduleDate = this.firstScheduleDate = new Date();
};
mini.extend(mini.Project, mini.Gantt, {
    allowUndo: false,
    undoMaxLength: 50,

    setAllowUndo: function (value) {
        this.allowUndo = value;
        if (value) {
            if (!this.undoManager) {
                this.undoManager = new PlusProject.UndoManager(this, this.undoMaxLength);
                var me = this;
                this.undoManager.onUpdate = function () {
                    me.fire('undochange');
                };
            }
        } else {
            if (this.undoManager) {
                this.undoManager = null;
            }
        }
    },

    executeAction: function (action) {
        if (this.undoManager) {
            this.undoManager.execute(action);
        } else {
            action.execute();
        }
    },

    undo: function (uid) {
        return this.undoManager ? this.undoManager.undo(uid) : false;
    },

    redo: function () {
        return this.undoManager ? this.undoManager.redo() : false;
    },

    canUndo: function () {
        return this.undoManager ? this.undoManager.canUndo() : false;
    },

    canRedo: function () {
        return this.undoManager ? this.undoManager.canRedo() : false;
    },

    showTotalSlack: false,

    showDelayedTask: false,

    setShowTotalSlack: function (value) {
        this.showTotalSlack = value;
        this.ganttView.invalidate();
    },

    setShowDelayedTask: function (value) {
        this.showDelayedTask = value;
        this.ganttView.invalidate();
    },

    isDelayedTask: function (task) {
        var date = this.data.StatusDate;
        if (!date) date = new Date();
        if (task.PercentComplete == 100) return false;
        if (task.Start && task.Start >= date) {
            return false;
        }
        return true;
    },

    showProjectSummary: false,
    setShowProjectSummary: function (value) {
        this.showProjectSummary = value;
        this.store.setRootVisible(value);
    },

    setConfigColumns: function (configColumns) {
        PlusProject.setConfigColumns(this, configColumns);
    },

    getConfigColumns: function () {
        return PlusProject.getProjectConfigColumns(this);
    },

    setProgressLine: function (config) {
        this.progressLine = config;

        this.plugins.progressLine.setVisible(config.visible);
        this.ganttView.invalidate();
    },

    getProgressLine: function () {
        this.progressLine;
    },

    highlightFilterFields: null,

    getMilestoneLabel: function (item) {
        return mini.formatDate(item.Start, 'MM-dd');
    },

    allowProjectDateRange: true,
    allowSummaryLink: true,
    allowSyncComplete: true,
    enableManualSchedule: false,

    syncParentPercentComplete: true,
    syncChildrenPercentComplete: true,

    limitFromProjectStart: false,

    enableHalfDay: false,
    hoursPerDay: 8,

    enableResourceCalendar: false,
    enableTaskWorkWithDuration: true,

    enableCompleteLogic: false,

    enableActualState: false,

    enableZeroDuration: true,
    keeyConstraint: false,

    dateFormat: 'yyyy-MM-dd',
    dateFormatHalfDay: 'yyyy-MM-dd HH',

    isSyncComputeTask: function (task) {
        if (this.enableActualState) {
            if (task.ActualStart || task.PercentComplete > 0) return false;
        }

        return true;
    },

    showCriticalPath: false,
    clearCriticalPath: function () {
        if (this._Critical) {
            this._Critical.clearCritical();
        }
    },

    createCriticalPath: function () {
        if (this._Critical) {
            this._Critical.createCritical();
        }
    },

    suspendCount: 0,
    suspendSchedule: function () {
        this.suspendCount++;
        this.allowOrderProject = false;
    },

    resumeSchedule: function () {
        this.suspendCount--;
        if (this.suspendCount <= 0) {
            this.allowOrderProject = true;
            this.schedule();
        }
    },

    schedule: function () {
        this.orderProject();
    },

    allowOrderProject: true,
    autoSyncSummary: false,

    customConfig: {
        setParentOnRestore: true,
        allowCritical: false
    },
    _orderModel: '',

    _FastModel: false,
    _doFast: false,

    _syncGroupItems: function () {
        var me = this;
        var store = this.store;
        if (!store.isGrouped()) return;

        function syncStart(result, item, field) {
            if (!result[field] || (item[field] && item[field] < result[field])) {
                result[field] = item[field];
            }
        }

        function syncFinish(result, item, field) {
            if (!result[field] || (item[field] && item[field] > result[field])) {
                result[field] = item[field];
            }
        }

        var percentCompleteProperty = 'Duration';

        function each(items) {
            var allDuration = 0,
                completeDuration = 0;
            var result = {};
            for (var i = 0, l = items.length; i < l; i++) {
                var item = items[i];

                if (store.isGroupItem(item)) {
                    var o = each(item.isBottomLevel ? item.items : item.groups);
                    $.extend(item, o);

                    if (item.PercentComplete != 100) {
                        item.ActualFinish = null;
                    }

                    item.Summary = 1;
                    item.Duration = 0;
                    if (item.Start && item.Finish) {
                        item.Duration = me._Calendar._getDuration(item.Start, item.Finish);
                    }
                }

                syncStart(result, item, 'Start');
                syncStart(result, item, 'ActualStart');
                syncStart(result, item, 'EarlyStart');
                syncStart(result, item, 'LateStart');

                syncFinish(result, item, 'Finish');
                syncFinish(result, item, 'ActualFinish');
                syncFinish(result, item, 'EarlyFinish');
                syncFinish(result, item, 'LateFinish');

                var duration = parseInt(item.Duration);
                if (isNaN(duration)) duration = 0;
                var percentComplete = parseFloat(item['PercentComplete']);
                if (isNaN(percentComplete)) percentComplete = 0;

                allDuration += duration;
                completeDuration += (duration * percentComplete) / 100;
            }

            var percentComplete = parseInt((completeDuration / allDuration) * 100);
            result.PercentComplete = percentComplete;

            return result;
        }

        each(store.groups);
    },

    _syncResources: function () {
        var me = this;

        var tasks = this.getTaskList();
        var resources = this.data.Resources;

        for (var i = 0, l = resources.length; i < l; i++) {
            var re = resources[i];
            re.Cost = 0;
            re.Work = 0;
        }

        function eachAssignments(task) {
            if (task.Assignments) {
                for (var i = 0, l = task.Assignments.length; i < l; i++) {
                    var item = task.Assignments[i];
                    var re = me.getResource(item.ResourceUID);
                    if (re) {
                        if (re.Type == 0) {
                            re.Work += item.Work;
                            re.Cost = re.Work * re.StandardRate;
                            item.Cost = item.Work * re.StandardRate;
                        } else if (re.Type == 1) {
                            re.Work += item.Work;
                            re.Cost = re.Work * re.StandardRate;
                            item.Cost = item.Work * re.StandardRate;
                        } else if (re.Type == 2) {
                            re.Cost += item.Cost;
                        }
                    }
                }
            }
        }

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            var work = eachAssignments(task);
        }
    },

    _syncTaskWork: function (task) {
        if (task.Assignments && !task.Summary) {
            var changed = false;
            var taskWork = 0;
            for (var i = 0, l = task.Assignments.length; i < l; i++) {
                var item = task.Assignments[i];
                var re = this.getResource(item.ResourceUID);
                if (re) {
                    if (re.Type == 0) {
                    } else if (re.Type == 1) {
                        taskWork += item.Work;
                        changed = true;
                    } else if (re.Type == 2) {
                    }
                }
            }
            if (changed) {
                task.Work = taskWork;
            }
        }
    },

    onStoreRefresh: function (e) {
        this._syncGroupItems();
    },

    orderProject: function () {
        var sss = new Date();
        this.store.beginChange();

        try {
            if (this._orderCount == 0) {
                this.syncTasks(false);

                if (this._Validator) this._Validator.valid();

                this._syncResources();

                this.onOrderProject();

                var ttt = new Date();
                if (this.allowOrderProject) {
                    if (this._Order) this._Order.orderByStart();
                }

                this.createCriticalPath();

                var dr = this.getDateRange();
                if (dr) {
                    this.ganttView.setDateRange(dr[0], dr[1]);
                }
            } else {
                if (this._doFast) {
                } else {
                    this._syncTasks2();
                }
            }

            this._syncGroupItems();
        } catch (ex) {
            throw ex;
        } finally {
            this.store.endChange();
        }

        this.invalidateLayout();

        this.lastScheduleDate = new Date();

        this.fire('schedule');
    },

    onOrderProject: function () {},

    syncPercentCompletes: function () {
        var me = this,
            taskList = me.getTaskList();

        function sync(task) {
            me._PercentComplete.syncParentComplete(task);
        }

        var parents = [];
        for (var i = 0, l = taskList.length; i < l; i++) {
            var task = taskList[i];
            sync(task);
        }
    },

    isWorking: function (date, timescale) {
        if (!this.data) return true;
        var type = timescale.type;
        if (
            (type == 'day' && timescale.number > 1) ||
            type == 'week' ||
            type == 'month' ||
            type == 'quarter' ||
            type == 'halfyear' ||
            type == 'tendays'
        )
            return true;

        var dayOfWeek = date?.getDay(),
            dateTime = date?.getTime();
        var weekday = null;

        var calendar = this.getProjectCalendar();

        return calendar._isWorkingDate(date);
    },

    _initCalendars: function () {
        var project = this.data;

        this._calendars = {};

        var calendarHash = {};

        for (var i = project.Calendars.length - 1; i >= 0; i--) {
            var c = project.Calendars[i];

            calendarHash[c.UID] = c;

            if (c.IsBaseCalendar == null) c.IsBaseCalendar = 1;

            if (!c.IsBaseCalendar) {
                project.Calendars.removeAt(i);
                continue;
            }

            c.WeekDays = c.WeekDays || [];
            c.Exceptions = c.Exceptions || [];

            var baseCalendar = this._getCalendarData(c.BaseCalendarUID);
            if (baseCalendar) {
                if (c.WeekDays.length == 0) {
                    c.WeekDays = mini.clone(baseCalendar.WeekDays);
                }

                var Exceptions = mini.clone(baseCalendar.Exceptions || []);
                c.Exceptions = c.Exceptions.concat(Exceptions);
            }

            this._calendars[c.UID] = new MyProjectSchedule.Calendar(this, c);
        }

        this._Calendar = this._calendars[project.CalendarUID];

        for (var i = 0, l = project.Resources.length; i < l; i++) {
            var o = project.Resources[i];
            var c = calendarHash[o.CalendarUID];
            if (c && !c.IsBaseCalendar && c.BaseCalendarUID != project.CalendarUID) {
                o.CalendarUID = c.BaseCalendarUID;
            }
        }
    },

    _initProject: function (project) {
        mini.Project.superclass._initProject.call(this, project);

        this._initCalendars();

        if (!this._Validator) this._Validator = new MyProjectSchedule.Validator(this);

        if (!this._Order) this._Order = new MyProjectSchedule.Order(this);
        if (!this._Critical) this._Critical = new MyProjectSchedule.Critical(this);
        if (!this._PercentComplete) this._PercentComplete = new MyProjectSchedule.PercentComplete(this);

        this.lastScheduleDate = this.firstScheduleDate = new Date();
    },

    setSchedulePercentComplete: function (value) {
        this._PercentComplete = value;
        value.project = this;
    },

    setScheduleCritical: function (value) {
        this._Critical = value;
        value.project = this;
    },

    parseTasks: function (tasks, taskmap) {
        if (!taskmap) return tasks;
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            var task2 = {};
            for (var key in taskmap) {
                var index = taskmap[key];
                var v = task[index];
                if (v !== null) {
                    task2[key] = v;
                }
                if (key == 'children' && v) {
                    this.parseTasks(v, taskmap);
                }
            }
            tasks[i] = task2;
        }

        return tasks;
    },
    isDataChanged: function () {
        return this.lastScheduleDate?.getTime() != this.firstScheduleDate?.getTime();
    },
    beforeFirstSchedule: function () {
        var tasks = this.getTaskList();
        for (var i = 0, l = tasks.length; i < l; i++) {
            this._syncTaskWork(tasks[i]);
        }
    },
    loadData: function (project) {
        if (this.undoManager) {
            this.undoManager.clear();
        }

        this.sortFields = [];
        this.filterFields = [];
        this.groupFields = [];
        this.highlightFields = [];
        this._highlightCache = null;
        if (project.Calendars && project.Calendars.length) {
            // 处理项目日历数据
            project.Calendars = [this.handleCalendarData(project.Calendars[0])];
            // 甘特图日历Id
            project.CalendarUID = project.Calendars[0].UID;
        }
        this.data = project;

        this._initProject(project);

        this.loadTasks(this.data.Tasks);

        this.lastScheduleDate = this.firstScheduleDate = new Date();
    },
    // 重新组装项目日历数据， 转为甘特图日历所需
    handleCalendarData(calendarData) {
        // 默认常规工作日
        let WeekDays = [
            //工作周: DayType(1~7)
            {
                DayType: 1,
                DayWorking: 0 //工作日1, 非工作日0
            },
            {
                DayType: 2,
                DayWorking: 1
            },
            {
                DayType: 3,
                DayWorking: 1
            },
            {
                DayType: 4,
                DayWorking: 1
            },
            {
                DayType: 5,
                DayWorking: 1
            },
            {
                DayType: 6,
                DayWorking: 1
            },
            {
                DayType: 7,
                DayWorking: 0
            }
        ];
        // 转换项目日历常规工作日
        if (calendarData.cycle && calendarData.cycle.length > 0) {
            // 如果项目日历已设置常规工作日 则将一周重置为工作日 (DayWorking ：0)
            WeekDays = [
                //工作周: DayType(1~7)
                {
                    DayType: 1,
                    DayWorking: 0 //工作日1, 非工作日0
                },
                {
                    DayType: 2,
                    DayWorking: 0
                },
                {
                    DayType: 3,
                    DayWorking: 0
                },
                {
                    DayType: 4,
                    DayWorking: 0
                },
                {
                    DayType: 5,
                    DayWorking: 0
                },
                {
                    DayType: 6,
                    DayWorking: 0
                },
                {
                    DayType: 7,
                    DayWorking: 0
                }
            ];
            // 项目日历常规工作日
            let cycleDate = calendarData.cycle.split(',');
            for (var item of cycleDate) {
                switch (item) {
                    case '1':
                        WeekDays[1].DayWorking = 1;
                        break;
                    case '2':
                        WeekDays[2].DayWorking = 1;
                        break;
                    case '3':
                        WeekDays[3].DayWorking = 1;
                        break;
                    case '4':
                        WeekDays[4].DayWorking = 1;
                        break;
                    case '5':
                        WeekDays[5].DayWorking = 1;
                        break;
                    case '6':
                        WeekDays[6].DayWorking = 1;
                        break;
                    case '7':
                        WeekDays[0].DayWorking = 1;
                        break;
                    default:
                        break;
                }
            }
        }
        // 重新将项目日历组装甘特图所需日历
        calendarData.UID = '2';
        calendarData.Name = calendarData?.name?.value;
        calendarData.IsBaseCalendar = 1;
        calendarData.BaseCalendarUID = '';
        calendarData.WeekDays = WeekDays;
        calendarData.Exceptions = [];
        let calendars = JSON.parse(JSON.stringify(calendarData));
        return calendars;
    },
    getData: function () {
        return this.data;
    },

    getProjectCalendar: function () {
        return this._Calendar;
    },
    getTaskCalendar: function (task) {
        return this._getTaskCalendar(task);
    },
    _getTaskCalendar: function (task) {
        var calendar = this.getProjectCalendar();

        if (task) {
            var taskCalendar = this._calendars[task.CalendarUID];
            if (taskCalendar) calendar = taskCalendar;
        }

        return calendar;
    },
    _getResourceCalendar: function (resourceUID) {
        var calendar = this.getProjectCalendar();

        var re = this.getResource(resourceUID);
        if (re) {
            var resourceCalendar = this._calendars[re.CalendarUID];
            if (resourceCalendar) calendar = resourceCalendar;
        }
        return calendar;
    },

    getStartByCalendar: function (finish, workingDays, task) {
        return this._getTaskCalendar(task)._getStart(finish, workingDays);
    },
    getFinishByCalendar: function (start, workingDays, task) {
        return this._getTaskCalendar(task)._getFinish(start, workingDays);
    },
    getDurationByCalendar: function (start, finish, task) {
        return this._getTaskCalendar(task)._getDuration(start, finish);
    },
    getNextWorkingStart: function (date, task) {
        return this._getTaskCalendar(task)._getNextWorkingStart(date);
    },
    getPreviousWorkingFinish: function (date, task) {
        return this._getTaskCalendar(task)._getPreviousWorkingFinish(date);
    },

    isWorkingDate: function (date, task) {
        return this._getTaskCalendar(task)._isWorkingDate(date);
    },

    _getCalendarData: function (uid) {
        if (typeof uid == 'object') return uid;
        var calendar = null;
        for (var i = 0, l = this.data.Calendars.length; i < l; i++) {
            var c = this.data.Calendars[i];
            if (c.UID == uid) {
                calendar = c;
                break;
            }
        }
        return calendar;
    },

    moveProject: function (date, keepProgress) {
        if (!mini.isDate(date)) return;
        var startDate = this.data.StartDate;

        var d1 = mini.clearTime(startDate);
        var d2 = mini.clearTime(date);

        var days = this._Calendar._getDuration(startDate, date);

        var projectDays = this._Calendar._getDuration(startDate, this.data.FinishDate);

        this.data.StartDate = date;
        this.data.FinishDate = this._Calendar._getFinish(date, projectDays);

        var tasks = this.getTaskList();
        for (var i = 0, l = tasks.length; i < l; i++) {
            var t = tasks[i];

            if (keepProgress !== true) {
                t.ActualStart = null;
                t.ActualFinish = null;
                t.PercentComplete = 0;
            }

            var start = t.Start;
            if (start != null && t.Finish != null) {
                var offsetDays = this._Calendar._getDuration(startDate, t.Finish);

                t.Finish = this._Calendar._getFinish(date, offsetDays);
                t.Start = this._Calendar._getStart(t.Finish, t.Duration);
            }

            var cdate = t.ConstraintDate;
            if (cdate != null) {
                cdate = mini.clearTime(t.ConstraintDate);

                var offsetDays = this._Calendar._getDuration(startDate, cdate);

                t.ConstraintDate = this._Calendar._getFinish(date, offsetDays);

                if (t.ConstraintDate?.getHours() == 23) {
                    t.ConstraintDate = mini.addDate(t.ConstraintDate, 1, 'S');
                }

                t.ConstraintDate = this._Calendar._getNextWorkingStart(t.ConstraintDate);
            }
        }

        if (this.progressLine && this.progressLine.date) {
            var time = this.progressLine.date?.getTime() - d1?.getTime();
            this.progressLine.date = new Date(d2?.getTime() + time);
        }

        if (this.timeLines) {
            for (var i = 0, l = this.timeLines.length; i < l; i++) {
                var item = this.timeLines[i];
                var time = item.date?.getTime() - d1?.getTime();
                item.date = new Date(d2?.getTime() + time);
            }
        }

        this.orderProject();
    },

    setStartDate: function (date) {
        this.moveProject(date);
    },

    setCalendars: function (calendars) {
        if (!mini.isArray(calendars)) return;

        this.data.Calendars = calendars;

        this._initCalendars();

        this.orderProject();
    },

    setCalendarUID: function (calendarUID) {
        this.data.CalendarUID = calendarUID;
        this._Calendar = this._calendars[calendarUID];

        this.orderProject();
    },

    setResources: function (data) {
        this.data.Resources = data || [];
        this._initResources();
        this.orderProject();
    },

    getResource: function (uid) {
        return this._ResourceUIDs[uid];
    },

    getResourceByName: function (name) {
        for (var i = 0, l = this.data.Resources.length; i < l; i++) {
            var item = this.data.Resources[i];
            if (item.Name == name) return item;
        }
    },

    parseDuration: function (value) {
        return this.getProjectCalendar()._parseDuration(value);
    },

    parseStartDate: function (value) {
        return this.getProjectCalendar()._parseStartDate(value);
    },

    parseFinishDate: function (value) {
        return this.getProjectCalendar()._parseFinishDate(value);
    },

    parseLinkLag: function (s) {
        var n = parseFloat(s);
        return this.parseDuration(n);
    },

    getHoursPerDay: function () {
        var MinutesPerDay = this.data.MinutesPerDay || 60 * 8;
        return MinutesPerDay / 60;
    },

    _hasWorkResource: function (task) {
        var items = task.Assignments || [];
        for (var i = 0, l = items.length; i < l; i++) {
            var item = items[i];
            var re = this.getResource(item.ResourceUID);
            if (re.Type == 1) {
                return true;
            }
        }
        return false;
    },

    changeTaskForWindow: function (task, oldTask) {
        if (!this.enableTaskWorkWithDuration) {
            var work = this._Order.getTaskAssignmentsTotalWork(task);
            this.updateTask(task, 'Work', work);
            return;
        }

        var me = this;
        var project = this,
            hoursPerDay = this.getHoursPerDay();

        var calendar = this._getTaskCalendar(oldTask);

        function fixDuration(task, doFixTaskDuration) {
            var duration = task.Duration;
            var taskWork = 0;

            $.each(task.Assignments, function (i, item) {
                var re = project.getResource(item.ResourceUID);
                if (re.Type == 0) {
                } else if (re.Type == 1) {
                    item.Work = item.Units * hoursPerDay * duration;
                    item.Cost = item.Work * re.StandardRate;
                    taskWork += item.Work;
                    item.Duration = duration;
                }
            });

            task.Work = taskWork;

            if (
                me._hasWorkResource(task) &&
                me.enableResourceCalendar &&
                !task.IgnoreResourceCalendar &&
                doFixTaskDuration === true
            ) {
                me._setTaskWithWorkResourceDuration(task, duration);
                me._syncTaskWork(task);
            }
        }

        function fixWork(task, completeDuration) {
            var taskWork = task.Work;

            var allUnits = 0;
            $.each(task.Assignments, function (i, item) {
                var re = project.getResource(item.ResourceUID);
                if (re.Type == 0) {
                } else if (re.Type == 1) {
                    allUnits += item.Units;
                }
            });

            if (allUnits == 0) return;

            var duration = calendar._parseDuration(taskWork / (hoursPerDay * allUnits));

            if (completeDuration !== false) {
                task.Duration = duration;
            }

            $.each(task.Assignments, function (i, item) {
                var re = project.getResource(item.ResourceUID);
                if (re.Type == 0) {
                } else if (re.Type == 1) {
                    item.Work = (item.Units / allUnits) * taskWork;
                    item.Cost = item.Work * re.StandardRate;
                    item.Duration = duration;
                }
            });

            if (me._hasWorkResource(task) && me.enableResourceCalendar && !task.IgnoreResourceCalendar) {
                me._resetAssignmentsWorkWithFixDuration(task);
                me._syncTaskWork(task);
            }
        }

        if (!this._hasWorkResource(oldTask)) {
            if (task.Work == 0) {
                fixDuration(task);
            } else {
                fixWork(task);
            }
        } else if (!this._hasWorkResource(task)) {
            if (task.Type == 2) {
            } else {
                fixDuration(task);
            }
        } else if (oldTask.Duration != task.Duration && this._hasWorkResource(task)) {
            if (task.Type == 0) {
                fixDuration(task);
            } else if (task.Type == 1) {
                fixDuration(task);
            } else if (task.Type == 2) {
                fixWork(task, false);
            }
        } else if (this._hasWorkResource(task)) {
            if (task.Type == 0) {
                if (task.EffortDriven) {
                    fixWork(task);
                } else {
                    fixDuration(task);
                }
            } else if (task.Type == 1) {
                if (task.EffortDriven) {
                    fixWork(task, false);
                } else {
                    fixDuration(task, true);
                }
            } else if (task.Type == 2) {
                fixWork(task);
            }
        }
    },

    _setTaskWithWorkResourceDuration: function (task, duration) {
        var me = this;
        var hoursPerDay = this.getHoursPerDay();
        var taskCalendar = this._getTaskCalendar(task);

        var hash = {};
        $.each(task.Assignments, function (i, item) {
            var re = me.getResource(item.ResourceUID);
            if (re.Type == 1) {
                hash[item.ResourceUID] = item.Work;
                item.Duration = 0;
                item.Work = 0;
            }
        });

        var dayAdd = 1;
        if (me.enableHalfDay) {
            dayAdd = 0.5;
        }

        var date = new Date(task.Start?.getTime());
        while (true) {
            if (duration == 0) break;

            var flag = false;

            if (task.Type == 1) {
                if (taskCalendar._isWorkingDate(date)) {
                    flag = true;
                }
            }

            $.each(task.Assignments, function (i, item) {
                var re = me.getResource(item.ResourceUID);
                if (re.Type == 1) {
                    var calendar = me._getResourceCalendar(item.ResourceUID);
                    if (calendar._isWorkingDate(date)) {
                        flag = true;
                        item.Duration += dayAdd;
                        item.Work += item.Units * hoursPerDay * dayAdd;
                    }
                }
            });

            if (flag) {
                duration -= dayAdd;
            }

            date?.setHours(date?.getHours() + dayAdd * 24);
        }

        if (task.Type == 0) {
        } else if (task.Type == 1) {
        } else if (task.Type == 2) {
            $.each(task.Assignments, function (i, item) {
                var re = me.getResource(item.ResourceUID);
                if (re.Type == 1) {
                    var work = hash[item.ResourceUID];
                    if (item.Duration > 0 && work > 0) {
                        item.Work = work;
                    }
                }
            });
        }
    },

    _updateTaskDuration: function (task) {
        if (!this.enableTaskWorkWithDuration) return;

        var duration = task.Duration;
        var hoursPerDay = this.getHoursPerDay();

        var me = this;
        if (task.Assignments && task.Assignments.length > 0) {
            function fixDuration() {
                $.each(task.Assignments, function (i, item) {
                    var re = me.getResource(item.ResourceUID);
                    if (re.Type == 0) {
                    } else if (re.Type == 1) {
                        item.Work = item.Units * hoursPerDay * duration;
                        item.Cost = item.Work * re.StandardRate;
                    }
                });

                if (me._hasWorkResource(task) && me.enableResourceCalendar && !task.IgnoreResourceCalendar) {
                    me._setTaskWithWorkResourceDuration(task, duration);
                }
            }

            function fixWork() {
                $.each(task.Assignments, function (i, item) {
                    var re = me.getResource(item.ResourceUID);
                    if (re.Type == 0) {
                    } else if (re.Type == 1) {
                        if (duration == 0) item.Work = 0;
                    }
                });

                if (me._hasWorkResource(task) && me.enableResourceCalendar && !task.IgnoreResourceCalendar) {
                    me._setTaskWithWorkResourceDuration(task, duration);
                }
            }

            if (task.Type == 0) {
                fixDuration();
            } else if (task.Type == 1) {
                fixDuration();
            } else if (task.Type == 2) {
                fixWork();
            }
        } else {
        }

        this._syncTaskWork(task);
    },

    _changeSummaryTaskToNormalTask: function (tasks) {
        var me = this;
        function fn(task) {
            if (task.children && task.children.length > 0) {
            } else {
                if (me._Order.HasTaskAssignmentsWorkType(task)) {
                    task.Work = me._Order.getTaskAssignmentsTotalWork(task);
                } else {
                    task.Duration = 1;
                    task.Work = 0;
                }
            }
        }

        for (var i = 0, l = tasks.length; i < l; i++) {
            fn(tasks[i]);
        }
    },

    _resetAssignmentsWorkWithFixDuration: function (task) {
        var me = this;
        var taskWork = task.Work;

        function hasWorkDay(item) {
            var calendar = me._getResourceCalendar(item.ResourceUID);
            for (var date = task.Start; date < task.Finish; ) {
                if (calendar._isWorkingDate(date)) {
                    return true;
                }
                date = mini.addDate(date, 1, 'D');
            }
            return false;
        }

        var items = [];
        var allUnits = 0;
        $.each(task.Assignments, function (i, item) {
            var re = me.getResource(item.ResourceUID);
            if (re.Type == 1) {
                if (hasWorkDay(item)) {
                    allUnits += item.Units;
                    items.push(item);
                } else {
                    item.Work = 0;
                    item.Cost = 0;
                }
            }
        });

        $.each(items, function (i, item) {
            var re = me.getResource(item.ResourceUID);
            item.Work = (item.Units / allUnits) * taskWork;
            item.Cost = item.Work * re.StandardRate;
        });
    },

    _updateTaskWork: function (task) {
        var me = this;
        var calendar = this._getTaskCalendar(task);
        var taskWork = task.Work;
        var hoursPerDay = this.getHoursPerDay();

        function getAllUnits() {
            var allUnits = 0;

            $.each(task.Assignments, function (i, item) {
                var re = me.getResource(item.ResourceUID);
                if (re.Type == 0) {
                } else if (re.Type == 1) {
                    allUnits += item.Units;
                }
            });
            return allUnits;
        }

        if (!this.enableTaskWorkWithDuration) {
            var taskWork = task.Work;
            var allUnits = getAllUnits();
            $.each(task.Assignments, function (i, item) {
                var re = me.getResource(item.ResourceUID);
                if (re.Type == 0) {
                } else if (re.Type == 1) {
                    item.Work = (item.Units / allUnits) * taskWork;
                    item.Cost = item.Work * re.StandardRate;
                }
            });

            return;
        }

        if (task.Assignments && task.Assignments.length > 0) {
            var allUnits = getAllUnits();

            function fixWork() {
                var duration = calendar._parseDuration(taskWork / (hoursPerDay * allUnits));
                me.store.updateRecord(task, 'Duration', duration);
                $.each(task.Assignments, function (i, item) {
                    var re = me.getResource(item.ResourceUID);
                    if (re.Type == 0) {
                    } else if (re.Type == 1) {
                        item.Work = (item.Units / allUnits) * taskWork;
                        item.Cost = item.Work * re.StandardRate;
                        item.Duration = duration;
                    }
                });
            }

            function fixDuration() {
                if (task.Work == 0) task.Duration = 0;

                $.each(task.Assignments, function (i, item) {
                    var re = me.getResource(item.ResourceUID);
                    if (re.Type == 0) {
                    } else if (re.Type == 1) {
                        item.Work = (item.Units / allUnits) * taskWork;
                        item.Cost = item.Work * re.StandardRate;

                        if (task.Work == 0) item.Duration = 0;
                    }
                });

                if (me._hasWorkResource(task) && me.enableResourceCalendar && !task.IgnoreResourceCalendar) {
                    me._resetAssignmentsWorkWithFixDuration(task);
                }
            }

            if (task.Type == 0) {
                fixWork();
            } else if (task.Type == 1) {
                fixDuration();
            } else if (task.Type == 2) {
                fixWork();
            }
        } else {
        }
    },

    onSetAssignments: function (task) {
        if (this.enableTaskWorkWithDuration) {
            this._updateTaskWork(task);
        } else {
            var work = this._Order.getTaskAssignmentsTotalWork(task);

            this.store.updateRecord(task, 'Work', work);
        }
    },
    updateTask: function (task, field, value, config = {}) {
        this.lastScheduleDate = new Date();

        var task = this.getTask(task);
        if (!task || !field) return;
        if (typeof field == 'object') {
            this._updateTask(task, field);
            return;
        }

        var duration = task.Duration;
        var percentComplete = task.PercentComplete;

        var calendar = this._getTaskCalendar(task);

        if (task.Milestone && field == 'Finish') {
            field = 'Start';
        }

        var syncFlag = true;

        switch (field) {
            case 'Work':
                value = parseFloat(value);

                this.store.updateRecord(task, field, value);
                this._updateTaskWork(task);
                this.store.updateRecord(task, 'Milestone', task.Duration == 0 ? 1 : 0);
                this.orderProject();

                break;
            case 'Duration':
                var days = parseFloat(value);
                if (!mini.isNumber(days)) return;
                if (days < 0) days = 0;

                days = calendar._parseDuration(days);

                this.store.beginChange();
                this.store.updateRecord(task, 'Duration', days);
                if (mini.isDate(task.Start)) {
                    task.Start = calendar._getNextWorkingStart(task.Start);
                    // 去除根据开始时间和工期计算结束时间  根据接口返回值显示
                    // task.Finish = calendar._getFinish(task.Start, days);
                    // this.setTaskModified(task, 'Finish');
                }

                if (task.Duration == 0) {
                    task.Finish = mini.cloneDate(task.Start);
                }
                this.store.updateRecord(task, 'Milestone', task.Duration == 0 ? 1 : 0);

                if (this.enableActualState && task.ActualStart && task.ActualFinish) {
                    this.store.updateRecord(task, 'ActualFinish', mini.cloneDate(task.Finish));
                }

                this._updateTaskDuration(task);

                this.orderProject();

                this.store.endChange();
                break;
            case 'Start':
                this.store.beginChange();
                this.store.updateRecord(task, 'Start', value);
                if (mini.isDate(task.Start)) {
                    if (task.Manual) {
                        task.Start = calendar._parseStartDate(task.Start);
                    } else {
                        task.Start = calendar._getNextWorkingStart(task.Start);
                    }

                    var duration =
                        task.Start && task.Finish ? calendar._getDuration(task.Start, task.Finish) : task.Duration || 0;
                    
                    // 去除根据开始时间和工期计算结束时间  根据接口返回值显示    
                    // if (task.Manual && duration == task.Duration) {
                    // } else {
                    //     task.Finish = calendar._getFinish(task.Start, task.Duration);
                    //     this.setTaskModified(task, 'Finish');
                    // }

                    if (this.enableActualState && task.ActualStart) {
                    } else {
                        if (!task.Manual) {
                            var ct = parseInt(task.ConstraintType);
                            if (ct != 2 && ct != 3) {
                                task.ConstraintType = 4;
                                task.ConstraintDate = new Date(task.Start?.getTime());
                            }
                            if (ct == 2) {
                                task.ConstraintDate = new Date(task.Start?.getTime());
                            }
                        }
                    }
                }

                if (this.enableActualState) {
                    if (task.ActualStart) this.store.updateRecord(task, 'ActualStart', mini.cloneDate(task.Start));
                    if (task.ActualFinish) this.store.updateRecord(task, 'ActualFinish', mini.cloneDate(task.Finish));
                }

                if (task.Manual && task.Duration == 0) {
                    task.Finish = mini.cloneDate(task.Start);
                }

                this.orderProject();
                this.store.endChange();
                break;
            case 'Finish':
                if (task.ConstraintType == 3 && task.Start != null) {
                    break;
                }

                this.store.beginChange();
                if (mini.isDate(value)) {
                    if (value < task.Start) {
                        value = task.Start;
                    }

                    value = calendar._parseFinishDate(value);
                }

                this.store.updateRecord(task, 'Finish', value);

                if (mini.isDate(task.Finish)) {
                    if (task.Manual) {
                        task.Finish = calendar._parseFinishDate(task.Finish);
                    } else {
                        task.Finish = calendar._getPreviousWorkingFinish(task.Finish);
                    }

                    if (task.Start == null) {
                        task.Start = calendar._getStart(task.Finish, task.Duration);
                    } else {
                        var d = task.Duration;

                        task.Duration = calendar._getDuration(task.Start, task.Finish);

                        if (d != task.Duration) {
                            this.setTaskModified(task, 'Duration');
                        }
                    }
                }

                if (this.enableActualState) {
                    if (task.ActualStart) this.store.updateRecord(task, 'ActualStart', mini.cloneDate(task.Start));
                    if (task.ActualFinish) this.store.updateRecord(task, 'ActualFinish', mini.cloneDate(task.Finish));
                }

                this._updateTaskDuration(task);

                if (task.Manual && task.Duration == 0) {
                    task.Start = mini.cloneDate(task.Finish);
                }

                var sss = new Date();
                this.orderProject();

                this.store.endChange();

                break;
            case 'PercentComplete':
                value = parseFloat(value);
                if (!mini.isNumber(value)) return;
                if (value < 0) value = 0;
                if (value > 100) value = 100;

                this.store.beginChange();
                this.store.updateRecord(task, 'PercentComplete', value);

                var actualStart = task.ActualStart;

                if (this.enableActualState && task.Start) {
                    if (task.PercentComplete == 0) {
                        this.store.updateRecord(task, 'ActualStart', null);
                        this.store.updateRecord(task, 'ActualFinish', null);
                    } else {
                        if (!task.ActualStart) {
                            this.store.updateRecord(task, 'ActualStart', mini.cloneDate(task.Start));
                        }
                        if (task.PercentComplete == 100) {
                            this.store.updateRecord(task, 'ActualFinish', mini.cloneDate(task.Finish));
                        } else {
                            this.store.updateRecord(task, 'ActualFinish', null);
                        }
                    }
                }

                if (config.setParentComplete) this._PercentComplete.syncComplete(task);

                syncFlag = false;

                this.orderProject();

                this.store.endChange();
                break;
            case 'ConstraintDate':
            case 'ConstraintType':
                this.store.beginChange();
                this.store.updateRecord(task, field, value);
                if (task.ConstraintType == 0 || task.ConstraintType == 1) {
                    if (!this.keeyConstraint) {
                        task.ConstraintDate = null;
                    }
                }
                this.orderProject();
                this.store.endChange();
                break;
            case 'PredecessorLink':
                task._predecessorLinkChanged = true;

                this.setLinks(task, value);
                break;
            case 'Assignments':
                this.setAssignments(task, value);
                break;
            case 'Manual':
                this.store.beginChange();
                this.store.updateRecord(task, field, value);
                this.orderProject();
                this.store.endChange();
                break;
            case 'ActualStart':
                if (this.enableActualState && task.Start) {
                    this.store.beginChange();
                    this.store.updateRecord(task, 'ActualStart', value);
                    if (mini.isDate(task.ActualStart)) {
                        task.ActualStart = calendar._getNextWorkingStart(task.ActualStart);

                        if (task.PercentComplete == 100) {
                            task.ActualFinish = calendar._getFinish(task.ActualStart, task.Duration);
                            this.setTaskModified(task, 'ActualFinish');
                        }

                        this.store.updateRecord(task, 'Start', mini.cloneDate(task.ActualStart));
                        var finish = calendar._getFinish(task.Start, task.Duration);
                        this.store.updateRecord(task, 'Finish', finish);
                    } else {
                        this.store.updateRecord(task, 'PercentComplete', 0);
                        this.store.updateRecord(task, 'ActualFinish', null);
                    }
                    this.orderProject();
                    this.store.endChange();
                } else {
                    this.store.updateRecord(task, 'ActualStart', value);
                }
                break;
            case 'ActualFinish':
                if (this.enableActualState && task.Start) {
                    this.store.beginChange();

                    this.store.updateRecord(task, 'ActualFinish', value);
                    if (mini.isDate(task.ActualFinish)) {
                        task.ActualFinish = calendar._getPreviousWorkingFinish(task.ActualFinish);

                        if (task.ActualFinish <= task.Start) {
                            this.store.updateRecord(task, 'Duration', 0);
                            var actualStart = calendar._getNextWorkingStart(task.ActualFinish);
                            this.store.updateRecord(task, 'ActualStart', actualStart);
                            task.ActualFinish = mini.cloneDate(task.ActualStart);
                        } else {
                            if (!task.ActualStart) {
                                this.store.updateRecord(task, 'ActualStart', mini.cloneDate(task.Start));
                            }

                            var duration = calendar._getDuration(task.ActualStart, task.ActualFinish);
                            this.store.updateRecord(task, 'Duration', duration);
                        }

                        this.store.updateRecord(task, 'Milestone', task.Duration == 0 ? 1 : 0);

                        this.store.updateRecord(task, 'PercentComplete', 100);

                        this.store.updateRecord(task, 'Start', mini.cloneDate(task.ActualStart));
                        this.store.updateRecord(task, 'Finish', mini.cloneDate(task.ActualFinish));
                    } else {
                        if (task.PercentComplete == 100) {
                            this.store.updateRecord(task, 'PercentComplete', 99);
                        }
                    }
                    this.orderProject();
                    this.store.endChange();
                } else {
                    this.store.updateRecord(task, 'ActualFinish', value);
                }
                break;
            default:
                this.store.updateRecord(task, field, value);
                break;
        }

        if (syncFlag) {
            if (
                this.allowSyncComplete &&
                (duration != task.Duration || percentComplete != task.PercentComplete) &&
                task.Duration != 0
            ) {
                this._PercentComplete.syncComplete(task);
            }
        }

        this.fireEvent('taskupdated', { task: task, field: field, value: value });
    },
    _updateTask: function (task, newTask) {
        task = this.getTask(task);
        if (!task || !newTask) return;
        this.store.beginChange();

        this.beginOrder();

        var calendar = this._getTaskCalendar(task);

        var taskStart = task.Start;

        var Assignments = newTask.Assignments;
        var PredecessorLink = newTask.PredecessorLink;
        delete newTask.Assignments;
        delete newTask.PredecessorLink;

        var oldStart = task.Start,
            oldFinish = task.Finish,
            oldConstraintType = task.ConstraintType,
            oldConstraintDate = task.ConstraintDate;

        try {
            if (PredecessorLink) this.setLinks(task, PredecessorLink);
        } catch (ex) {
            this.endOrder();
            this.store.endChange();

            throw ex;
        }

        this.store.updateRecord(task, newTask);

        if (Assignments) this.setAssignments(task, Assignments);

        if (task.Start && task.Finish && task.Start > task.Finish) {
            task.Finish = task.Start;
        }
        // 计划开始时间、计划完成时间获取去除跳过非工作日
        if (task.Start) task.Start = task.Start; // calendar._getNextWorkingStart(task.Start);
        if (task.Finish) task.Finish = task.Finish; // calendar._getPreviousWorkingFinish(task.Finish);
        // if (task.Start && task.Duration) {
        //     task.Finish = calendar._getFinish(task.Start, task.Duration);
        // }

        this.store.updateRecord(task, 'Milestone', task.Duration == 0 ? 1 : 0);

        if (this.enableActualState && task.ActualStart) {
        } else {
            if (!task.Manual) {
                if (String(taskStart) != task.Start && task.Start) {
                    if (task.ConstraintType != 2 && task.ConstraintType != 3) {
                        task.ConstraintType = 4;
                        task.ConstraintDate = new Date(task.Start?.getTime());
                    }
                }
            }
        }

        if (task.ConstraintType == 0 || task.ConstraintType == 1) {
            task.ConstraintDate = null;
        }
        if (!task.ConstraintDate) task.ConstraintType = 0;

        if (task.PercentComplete < 0) task.PercentComplete = 0;
        if (task.PercentComplete > 100) task.PercentComplete = 100;
        if (this.allowSyncComplete && mini.isNumber(newTask.PercentComplete)) {
            this._PercentComplete.syncComplete(task);
        }

        if (oldStart != task.Start) {
            if (oldStart && task.Start && oldStart?.getTime() == task.Start?.getTime()) {
            } else {
                this.setTaskModified(task, 'Start');
            }
        }
        if (oldFinish != task.Finish) {
            if (oldFinish && task.Finish && oldFinish?.getTime() == task.Finish?.getTime()) {
            } else {
                this.setTaskModified(task, 'Finish');
            }
        }
        if (oldConstraintType != task.ConstraintType) {
            this.setTaskModified(task, 'ConstraintType');
        }
        if (oldConstraintDate != task.ConstraintDate) {
            this.setTaskModified(task, 'ConstraintDate');
        }

        if (this.enableActualState && task.Start) {
            this.store.updateRecord(task, 'ActualStart', mini.cloneDate(task.Start));
            this.store.updateRecord(task, 'ActualFinish', mini.cloneDate(task.Finish));

            if (task.PercentComplete == 0) {
                this.store.updateRecord(task, 'ActualStart', null);
                this.store.updateRecord(task, 'ActualFinish', null);
            } else {
                if (!task.ActualStart) {
                    this.store.updateRecord(task, 'ActualStart', mini.cloneDate(task.Start));
                }
                if (task.PercentComplete == 100) {
                    this.store.updateRecord(task, 'ActualFinish', mini.cloneDate(task.Finish));
                } else {
                    this.store.updateRecord(task, 'ActualFinish', null);
                }
            }
        }

        this.endOrder(task);
        this.store.endChange();

        this.fireEvent('taskupdated', { task: task, field: newTask });
    },
    updateTasks: function (tasks, newTask) {
        if (!mini.isArray(tasks) || typeof newTask != 'object') return;
        this.beginOrder();
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            task = this.getTask(task);
            var keyValue = mini.clone(newTask);
            this._updateTask(task, keyValue);
        }
        this.endOrder(tasks);
    }
});
mini.regClass(mini.Project, 'project');
MyProject = mini.Project;
PlusProject = mini.Project;

mini.Project.IDColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'ID',
            header: '',
            field: 'ID',
            width: 30,
            cellCls: 'mini-indexcolumn',
            align: 'center',
            allowDrag: true,
            cellStyle: 'cursor:move;'
        },
        optons
    );
};
mini.Project.NameColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Name',
            header: mini.Gantt.Name_Text,
            field: 'Name',
            width: 200,
            editor: {
                type: 'textbox'
            },
            renderer: function (e) {
                var value = mini.htmlEncode(e.value);
                if (e.record.Summary) {
                    return '<b>' + value + '</b>';
                }
                return value;
            }
        },
        optons
    );
};
mini.Project.PercentCompleteColumn = function (optons) {
    return $.extend(
        true,
        {
            name: 'PercentComplete',
            header: mini.Gantt.PercentComplete_Text,
            field: 'PercentComplete',
            width: 60,
            editor: {
                type: 'spinner',
                minValue: 0,
                maxValue: 100,
                decimalPlaces: 0
            }
        },
        optons
    );
};
mini.Project.PredecessorLinkColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'PredecessorLink',
            header: mini.Gantt.PredecessorLink_Text,
            field: 'PredecessorLink',
            editor: {
                type: 'textbox'
            },
            renderer: function (e) {
                var table = e.source,
                    project = table.owner;
                var links = e.value;
                return project.getLinkString(links);
            },
            oncellbeginedit: function (e) {
                var table = e.source,
                    project = table.owner;
                var links = e.value;
                e.value = project.getLinkString(links);
            }
        },
        optons
    );
};
mini.Project.DurationColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Duration',
            header: mini.Gantt.Duration_Text,
            field: 'Duration',
            width: 60,
            editor: {
                type: 'spinner',
                minValue: 0,
                maxValue: 10000,
                decimalPlaces: 1
            }
        },
        optons
    );
};
mini.Project.WorkColumn = function (optons) {
    return jQuery.extend(
        true,
        {
            name: 'Work',
            header: mini.Gantt.Work_Text,
            field: 'Work',
            width: 60,
            editor: {
                type: 'spinner',
                minValue: 0,
                maxValue: 1000000
            }
        },
        optons
    );
};

mini._toFixed = function (value, num) {
    if (value != parseInt(value)) {
        value = value.toFixed(num);
    }
    return value;
};

mini.Project.dateRenderer = function (e) {
    var d = e.value;
    if (d) {
        var project = e.source.owner;

        return mini.formatDate(d, project.enableHalfDay ? project.dateFormatHalfDay : project.dateFormat);
    } else {
        return '';
    }
};
mini.Project.BaselineStartColumn = function (options) {
    return mini.copyTo(
        {
            name: 'BaselineStart',
            header: '基线开始时间',
            field: 'BaselineStart',
            renderer: mini.Project.dateRenderer,

            renderer: function (e) {
                var project = e.source.owner;
                var task = e.record;
                var baselineList = task.Baseline || [];
                var baseline = baselineList[project.baselineIndex];
                if (this.baselineIndex != null) baseline = baselineList[this.baselineIndex];
                var d = baseline ? baseline.Start : null;
                if (d) {
                    return mini.formatDate(d, project.enableHalfDay ? project.dateFormatHalfDay : project.dateFormat);
                } else {
                    return '';
                }
            }
        },
        options
    );
};
mini.Project.BaselineFinishColumn = function (options) {
    return mini.copyTo(
        {
            name: 'BaselineFinish',
            header: '基线完成时间',
            field: 'BaselineFinish',
            renderer: mini.Project.dateRenderer,

            renderer: function (e) {
                var project = e.source.owner;
                var task = e.record;
                var baselineList = task.Baseline || [];
                var baseline = baselineList[project.baselineIndex];
                if (this.baselineIndex != null) baseline = baselineList[this.baselineIndex];
                var d = baseline ? baseline.Finish : null;
                if (d) {
                    return mini.formatDate(d, project.enableHalfDay ? project.dateFormatHalfDay : project.dateFormat);
                } else {
                    return '';
                }
            }
        },
        options
    );
};

mini.Project.StartColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Start',
            header: mini.Gantt.Start_Text,
            field: 'Start',
            renderer: mini.Project.dateRenderer,

            editor: {
                type: 'datepicker'
            }
        },
        optons
    );
};
mini.Project.FinishColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Finish',
            header: mini.Gantt.Finish_Text,
            field: 'Finish',
            renderer: mini.Project.dateRenderer,

            editor: {
                type: 'datepicker'
            }
        },
        optons
    );
};
mini.Project.PriorityColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Priority',
            header: mini.Gantt.Priority_Text,
            field: 'Priority',
            width: 60,
            editor: {
                type: 'spinner',
                minValue: 0,
                maxValue: 1000
            }
        },
        optons
    );
};
mini.Project.WeightColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Weight',
            header: mini.Gantt.Weight_Text,
            field: 'Weight',
            width: 60,
            editor: {
                type: 'spinner',
                minValue: 0,
                maxValue: 100
            }
        },
        optons
    );
};
mini.Project.OutlineNumberColumn = function (optons) {
    return mini.copyTo(
        {
            header: mini.Gantt.OutlineNumber_Text,
            field: 'OutlineNumber',
            width: 150
        },
        optons
    );
};
mini.Project.OutlineLevelColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'OutlineLevel',
            header: mini.Gantt.OutlineLevel_Text,
            field: 'OutlineLevel',
            width: 80
        },
        optons
    );
};

mini.Project.ActualStartColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'ActualStart',
            header: mini.Gantt.ActualStart_Text,
            field: 'ActualStart',
            renderer: mini.Project.dateRenderer,

            editor: {
                type: 'datepicker'
            }
        },
        optons
    );
};
mini.Project.ActualFinishColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'ActualFinish',
            header: mini.Gantt.ActualFinish_Text,
            field: 'ActualFinish',
            renderer: mini.Project.dateRenderer,

            editor: {
                type: 'datepicker'
            }
        },
        optons
    );
};

mini.Project.DeadlineColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Deadline',
            header: mini.Gantt.Deadline_Text,
            field: 'Deadline',
            renderer: mini.Project.dateRenderer,

            editor: { type: 'datepicker' }
        },
        optons
    );
};

mini.Project.EarlyStartColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'EarlyStart',
            header: mini.Gantt.EarlyStart_Text,
            field: 'EarlyStart',
            renderer: mini.Project.dateRenderer,
            readOnly: true,
            editor: { type: 'datepicker' }
        },
        optons
    );
};
mini.Project.EarlyFinishColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'EarlyFinish',
            header: mini.Gantt.EarlyFinish_Text,
            field: 'EarlyFinish',
            renderer: mini.Project.dateRenderer,
            readOnly: true,
            editor: { type: 'datepicker' }
        },
        optons
    );
};
mini.Project.LateStartColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'LateStart',
            header: mini.Gantt.LateStart_Text,
            field: 'LateStart',
            renderer: mini.Project.dateRenderer,
            readOnly: true,
            editor: { type: 'datepicker' }
        },
        optons
    );
};
mini.Project.LateFinishColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'LateFinish',
            header: mini.Gantt.LateFinish_Text,
            field: 'LateFinish',
            renderer: mini.Project.dateRenderer,
            readOnly: true,
            editor: { type: 'datepicker' }
        },
        optons
    );
};

mini.Project.WBSColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'WBS',
            header: mini.Gantt.WBS_Text,
            field: 'WBS',
            width: 150,
            editor: {
                type: 'textbox'
            }
        },
        optons
    );
};

mini.Project.ManualColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Manual',
            header: mini.Gantt.Manual_Text,
            field: 'Manual',
            width: 60,
            editor: {
                type: 'combobox',
                valueField: 'ID',
                displayField: 'Name',
                data: mini.Array.clone(mini.Gantt.Manual)
            },
            renderer: function (e) {
                var table = e.source,
                    project = table.owner;
                var ct = mini.Gantt.Manual[e.value];

                var cls = 'mini-gantt-icon-' + (e.value ? 'manual' : 'automatic');
                return '<div class="' + cls + '"></div>';
            }
        },
        optons
    );
};

mini.Project.ConstraintTypeColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'ConstraintType',
            header: mini.Gantt.ConstraintType_Text,
            field: 'ConstraintType',
            width: 120,
            editor: {
                type: 'combobox',
                valueField: 'ID',
                displayField: 'Name',
                data: mini.Array.clone(mini.Gantt.ConstraintType)
            },
            renderer: function (e) {
                var table = e.source,
                    project = table.owner;
                var ct = mini.Gantt.ConstraintType[e.value];
                return ct ? ct.Name : '';
            }
        },
        optons
    );
};
mini.Project.ConstraintDateColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'ConstraintDate',
            header: mini.Gantt.ConstraintDate_Text,
            field: 'ConstraintDate',
            renderer: function (e) {
                var d = e.value;
                if (d) {
                    return d?.getFullYear() + '-' + (d?.getMonth() + 1) + '-' + d?.getDate();
                } else {
                    return '';
                }
            },
            editor: {
                type: 'datepicker'
            }
        },
        optons
    );
};

mini.Project.fn.getDepartmentName = function (value) {
    return mini._getTextByValue(value, this.data.Departments, 'UID', 'Name');
};

mini.Project.DepartmentColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Department',
            header: mini.Gantt.Department_Text,
            field: 'Department',
            width: 120,
            editor: {
                type: 'combobox',
                valueField: 'UID',
                displayField: 'Name'
            },
            renderer: function (e) {
                var table = e.source,
                    project = table.owner;
                return project.getDepartmentName(e.value);
            },
            oncellbeginedit: function (e) {
                var table = e.source,
                    project = table.owner;
                var data = project.data.Departments || [];
                e.editor.load(data);
            }
        },
        optons
    );
};

mini.Project.fn.getPrincipalName = function (value) {
    return mini._getTextByValue(value, this.data.Principals, 'UID', 'Name');
};

mini.Project.PrincipalColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Principal',
            header: mini.Gantt.Principal_Text,
            field: 'Principal',
            width: 150,
            editor: {
                type: 'combobox',
                valueField: 'UID',
                displayField: 'Name',
                multiSelect: true,
                showCheckIcon: true
            },
            renderer: function (e) {
                var table = e.source,
                    project = table.owner;
                return project.getPrincipalName(e.value);
            },
            oncellbeginedit: function (e) {
                var table = e.source,
                    project = table.owner;
                var data = project.data.Principals || [];
                e.editor.load(data);
            }
        },
        optons
    );
};

mini.Project.fn.getAssignmentsName = function (value) {
    var texts = [];
    var Assignments = value;
    if (Assignments) {
        for (var i = 0, l = Assignments.length; i < l; i++) {
            var as = Assignments[i];
            var value = as.ResourceUID;
            var re = this.getResource(value);
            if (re) {
                var name = re.Name;
                if (re.Type == 1) {
                    if (as.Units != 1) name += '[' + as.Units * 100 + '%]';
                } else if (re.Type == 0) {
                    if (as.Work > 0) name += '[' + as.Work + ']';
                } else {
                    if (as.Cost > 0) name += '[￥' + as.Cost + ']';
                }
                texts.push(name);
            }
        }
    }
    return texts.join(',');
};

mini.Project.AssignmentsColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Assignments',
            header: mini.Gantt.Assignments_Text,
            field: 'Assignments',
            width: 150,

            editor: {
                type: 'combobox',
                valueField: 'UID',
                displayField: 'Name',
                multiSelect: true,
                showCheckIcon: true
            },
            renderer: function (e) {
                var table = e.source,
                    project = table.owner;
                return project.getAssignmentsName(e.value);
            },
            oncellbeginedit: function (e) {
                var table = e.source,
                    project = table.owner,
                    task = e.record;

                var data = project.data.Resources;
                e.editor.load(data);

                var list = task.Assignments || [];
                var value = [];
                for (var i = 0, l = list.length; i < l; i++) {
                    var item = list[i];
                    value.push(item.ResourceUID);
                }
                e.value = value.join(',');
            },
            oncellcommitedit: function (e) {
                var table = e.source,
                    project = table.owner,
                    task = e.record;

                function getAssignment(ResourceUID) {
                    var list = task.Assignments || [];
                    for (var i = 0, l = list.length; i < l; i++) {
                        var item = list[i];
                        if (item.ResourceUID == ResourceUID) return item;
                    }
                }

                var duration = task.Duration;
                var resources = e.editor.getSelecteds();
                var assignments = [];

                for (var i = 0, l = resources.length; i < l; i++) {
                    var res = resources[i];
                    var ass = { ResourceUID: res.UID, Units: 1, Cost: 0, Work: duration * 8 };

                    var preItem = getAssignment(res.UID);
                    if (preItem) {
                        ass.Units = preItem.Units;
                        ass.Work = preItem.Work;
                        ass.Cost = preItem.Cost;
                    }

                    assignments.push(ass);
                }

                e.value = assignments;
            }
        },
        optons
    );
};

mini._getTextByValue = function (value, data, idField, textField) {
    var data = data || [];
    if (value == null) value = '';
    var values = mini.isArray(value) ? value : String(value).split(',');
    var texts = [];
    for (var i = 0, l = values.length; i < l; i++) {
        var value = values[i];
        for (var j = 0, k = data.length; j < k; j++) {
            var record = data[j];
            if (String(record[idField]) == String(value)) {
                texts.push(record[textField]);
                break;
            }
        }
    }
    return texts.join(',');
};

mini.Project.TaskStatus = [
    { id: 1, name: '未启动' },
    { id: 2, name: '进行中' },
    { id: 3, name: '暂停中' },
    { id: 4, name: '已完成' }
];

mini.Project.fn.getTaskStatusName = function (value) {
    return mini._getTextByValue(value, PlusProject.TaskStatus, 'id', 'name');
};

mini.Project.TaskStatusColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'TaskStatus',
            header: mini.Gantt.TaskStatus_Text,
            type: 'comboboxcolumn',
            field: 'TaskStatus',
            width: 100,
            editor: {
                type: 'combobox',
                valueField: 'id',
                displayField: 'name',
                data: PlusProject.TaskStatus
            }
        },
        optons
    );
};

mini.Project.Critical2Column = function (optons) {
    return mini.copyTo(
        {
            name: 'Critical2',

            header: mini.Gantt.ManualCritical_Text,
            field: 'Critical2',
            width: 60,
            type: 'checkboxcolumn',
            trueValue: 1,
            falseValue: 0
        },
        optons
    );
};

mini.Project.CriticalColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'Critical',
            header: mini.Gantt.Critical_Text,
            field: 'Critical',
            width: 60,
            type: 'checkboxcolumn',
            trueValue: 1,
            falseValue: 0,
            readOnly: true
        },
        optons
    );
};

mini.Project.TotalSlackColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'TotalSlack',
            header: mini.Gantt.TotalSlack_Text,
            field: 'TotalSlack',
            width: 100,
            readOnly: true
        },
        optons
    );
};

mini.Project.TaskType = [
    { id: 0, name: '固定单位' },
    { id: 1, name: '固定工期' },
    { id: 2, name: '固定工时' }
];

mini.Project.fn.getTaskTypeName = function (value) {
    return mini._getTextByValue(value, PlusProject.TaskType, 'id', 'name');
};

mini.Project.TaskTypeColumn = function (optons) {
    return mini.copyTo(
        {
            name: 'TaskType',
            header: mini.Gantt.TaskType_Text,
            type: 'comboboxcolumn',
            field: 'Type',
            width: 100,
            editor: {
                type: 'combobox',
                valueField: 'id',
                displayField: 'name',
                data: PlusProject.TaskType
            }
        },
        optons
    );
};

MyProjectSchedule.Order = mini.Base.extend({
    constructor: function (project) {
        this.project = project;
    },
    Tasks: [],

    addDate: function (date, dayAdd) {
        return new Date(
            date?.getFullYear(),
            date?.getMonth(),
            date?.getDate(),
            date?.getHours() + dayAdd,
            date?.getMinutes(),
            date?.getSeconds()
        );
    },
    createSuccessorTasks: function () {
        var tasks = this.Tasks;
        if (tasks == null) return;
        for (var i = 0, l = tasks.length; i < l; i++) {
            var t = tasks[i];
            t._successorTasks = [];

            t['Conflict'] = 0;

            this._workResourceHash[t.UID] = this.project._hasWorkResource(t);
        }
        for (var i = 0, l = tasks.length; i < l; i++) {
            var t = tasks[i];
            var lks = t.PredecessorLink;
            if (lks != null && lks.length > 0) {
                for (var j = 0, k = lks.length; j < k; j++) {
                    var lk = lks[j];
                    var task = this.project.getTask(lk.PredecessorUID);
                    if (task != null) {
                        task._successorTasks.push(t);
                    }
                }
            }
        }
    },
    clearSuccessorTasks: function () {
        var tasks = this.Tasks;
        for (var i = 0, l = tasks.length; i < l; i++) {
            var t = tasks[i];
            delete t._successorTasks;
        }
    },

    getLinkedTasks: function (tasks) {},

    orderByStart: function () {
        var project = this.project;

        var sss = new Date();
        this._TaskUIDs = project._TaskUIDs;

        this.nodesField = project.store.nodesField;
        this.Tasks = project.getTaskList();
        this.StartDate = project.data.DataDate || project.getStartDate();
        this.FinishDate = project.getFinishDate();
        this.enableZeroDuration = project.enableZeroDuration;
        var tasks = this.Tasks;

        var forTasks = (this.forTasks = {});
        this.ancestorTasks = {};
        this.limitDates = {};
        this._workResourceHash = {};

        var olds = {};
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            if (!mini.isDate(task.Start)) task.Start = null;
            if (!mini.isDate(task.Finish)) task.Finish = null;

            olds[task.UID] = {
                Start: task.Start,
                Finish: task.Finish,
                Duration: task.Duration,
                Work: task.Work,
                Summary: task.Summary
            };

            forTasks[task.UID] = 1;

            delete task._summaryStart;
            delete task._summaryFinish;

            var ps = this.project.getAncestorTasks(task);
            ps.reverse();
            this.ancestorTasks[task.UID] = ps;
        }

        this.createSuccessorTasks();

        this.createAllPredecessorLinks(tasks);

        this.orderCount = 0;

        this._orderedTasks = {};

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            if (!this._orderedTasks[task.UID]) {
                this.orderTaskByStart(task);
            }
        }

        var root = project.store.root;
        root.Name = project.data.Name;
        root.ID = 0;
        root.Summary = true;
        this.doSummary(root);

        this.clearSuccessorTasks();

        this.allPredecessorLinks = null;

        this.limitDates = {};

        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            var old = olds[task.UID];
            var _Start = old.Start,
                _Finish = old.Finish,
                _Duration = old.Duration,
                _Work = old.Work,
                _Summary = old.Summary;

            if (
                (!_Start && task.Start) ||
                (_Start && !task.Start) ||
                (_Start && task.Start && _Start?.getTime() != task.Start?.getTime())
            ) {
                this.project.setTaskModified(task, 'Start');
            }
            if (
                (!_Finish && task.Finish) ||
                (_Finish && !task.Finish) ||
                (_Finish && task.Finish && _Finish?.getTime() != task.Finish?.getTime())
            ) {
                this.project.setTaskModified(task, 'Finish');
            }

            if (_Duration != task.Duration) {
                this.project.setTaskModified(task, 'Duration');
            }
            if (_Work != task.Work) {
                this.project.setTaskModified(task, 'Work');
            }
            if (_Summary != task.Summary) {
                this.project.setTaskModified(task, 'Summary');
            }
        }
    },

    HasTaskAssignmentsWorkType: function (task) {
        var list = task.Assignments || [];
        for (var i = list.length - 1; i >= 0; i--) {
            var item = list[i];
            var re = this.project.getResource(item.ResourceUID);
            if (re.Type == 1) {
                return true;
            }
        }
        return false;
    },
    getTaskAssignmentsTotalWork: function (task) {
        var work = 0;
        var list = task.Assignments || [];
        for (var i = list.length - 1; i >= 0; i--) {
            var item = list[i];
            var re = this.project.getResource(item.ResourceUID);
            if (re.Type == 1) {
                work += item.Work;
            }
        }
        return work;
    },
    doSummary: function (task) {
        if (this.isFixedTask(task)) return;

        var nodes = task[this.nodesField];
        if (!nodes || nodes.length == 0) return;

        var me = this;
        var calendar = this.project._getTaskCalendar(task);

        function getStartEnd(nodes) {
            var summaryStart = null,
                summaryFinish = null,
                work = 0;

            var HasActualStart = false;

            for (var i = 0, l = nodes.length; i < l; i++) {
                var task = nodes[i];

                if (task.Start != null && task.Finish != null) {
                    var start = task._summaryStart || task.Start;
                    var finish = task._summaryFinish || task.Finish;
                    if (summaryStart == null || summaryStart?.getTime() > start?.getTime()) {
                        summaryStart = mini.cloneDate(start);
                    }
                    if (summaryFinish == null || summaryFinish?.getTime() < finish?.getTime()) {
                        summaryFinish = mini.cloneDate(finish);
                    }
                }

                var taskWork = parseFloat(task.Work);
                if (!isNaN(taskWork)) {
                    work += taskWork;
                }

                if (task.ActualStart) HasActualStart = true;
            }
            return {
                Start: summaryStart,
                Finish: summaryFinish,
                Work: work,
                HasActualStart: HasActualStart
            };
        }

        var isManual = task.Manual == 1 && this.project.enableManualSchedule;

        var returns = getStartEnd(nodes);
        var newStart = returns.Start,
            newFinish = returns.Finish;
        var oldStart = task.Start,
            oldFinish = task.Finish;

        task._summaryStart = null;
        task._summaryFinish = null;

        if (newStart && newFinish) {
            task.Work = returns.Work + this.getTaskAssignmentsTotalWork(task);

            if (isManual) {
            } else {
                task.Start = newStart;
                task.Finish = newFinish;
            }

            task._summaryStart = newStart;
            task._summaryFinish = newFinish;

            if (
                !oldStart ||
                !oldFinish ||
                oldStart?.getTime() != newStart.getTime ||
                oldFinish?.getTime() != newFinish.getTime
            ) {
                task.Duration = calendar._getDuration(task.Start, task.Finish);
            }
        }

        if (this.project.enableActualState) {
            if (returns.HasActualStart) {
                task.ActualStart = mini.cloneDate(task.Start);
            } else {
                task.ActualStart = null;
            }
            if (task.PercentComplete == 100) {
                task.ActualFinish = mini.cloneDate(task.Finish);
            } else {
                task.ActualFinish = null;
            }
        }

        task.Milestone = task.Duration == 0 ? 1 : 0;
    },

    isFixedTask: function (task) {
        return !!task.Summary && !!task.FixedDate;
    },
    isSummaryTask: function (task) {
        return !!task.Summary;
    },
    getParentTask: function (task) {
        var parentTask = this.project.getParentTask(task.UID);
        if (parentTask && parentTask.UID != this.project.rootTaskUID) {
            return parentTask;
        }
        return null;
    },

    count: 0,

    orderPredecessorLinks: function (task) {
        var me = this,
            links = me.getAllPredecessorLinks(task);

        if (links == null || links.length == 0) return;

        for (var i = 0, l = links.length; i < l; i++) {
            var link = links[i];
            var ptask = me._TaskUIDs[link.PredecessorUID];
            if (ptask && !me._orderedTasks[ptask.UID]) {
                me.orderTaskByStart(ptask);
            }
        }
    },

    _getStartDate: function (task) {
        var date = this.StartDate;
        while (task) {
            var parentTask = this.project.getParentTask(task);
            if (!parentTask) break;
            if (parentTask.Manual && parentTask.Start && parentTask.Start > date) {
                date = parentTask.Start;
            }
            task = parentTask;
        }
        return date;
    },

    _getTaskStartDate: function (task) {
        var date = this._getStartDate(task);
        var calendar = this.project._getTaskCalendar(task);
        date = calendar._getNextWorkingStart(date);
        return date;
    },

    _hasWorkResource: function (task) {
        return this._workResourceHash[task.UID];
    },

    _getAssignmentStartDate: function (task, item) {
        var date = this._getStartDate(task);
        var calendar = this.project._getResourceCalendar(item.ResourceUID);
        date = calendar._getNextWorkingStart(date);
        return date;
    },

    getLastStartDateByPredecessorLinkForAssignment: function (task, item) {
        return this.getLastStartDateByPredecessorLink(task, item);
    },

    limitAssignmentByStart: function (task, item) {
        this.limitTaskByStart(task, false, false, item);
    },

    orderWorkResourceAssignment: function (task, item) {
        if (mini.isNull(item.Duration)) throw new Error('');

        var project = this.project;
        var calendar = project._getResourceCalendar(item.ResourceUID);
        var isZERO = project.enableZeroDuration && task.Milestone;
        var start = this._getAssignmentStartDate(task, item);

        var PredecessorLink = this.getAllPredecessorLinks(task);
        var hasPredecessorLink = PredecessorLink != null && PredecessorLink.length > 0;

        if (hasPredecessorLink) {
            var lastStart = this.getLastStartDateByPredecessorLinkForAssignment(task, item);

            if (lastStart != null) {
                if (project.data.DataDate && project.data.DataDate > lastStart) {
                } else {
                    start = lastStart;
                }
            }
        }

        if (!item.Start || start?.getTime() != item.Start?.getTime()) {
            if (isZERO) {
                item.Start = mini.cloneDate(start);
                item.Finish = mini.cloneDate(start);
            } else {
                item.Start = calendar._getNextWorkingStart(start);
                item.Finish = calendar._getFinish(item.Start, item.Duration);
            }
        }

        this.limitAssignmentByStart(task, item);
    },

    orderTaskByWorkResource: function (task) {
        if (task.Manual || task.Summary) throw new Error('');

        var taskStart, taskFinish;
        for (var i = 0, l = task.Assignments.length; i < l; i++) {
            var item = task.Assignments[i];

            this.orderWorkResourceAssignment(task, item);

            if (item.Work == 0 && task.Work > 0) continue;

            if (!taskStart || item.Start < taskStart) {
                taskStart = item.Start;
            }

            if (!taskFinish || item.Finish > taskFinish) {
                taskFinish = item.Finish;
            }
        }

        if (task.Duration == 0) taskFinish = taskStart;

        task.Start = taskStart;
        task.Finish = taskFinish;

        this._syncTaskDurationByWorkResources(task);
    },

    _syncTaskDurationByWorkResources: function (task) {
        var project = this.project;

        if (task.Type == 1) {
            var taskCalendar = this.project._getTaskCalendar(task);
            task.Duration = taskCalendar._getDuration(task.Start, task.Finish);
            return;
        }

        var items = task.Assignments;
        if (items.length == 1) {
            task.Duration = items[0].Duration;
            return;
        }

        var duration = 0;

        var dayAdd = 1;
        if (project.enableHalfDay) {
            dayAdd = 0.5;
        }

        var date = new Date(task.Start?.getTime());
        var finishTime = task.Finish?.getTime();
        while (true) {
            var flag = false;
            for (var i = 0, l = items.length; i < l; i++) {
                var item = items[i];
                var re = project.getResource(item.ResourceUID);
                if (re.Type == 1 && item.Start <= date && date < item.Finish) {
                    var calendar = project._getResourceCalendar(item.ResourceUID);
                    if (calendar._isWorkingDate(date)) {
                        flag = true;
                        break;
                    }
                }
            }

            if (flag) {
                duration += dayAdd;
            }

            date?.setHours(date?.getHours() + dayAdd * 24);

            if (date?.getTime() >= finishTime) break;
        }

        task.Duration = duration;
    },

    _useResourceCalendar: function (task) {
        return (
            this._hasWorkResource(task) &&
            !task.IgnoreResourceCalendar &&
            this.project.enableResourceCalendar &&
            !task.Milestone
        );
    },

    orderTaskByStart: function (task) {
        if (this._orderedTasks[task.UID]) return;

        this._orderedTasks[task.UID] = task;

        var project = this.project;
        var calendar = project._getTaskCalendar(task);

        var start = this._getTaskStartDate(task),
            isSummary = this.isSummaryTask(task),
            oldStart = task.Start,
            oldFinish = task.Finish;

        var isManual = task.Manual == 1 && project.enableManualSchedule;

        var isZERO = project.enableZeroDuration && task.Milestone;

        this.orderPredecessorLinks(task);

        if (!isManual) {
            var ConstraintDate = task.ConstraintDate;
            if (ConstraintDate) {
                var ConstraintType = parseInt(task.ConstraintType);
                if (ConstraintType == 4) {
                    start = calendar._getNextWorkingStart(ConstraintDate);
                } else if (ConstraintType == 6) {
                    var finish = calendar._getNextWorkingStart(ConstraintDate);
                    finish = new Date(finish?.getFullYear(), finish?.getMonth(), finish?.getDate(), 23, 59, 59);
                    start = calendar._getStart(finish, task.Duration);
                }
            }
        }

        if (!isManual) {
            if (
                (project.enableCompleteLogic && task.PercentComplete == 100) ||
                project.isSyncComputeTask(task) === false
            ) {
                if (task.PercentComplete != 100) {
                    if (isZERO) {
                    } else {
                        task.Finish = calendar._getFinish(task.Start, task.Duration);
                    }
                }
            } else {
                if (!isSummary) {
                    if (this._useResourceCalendar(task)) {
                        this.orderTaskByWorkResource(task);
                    } else {
                        var PredecessorLink = this.getAllPredecessorLinks(task);
                        var hasPredecessorLink = PredecessorLink != null && PredecessorLink.length > 0;

                        if (hasPredecessorLink) {
                            var lastStart = this.getLastStartDateByPredecessorLink(task);

                            if (lastStart != null) {
                                if (project.data.DataDate && project.data.DataDate > lastStart) {
                                } else {
                                    start = lastStart;
                                }
                            }
                        }

                        if (!task.Start || start?.getTime() != task.Start?.getTime()) {
                            if (this.isFixedTask(task)) {
                            } else {
                                if (isZERO) {
                                    task.Start = mini.cloneDate(start);
                                    task.Finish = mini.cloneDate(start);
                                } else {
                                    task.Start = calendar._getNextWorkingStart(start);
                                    task.Finish = calendar._getFinish(task.Start, task.Duration);
                                }
                            }
                        }

                        this.limitTaskByStart(task);
                    }
                } else {
                    if (this.isFixedTask(task)) {
                        this.limitTaskByStart(task);
                    }
                }
            }
        } else {
            this.limitTaskByStart(task, true);
        }

        delete task._predecessorLinkChanged;

        if (isSummary) {
            this.syncChildrenTasksByStart(task);
        }

        if (isSummary) {
            this.doSummary(task);
        }
    },

    syncChildrenTasksByStart: function (task) {
        var children = task[this.nodesField];
        if (children == null || children.length == 0) return;

        var isChildrenUp = false;
        for (var i = 0, l = children.length; i < l; i++) {
            var t = children[i];
            if (this._orderedTasks[t.UID + 'toParent']) {
                isChildrenUp = true;
                break;
            }
        }
        if (isChildrenUp) return;

        this._orderedTasks[task.UID + 'toChildren'] = true;
        for (var i = 0, l = children.length; i < l; i++) {
            var t = children[i];

            this.orderTaskByStart(t);
        }
        delete this._orderedTasks[task.UID + 'toChildren'];
    },

    syncSuccessorTasks: function (task) {
        var stasks = task._successorTasks;
        if (!stasks || stasks.length == 0) return;
        for (var i = stasks.length - 1; i >= 0; i--) {
            var t = stasks[i];
            this.orderTaskByStart(t);
        }
    },

    getAllPredecessorLinks: function (task) {
        return this.allPredecessorLinks[task.UID];
    },

    createAllPredecessorLinks: function (tasks) {
        var me = this,
            all = (this.allPredecessorLinks = {});

        function eachChildren(children) {
            for (var i = 0, l = children.length; i < l; i++) {
                var task = children[i];

                me.createTaskAllPredecessorLinks(task);

                if (task.children) {
                    eachChildren(task.children);
                }
            }
        }

        eachChildren(tasks);
    },

    createTaskAllPredecessorLinks: function (task) {
        var links = mini.Array.clone(task.PredecessorLink || []);
        var ps = this.ancestorTasks[task.UID];
        for (var i = 0, l = ps.length; i < l; i++) {
            var t = ps[i];
            var isManual = t.Manual == 1 && this.project.enableManualSchedule;
            if (this.isFixedTask(t) == false && t.PredecessorLink && !isManual) {
                mini.Array.addRange(links, t.PredecessorLink);
            }
        }
        this.allPredecessorLinks[task.UID] = links;
    },

    getLastStartDateByPredecessorLink: function (task, _assignment) {
        var taskStart = null;
        var PredecessorLink = this.getAllPredecessorLinks(task);
        if (PredecessorLink == null || PredecessorLink.length == 0) return taskStart;

        var calendar = this.project._getTaskCalendar(task);
        var taskDays = task.Duration;
        var isZERO = this.enableZeroDuration && task.Milestone;

        if (_assignment) {
            calendar = this.project._getResourceCalendar(_assignment.ResourceUID);
            taskDays = _assignment.Duration;
        }

        for (var i = 0, l = PredecessorLink.length; i < l; i++) {
            var link = PredecessorLink[i];
            var ptask = this._TaskUIDs[link.PredecessorUID];
            if (ptask == null) continue;

            var start = ptask.Start;
            var finish = ptask.Finish;
            var duration = ptask.Duration;

            if (!start || !finish) continue;

            if (isZERO) {
                switch (link.Type) {
                    case 0:
                        start = new Date(finish?.getTime());
                        break;
                    case 1:
                        start = new Date(finish?.getTime());
                        break;
                    case 2:
                        start = new Date(start?.getTime());
                        break;
                    case 3:
                        start = new Date(start?.getTime());
                        break;
                }
            } else {
                switch (link.Type) {
                    case 0:
                        start = calendar._getStart(finish, taskDays);
                        break;
                    case 1:
                        start = calendar._getNextWorkingStart(this.addDate(finish, 1));
                        break;
                    case 2:
                        finish = calendar._getPreviousWorkingFinish(this.addDate(start, -1));
                        start = calendar._getStart(finish, taskDays);
                        break;
                    case 3:
                        start = start;
                        break;
                }
            }

            var linkLag = link.LinkLag || 0;
            if (linkLag != 0) {
                start = calendar._getWorkingStartDate(start, linkLag);
            }

            if (taskStart == null || taskStart?.getTime() < start?.getTime()) {
                taskStart = start;
            }
        }
        return taskStart;
    },

    limitTaskByStart: function (task, onlyFixedDate, useLateDate, _assignment) {
        if (!_assignment) {
            if (task.Start == null || task.Finish == null) return;
        }

        var startField = 'Start',
            finishField = 'Finish';
        if (useLateDate) (startField = 'LateStart'), (finishField = 'LateFinish');

        var calendar = this.project._getTaskCalendar(task);

        var start = task[startField],
            finish = task[finishField];
        var duration = task.Duration;

        if (_assignment) {
            calendar = this.project._getResourceCalendar(_assignment.ResourceUID);
            start = _assignment[startField];
            finish = _assignment[finishField];
            duration = _assignment.Duration;
        }

        if (!onlyFixedDate) {
            if (!this.isSummaryTask(task)) {
                var ConstraintDate = task.ConstraintDate;

                var ConstraintType = parseInt(task.ConstraintType);
                if (ConstraintType != 0 && ConstraintType != 1 && ConstraintDate == null) {
                } else {
                    switch (ConstraintType) {
                        case 0:
                            break;
                        case 1:
                            break;
                        case 2:
                            start = calendar._getNextWorkingStart(ConstraintDate);
                            break;
                        case 3:
                            finish = calendar._getPreviousWorkingFinish(ConstraintDate);
                            start = calendar._getStart(finish, duration);
                            break;
                        case 4:
                            if (start?.getTime() < ConstraintDate?.getTime()) {
                                start = calendar._getNextWorkingStart(ConstraintDate);
                            }
                            break;
                        case 5:
                            if (start?.getTime() > ConstraintDate?.getTime()) {
                                start = calendar._getPreviousWorkingFinish(ConstraintDate);
                                start = mini.clearTime(start);
                            }
                            break;
                        case 6:
                            var date = mini.clearTime(finish);
                            if (date?.getTime() < ConstraintDate?.getTime()) {
                                finish = calendar._getNextWorkingStart(ConstraintDate);
                                finish = new Date(
                                    finish?.getFullYear(),
                                    finish?.getMonth(),
                                    finish?.getDate(),
                                    23,
                                    59,
                                    59
                                );
                                start = calendar._getStart(finish, duration);
                            }
                            break;
                        case 7:
                            var date2 = mini.clearTime(finish);
                            if (date2?.getTime() > ConstraintDate?.getTime()) {
                                finish = calendar._getPreviousWorkingFinish(ConstraintDate);
                                start = calendar._getStart(finish, duration);
                            }
                            break;
                    }
                }

                finish = calendar._getFinish(start, duration);
            }
        }

        var dateLimit = this.getSummaryLimitDate(task, onlyFixedDate, useLateDate);
        var limitStart = dateLimit.Start;
        var limitFinish = dateLimit.Finish;
        if (start?.getTime() < limitStart?.getTime()) {
            start = limitStart;
            finish = calendar._getFinish(start, duration);
        }
        if (finish?.getTime() > limitFinish?.getTime()) {
            finish = limitFinish;
            start = calendar._getStart(finish, duration);

            if (start?.getTime() < limitStart?.getTime() && !useLateDate) {
                task.Duration = duration = calendar._getDuration(limitStart, finish);
                start = limitStart;
            }
        }

        if (this.project.enableLimitCalculation) {
            if (task.LimitStart && start < task.LimitStart) {
                start = mini.clearTime(task.LimitStart);
            }
            if (task.LimitFinish && finish > task.LimitFinish) {
                finish = calendar._getPreviousWorkingFinish(task.LimitFinish);
                start = calendar._getStart(finish, duration);
            }
        }

        if (this.project.limitFromProjectStart && !useLateDate) {
            if (start < this.StartDate) {
                start = calendar._getNextWorkingStart(this.StartDate);
                finish = calendar._getFinish(start, duration);
            }
        }

        var item = _assignment || task;

        if (start != null && finish != null) {
            if (
                item[startField] == null ||
                item[finishField] == null ||
                item[startField]?.getTime() != start?.getTime() ||
                item[finishField]?.getTime() != finish?.getTime()
            ) {
                var start1 = item[startField],
                    finish1 = item[finishField];

                item[startField] = calendar._getNextWorkingStart(start);
                item[finishField] = calendar._getFinish(item[startField], duration);

                if (!this.isSummaryTask(task) && !useLateDate) {
                    var links = task.PredecessorLink;
                    if (links != null && links.length > 0) {
                        task.Conflict = 1;

                        if (item[startField]?.getTime() >= start1?.getTime()) {
                            task.Conflict = 0;
                        }
                    }
                }
            }
        }

        if (!onlyFixedDate) {
            if (!this.isSummaryTask(task) && !useLateDate) {
                if (ConstraintDate && item[startField] && item[finishField]) {
                    switch (ConstraintType) {
                        case 0:
                            break;
                        case 1:
                            break;
                        case 2:
                            if (item[startField]?.getTime() != ConstraintDate?.getTime()) {
                                task.Conflict = 1;
                            }
                            break;
                        case 3:
                            break;
                        case 4:
                            if (item[startField]?.getTime() < ConstraintDate?.getTime()) {
                                task.Conflict = 1;
                            }
                            break;
                        case 5:
                            break;
                        case 6:
                            break;
                        case 7:
                            break;
                    }
                }
            }
        }
    },

    minDate: new Date(1900, 0, 1),
    maxDate: new Date(9999, 0, 1),
    getSummaryLimitDate: function (task, onlyFixedDate, useLateDate) {
        var limitDate = this.limitDates[task.UID];
        if (limitDate) return limitDate;

        var startField = 'Start',
            finishField = 'Finish';
        if (useLateDate) (startField = 'LateStart'), (finishField = 'LateFinish');

        var calendar = this.project._getTaskCalendar(task);

        var start = this.minDate,
            finish = this.maxDate;

        var ps = this.ancestorTasks[task.UID] || this.project.getAncestorTasks(task);

        for (var i = 0, l = ps.length; i < l; i++) {
            var p = ps[i];
            var fixedDate = p.FixedDate;
            if (fixedDate != 0 && p[startField] != null && p[finishField] != null) {
                start = p[startField];
                finish = p[finishField];
                break;
            } else {
                if (onlyFixedDate) continue;

                var ConstraintDate = mini.clearTime(p.ConstraintDate);
                var ConstraintType = parseInt(p.ConstraintType);
                if (ConstraintType != 0 && ConstraintType != 1 && ConstraintDate == null) {
                    continue;
                }
                switch (ConstraintType) {
                    case 0:
                        break;

                    case 4:
                        start = calendar._getNextWorkingStart(ConstraintDate);
                        break;

                    case 7:
                        finish = calendar._getPreviousWorkingFinish(ConstraintDate);
                        break;
                }
            }
        }

        var dateLimit = {
            Start: start,
            Finish: finish
        };

        this.limitDates[task.UID] = dateLimit;

        return dateLimit;
    }
});

PlusProject.ProjectStatus = [
    { id: 1, text: '未开始' },
    { id: 2, text: '进行中' },
    { id: 3, text: '已完成' },
    { id: 4, text: '已暂停' }
];

PlusProject.generateTaskUID = function (tasks) {
    var hash = {};

    function each(tasks) {
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];
            hash[task.UID] = task;
            task.UID = UUID();

            if (!task.Start) task.Start = new Date();
            if (!task.Finish) task.Finish = new Date();

            if (task.children) {
                each(task.children);
            }
        }
    }

    function eachLink(links) {
        for (var i = links.length - 1; i >= 0; i--) {
            var link = links[i];
            var preTask = hash[link.PredecessorUID];
            link.PredecessorUID = preTask.UID;
        }
    }

    function each2(tasks) {
        for (var i = 0, l = tasks.length; i < l; i++) {
            var task = tasks[i];

            if (task.PredecessorLink) {
                eachLink(task.PredecessorLink);
            }
            if (task.children) {
                each2(task.children);
            }
        }
    }

    each(tasks);
    each2(tasks);
};

window['Plu' + 'sPr' + 'oject'] = PlusProject;

PlusProject.UndoManager = mini.Base.extend({
    constructor: function (context, maxLength) {
        context.undoManager = this;
        this.context = context;
        this.undoList = [];
        this.redoList = [];
        this.maxLength = maxLength || 50;
    },
    clear: function () {
        this.undoList = [];
        this.redoList = [];
        if (this.onUpdate) this.onUpdate();
    },

    canUndo: function () {
        return this.undoList.length > 0;
    },

    canRedo: function () {
        return this.redoList.length > 0;
    },

    execute: function (action) {
        action.execute(this.context);

        this.undoList.push(action);
        if (this.undoList.length > this.maxLength) this.undoList.shift();
        this.redoList.length = 0;

        if (this.onUpdate) this.onUpdate();
    },

    undo: function (uid) {
        var flags = [];
        if (this.undoList.length > 0) {
            let actions = [];
            this.undoList = this.undoList.reverse().filter((action, index) => {
                let needUndo = (uid && action.task?.UID === uid) || (!uid && index === 0);
                if (needUndo) {
                    actions.push(action);

                    let flag = action.undo(this.context);
                    flags.push(flag);

                    this.redoList.push(action);

                    if (this.redoList.length > this.maxLength) this.redoList.shift();
                }
                return !needUndo;
            });

            if (this.onUpdate) this.onUpdate();
        }
        return flags.every((item) => item);
    },

    redo: function () {
        var flag = false;
        if (this.redoList.length > 0) {
            var action = this.redoList.pop();
            action.execute(this.context);

            this.undoList.push(action);
            if (this.undoList.length > this.maxLength) this.undoList.shift();

            if (this.onUpdate) this.onUpdate();
            flag = true;
        }
        return flag;
    }
});

PlusProject.ActionBase = mini.Base.extend({
    canExecute: function (parameter) {
        return true;
    },
    execute: function (parameter) {
        if (this.canExecute(parameter)) {
            this.saveState();
            this.onExecute(parameter);
        }
    },

    saveState: function () {},

    canUndo: function () {
        return true;
    },

    undo: function (parameter) {
        var result = false;
        try {
            this.restore();
            result = true;
        } finally {
        }
        return result;
    },

    onExecute: function (parameter) {},
    restore: function () {}
});

PlusProject.ProjectGroupAction = PlusProject.ActionBase.extend({
    constructor: function (project, actions) {
        this.project = project;
        this.actions = actions;
    },
    onExecute: function (parameter) {
        this.project.suspendSchedule();
        for (var i = 0, l = this.actions.length; i < l; i++) {
            var action = this.actions[i];
            action.execute(parameter);
        }
        this.project.resumeSchedule();
    },
    undo: function (parameter) {
        this.project.suspendSchedule();
        for (var i = this.actions.length - 1; i >= 0; i--) {
            var action = this.actions[i];
            action.undo(parameter);
        }
        this.project.resumeSchedule();
    }
});

PlusProject.ProjectAction = mini.extend(PlusProject.ActionBase, {
    project: null,
    constructor: function (project) {
        this.project = project;

        this._selecteds = project.getSelecteds().clone();
        this._currentCell = project.tableView.getCurrentCell();

        var onExecute = this.onExecute;
        this.onExecute = function (parameter) {
            onExecute.call(this, parameter);

            project.deselectAll(false);
            project.selects(this._selecteds.clone(), false);
            project.tableView.setCurrentCell(this._currentCell);
        };

        var restore = this.restore;
        this.restore = function () {
            restore.call(this);

            project.deselectAll(false);

            project.selects(this._selecteds.clone(), false);
            project.tableView.setCurrentCell(this._currentCell);
        };
    }
});

PlusProject.InsertTaskAction = PlusProject.ProjectAction.extend({
    constructor: function (project, tasks, action, targetTask) {
        PlusProject.ProjectAction.call(this, project);
        this.targetTask = targetTask;
        this.action = action;
        this.tasks = jQuery.makeArray(tasks);
    },
    onExecute: function (parameter) {
        if (this.targetTask) {
            this._duration = this.targetTask.Duration;
        }

        this.project.addTasks(this.tasks, this.action, this.targetTask);
    },
    restore: function () {
        if (this.targetTask) this.targetTask.Duration = this._duration;

        this.project.removeTasks(this.tasks);
    }
});

PlusProject.UpdateTaskAction = PlusProject.ProjectAction.extend({
    constructor: function (project, task, field, value) {
        PlusProject.ProjectAction.call(this, project);
        this.task = task;
        this.field = field;
        this.value = value;
    },

    onExecute: function (parameter) {
        this.oldConstraintType = this.task.ConstraintType;
        this.oldConstraintDate = this.task.ConstraintDate;

        this.oldPercentComplete = this.task.PercentComplete;
        this.oldActualStart = this.task.ActualStart;
        this.oldDuration = this.task.Duration;

        this.oldAssignments = this.task.Assignments;

        if (typeof this.field == 'string') {
            this.oldValue = this.task[this.field];

            this.project.updateTask(this.task, this.field, this.value);
        } else {
            this.oldValue = mini.clone(this.field);

            var taskData = this.field;
            for (var key in taskData) {
                this.oldValue[key] = this.task[key];
            }

            this.field = mini.clone(taskData);
            this.oldValue = mini.clone(this.oldValue);

            this.project.updateTask(this.task, taskData);
        }
    },
    restore: function () {
        var project = this.project;
        project.allowOrderProject = false;
        if (typeof this.field == 'string') {
            this.project.updateTask(this.task, this.field, this.oldValue);

            this.project.updateTask(this.task, 'ConstraintType', this.oldConstraintType);
            this.project.updateTask(this.task, 'ConstraintDate', this.oldConstraintDate);
            this.project.updateTask(this.task, 'PercentComplete', this.oldPercentComplete, {
                setParentComplete: project.customConfig.setParentOnRestore
            });
            this.project.updateTask(this.task, 'ActualStart', this.oldActualStart);
            this.project.updateTask(this.task, 'Duration', this.oldDuration);
        } else {
            this.project.updateTask(this.task, this.oldValue);

            this.project.updateTask(this.task, 'ConstraintType', this.oldConstraintType);
            this.project.updateTask(this.task, 'ConstraintDate', this.oldConstraintDate);
            this.project.updateTask(this.task, 'Assignments', this.oldAssignments);
        }

        project.allowOrderProject = true;
        project.orderProject();
    }
});

PlusProject.RemoveTaskAction = PlusProject.ProjectAction.extend({
    constructor: function (project, tasks) {
        PlusProject.ProjectAction.call(this, project);
        this.tasks = jQuery.makeArray(tasks).clone();

        this.tasks.sort(function (a, b) {
            if (a.ID > b.ID) return 1;
            else if (a.ID < b.ID) return -1;
        });

        var hash = {};
        for (var i = 0, l = this.tasks.length; i < l; i++) {
            var task = this.tasks[i];
            hash[task.UID] = task;
        }

        function hasParentRemove(task) {
            var parentTask = project.getParentTask(task);
            while (parentTask) {
                if (hash[parentTask.UID]) return true;
                parentTask = project.getParentTask(parentTask);
            }
        }
        for (var i = this.tasks.length - 1; i >= 0; i--) {
            var task = this.tasks[i];
            if (hasParentRemove(task)) {
                this.tasks.removeAt(i);
            }
        }
    },
    onExecute: function (parameter) {
        this.cache = [];
        var store = this.project.store;

        for (var i = 0, l = this.tasks.length; i < l; i++) {
            var task = this.tasks[i];
            var parentTask = this.project.getParentTask(task);
            var index = store.indexOfParent(task);
            var o = {
                task: task,
                parentTask: parentTask,
                index: index
            };
            this.cache.push(o);

            if (store.isGrouped()) {
                o.parentGroup = store.getParentGroup(task);
                o.groupIndex = o.parentGroup.items.indexOf(task);
            }
        }

        this._predecessorLinks = PlusProject.saveTasksField(this.project, 'PredecessorLink');

        this.project.removeTasks(this.tasks);
    },
    restore: function () {
        var project = this.project;
        project.allowOrderProject = false;
        for (var i = 0, l = this.cache.length; i < l; i++) {
            var o = this.cache[i];
            project.addTask(o.task, o.index, o.parentTask);

            if (o.parentGroup) {
                var parentGroup = mini.Group.findGroupByPath(project.store.groups, o.parentGroup.path);
                parentGroup.items.insert(o.groupIndex, o.task);
                project.store._parentGroupHash[o.task._id] = parentGroup;
            }
        }

        PlusProject.restoreTasksField(project, 'PredecessorLink', this._predecessorLinks);

        project.allowOrderProject = true;
        project.orderProject();
    }
});

PlusProject.saveTasksField = function (project, field) {
    var cache = {};
    var taskList = project.getTaskList();
    for (var i = 0, l = taskList.length; i < l; i++) {
        var task = taskList[i];
        if (task[field]) {
            cache[task.UID] = task[field];
        }
    }
    cache = mini.clone(cache);
    return cache;
};
PlusProject.restoreTasksField = function (project, field, cache) {
    var taskList = project.getTaskList();
    for (var i = 0, l = taskList.length; i < l; i++) {
        var task = taskList[i];
        if (cache[task.UID]) {
            task[field] = cache[task.UID];
        }
    }
};

function __restoreSuccLinks(project, succLinks) {
    if (!succLinks || succLinks.length == 0) return;
    for (var i = 0, l = succLinks.length; i < l; i++) {
        var link = succLinks[i];
        var succTask = project.getTask(link.TaskUID);
        if (!succTask.PredecessorLink) succTask.PredecessorLink = [];
        succTask.PredecessorLink.push(link);
    }
}

PlusProject.MoveTaskAction = PlusProject.ProjectAction.extend({
    constructor: function (project, tasks, targetTask, action) {
        PlusProject.ProjectAction.call(this, project);
        this.tasks = jQuery.makeArray(tasks);
        this.targetTask = targetTask;
        this.action = action;

        this.tasks.sort(function (a, b) {
            if (a.ID > b.ID) return 1;
            else if (a.ID < b.ID) return -1;
        });
    },
    onExecute: function (parameter) {
        this.cache = [];
        var store = this.project.store;

        var project = this.project;

        for (var i = 0, l = this.tasks.length; i < l; i++) {
            var task = this.tasks[i];

            var parentTask = project.getParentTask(task);
            var index = project.indexOfList(task);
            var o = {
                task: task,
                prevTask: project.getTaskAt(index - 1),
                parentTask: parentTask
            };
            this.cache.push(o);
        }

        project.moveTasks(this.tasks, this.targetTask, this.action);
    },
    restore: function () {
        var project = this.project;
        project.allowOrderProject = false;

        for (var i = 0, l = this.cache.length; i < l; i++) {
            var o = this.cache[i];

            if (o.parentTask == o.prevTask) {
                this.project.moveTask(o.task, o.prevTask, 0);
            } else {
                this.project.moveTask(o.task, o.prevTask, 'after');
            }
        }

        project.allowOrderProject = true;
        project.orderProject();
    }
});

PlusProject.UpgradeTaskAction = PlusProject.ProjectAction.extend({
    constructor: function (project, tasks) {
        PlusProject.ProjectAction.call(this, project);
        this.tasks = jQuery.makeArray(tasks);
    },

    onExecute: function (parameter) {
        var project = this.project;

        this.cache = {};
        for (var i = 0, l = this.tasks.length; i < l; i++) {
            var task = this.tasks[i];
            var parentTask = project.getParentTask(task);
            var obj = {
                oldDuration: task.Duration,
                oldWork: task.Work,
                oldParentTask: parentTask,
                oldIndex: project.indexOfParent(task),
                oldChildren: (task.children || []).concat(),
                oldSuccLinks: project.getSuccessorLinks(task)
            };
            this.cache[task.UID] = obj;
        }

        project.upgradeTask(this.tasks);
    },
    restore: function () {
        var project = this.project;

        project.allowOrderProject = false;

        function fn(task, obj) {
            if (!obj.oldParentTask || obj.oldParentTask == project.getParentTask(task)) {
                return;
            }

            project.downgradeTask(task);

            var children = task.children || [];
            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                if (obj.oldChildren.indexOf(child) == -1) {
                    obj.oldParentTask.children.insert(obj.oldIndex + 1 + (i - obj.oldChildren.length), child);
                }
            }

            task.children = obj.oldChildren;

            __restoreSuccLinks(project, obj.oldSuccLinks);

            project.store.updateNodeState(obj.oldParentTask);

            task.Duration = obj.oldDuration;
            task.Work = obj.oldWork;
        }

        for (var i = 0, l = this.tasks.length; i < l; i++) {
            var task = this.tasks[i];
            var obj = this.cache[task.UID];
            fn(task, obj);
        }

        project.allowOrderProject = true;
        project.orderProject();
    }
});

PlusProject.DowngradeTaskAction = PlusProject.ProjectAction.extend({
    constructor: function (project, tasks) {
        PlusProject.ProjectAction.call(this, project);
        this.tasks = jQuery.makeArray(tasks);
    },
    onExecute: function (parameter) {
        var project = this.project;

        this.cache = {};
        for (var i = 0, l = this.tasks.length; i < l; i++) {
            var task = this.tasks[i];
            var parentTask = project.getParentTask(task);
            if (!parentTask) parentTask = project.store.getRootNode();

            var obj = {
                oldDuration: task.Duration,
                oldParentTask: parentTask,
                oldIndex: project.indexOfParent(task)
            };

            var prevTask = obj.oldParentTask.children[obj.oldIndex - 1];
            if (prevTask) {
                obj.prevTask = prevTask;
                obj.oldSuccLinks = project.getSuccessorLinks(prevTask);
                obj.oldDuration = prevTask.Duration;
            }

            this.cache[task.UID] = obj;
        }

        project.downgradeTask(this.tasks);
    },
    restore: function () {
        var project = this.project;

        project.allowOrderProject = false;

        function fn(task, obj) {
            var parentTask = project.getParentTask(task);
            if (!parentTask) parentTask = project.store.getRootNode();

            if (!obj.prevTask || obj.oldParentTask == parentTask) {
                return;
            }

            project.upgradeTask(task);

            obj.prevTask.Duration = obj.oldDuration;
            __restoreSuccLinks(project, obj.oldSuccLinks);
        }

        for (var i = 0, l = this.tasks.length; i < l; i++) {
            var task = this.tasks[i];
            var obj = this.cache[task.UID];
            fn(task, obj);
        }

        project.allowOrderProject = true;
        project.orderProject();
    }
});

PlusProject.ChangeColumnWidthAction = PlusProject.ProjectAction.extend({
    constructor: function (project, column, width) {
        PlusProject.ProjectAction.call(this, project);
        this.column = column;
        this.width = width;
    },
    onExecute: function (parameter) {
        this.oldWidth = this.column.width;
        this.project.setColumnWidth(this.column, this.width);
    },
    restore: function () {
        this.project.setColumnWidth(this.column, this.oldWidth);
    }
});

PlusProject.ReorderColumnAction = PlusProject.ProjectAction.extend({
    constructor: function (project, column, targetColumn, insertAction) {
        PlusProject.ProjectAction.call(this, project);
        this.column = column;
        this.targetColumn = targetColumn;
        this.insertAction = insertAction;
    },
    onExecute: function (parameter) {
        var table = this.project.tableView;
        var parentColumn = table.getParentColumn(this.column);
        var index = parentColumn.columns.indexOf(this.column);
        var nextColumn = parentColumn.columns[index + 1];

        this.nextColumn = nextColumn;
        this.parentColumn = parentColumn;
        this.index = index;

        this.project.moveColumn(this.column, this.targetColumn, this.insertAction);
    },
    restore: function () {
        if (this.nextColumn) {
            this.project.moveColumn(this.column, this.nextColumn, 'before');
        } else {
            this.project.moveColumn(this.column, this.parentColumn, 'add');
        }
    }
});

PlusProject.setProgressLineAction = PlusProject.ProjectAction.extend({
    constructor: function (project, progressLine) {
        PlusProject.ProjectAction.call(this, project);
        this.progressLine = progressLine;
    },
    onExecute: function (parameter) {
        this._progressLine = this.project.progressLine;
        this.project.setProgressLine(this.progressLine);
    },
    restore: function () {
        this.project.setProgressLine(this._progressLine);
    }
});

PlusProject.ShowBaselineAction = PlusProject.ProjectAction.extend({
    constructor: function (project, viewModel, baselineIndex) {
        PlusProject.ProjectAction.call(this, project);
        this.viewModel = viewModel;
        this.baselineIndex = baselineIndex;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this.prevBaselineIndex = project.baselineIndex;
        this.prevViewModel = project.viewModel;

        project.setBaselineIndex(this.baselineIndex);
        project.setViewModel(this.viewModel);
    },
    restore: function () {
        var project = this.project;
        project.setBaselineIndex(this.prevBaselineIndex);
        project.setViewModel(this.prevViewModel);
    }
});

PlusProject.CreateBaselineAction = PlusProject.ProjectAction.extend({
    constructor: function (project, baselineIndex, baselineAction) {
        PlusProject.ProjectAction.call(this, project);
        this.baselineIndex = baselineIndex;
        this.baselineAction = baselineAction;
    },
    onExecute: function (parameter) {
        var project = this.project;

        this._hasBaseline = PlusProject.hasBaseline(project, this.baselineIndex);
        this._cache = PlusProject.copyBaseline(project, this.baselineIndex);

        if (this.baselineAction == 'remove') {
            PlusProject.removeBaseline(project, this.baselineIndex);
        } else {
            PlusProject.createBaseline(project, this.baselineIndex);
        }
        project.refresh();
    },
    restore: function () {
        var project = this.project;

        PlusProject.removeBaseline(project, this.baselineIndex);
        if (this._hasBaseline) {
            var map = this._cache;
            for (var uid in map) {
                var item = map[uid];
                var task = project.getTask(uid);
                task.Baseline[this.baselineIndex] = item;
            }
        }
        project.refresh();
    }
});

PlusProject.CollapseExpandTaskLevelAction = PlusProject.ProjectAction.extend({
    constructor: function (project, taskLevel) {
        PlusProject.ProjectAction.call(this, project);
        this.taskLevel = taskLevel;
    },
    onExecute: function (parameter) {
        var project = this.project;

        this._cache = {};
        var tasklist = project.getTaskList();
        for (var i = 0, l = tasklist.length; i < l; i++) {
            var task = tasklist[i];
            this._cache[task.UID] = task.expanded;
        }

        var taskLevel = this.taskLevel;
        if (project.showProjectSummary) taskLevel += 1;

        if (this.taskLevel == -1) {
            project.expandAll();
        } else {
            project.store.beginChange();
            for (var i = 0, l = tasklist.length; i < l; i++) {
                var task = tasklist[i];
                var level = project.store.getLevel(task) + 1;
                if (level < taskLevel) {
                    task.expanded = true;
                } else {
                    task.expanded = false;
                }
            }
            project.store.endChange();
        }
    },
    restore: function () {
        var project = this.project;
        project.store.beginChange();
        var tasklist = project.getTaskList();
        for (var i = 0, l = tasklist.length; i < l; i++) {
            var task = tasklist[i];
            var expanded = this._cache[task.UID];
            if (expanded != null) task.expanded = expanded;
        }
        project.store.endChange();
    }
});

PlusProject.CollapseExpandGroupLevelAction = PlusProject.ProjectAction.extend({
    constructor: function (project, groupLevel) {
        PlusProject.ProjectAction.call(this, project);
        this.groupLevel = groupLevel;
    },

    updateGroupList: function () {
        this.groupList = mini.treeToArray(this.project.store.groups, 'groups');
    },

    onExecute: function (parameter) {
        this.updateGroupList();

        var project = this.project;

        this._groupsState = PlusProject.__saveGroupsState(project);

        var groupLevel = this.groupLevel;
        if (groupLevel < 0) groupLevel = 100;

        project.store.beginChange();
        for (var i = 0, l = this.groupList.length; i < l; i++) {
            var item = this.groupList[i];
            var level = project.store.getGroupLevel(item) + 1;
            if (level < groupLevel) {
                item.expanded = true;
            } else {
                item.expanded = false;
            }
        }
        project.store.endChange();
    },
    restore: function () {
        var project = this.project;

        PlusProject.__restoreGroupsState(project, this._groupsState);
    }
});

PlusProject.__saveGroupsState = function (project) {
    var store = project.store;
    if (!store.isGrouped()) return null;

    var state = {};
    var groupList = mini.treeToArray(store.groups, 'groups');
    for (var i = 0, l = groupList.length; i < l; i++) {
        var item = groupList[i];
        state[item.path] = item.expanded;
    }
    return state;
};

PlusProject.__restoreGroupsState = function (project, state) {
    if (!state) return;
    var store = project.store;
    var groupList = mini.treeToArray(store.groups, 'groups');
    store.beginChange();
    for (var i = 0, l = groupList.length; i < l; i++) {
        var item = groupList[i];
        var expanded = state[item.path];
        if (expanded != null) item.expanded = expanded;
    }
    store.endChange();
};

PlusProject.ChangeTimeScaleAction = PlusProject.ProjectAction.extend({
    constructor: function (project, timelineConfig) {
        PlusProject.ProjectAction.call(this, project);
        this.timelineConfig = timelineConfig;
        project.getDefaultTimeScales();
    },
    onExecute: function (parameter) {
        var project = this.project;

        var data = this.timelineConfig;

        this._timelineConfig = {
            topTimeScale: project.ganttView.topTimeScale,
            bottomTimeScale: project.ganttView.bottomTimeScale,
            middleTimeScale: project.ganttView.middleTimeScale,
            timelineRatio: project.ganttView.timelineRatio,
            scrollLeft: project.ganttView.scrollLeft
        };
        this._middleTimeScaleVisible = project.ganttView.middleTimeScale.visible;

        project.setTopTimeScale(data.topTimeScale);
        project.setMiddleTimeScale(data.middleTimeScale);
        project.setBottomTimeScale(data.bottomTimeScale);
        project.setTimelineRatio(data.timelineRatio);
    },
    restore: function () {
        var project = this.project;

        var data = this._timelineConfig;

        project.setTopTimeScale(data.topTimeScale);
        project.setBottomTimeScale(data.bottomTimeScale);
        project.setMiddleTimeScale(data.middleTimeScale);
        project.setTimelineRatio(data.timelineRatio);

        project.ganttView.doLayout();
        project.ganttView.setScrollLeft(data.scrollLeft);
    }
});

PlusProject.ChangeConfigColumnsAction = PlusProject.ProjectAction.extend({
    constructor: function (project, configColumns) {
        PlusProject.ProjectAction.call(this, project);
        this.configColumns = configColumns;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._configColumns = project.getConfigColumns();
        project.setConfigColumns(this.configColumns);
    },
    restore: function () {
        var project = this.project;
        project.setConfigColumns(this._configColumns);
    }
});

PlusProject.SortAction = PlusProject.ProjectAction.extend({
    constructor: function (project, fields) {
        PlusProject.ProjectAction.call(this, project);
        this.fields = fields;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._fields = project.sortFields;
        project.sort(this.fields);
    },
    restore: function () {
        var project = this.project;
        project.sort(this._fields);
    }
});

PlusProject.FilterAction = PlusProject.ProjectAction.extend({
    constructor: function (project, fields) {
        PlusProject.ProjectAction.call(this, project);

        this.fields = fields;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._fields = project.filterFields;

        project.filter(this.fields);
    },
    restore: function () {
        var project = this.project;

        project.filter(this._fields);
    }
});

PlusProject.GroupAction = PlusProject.ProjectAction.extend({
    constructor: function (project, fields, includeParentOnGroup) {
        PlusProject.ProjectAction.call(this, project);
        this.fields = fields;
        this.includeParentOnGroup = includeParentOnGroup;
    },
    onExecute: function (parameter) {
        var project = this.project;

        this._groupsState = PlusProject.__saveGroupsState(project);

        this._fields = project.groupFields;
        this._includeParentOnGroup = project.store.includeParentOnGroup;
        project.store.includeParentOnGroup = this.includeParentOnGroup;
        project.group(this.fields);
    },
    restore: function () {
        var project = this.project;
        project.store.includeParentOnGroup = this._includeParentOnGroup;
        project.group(this._fields);

        PlusProject.__restoreGroupsState(project, this._groupsState);
    }
});

PlusProject.HighlightAction = PlusProject.ProjectAction.extend({
    constructor: function (project, fields) {
        PlusProject.ProjectAction.call(this, project);
        this.fields = fields;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._fields = project.highlightFields;
        project.highlight(this.fields);
    },
    restore: function () {
        var project = this.project;
        project.highlight(this._fields);
    }
});

PlusProject.ProjectInfoAction = PlusProject.ProjectAction.extend({
    constructor: function (project, data) {
        PlusProject.ProjectAction.call(this, project);
        this.data = data;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._data = $.extend({}, project.data);
        $.extend(project.data, this.data);

        this._showProjectSummary = project.showProjectSummary;

        project.setShowProjectSummary(this.data.showProjectSummary);
        project.setCalendarUID(this.data.CalendarUID);
        project.orderProject();
    },
    restore: function () {
        var project = this.project;
        $.extend(project.data, this._data);
        project.setShowProjectSummary(this._showProjectSummary);
        project.setCalendarUID(this._data.CalendarUID);
        project.orderProject();
    }
});

PlusProject.ChangeCalendarsAction = PlusProject.ProjectAction.extend({
    constructor: function (project, data) {
        PlusProject.ProjectAction.call(this, project);
        this.data = data;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._data = project.data.Calendars;
        project.setCalendars(this.data);
    },
    restore: function () {
        var project = this.project;
        project.setCalendars(this._data);
    }
});

PlusProject.ChangeResourcesAction = PlusProject.ProjectAction.extend({
    constructor: function (project, data) {
        PlusProject.ProjectAction.call(this, project);
        this.data = data;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._data = project.data.Resources;

        this._cache = {};
        var taskList = project.getTaskList();
        for (var i = 0, l = taskList.length; i < l; i++) {
            var task = taskList[i];
            if (task.Assignments) {
                this._cache[task.UID] = task.Assignments;
            }
        }
        this._cache = mini.clone(this._cache);

        project.setResources(this.data);
    },
    restore: function () {
        var project = this.project;

        var taskList = project.getTaskList();
        for (var i = 0, l = taskList.length; i < l; i++) {
            var task = taskList[i];
            if (this._cache[task.UID]) {
                task.Assignments = this._cache[task.UID];
            }
        }

        project.setResources(this._data);
    }
});

PlusProject.MoveProjectAction = PlusProject.ProjectAction.extend({
    constructor: function (project, date) {
        PlusProject.ProjectAction.call(this, project);
        this.date = date;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._date = project.data.StartDate;

        this._cache = mini.clone(project.data);

        this._progressLine = mini.clone(project.progressLine);
        this._timeLines = mini.clone(project.timeLines);

        project.moveProject(this.date);
    },
    restore: function () {
        var project = this.project;

        project.data = this._cache;
        if (this._progressLine) project.setProgressLine(this._progressLine);
        if (this._timeLines) project.setTimeLines(this._timeLines);
        project.orderProject();
    }
});

PlusProject.TimeLinesAction = PlusProject.ProjectAction.extend({
    constructor: function (project, data) {
        PlusProject.ProjectAction.call(this, project);
        this.data = data;
    },
    onExecute: function (parameter) {
        var project = this.project;
        this._data = mini.clone(project.timeLines);

        project.setTimeLines(this.data);
    },
    restore: function () {
        var project = this.project;
        project.setTimeLines(this._data);
    }
});

PlusProject.ContextMenu = mini.extend(mini.Menu, {
    project: null,

    constructor: function (project, options) {
        mini.Menu.call(this);

        var me = this;
        this.owner = project;
        this.project = project;

        mini.addClass(this.el, 'mini-contextmenu');

        if (project) {
            project.ganttView.stopContextMenu = false;
            jQuery(project.el).on('contextmenu', jQuery.proxy(this.onContextMenu, this));
        }

        var items = this.createMenuItems();
        if (items) this.setItems(items);

        this.on('itemclick', this.onMenuItemClick, this);

        if (options) this.set(options);
    },

    getContextMenuTargetEl: function (event) {
        return this.project.el;
    },

    onContextMenu: function (event) {
        this.contextMenuEvent = event;
        var el = this.getContextMenuTargetEl(event);
        if (el) {
            if (jQuery(event.target).closest(el)[0]) {
                var e = {
                    htmlEvent: event,
                    cancel: false
                };
                this.fire('beforeopen', e);
                this.beforeOpen(e);
                if (e.cancel) return;

                this.showAtPos(event.pageX, event.pageY);
            }
        }
        return false;
    },

    beforeOpen: function (e) {},

    createMenuItems: function () {},

    onMenuItemClick: function (e) {}
});

PlusProject.GanttBarMenu = PlusProject.ContextMenu.extend({
    getContextMenuTargetEl: function (event) {
        var item = this.project.ganttView.getItemByEvent(event);
        if (!item) return null;
        return this.project.ganttView.getBodyEl();
    },

    createMenuItems: function () {
        var items = [
            { iconCls: 'icon-gantt-info', text: '任务信息', name: 'info', onClick: this.onInfoClick.bind(this) },

            { iconCls: 'icon-gantt-assign', text: '资源分配', name: 'notes', onClick: this.onAssignClick.bind(this) }
        ];
        return items;
    },

    onInfoClick: function (e) {
        var win = ShowTaskWindow(this.project);
        win.setActiveTab('base');
    },

    onNotesClick: function (e) {
        var win = ShowTaskWindow(this.project);

        win.setActiveTab('notes');
    },

    onAssignClick: function (e) {
        var win = ShowTaskWindow(this.project);

        win.setActiveTab('res');
    }
});

PlusProject.GanttHeaderMenu = PlusProject.ContextMenu.extend({
    getContextMenuTargetEl: function () {
        return this.project.ganttView.getHeaderEl();
    },

    createMenuItems: function () {
        var timescaleItems = [
            { text: '小时', units: 'hour' },
            { text: '天', units: 'day', topscale: 'week' },
            { text: '周', units: 'week' },
            { text: '旬', units: 'tendays' },
            { text: '月', units: 'month' },
            { text: '季度', units: 'quarter' },
            { text: '半年', units: 'halfyear' },
            { text: '年', units: 'year' }
        ];

        var items = [
            {
                iconCls: 'icon-config',
                _iconCls: 'icon-gantt-timescale',
                text: '时间刻度配置',
                name: 'timescale',
                onClick: this.onTimeScaleClick.bind(this)
            },
            {
                iconCls: 'icon-calendar',
                _iconCls: 'icon-gantt-calendar',
                text: '更改工作时间',
                name: 'calendar',
                onClick: this.onCalenarClick.bind(this)
            },
            '-',
            {
                iconCls: 'icon-gantt-fullproject',
                text: '完整项目',
                name: 'fullproject',
                onClick: this.onFullProjectClick.bind(this)
            },
            { _iconCls: 'icon-gantt-tick', text: '时间刻度', name: 'timescaleList', items: timescaleItems },
            '-',
            { iconCls: 'icon-zoomin', text: mini.Gantt.ZoomIn_Text, name: 'zoomin', onclick: this.onZoomIn.bind(this) },
            {
                iconCls: 'icon-zoomout',
                text: mini.Gantt.ZoomOut_Text,
                name: 'zoomout',
                onclick: this.onZoomOut.bind(this)
            }
        ];
        return items;
    },

    onMenuItemClick: function (e) {
        var item = e.item;
        if (item.units) {
            this.onTimeScaleItemClick(e);
        }
    },

    onTimeScaleItemClick: function (e) {
        var project = this.project;
        var ganttView = this.project.ganttView;

        var item = e.item;
        var ts = ganttView.findZoomTimeScale(item.units, item.topscale);

        var data = {
            topTimeScale: ts[0],
            bottomTimeScale: ts[1],
            middleTimeScale: $.extend({}, ts[0], { visible: ganttView.middleTimeScale.visible }),
            timelineRatio: project.timelineRatio
        };

        if (project.executeAction && PlusProject.ChangeTimeScaleAction) {
            var action = new PlusProject.ChangeTimeScaleAction(project, data);
            project.executeAction(action);
        } else {
            ganttView.setTopTimeScale(ts[0]);
            ganttView.setBottomTimeScale(ts[1]);
        }

        ganttView.invalidate();
    },

    onFullProjectClick: function (e) {
        this.project.zoomFit();
    },

    onTimeScaleClick: function (e) {
        var win = new PlusProject.TimeScaleWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;
        win.setData();
        win.show();
    },

    onCalenarClick: function (e) {
        ShowCalendarWindow(this.project);
    },

    onZoomIn: function (e) {
        this.project.zoomIn();
    },
    onZoomOut: function (e) {
        this.project.zoomOut();
    }
});

PlusProject.GanttMenu = PlusProject.ContextMenu.extend({
    getContextMenuTargetEl: function (event) {
        var item = this.project.ganttView.getItemByEvent(event);
        if (item) return null;
        return this.project.ganttView.getBodyEl();
    },

    createMenuItems: function () {
        var items = [
            { _iconCls: 'icon-gantt-grid', text: '网格', name: 'grid', onClick: this.onGridClick.bind(this) },
            {
                _iconCls: 'icon-gantt-progressline',
                text: '进度线',
                name: 'progressline',
                onClick: this.onProgressLineClick.bind(this)
            },
            { text: '显示/隐藏条形图样式', hideOnClick: false, items: this.createBarStyleItems() }
        ];
        return items;
    },

    createBarStyleItems: function () {
        var baselineItems = [
            { text: '设置基线', iconCls: 'icon-gantt-createbaseline', onClick: this.onCreateBaselineClick.bind(this) },
            { text: '清除基线', iconCls: 'icon-remove', onClick: this.onRemoveBaselineClick.bind(this) },
            '-'
        ];

        for (var i = 0, l = PlusProject.Baselines.length; i < l; i++) {
            var baseline = PlusProject.Baselines[i];
            baselineItems.push({ text: baseline.text, baselineIndex: i, baseline: true });
        }

        var items = [
            { text: '关键任务', name: 'critical', onClick: this.onCriticalClick.bind(this) },
            { text: '可宽延时间', name: 'totalslack', onClick: this.onShowTotalSlackClick.bind(this) },
            { text: '延迟的任务', name: 'delayedtask', onClick: this.onShowDelayedTaskClick.bind(this) },
            { _iconCls: 'icon-gantt-baseline', text: '基线', name: 'baseline', items: baselineItems }
        ];
        return items;
    },

    onShowTotalSlackClick: function (e) {
        var project = this.project;
        project.setShowTotalSlack(!project.showTotalSlack);
    },

    onShowDelayedTaskClick: function (e) {
        var project = this.project;
        project.setShowDelayedTask(!project.showDelayedTask);
    },

    onGridClick: function (e) {
        var project = this.project;
        project.setShowGridLines(!project.showGridLines);
    },

    onProgressLineClick: function (e) {
        var win = new PlusProject.ProgressLineWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;

        win.setData();
        win.show();
    },

    onTimeLineClick: function () {
        var win = new PlusProject.TimelinesWindow({
            project: this.project
        });
        win.setData();
        win.show();
    },

    onCriticalClick: function (e) {
        var project = this.project;
        project.setShowCriticalPath(!project.showCriticalPath);
    },

    onCreateBaselineClick: function (e) {
        var win = new PlusProject.CreateBaselineWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;
        win.setData();
        win.show();
    },

    onRemoveBaselineClick: function (e) {
        var win = new PlusProject.RemoveBaselineWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;
        win.setData();
        win.show();
    },

    onMenuItemClick: function (e) {
        var project = this.project;
        var item = e.item;
        if (item.baseline) {
            item.setChecked(!item.checked);

            if (item.checked) {
                var action = new PlusProject.ShowBaselineAction(project, 'track', item.baselineIndex);
                project.executeAction(action);
            } else {
                var action = new PlusProject.ShowBaselineAction(project, 'gantt', -1);
                project.executeAction(action);
            }
        }
    },

    beforeOpen: function (e) {
        var project = this.project;
        var item = this.getByName('grid');
        item.setChecked(project.showGridLines);

        var item = this.getByName('critical');
        item.setChecked(project.showCriticalPath);

        item = this.getByName('totalslack');
        item.setChecked(project.showTotalSlack);

        item = this.getByName('delayedtask');
        item.setChecked(project.showDelayedTask);

        var baseline = this.getByName('baseline');
        for (var i = 0, l = baseline.menu.items.length; i < l; i++) {
            var item = baseline.menu.items[i];
            if (item.baseline) {
                var checked = item.baselineIndex == project.baselineIndex && project.viewModel == 'track';
                item.setChecked(checked);

                var hasBaseline = PlusProject.hasBaseline(project, item.baselineIndex);
                mini.toggleClass(item.el, 'baseline-item', hasBaseline);
            }
        }
    }
});

PlusProject.TableHeaderMenu = PlusProject.ContextMenu.extend({
    getContextMenuTargetEl: function () {
        return this.project.tableView.getHeaderEl();
    },

    createMenuItems: function () {
        var levelItems = [{ text: '所有子任务', taskLevel: -1 }];
        for (var i = 1; i <= 9; i++) {
            levelItems.push({ text: '层级' + i, taskLevel: i });
        }

        var tableItems = [{ text: '新建' }, { text: '编辑' }];
        tableItems.push('-', { text: '表格1' }, { text: '表格2' });

        var items = [
            { iconCls: 'icon-config', text: '列配置', name: 'config', onClick: this.onConfigClick.bind(this) },
            { iconCls: 'icon-lock', text: '列锁定', name: 'lock', onClick: this.onLockClick.bind(this) },
            {
                text: '取消列锁定',
                checked: true,
                visible: false,
                name: 'unlock',
                onClick: this.onUnlockClick.bind(this)
            },
            '-',
            { iconCls: 'icon-sort', text: '排序条件', name: 'sort', onClick: this.onSortClick.bind(this) },
            { iconCls: 'icon-filter', text: '过滤条件', name: 'filter', onClick: this.onFilterClick.bind(this) },
            { iconCls: 'icon-expand', text: '分组条件', name: 'group', onClick: this.onGroupClick.bind(this) },
            '-',
            { iconCls: 'icon-tip', text: '高亮条件', name: 'highlight', onClick: this.onHighlightClick.bind(this) },
            { iconCls: 'icon-find', text: '查找替换', onClick: this.onFindReplaceClick.bind(this) },
            '-',
            { iconCls: '', text: '层级显示', name: 'level', items: levelItems }
        ];

        return items;
    },

    onConfigClick: function (e) {
        var win = new PlusProject.ColumnConfigWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;
        win.setData();
        win.show();
    },

    onLockClick: function (e) {
        var project = this.project;

        var from = project.tableView.getLeftColumn();
        var column = project.tableView.getColumnByEvent(this.contextMenuEvent);
        var to = project.tableView.indexOfColumn(column);

        if (to < from) return;

        project.frozenColumn(from, to);
    },

    onUnlockClick: function (e) {
        this.project.unfrozenColumn();

        this.getByName('lock').show();
        this.getByName('unlock').hide();
    },
    onSortClick: function (e) {
        var win = new PlusProject.SortConfigWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;
        win.setData();
        win.show();
    },
    onFilterClick: function (e) {
        var win = new PlusProject.FilterConfigWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;
        win.setData();
        win.show();
    },
    onHighlightClick: function (e) {
        var win = new PlusProject.FilterConfigWindow({
            closeAction: 'destroy',
            title: '设置高亮条件',
            highlight: true
        });
        win.project = this.project;
        win.setData();
        win.show();
    },
    onGroupClick: function (e) {
        var win = new PlusProject.GroupConfigWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;
        win.setData();
        win.show();
    },

    onFindReplaceClick: function (e) {
        var win = new PlusProject.FindReplaceWindow({
            closeAction: 'destroy'
        });
        win.project = this.project;
        win.setData();
        win.show();
    },

    onLevelClick: function (e) {
        var item = e.item;

        var project = this.project;

        var action;

        if (project.store.isGrouped()) {
            action = new PlusProject.CollapseExpandGroupLevelAction(project, item.taskLevel);
        } else {
            action = new PlusProject.CollapseExpandTaskLevelAction(project, item.taskLevel);
        }

        project.executeAction(action);
    },

    onMenuItemClick: function (e) {
        var item = e.item;
        if (item.taskLevel != null) {
            this.onLevelClick(e);
        }
    },

    beforeOpen: function (e) {
        var project = this.project;

        var lock = this.getByName('lock');
        var unlock = this.getByName('unlock');

        if (project.tableView.isFrozen()) {
            lock.hide();
            unlock.show();
        } else {
            lock.show();
            unlock.hide();
        }

        var sort = this.getByName('sort');
        var filter = this.getByName('filter');
        var group = this.getByName('group');
        var highlight = this.getByName('highlight');

        var s1 = 'font-weight:bold';
        var s2 = 'font-weight:normal';

        mini.setStyle(sort.el, project.isSorted() ? s1 : s2);
        mini.setStyle(filter.el, project.isFiltered() ? s1 : s2);
        mini.setStyle(group.el, project.isGrouped() ? s1 : s2);
        mini.setStyle(highlight.el, project.isHighlighted() ? s1 : s2);
    }
});

PlusProject.Window = mini.Window.extend({
    props: {
        width: 500,
        height: 350,
        closeAction: 'destroy',
        showFooter: true,
        footerStyle: 'padding:8px;padding-right:10px;text-align:right;',
        footer: '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>'
    },

    project: null,

    setData: function (data) {},

    getData: function () {},

    onOkClick: function (event) {
        this.close('ok');
    },

    onCancelClick: function (event) {
        this.close('cancel');
    }
});
PlusProject.CreateBaselineWindow = PlusProject.Window.extend({
    props: {
        title: '设置基准',
        width: 280,
        height: 'auto'
    },

    content:
        '<table style="margin-bottom:10px;">' +
        '<tr>' +
        '<td>设置基准：</td>' +
        '<td><mini-combobox @drawcell="onDrawItem" ref="baseline" width="180"></mini-combobox></td>' +
        '</tr>' +
        '</table>',

    updateTtt: function (value) {},

    setData: function () {
        var data = mini.clone(PlusProject.Baselines);
        this.refs.baseline.setData(data);
    },

    getSelectedIndex: function () {
        var item = this.refs.baseline.getSelected();
        return this.refs.baseline.indexOf(item);
    },

    onDrawItem: function (e) {
        var item = e.record,
            field = e.field,
            value = e.value;

        if (PlusProject.hasBaseline(this.project, item.id)) {
            e.cellCls = 'baseline-item';
        }
    },

    onOkClick: function (event) {
        var project = this.project;

        var index = this.getSelectedIndex();
        if (index != -1) {
            var action = new PlusProject.CreateBaselineAction(project, index);
            project.executeAction(action);
        }

        this.close('ok');
    }
});

PlusProject.RemoveBaselineWindow = PlusProject.Window.extend({
    props: {
        title: '清除基准',
        width: 280,
        height: 'auto'
    },

    content:
        '<table style="margin-bottom:10px;">' +
        '<tr>' +
        '<td>清除基准：</td>' +
        '<td><mini-combobox @drawcell="onDrawItem" ref="baseline" width="180"></mini-combobox></td>' +
        '</tr>' +
        '</table>',

    setData: function () {
        var data = mini.clone(PlusProject.Baselines);
        this.refs.baseline.setData(data);
    },

    getSelectedIndex: function () {
        var item = this.refs.baseline.getSelected();
        return this.refs.baseline.indexOf(item);
    },

    onDrawItem: function (e) {
        var item = e.record,
            field = e.field,
            value = e.value;

        if (PlusProject.hasBaseline(this.project, item.id)) {
            e.cellCls = 'baseline-item';
        }
    },

    onOkClick: function (event) {
        var project = this.project;

        var index = this.getSelectedIndex();
        if (index != -1) {
            var action = new PlusProject.CreateBaselineAction(project, index, 'remove');
            project.executeAction(action);
        }

        this.close('ok');
    }
});

PlusProject.Baselines = [
    { id: 0, text: '基线' },
    { id: 1, text: '基线1' },
    { id: 2, text: '基线2' },
    { id: 3, text: '基线3' },
    { id: 4, text: '基线4' },
    { id: 5, text: '基线5' },
    { id: 6, text: '基线6' },
    { id: 7, text: '基线7' },
    { id: 8, text: '基线8' },
    { id: 9, text: '基线9' },
    { id: 10, text: '基线10' }
];

PlusProject.createBaseline = function (project, index) {
    var tasklist = project.getTaskList();
    for (var i = 0, l = tasklist.length; i < l; i++) {
        var task = tasklist[i];

        if (!task.Baseline) task.Baseline = [];

        if (!task.Start || !task.Finish) continue;

        var baseline = {
            Start: new Date(task.Start?.getTime()),
            Finish: new Date(task.Finish?.getTime())
        };

        task.Baseline[index] = baseline;
    }
};

PlusProject.removeBaseline = function (project, index) {
    var tasklist = project.getTaskList();
    for (var i = 0, l = tasklist.length; i < l; i++) {
        var task = tasklist[i];
        if (task.Baseline) {
            delete task.Baseline[index];
        }
    }
};

PlusProject.hasBaseline = function (project, index) {
    var task = project.getTaskList()[0];
    return !!(task && task.Baseline && task.Baseline[index]);
};

PlusProject.copyBaseline = function (project, index) {
    var map = {};
    var tasklist = project.getTaskList();
    for (var i = 0, l = tasklist.length; i < l; i++) {
        var task = tasklist[i];
        if (task.Baseline) {
            var item = task.Baseline[index];
            map[task.UID] = item;
        }
    }
    return map;
};

PlusProject.CalendarWindow = PlusProject.Window.extend({
    title: '项目日历',
    width: 450,
    height: 480,
    showModal: true,
    showFooter: true,

    projectSuffixName: '(项目日历)',

    content:
        '<div style="padding-bottom:5px;display:flex">' +
        '<div>当前日历：<input ref="combo" @change="onChangeCalendar" width="150" class="mini-combobox" valueField="UID" textField="Name"/></div>' +
        '<div style="flex:1"></div><div><mini-button ref="add" @click="onNewClick" style="margin-right:10px;">新建</mini-button><mini-button ref="edit" @click="onEditName">修改</mini-button><mini-button ref="remove" @click="onDelClick" style="margin-left:10px">删除</mini-button></div></div>  ' +
        '<div style="height:190px;overflow:hidden;"><div style="float:left;width:200px;">图例：<div class="mini-gantt-calendar-legend">' +
        '<div class="mini-gantt-calendar-legend-item"><div class="mini-gantt-calendar-legend-icon "></div><div class="mini-gantt-calendar-legend-text">工作日</div></div>' +
        '<div class="mini-gantt-calendar-legend-item"><div class="mini-gantt-calendar-legend-icon mini-gantt-offday"></div><div class="mini-gantt-calendar-legend-text">非工作日</div></div>' +
        '<div class="mini-gantt-calendar-legend-item"><div class="mini-gantt-calendar-legend-icon mini-gantt-exception-working"></div><div class="mini-gantt-calendar-legend-text">例外日期：工作日</div></div>' +
        '<div class="mini-gantt-calendar-legend-item"><div class="mini-gantt-calendar-legend-icon mini-gantt-exception-nonworking"></div><div class="mini-gantt-calendar-legend-text">例外日期：非工作日</div></div>' +
        '</div></div>' +
        '<div style="float:right;">' +
        '<mini-calendar ref="calendar" @drawdate="onCalendarDrawCell" showFooter="false" height="170" ></mini-calendar>' +
        '</div><div style="clear:both;overflow:hidden;width:0px;height:0px;"></div>' +
        '</div>' +
        '<div class="mini-tabs" activeIndex="0" bodyStyle="padding:0;" height="186">' +
        '<div title="例外日期">' +
        '<div class="mini-panel" showHeader="false" showToolbar="true" width="100%" height="100%" bodyStyle="padding:0" borderStyle="border:0;">' +
        '<div property="toolbar" class="mini-toolbar" style="border-width:0;border-bottom-width:1px;" >' +
        '<a ref="exAdd" @click="onAddEx" class="mini-button" plain="true">增加</a>' +
        '<a ref="exRemove" @click="onDelEx" class="mini-button" plain="true">删除</a>' +
        '</div>' +
        '<div ref="exceptions" name="exceptions" class="mini-supergrid" style="width:100%;height:100%;" borderStyle="border:0;"' +
        ' @drawcell="onExceptionsDrawCell" @cellbeginedit="onExceptionsCellBeginEdit" @cellcommitedit="onExceptionsCellCommitEdit" @selectionchange="onExceptionSelectionChange">' +
        '<div property="columns">' +
        '<div type="indexcolumn"></div>' +
        '<div type="checkboxcolumn" trueValue="1" falseValue="0" field="DayWorking" width="60">工作日</div>' +
        '<div field="Name" width="120" editor="{type: \'textbox\'}">例外名称</div>' +
        '<div name="from" field="FromDate" >开始时间<input property="editor" class="mini-datepicker" allowInput="false" /></div>' +
        '<div name="to" field="ToDate" >完成时间<input property="editor" class="mini-datepicker" allowInput="false"/></div>' +
        '<div name="repeatType" field="RepeatType" displayField="RepeatName">循环方式<input property="editor" class="mini-combobox" allowInput="false" data=\'[{value: "", text: "不重复"},{value: "month", text: "每月重复"},{value:"year", text: "每年重复"}]\' valueField="value"/></div>' +
        '</div>' +
        '</div>' +
        '</div>' +
        '</div>' +
        '<div title="工作周">' +
        '<div ref="weekdays" name="weekdays" class="mini-supergrid" style="width:100%;height:100%;" borderStyle="border:0;" ' +
        ' @drawcell="onWeekDaysDrawCell" @cellcommitedit="onWeekDaysCellCommitEdit">' +
        '<div property="columns">' +
        '<div type="checkboxcolumn" trueValue="1" falseValue="0" field="DayWorking" width="60">工作日</div>' +
        '<div field="DayType" width="150" headerAlign="center" align="center">星期</div>' +
        '</div>' +
        '</div>' +
        '</div>' +
        '</div>',

    isWorkingWeekDay: function (date) {
        var calendar = this.selectedCalendar;
        for (var i = 0, l = calendar.WeekDays.length; i < l; i++) {
            var weekday = calendar.WeekDays[i];
            if (weekday.DayType == date?.getDay() + 1) {
                return weekday.DayWorking;
            }
        }
        return true;
    },

    getException: function (date) {
        date = mini.clearTime(date);
        var calendar = this.selectedCalendar;
        for (var i = 0, l = calendar.Exceptions.length; i < l; i++) {
            var ex = calendar.Exceptions[i];

            if (!ex.TimePeriod.FromDate || !ex.TimePeriod.ToDate) {
                continue;
            }

            var ex_from = mini.clearTime(ex.TimePeriod.FromDate),
                ex_to = mini.clearTime(ex.TimePeriod.ToDate);
            if (ex_from <= date && date <= ex_to) {
                return ex;
            }
        }
        return null;
    },

    onCalendarDrawCell: function (e) {
        var calendar = this.selectedCalendar;
        if (calendar) {
            var isWorking = this.isWorkingWeekDay(e.date);
            if (!isWorking) {
                e.dateCls += ' mini-gantt-offday';
            }

            var ex = this.getException(e.date);
            if (ex) {
                if (ex.DayWorking) {
                    e.dateCls += ' mini-gantt-exception-working';
                } else {
                    e.dateCls += ' mini-gantt-exception-nonworking';
                }
            }
        }
    },

    onNewClick: function (e) {
        var me = this;

        if (!this.validateExceptions()) {
            return;
        }

        function createCalendarUID(calendars) {
            var uid = 1;
            for (var i = 0, l = calendars.length; i < l; i++) {
                var cid = parseInt(calendars[i].UID);
                if (!isNaN(cid)) {
                    if (uid < cid) uid = cid;
                }
            }
            uid++;
            return uid;
        }

        mini.prompt('日历名称：', '新建日历', function (action, value) {
            if (action == 'ok') {
                if (!value) {
                    alert('日历名称不能为空');
                    return;
                }

                var data = me.Calendars;

                var calendar = PlusProject.createDefaultCalendar();
                calendar.Name = value;
                calendar.UID = createCalendarUID(data);

                data.push(calendar);
                me.refs.combo.setData(data);
                me.refs.combo.setValue(calendar.UID);

                me.selectCalendar(calendar.UID);
            }
        });
    },

    onDelClick: function (e) {
        var me = this;
        var data = me.Calendars;

        var item = me.getCalendar(me.refs.combo.getValue());

        if (item.UID == me.project.data.CalendarUID) {
            alert('不能删除项目日历');
            return;
        }

        if (confirm('确定删除日历 "' + item.Name + '" ')) {
            var index = data.indexOf(item);
            data.remove(item);
            var nextItem = data[index] || data[index - 1];
            me.refs.combo.setData(data);
            me.refs.combo.setValue(nextItem.UID);
            me.selectCalendar(nextItem.UID);
        }
    },

    onEditName: function (e) {
        var me = this;
        var win = mini.prompt('日历名称：', '修改日历', function (action, value) {
            if (action == 'ok') {
                var data = me.Calendars;
                if (calendar.UID == me.project.data.CalendarUID) value += me.projectSuffixName;
                calendar.Name = value;
                me.refs.combo.setData(data);
            }
        });

        var calendar = me.getCalendar(me.refs.combo.getValue());
        var name = calendar.Name;
        if (calendar.UID == me.project.data.CalendarUID) name = name.replace(me.projectSuffixName, '');
        win.input.value = name;
    },

    onChangeCalendar: function (e) {
        if (!this.validateExceptions()) {
            this.refs.combo.setValue(this.selectedCalendar.UID);
            return;
        }

        this.selectCalendar(this.refs.combo.value);
    },

    onWeekDaysDrawCell: function (e) {
        if (e.field == 'DayType') {
            e.cellHtml = mini.getLongWeek(e.value - 1);
        }
    },

    onWeekDaysCellCommitEdit: function (e) {
        if (e.field == 'DayWorking') {
            var working = false;
            var WeekDays = this.refs.weekdays.getData();

            for (var i = 0, l = WeekDays.length; i < l; i++) {
                var weekday = WeekDays[i];
                if (weekday == e.record) continue;
                if (weekday.DayWorking == 1) {
                    working = true;
                    break;
                }
            }
            if (working == false) {
                alert('工作周必须有一天是工作日');
                e.cancel = true;
            }

            this.refs.calendar.invalidate();
        }
    },

    onExceptionsDrawCell: function (e) {
        if (e.field == 'FromDate' || e.field == 'ToDate') {
            var ex = e.record;
            if (ex.TimePeriod) {
                e.cellHtml = mini.formatDate(ex.TimePeriod[e.field], 'yyyy-MM-dd');
            } else {
                e.cellHtml = '';
            }
        } else if (e.field == 'RepeatType') {
        }
    },

    onExceptionSelectionChange: function (e) {
        var item = e.sender.getSelected();
        if (item && item.TimePeriod && item.TimePeriod.FromDate) {
            this.refs.calendar.setViewDate(item.TimePeriod.FromDate);
        }
    },

    onExceptionsCellBeginEdit: function (e) {
        if (e.field == 'FromDate' || e.field == 'ToDate') {
            var ex = e.record;
            if (ex.TimePeriod) {
                e.value = ex.TimePeriod[e.field];
            } else {
                e.value = null;
            }
        }
    },

    onExceptionsCellCommitEdit: function (e) {
        if (e.field == 'FromDate' || e.field == 'ToDate') {
            e.cancel = true;
            var ex = e.record;

            if (String(ex.TimePeriod[e.field]) == String(e.value)) return;
            ex.TimePeriod[e.field] = e.value;

            if (e.field == 'FromDate' && !ex.TimePeriod.ToDate && e.value) {
                ex.TimePeriod.ToDate = mini.cloneDate(e.value);
            }

            if (e.field == 'ToDate' && !ex.TimePeriod.FromDate && e.value) {
                ex.TimePeriod.FromDate = mini.cloneDate(e.value);
            }

            e.sender.invalidate();
        } else {
        }
        this.refs.calendar.invalidate();
    },

    onAddEx: function (e) {
        var ex = {
            DayWorking: 0,
            DayType: 0,
            Name: '',
            TimePeriod: { FromDate: null, ToDate: null }
        };

        var date = this.refs.calendar.getValue();
        if (date) {
            date = mini.clearTime(date);
            ex.TimePeriod.FromDate = mini.cloneDate(date);
            ex.TimePeriod.ToDate = mini.cloneDate(date);
        }

        this.refs.exceptions.addRow(ex);
        this.refs.calendar.invalidate();
    },

    onDelEx: function (e) {
        this.refs.exceptions.removeSelected();
        this.refs.calendar.invalidate();
    },

    getCalendar: function (calendarUID, _data) {
        _data = _data || this.Calendars;
        for (var i = 0, l = _data.length; i < l; i++) {
            var c = _data[i];
            if (c.UID == calendarUID) return c;
        }
    },

    markCalenar: function () {
        if (!this.selectedCalendar) return;
        var calendar = this.selectedCalendar;
        calendar.WeekDays = this.refs.weekdays.getData();
        calendar.Exceptions = this.refs.exceptions.getData();
    },

    selectCalendar: function (calendarUID) {
        var c = this.getCalendar(calendarUID);
        if (!c) return;

        this.markCalenar();
        var calendar = (this.selectedCalendar = this.getCalendar(calendarUID));

        mini.sort(calendar.WeekDays, function (a, b) {
            return a.DayType - b.DayType;
        });

        this.refs.exceptions.setData(calendar.Exceptions);
        this.refs.weekdays.setData(calendar.WeekDays);

        this.refs.calendar.refresh();
    },

    setData: function () {
        var project = this.project;

        var dataProject = project.getData();
        var startDate = dataProject.StartDate;
        var calendarUID = dataProject.CalendarUID;

        this.Calendars = mini.clone(project.data.Calendars);

        var projectCalendar = this.getCalendar(project.data.CalendarUID);
        projectCalendar.Name += this.projectSuffixName;

        this.selectCalendar(calendarUID);

        this.refs.combo.setData(this.Calendars);
        this.refs.combo.setValue(calendarUID);

        var fromColumn = this.refs.exceptions.getColumn('from');
        var toColumn = this.refs.exceptions.getColumn('to');
        fromColumn.editor.setViewDate(startDate);
        toColumn.editor.setViewDate(startDate);

        this.refs.calendar.setViewDate(startDate);

        var repeatTypeColumn = this.refs.exceptions.getColumn('repeatType');
        repeatTypeColumn.visible = !!project.enableCycleCalendar;

        this.refs.exceptions.setColumns(this.refs.exceptions.getColumns());
    },

    getData: function () {
        var project = this.project;
        this.markCalenar();
        for (var i = 0, l = this.Calendars.length; i < l; i++) {
            var c = this.Calendars[i];
            var Exceptions = c.Exceptions;
            for (var j = Exceptions.length - 1; j >= 0; j--) {
                var ex = Exceptions[j];
                if (
                    !ex.TimePeriod ||
                    !ex.TimePeriod.FromDate ||
                    !ex.TimePeriod.ToDate ||
                    ex.TimePeriod.FromDate > ex.TimePeriod.ToDate
                ) {
                    Exceptions.removeAt(j);
                    continue;
                }
                ex.TimePeriod.FromDate = mini.clearTime(ex.TimePeriod.FromDate);
                ex.TimePeriod.ToDate = mini.maxTime(ex.TimePeriod.ToDate);
            }
        }

        var data = mini.clone(this.Calendars);

        var projectCalendar = this.getCalendar(project.data.CalendarUID, data);
        projectCalendar.Name = projectCalendar.Name.replace(this.projectSuffixName, '');

        return data;
    },

    validateExceptions: function () {
        var data = this.refs.exceptions.getData();

        function validate(item, index) {
            var from = item.TimePeriod.FromDate,
                to = item.TimePeriod.ToDate;

            if (!from) {
                alert('例外日期 #' + (index + 1) + ' 的开始时间不能为空值');
                return false;
            }
            if (!to) {
                alert('例外日期 #' + (index + 1) + ' 的完成时间不能为空值');
                return false;
            }

            if (from > to) {
                alert('例外日期 #' + (index + 1) + ' 的开始时间不能大于完成时间');
                return;
            }

            from = mini.clearTime(from);
            to = mini.clearTime(to);

            for (var i = 0, l = index - 1; i <= l; i++) {
                var ex = data[i];
                var ex_from = mini.clearTime(ex.TimePeriod.FromDate),
                    ex_to = mini.clearTime(ex.TimePeriod.ToDate);

                if (to < ex_from || from > ex_to) {
                } else {
                    alert('例外日期 #' + (index + 1) + ' 与 #' + (i + 1) + ' 时间冲突');
                    return false;
                }
            }

            return true;
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var item = data[i];
            if (!validate(item, i)) return false;
        }

        return true;
    },

    onOkClick: function (event) {
        var project = this.project;

        if (!this.validateExceptions()) {
            return;
        }

        var data = this.getData();

        var action = new PlusProject.ChangeCalendarsAction(project, data);
        project.executeAction(action);

        this.close('ok');
    },

    onCancelClick: function (event) {
        var project = this.project;

        this.close('cancel');
    }
});

PlusProject.createDefaultCalendar = function () {
    return {
        WeekDays: [
            {
                DayWorking: 0,
                DayType: 1
            },
            {
                DayWorking: 1,
                DayType: 2,
                WorkingTimes: [
                    {
                        FromTime: '08:00:00',
                        ToTime: '12:00:00'
                    },
                    {
                        FromTime: '13:00:00',
                        ToTime: '17:00:00'
                    }
                ]
            },
            {
                DayWorking: 1,
                DayType: 3,
                WorkingTimes: [
                    {
                        FromTime: '08:00:00',
                        ToTime: '12:00:00'
                    },
                    {
                        FromTime: '13:00:00',
                        ToTime: '17:00:00'
                    }
                ]
            },
            {
                DayWorking: 1,
                DayType: 4,
                WorkingTimes: [
                    {
                        FromTime: '08:00:00',
                        ToTime: '12:00:00'
                    },
                    {
                        FromTime: '13:00:00',
                        ToTime: '17:00:00'
                    }
                ]
            },
            {
                DayWorking: 1,
                DayType: 5,
                WorkingTimes: [
                    {
                        FromTime: '08:00:00',
                        ToTime: '12:00:00'
                    },
                    {
                        FromTime: '13:00:00',
                        ToTime: '17:00:00'
                    }
                ]
            },
            {
                DayWorking: 1,
                DayType: 6,
                WorkingTimes: [
                    {
                        FromTime: '08:00:00',
                        ToTime: '12:00:00'
                    },
                    {
                        FromTime: '13:00:00',
                        ToTime: '17:00:00'
                    }
                ]
            },
            {
                DayWorking: 0,
                DayType: 7
            }
        ],
        Name: '标准',
        UID: '1',
        BaseCalendarUID: '-1',
        IsBaseCalendar: 1,
        Exceptions: []
    };
};

PlusProject.ColumnConfigWindow = PlusProject.Window.extend({
    props: {
        allColumns: [],
        columns: [],
        title: '列配置',
        width: 550,
        height: 350,
        footer:
            '<div style="display:flex;">' +
            '<mini-button ref="reset" @click="onResetClick" >恢复默认</mini-button>' +
            '<div style="flex:1"></div>' +
            '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
            '</div>',
        content:
            '<div style="display:flex;height:100%;">' +
            '<div style="flex:1;">' +
            '<mini-panel height="100%" showHeader="false" showToolbar="true" bodyStyle="padding:0;">' +
            '<toolbar>' +
            '<div style="font-weight:bold;">可用的列：</div>' +
            '</toolbar>' +
            '<mini-listbox ref="allColumns" @itemdblclick="handleRight" style="height:100%;width:100%;" borderStyle="border:0">' +
            '</mini-listbox>' +
            '</mini-panel>' +
            '</div>' +
            '<div style="display:flex;flex-direction: column;justify-content:center;padding:4px;width:60px;">' +
            '<mini-button @click="handleRight" text=">" style="margin:2px 0;"></mini-button>' +
            '<mini-button @click="handleLeft" text="<" style="margin:2px 0;"></mini-button>' +
            '<mini-button @click="handleRightAll" text=">>" style="margin:2px 0;"></mini-button>' +
            '<mini-button @click="handleLeftAll" text="<<" style="margin:2px 0;"></mini-button>' +
            '</div>' +
            '<div style="flex:1">' +
            '<mini-panel height="100%" showHeader="false" showToolbar="true" bodyStyle="padding:0;">' +
            '<toolbar>' +
            '<div style="font-weight:bold;">已选的列：</div>' +
            '</toolbar>' +
            '<mini-listbox ref="currentColumns" @itemdblclick="handleLeft" style="height:100%;width:100%;" borderStyle="border:0">' +
            '</mini-listbox>' +
            '</mini-panel>' +
            '</div>' +
            '<div style="display:flex;flex-direction: column;justify-content:center;padding:4px;width:60px;">' +
            '<mini-button @click="handleUp" text="向上" style="margin:2px 0;"></mini-button>' +
            '<mini-button @click="handleDown" text="向下" style="margin:2px 0;"></mini-button>' +
            '</div>' +
            '</div>'
    },

    setData: function () {
        this.currentColumns = this.project.getConfigColumns();
        this.allColumns = this.createAllColumns(this.currentColumns);

        this.refresh();
    },

    refresh: function () {
        this.refs.allColumns.setData(this.allColumns);
        this.refs.currentColumns.setData(this.currentColumns);
    },

    createAllColumns: function (currentColumns) {
        var allColumns = PlusProject.ConfigColumns.clone();

        function hasCurrentColumn(name) {
            var item = PlusProject.getConfigColumn(name, currentColumns);
            return !!item;
        }

        for (var i = allColumns.length - 1; i >= 0; i--) {
            var column = allColumns[i];

            if (hasCurrentColumn(column.name)) {
                allColumns.removeAt(i);
            }
        }
        return allColumns;
    },

    handleRight: function () {
        var item = this.refs.allColumns.getSelected();
        var index = this.allColumns.indexOf(item);
        if (item) {
            this.allColumns.remove(item);
            this.currentColumns.push(item);
            this.refresh();

            item = this.allColumns[index];
            if (!item) item = this.allColumns[index - 1];
            this.refs.allColumns.setSelected(item);
        }
    },

    handleLeft: function () {
        var item = this.refs.currentColumns.getSelected();
        var index = this.currentColumns.indexOf(item);
        if (item) {
            this.currentColumns.remove(item);
            this.allColumns = this.createAllColumns(this.currentColumns);
            this.refresh();

            item = this.currentColumns[index];
            if (!item) item = this.currentColumns[index - 1];
            this.refs.currentColumns.setSelected(item);
        }
    },

    handleRightAll: function () {
        this.currentColumns = this.currentColumns.concat(this.allColumns);
        this.allColumns.length = 0;
        this.refresh();
    },

    handleLeftAll: function () {
        this.currentColumns = [];
        this.allColumns = PlusProject.ConfigColumns.clone();
        this.refresh();
    },

    handleUp: function () {
        var item = this.refs.currentColumns.getSelected();
        var index = this.currentColumns.indexOf(item);
        if (item && index > 0) {
            this.currentColumns.removeAt(index);
            this.currentColumns.insert(index - 1, item);
            this.refresh();
            this.refs.currentColumns.setSelected(item);
        }
    },

    handleDown: function () {
        var item = this.refs.currentColumns.getSelected();
        var index = this.currentColumns.indexOf(item);
        if (item) {
            this.currentColumns.insert(index + 2, item);
            this.currentColumns.removeAt(index);
            this.refresh();
            this.refs.currentColumns.setSelected(item);
        }
    },

    onOkClick: function (e) {
        var project = this.project;

        var columns = this.currentColumns;

        if (columns.length <= project.tableView.frozenEndColumn + 1) {
            project.unfrozenColumn();
        }

        var action = new PlusProject.ChangeConfigColumnsAction(project, columns);
        project.executeAction(action);

        this.close('ok');
    },

    onResetClick: function () {
        this.currentColumns = this.project.defaultConfigColumns.clone();
        this.allColumns = this.createAllColumns(this.currentColumns);
        this.refresh();
        this.onOkClick();
    }
});

PlusProject.ConfigColumns = [
    {
        name: 'checkcolumn',
        text: '选择列',
        column: function (config) {
            return $.extend({ type: 'checkcolumn' }, config);
        }
    },
    { name: 'ID', text: 'ID', column: PlusProject.IDColumn },
    { name: 'Name', text: '名称', column: PlusProject.NameColumn },
    { name: 'Manual', text: '任务模式', column: PlusProject.ManualColumn },
    { name: 'TaskType', text: '任务类型', column: PlusProject.TaskTypeColumn },
    { name: 'PredecessorLink', text: '前置关系', column: PlusProject.PredecessorLinkColumn },
    { name: 'Duration', text: '工期', column: PlusProject.DurationColumn },
    { name: 'Work', text: '工时', column: PlusProject.WorkColumn },
    { name: 'PercentComplete', text: '完成百分比', column: PlusProject.PercentCompleteColumn },
    { name: 'Assignments', text: '资源分配', column: PlusProject.AssignmentsColumn },
    { name: 'Start', text: '开始时间', column: PlusProject.StartColumn },
    { name: 'Finish', text: '完成时间', column: PlusProject.FinishColumn },
    { name: 'ActualStart', text: '实际开始时间', column: PlusProject.ActualStartColumn },
    { name: 'ActualFinish', text: '实际完成时间', column: PlusProject.ActualFinishColumn },
    { name: 'BaselineStart', text: '基线开始时间', column: PlusProject.BaselineStartColumn },
    { name: 'BaselineFinish', text: '基线完成时间', column: PlusProject.BaselineFinishColumn },
    { name: 'EarlyStart', text: '最早开始时间', column: PlusProject.EarlyStartColumn },
    { name: 'EarlyFinish', text: '最早完成时间', column: PlusProject.EarlyFinishColumn },
    { name: 'LateStart', text: '最晚开始时间', column: PlusProject.LateStartColumn },
    { name: 'LateFinish', text: '最晚完成时间', column: PlusProject.LateFinishColumn },
    { name: 'TotalSlack', text: '可宽延的总时间', column: PlusProject.TotalSlackColumn },
    { name: 'Critical', text: '关键任务', column: PlusProject.CriticalColumn },
    { name: 'ConstraintType', text: '限制类型', column: PlusProject.ConstraintTypeColumn },
    { name: 'ConstraintDate', text: '限制日期', column: PlusProject.ConstraintDateColumn },
    { name: 'Deadline', text: '最后期限', column: PlusProject.DeadlineColumn },
    { name: 'WBS', text: 'WBS', column: PlusProject.WBSColumn },
    { name: 'TaskStatus', text: '任务状态', column: PlusProject.TaskStatusColumn },
    { name: 'Department', text: '部门', column: PlusProject.DepartmentColumn },
    { name: 'Principal', text: '负责人', column: PlusProject.PrincipalColumn }
];

PlusProject.setConfigColumns = function (project, configColumns) {
    var columns = [];
    for (var i = 0, l = configColumns.length; i < l; i++) {
        var item = configColumns[i];
        if (!item) continue;
        var name = item.name || item;
        var columnColumn = PlusProject.getConfigColumn(name);

        var config = {};
        if (item.width) config.width = item.width;

        var tableColumn = columnColumn.column(config);

        columns.push(tableColumn);
    }
    project.setColumns(columns);
};

PlusProject.getConfigColumn = function (name, _columns) {
    _columns = _columns || PlusProject.ConfigColumns;
    for (var i = 0, l = _columns.length; i < l; i++) {
        var item = _columns[i];

        if (item.name == name) return item;
    }
};

PlusProject.getProjectConfigColumns = function (project) {
    var columns = PlusProject._getConfigColumnsFromTableColumns(project);

    if (!project.defaultConfigColumns) project.defaultConfigColumns = columns.clone();

    return columns;
};

PlusProject.getConfigColumns = PlusProject.getProjectConfigColumns;

PlusProject._getConfigColumnsFromTableColumns = function (project) {
    var columns = [];
    for (var i = 0, l = project.tableView.columns.length; i < l; i++) {
        var item = project.tableView.columns[i];
        var column = PlusProject.getConfigColumn(item.name || item.field || item.type);
        if (column) {
            column = { name: column.name, text: column.text, width: item.width };
            columns.push(column);
        }
    }
    return columns;
};

PlusProject.FilterConfigWindow = PlusProject.Window.extend({
    props: {
        title: '设置过滤条件',
        width: 500,
        height: 'auto',
        highlight: false
    },
    footer:
        '<div style="display:flex;">' +
        '<mini-button ref="reset" @click="onResetClick" >清除过滤</mini-button>' +
        '<div style="flex:1"></div>' +
        '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
        '</div>',
    content:
        '<mini-datagrid ref="grid" width="100%" height="180" showPager="false"' +
        'allowCellEdit="true" allowCellSelect="true" showHGridLines="false" showDirty="false"' +
        '@cellbeginedit="onCellBeginEdit" @drawcell="onDrawCell" @cellcommitedit="onCellCommitEdit"' +
        '>' +
        '<columns>' +
        '<column type="comboboxcolumn" field="relation" header="与/或" width="60">' +
        '<editor>' +
        '<mini-combobox config="{data: PlusProject.Relations}"></mini-combobox>' +
        '</editor>' +
        '</column>' +
        '<column type="comboboxcolumn" field="property" header="字段" width="150">' +
        '<editor>' +
        '<mini-combobox config="{data: PlusProject.FilterTaskFields}"></mini-combobox>' +
        '</editor>' +
        '</column>' +
        '<column type="comboboxcolumn" field="operator" header="条件" width="100">' +
        '<editor>' +
        '<mini-combobox config="{data: PlusProject.FilterOperators}"></mini-combobox>' +
        '</editor>' +
        '</column>' +
        '<column field="value" header="值" width="150">' +
        '<editor>' +
        '<mini-textbox></mini-textbox>' +
        '</editor>' +
        '</column>' +
        '</columns>' +
        '</mini-datagrid>' +
        '<!--<mini-checkbox ref="checkbox">显示相关的摘要行</mini-checkbox>-->',

    setData: function () {
        var data = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}];

        var field = this.highlight ? 'highlightFields' : 'filterFields';

        if (this.highlight) this.refs.reset.setText('清除高亮');

        var fields = this.project[field] || [];

        for (var i = 0, l = fields.length; i < l; i++) {
            var item = fields[i];
            data[i].relation = item.relation;
            data[i].property = item.property;
            data[i].operator = item.operator;
            data[i].value = item.value;
        }

        this.refs.grid.setData(data);

        this.refresh();
    },

    getData: function () {
        var data = mini.clone(this.refs.grid.getData());
        for (var i = data.length - 1; i >= 0; i--) {
            var item = data[i];
            if (!item.property || !item.operator) {
                data.removeAt(i);
            } else {
                if (!item.relation && i > 0) item.relation = 'and';
            }
        }
        return data;
    },

    onCellCommitEdit: function (e) {
        if (e.field == 'property') {
            var item = e.record;

            if (!item.relation && e.rowIndex != 0) item.relation = 'and';
            if (!item.operator) item.operator = '==';
        }
    },

    onCellBeginEdit: function (e) {},

    onDrawCell: function (e) {},

    refresh: function () {},

    onOkClick: function (event) {
        var project = this.project;

        var fields = this.getData();

        var action = new PlusProject.FilterAction(project, fields);

        if (this.highlight) {
            action = new PlusProject.HighlightAction(project, fields);
        }

        project.executeAction(action);

        this.close('ok');
    },

    onResetClick: function () {
        var data = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}];
        this.refs.grid.setData(data);
        this.refresh();

        this.onOkClick();
    }
});

PlusProject.Relations = [
    { id: 'and', text: '与' },
    { id: 'or', text: '或' }
];

PlusProject.FilterOperators = [
    { id: '!=', text: '不等于' },
    { id: '==', text: '等于' },
    { id: '>', text: '大于' },
    { id: '>=', text: '大于或等于' },
    { id: '<', text: '小于' },
    { id: '<=', text: '小于或等于' },
    { id: 'like', text: '包含' },
    { id: 'notlike', text: '不包含' }
];

PlusProject.FilterTaskFields = [
    { id: '', text: '' },
    { id: 'ID', text: 'ID', type: 'number' },
    { id: 'Name', text: '名称' },
    { id: 'Duration', text: '工期', type: 'number' },
    { id: 'Work', text: '工时', type: 'number' },
    { id: 'PercentComplete', text: '完成百分比', type: 'number' },
    { id: 'Start', text: '开始时间', type: 'date' },
    { id: 'Finish', text: '完成时间', type: 'date' },
    { id: 'ActualStart', text: '实际开始时间', type: 'date' },
    { id: 'ActualFinish', text: '实际完成时间', type: 'date' },
    { id: 'Deadline', text: '最后期限', type: 'date' },
    { id: 'Summary', text: '摘要任务', type: 'boolean' },
    { id: 'Milestone', text: '里程碑', type: 'boolean' },
    { id: 'Critical', text: '关键任务', type: 'boolean' },
    { id: 'TotalSlack', text: '可宽延的总时间', type: 'number' },
    { id: 'PredecessorLink', text: '前置任务' },
    { id: 'Assignments', text: '资源名称' },
    { id: 'TaskStatus', text: '任务状态' },
    { id: 'Department', text: '部门' },
    { id: 'Principal', text: '负责人' },
    { id: 'Note', text: '备注' }
];

PlusProject.getItemById = function (id, data, idField) {
    idField = idField || 'id';
    for (var i = 0, l = data.length; i < l; i++) {
        var item = data[i];
        if (item[idField] == id) return item;
    }
};

PlusProject.getFilterTaskField = function (id) {
    return PlusProject.getItemById(id, PlusProject.FilterTaskFields, 'id');
};

PlusProject.GroupConfigWindow = PlusProject.Window.extend({
    props: {
        title: '设置分组条件',
        width: 500,
        height: 'auto',
        highlight: false
    },
    footer:
        '<div style="display:flex;">' +
        '<mini-button ref="reset" @click="onResetClick" >清除分组</mini-button>' +
        '<div style="flex:1"></div>' +
        '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
        '</div>',
    content:
        '<mini-datagrid ref="grid" width="100%" height="180" showPager="false"' +
        'allowCellEdit="true" allowCellSelect="true" showHGridLines="false" showDirty="false"' +
        '@cellendedit="onCellEndEdit"' +
        '>' +
        '<columns>' +
        '<column type="comboboxcolumn" field="property" header="分组字段" width="150">' +
        '<editor>' +
        '<mini-combobox config="{data: PlusProject.GroupTaskFields}"></mini-combobox>' +
        '</editor>' +
        '</column>' +
        '<column type="comboboxcolumn" field="direction" header="顺序" width="80">' +
        '<editor>' +
        '<mini-combobox config="{data: PlusProject.SortOrders}"></mini-combobox>' +
        '</editor>' +
        '</column>' +
        '<column field="style" header="样式" width="100">' +
        '<editor>' +
        '<mini-textbox></mini-textbox>' +
        '</editor>' +
        '</column>' +
        '<column field="color" header="颜色" width="100">' +
        '<editor>' +
        '<mini-textbox></mini-textbox>' +
        '</editor>' +
        '</column>' +
        '</columns>' +
        '</mini-datagrid>' +
        '<mini-checkbox ref="showSummary">显示摘要任务</mini-checkbox>' +
        '<!--<mini-checkbox ref="keepTree">维护层次结构</mini-checkbox>-->',

    onCellEndEdit: function (e) {
        if (e.field == 'property') {
            if (e.value && !e.record.direction) {
                var index = e.rowIndex % 4;
                e.sender.updateRow(e.record, { direction: 'asc', color: PlusProject.GroupColors[index], font: '' });
            }
        }
    },

    setData: function () {
        var data = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}];

        var fields = this.project.groupFields || [];

        for (var i = 0, l = fields.length; i < l; i++) {
            var item = fields[i];
            data[i].property = item.property;
            data[i].direction = item.direction;
            data[i].color = item.color;
            data[i].style = item.style;
        }

        this.refs.grid.setData(data);

        this.refresh();
    },

    getData: function () {
        var data = mini.clone(this.refs.grid.getData());
        for (var i = data.length - 1; i >= 0; i--) {
            var item = data[i];
            if (!item.property || !item.direction) {
                data.removeAt(i);
            }
        }
        return data;
    },

    refresh: function () {},

    onOkClick: function (event) {
        var project = this.project;

        var fields = this.getData();

        var action = new PlusProject.GroupAction(project, fields, this.refs.showSummary.getChecked());

        project.executeAction(action);

        this.close('ok');
    },

    onResetClick: function () {
        var data = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}];
        this.refs.grid.setData(data);
        this.refresh();

        this.onOkClick();
    }
});

PlusProject.Relations = [
    { id: 'and', text: '与' },
    { id: 'or', text: '或' }
];

PlusProject.SortOrders = [
    { id: 'asc', text: '顺序' },
    { id: 'desc', text: '倒序' }
];

PlusProject.GroupColors = ['#FFF6C1', '#D2EEFF', '#D3F5CC', '#E1E3FA'];

PlusProject.GroupTaskFields = [
    { id: '', text: '' },
    { id: 'Duration', text: '工期', type: 'number' },
    { id: 'Work', text: '工时', type: 'number' },
    { id: 'PercentComplete', text: '完成百分比', type: 'number' },
    { id: 'Start', text: '开始时间', type: 'date' },
    { id: 'Finish', text: '完成时间', type: 'date' },
    { id: 'ActualStart', text: '实际开始时间', type: 'date' },
    { id: 'ActualFinish', text: '实际完成时间', type: 'date' },

    { id: 'Summary', text: '摘要任务', type: 'number' },
    { id: 'Milestone', text: '里程碑', type: 'number' },
    { id: 'Critical', text: '关键任务', type: 'number' },
    { id: 'SlackTime', text: '可宽延时间', type: 'number' },
    { id: 'TaskStatus', text: '任务状态' },
    { id: 'Department', text: '部门' },
    { id: 'Principal', text: '负责人' }
];

PlusProject.getGroupTaskField = function (id) {
    return PlusProject.getItemById(id, PlusProject.GroupTaskFields, 'id');
};

PlusProject.ImportProjectWindow = PlusProject.Window.extend({
    props: {
        title: '导入项目',
        width: 350,
        height: 'auto'
    },

    footer:
        '<mini-button ref="ok" @click="onOkClick" style="margin-right:10px;">导入项目</mini-button>' +
        '<mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>',

    content:
        '<div style="padding:10px">' +
        '<form id="form1" enctype="multipart/form-data" method="post">' +
        '<div>' +
        '<input type="hidden" name="type" value="importProject"/>' +
        '<input type="file" name="Fdata" />' +
        '<div style="font-size:13px;margin-top:5px;">请选择导入微软Project的XML文件。</div>' +
        '<div style="font-size:11px;margin-top:5px;color:blue;text-decoration:underline;">购买后支持MPP文件的导入功能，可以在<a href="http://www.plusgantt.com/project/demo/ProjectApp.html" target="_blank" style="font-weight:bold;color:blue;margin-left:4px;">这里体验</a>。</div>' +
        '</div>' +
        '</form>' +
        '</div>',

    onOkClick: function (e) {
        var me = this;
        var project = this.project;

        function fn() {
            var form = $('#form1', this.el)[0];
            form.action = ProjectApiUrl;

            var formData = new FormData(form);

            function onComplete(event) {
                var text = event.target.response;

                if (!text) {
                    alert('导入项目失败');
                    return;
                }

                var result = mini.decode(text);
                if (result.success) {
                    var data = result.data;
                    data.UID = '';
                    project.loadData(data);
                    project.lastScheduleDate = new Date(new Date()?.getTime() + 1);

                    me.close('ok');
                    alert('项目导入成功');
                } else {
                    alert('导入项目失败\n' + result.message + '\n' + result.stackTrace);
                }
            }

            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', onComplete, false);
            xhr.open('POST', form.action + '?type=importProject');
            xhr.send(formData);
        }

        if (project.isDataChanged()) {
            if (confirm('是否保存当前项目？')) {
                PlusProject.api.saveProject(project, fn);
            } else {
                fn();
            }
        } else {
            fn();
        }
    }
});

PlusProject.ExportProjectWindow = PlusProject.Window.extend({
    props: {
        title: '导出项目',
        width: 350,
        height: 'auto'
    },
    footer:
        '<div style="display:flex;">' +
        '<mini-button ref="mpp" @click="onMppClick" style="margin-right:10px;" _visible="false">导出MPP</mini-button>' +
        '<div style="flex:1"></div>' +
        '<mini-button ref="ok" @click="onOkClick" style="margin-right:10px;">导出XML</mini-button>' +
        '<mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
        '</div>',
    content:
        '<div style="padding:10px;font-size:13px;">' +
        '<form id="form1" enctype="multipart/form-data" method="post">' +
        '<table style="width:100%">' +
        '<tr>' +
        '<td style="width:80px;vertical-align:top;">项目名称：</td>' +
        '<td><span ref="name"></span></td>' +
        '</tr>' +
        '</table>' +
        '<div>' +
        '<div style="margin-top:5px;color:#999;">当前只支持导出为微软Project的XML文件。</div>' +
        '</div>' +
        '</form>' +
        '</div>',

    constructor: function (options) {
        mini.Window.call(this, options);
        this.setData();
    },

    setData: function () {
        this.refs.name.html(this.project.data.Name);
    },

    exportProject: function (filetype) {
        var project = this.project;
        var me = this;

        function fn() {
            var downloadURL = ProjectApiUrl + '?type=exportProject&id=' + project.data.UID + '&filetype=' + filetype;
            var iframe = document.createElement('iframe');
            iframe.name = 'download';
            iframe.style.display = 'none';
            document.body.appendChild(iframe);

            function createForm() {
                return jQuery('<form />')
                    .attr({
                        method: 'post',
                        action: downloadURL,
                        enctype: 'multipart/form-data',
                        target: iframe.name
                    })
                    .hide()
                    .appendTo('body');
            }

            form = createForm();

            var data = mini.encode(project.data);
            var input = $('<input type="hidden" name="data" value="' + data + '"/>').appendTo(form);
            input[0].value = data;

            form.submit();

            function removeForm() {
                document.body.removeChild(iframe);
                form.remove();
            }

            var time = filetype == 'mpp' ? 5000 : 1500;

            setTimeout(function () {
                setTimeout(removeForm, 20000);
                me.close('ok');
            }, time);
        }

        if (project.isDataChanged()) {
            if (confirm('是否保存当前项目？')) {
                PlusProject.api.saveProject(project, fn);
            } else {
                fn();
            }
        } else {
            fn();
        }
    },

    onMppClick: function () {
        this.exportProject('mpp');
    },

    onOkClick: function (e) {
        this.exportProject('xml');
    }
});

PlusProject.MoveProjectWindow = PlusProject.Window.extend({
    props: {
        title: '移动项目',
        width: 400,
        height: 'auto'
    },

    content:
        '<table style="margin-bottom:10px;">' +
        '<tr>' +
        '<td style="width:150px;">原来的项目开始日期：</td>' +
        '<td><span ref="start"></span></td>' +
        '</tr>' +
        '<tr>' +
        '<td>新的项目开始日期：</td>' +
        '<td><mini-datepicker ref="date" width="180"></mini-datepicker></td>' +
        '</tr>' +
        '</table>',

    setData: function () {
        var text = mini.formatDate(this.project.data.StartDate, 'yyyy-MM-dd');
        this.refs.start.html(text);
    },

    onOkClick: function (event) {
        var project = this.project;

        var date = this.refs.date.getValue();
        if (!date) {
            alert('请输入正确的日期值');
            return;
        }

        var action = new PlusProject.MoveProjectAction(project, date);
        project.executeAction(action);

        this.close('ok');
    }
});

PlusProject.PredecessorLinkWindow = PlusProject.Window.extend({
    props: {
        title: '任务相关性',
        width: 380,
        height: 'auto',

        footerStyle: 'display:flex;padding:8px;padding-right:10px;',
        footer:
            '<mini-button ref="del" @click="onDelClick" width="60" style="margin-right:0px;">删除</mini-button>' +
            '<div style="flex:1"></div>' +
            '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button>' +
            '<mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>'
    },

    content:
        '<table style="width:100%">' +
        '<tr>' +
        '<td style="width:50px">从：</td>' +
        '<td ref="from"></td>' +
        '</tr>' +
        '<tr>' +
        '<td>到：</td>' +
        '<td ref="to"></td>' +
        '</tr>' +
        '<tr>' +
        '<td>类型：</td>' +
        '<td>' +
        '<mini-combobox ref="linkType" width="160" valueField=\'ID\' textField=\'Name\'></mini-combobox>' +
        '</td>' +
        '<td>延隔时间：</td>' +
        '<td>' +
        '<mini-spinner ref="linkLag" width="60"></mini-spinner>' +
        '</td>' +
        '</tr>' +
        '</table>',

    setData: function (link) {
        this.link = link;

        var from = this.project.getTask(link.TaskUID);
        var to = this.project.getTask(link.PredecessorUID);

        this.from = from;
        this.to = to;

        this.refs.linkType.setData(mini.Gantt.PredecessorLinkType);

        this.refs.from.html(from.Name);
        this.refs.to.html(to.Name);
        this.refs.linkLag.setValue(link.LinkLag);
        this.refs.linkType.setValue(link.Type);
    },

    getData: function () {
        return {
            TaskUID: this.link.TaskUID,
            PredecessorUID: this.link.PredecessorUID,
            LinkLag: this.refs.linkLag.getValue(),
            Type: this.refs.linkType.getValue()
        };
    },

    onOkClick: function (e) {
        var project = this.project;
        var link = this.getData();
        var links = mini.clone(this.from.PredecessorLink);

        var changed = false;

        links.map(function (item) {
            if (item.PredecessorUID == link.PredecessorUID) {
                if (item.LinkLag != link.LinkLag || item.Type != link.Type) {
                    item.LinkLag = link.LinkLag;
                    item.Type = link.Type;
                    changed = true;
                }
            }
        });

        if (changed) {
            var action = new PlusProject.UpdateTaskAction(project, this.from, 'PredecessorLink', links);
            project.executeAction(action);
        }

        this.close('ok');
    },

    onDelClick: function (e) {
        var project = this.project;
        var link = this.link;

        if (project.undoManager) {
            var links = this.from.PredecessorLink.filter(function (item) {
                return item.PredecessorUID != link.PredecessorUID;
            });
            var action = new PlusProject.UpdateTaskAction(project, this.from, 'PredecessorLink', links);
            project.undoManager.execute(action);
        } else {
            this.project.removeLink(this.from, this.to);
        }

        this.close('del');
    }
});
PlusProject.PrintProjectWindow = PlusGantt.PrintGanttWindow.extend({});

PlusProject.ProgressLineWindow = PlusProject.Window.extend({
    props: {
        title: '进度线',
        width: 320,
        height: 'auto'
    },

    content:
        '<div style="padding-left:8px;padding-bottom:2px;">' +
        '<mini-checkbox ref="show" @click="handleShow">显示</mini-checkbox>' +
        '<div style="padding-left:15px;">' +
        '<label><input @change="handleSelect" type="radio" name="progressline" value="currentDate" checked="true" disabled/> 当前日期</label> <span ref="currentDate" style="margin-left:6px;">2022年08月25日</span><br/>' +
        '<label><input @change="handleSelect" type="radio" name="progressline" value="customDate" disabled/> 选择日期</label> <mini-datepicker ref="customDate" style="margin-left:6px;" enabled="false" @change="handleDateChange"></mini-datepicker></br>' +
        '</div>' +
        '</div>',

    refresh: function () {
        var data = this.data;

        var s = mini.formatDate(new Date(), 'yyyy-MM-dd');
        this.refs.currentDate.html(s);
        this.refs.show.setValue(data.visible);
        this.refs.customDate.setValue(data.date);
        this.refs.customDate.setEnabled(data.type == 'customDate' && data.visible);
        this.refs.customDate.setViewDate(this.project.data.StartDate);

        jQuery('[name=progressline]', this.el).each(function () {
            this.disabled = !data.visible;
            if (this.value == data.type) {
                this.checked = true;
            }
        });
    },

    setData: function () {
        this.data = mini.clone(this.project.progressLine);
        this.refresh();
    },

    getData: function () {
        return this.data;
    },

    handleShow: function (e) {
        this.data.visible = this.refs.show.getChecked();

        this.refresh();
    },

    handleSelect: function (e) {
        var data = this.data;
        jQuery('[name=progressline]', this.el).each(function () {
            if (this.checked) {
                data.type = this.value;
            }
        });
        this.refresh();
    },

    handleDateChange: function (e) {
        var value = e.value;
        this.data.date = value;
        this.refresh();
    },

    onOkClick: function (e) {
        var project = this.project;
        var progressLine = this.getData();

        var action = new PlusProject.setProgressLineAction(project, progressLine);
        project.executeAction(action);

        this.close('ok');
    }
});
PlusProject.SortConfigWindow = PlusProject.Window.extend({
    props: {
        title: '排序',
        width: 350,
        height: 'auto'
    },
    footer:
        '<div style="display:flex;">' +
        '<mini-button ref="reset" @click="onResetClick" >清除排序</mini-button>' +
        '<div style="flex:1"></div>' +
        '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
        '</div>',
    content:
        '<table>' +
        '<tr>' +
        '<td style="width:80px;">主要关键字：</td>' +
        '<td ><mini-combobox ref="field1" width="140" @change="refresh"></mini-combobox></td>' +
        '<td>' +
        '<select ref="order1" class="mini-radiobuttonlist">' +
        '<option value="asc">升序</option>' +
        '<option value="desc">降序</option>' +
        '</select>' +
        '</td>' +
        '</tr>' +
        '<tr>' +
        '<td>次要关键字：</td>' +
        '<td ><mini-combobox ref="field2" width="140" @change="refresh"></mini-combobox></td>' +
        '<td>' +
        '<select ref="order2" class="mini-radiobuttonlist">' +
        '<option value="asc">升序</option>' +
        '<option value="desc">降序</option>' +
        '</select>' +
        '</td>' +
        '</tr>' +
        '<tr>' +
        '<td>第三关键字：</td>' +
        '<td ><mini-combobox ref="field3" width="140"></mini-combobox></td>' +
        '<td>' +
        '<select ref="order3" class="mini-radiobuttonlist">' +
        '<option value="asc">升序</option>' +
        '<option value="desc">降序</option>' +
        '</select>' +
        '</td>' +
        '</tr>' +
        '</table>',

    setData: function () {
        var fields = PlusProject.SortTaskFields.clone();
        fields.unshift({ id: '', text: '' });

        this.refs.field1.setData(fields);
        this.refs.field2.setData(fields);
        this.refs.field3.setData(fields);

        var sortFields = this.project.sortFields || [];

        this.refs.field1.setValue(sortFields[0] ? sortFields[0].property : '');
        this.refs.order1.setValue(sortFields[0] ? sortFields[0].direction : 'asc');

        this.refs.field2.setValue(sortFields[1] ? sortFields[1].property : '');
        this.refs.order2.setValue(sortFields[1] ? sortFields[1].direction : 'asc');

        this.refs.field3.setValue(sortFields[2] ? sortFields[2].property : '');
        this.refs.order3.setValue(sortFields[2] ? sortFields[2].direction : 'asc');

        this.refresh();
    },

    refresh: function () {
        this.refs.field2.setEnabled(this.refs.field1.getValue() != '');
        this.refs.field3.setEnabled(this.refs.field2.getValue() != '' && this.refs.field2.enabled);
    },

    getData: function () {
        var fields = [];
        for (var i = 1; i <= 3; i++) {
            var property = this.refs['field' + i].getValue();
            var direction = this.refs['order' + i].getValue();
            if (property == '') {
                break;
            }
            fields.push({ property: property, direction: direction });
        }
        return fields;
    },

    onOkClick: function (event) {
        var project = this.project;

        var fields = this.getData();

        var action = new PlusProject.SortAction(project, fields);
        project.executeAction(action);

        this.close('ok');
    },

    onResetClick: function () {
        this.refs.field1.setValue('');
        this.refs.order1.setValue('asc');
        this.refs.field2.setValue('');
        this.refs.order2.setValue('asc');
        this.refs.field3.setValue('');
        this.refs.order3.setValue('asc');
        this.refresh();
        this.onOkClick();
    }
});

PlusProject.SortTaskFields = [
    { id: 'ID', text: 'ID' },
    { id: 'Name', text: '名称' },

    { id: 'Duration', text: '工期' },
    { id: 'Work', text: '工时' },
    { id: 'PercentComplete', text: '完成百分比' },
    { id: 'Start', text: '开始时间' },
    { id: 'Finish', text: '完成时间' },
    { id: 'ActualStart', text: '实际开始时间' },
    { id: 'ActualFinish', text: '实际完成时间' },
    { id: 'TotalSlack', text: '可宽延的总时间', type: 'number' }
];

PlusProject.ProjectTemplateWindow = PlusProject.Window.extend({
    props: {
        title: '项目模板列表',
        width: 580,
        height: 'auto'
    },
    footer:
        '<div style="display:flex;">' +
        '<mini-button @click="onDelClick" style="margin-right:10px;">删除项目模板</mini-button>' +
        '<mini-button @click="onEditClick" >编辑项目模板名称</mini-button>' +
        '<div style="flex:1"></div>' +
        '<mini-button ref="ok" @click="onOkClick" style="margin-right:10px;">新建项目</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
        '</div>',
    content:
        '<mini-datagrid ref="grid" width="100%" height="220" showPager="false" showDirty="false"' +
        '>' +
        '<columns>' +
        '<column field="name" header="项目模板名称" width="200"></column>' +
        '<column field="lastupdatedate" header="最后保存日期" width="120" dateFormat="yyyy-MM-dd HH:mm:ss"></column>' +
        '</columns>' +
        '</mini-datagrid>',

    setData: function () {
        var me = this;
        me.mask('项目模板加载中...');
        PlusProject.api.listTemplate(1, function (success, result) {
            if (success) {
                me.refs.grid.setData(result.data);
            }
            me.unmask();
        });
    },

    refresh: function () {},

    onOkClick: function (event) {
        var me = this;
        var project = this.project;

        var fields = this.getData();

        var item = this.refs.grid.getSelected();

        if (!item) {
            alert('请先选择一个要新建的项目模板');
            return;
        }

        function clearProjectActural(project) {
            var tasks = project.getTaskList();
            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];
                task.ActualStart = task.ActualFinish = null;
                task.PercentComplete = 0;
                task.Baseline = null;
            }
        }

        function fn() {
            PlusProject.api.loadTemplate(item.id, function (success, result) {
                if (!success) return;

                var template = result.data;

                var newProject = new PlusProject();

                var d = new Date();
                newProject.data.StartDate = new Date(d?.getFullYear(), d?.getMonth(), d?.getDate());
                newProject.data.FinishDate = new Date(d?.getFullYear(), d?.getMonth() + 3, d?.getDate());

                var win = new PlusProject.ProjectWindow({
                    title: '新建项目 - 从项目模板（' + template.name + '）',
                    mode: 'new',
                    project: newProject,
                    closeHandler: function (action) {
                        if (action == 'ok') {
                            var newData = this.getData();

                            var data = template.data;

                            data = $.extend({}, data, newData, {
                                UID: '',
                                StartDate: data.StartDate,
                                FinishDate: data.FinishDate
                            });

                            project.loadData(data);

                            clearProjectActural(project);

                            project.moveProject(newData.StartDate);

                            project.data.FinishDate = newData.FinishDate;

                            project.acceptChanges();

                            project.lastScheduleDate = new Date(new Date()?.getTime() + 1);
                        }
                    }
                });
                win.setData();
                win.show();

                me.close('ok');
            });
        }

        if (project.isDataChanged()) {
            if (confirm('是否保存当前项目？')) {
                PlusProject.api.saveProject(project, fn);
            } else {
                fn();
            }
        } else {
            fn();
        }
    },

    onDelClick: function () {
        var me = this;
        var item = this.refs.grid.getSelected();

        if (!item) {
            alert('请先选择一个要删除的项目模板');
            return;
        }

        if (confirm('确定要删除项目模板“' + item.name + '”？\n注意：本操作无法恢复。')) {
            PlusProject.api.deleteTemplate(item.id, function (success) {
                if (success) {
                    me.refs.grid.removeRow(item);
                }
            });
        }
    },

    onEditClick: function (e) {
        var me = this;
        var item = this.refs.grid.getSelected();

        if (!item) {
            alert('请先选择一个项目模板');
            return;
        }

        var win = mini.prompt('项目模板名称：', '修改项目模板名称', function (action, value) {
            if (action == 'ok') {
                PlusProject.api.changeTemplateName(item.id, value, function (success) {
                    if (success) me.refs.grid.updateRow(item, 'name', value);
                });
            }
        });
        win.input.value = item.name;
    }
});

PlusProject.TaskTemplateWindow = PlusProject.Window.extend({
    props: {
        title: '任务模板列表',
        width: 580,
        height: 'auto',
        insertAction: 'before'
    },
    footer:
        '<div style="display:flex;">' +
        '<mini-button @click="onDelClick" style="margin-right:10px;">删除任务模板</mini-button>' +
        '<mini-button @click="onEditClick" >编辑任务模板名称</mini-button>' +
        '<div style="flex:1"></div>' +
        "<mini-combobox ref=\"action\" width=\"60\" config=\"{data: [{id: 'before', text: '节点前'}, {id: 'append', text: '节点内'}]}\"></mini-combobox>" +
        '<mini-button ref="ok" @click="onOkClick" style="margin-right:10px;margin-left:10px;">插入任务模板</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
        '</div>',
    content:
        '<mini-datagrid ref="grid" width="100%" height="220" showPager="false"' +
        '>' +
        '<columns>' +
        '<column field="name" header="任务模板名称" width="200"></column>' +
        '<column field="lastupdatedate" header="最后保存日期" width="120" dateFormat="yyyy-MM-dd HH:mm:ss"></column>' +
        '</columns>' +
        '</mini-datagrid>',

    setData: function () {
        var me = this;
        me.mask('任务模板加载中...');
        PlusProject.api.listTemplate(2, function (success, result) {
            if (success) {
                me.refs.grid.setData(result.data);
            }
            me.unmask();
        });

        this.refs.action.setValue(this.insertAction);
    },

    refresh: function () {},

    onOkClick: function (event) {
        var project = this.project;

        var fields = this.getData();

        var item = this.refs.grid.getSelected();

        if (!item) {
            alert('请先选择一个任务模板');
            return;
        }

        var insertAction = this.refs.action.getValue();

        var me = this;
        PlusProject.api.loadTemplate(item.id, function (success, result) {
            var template = result.data;

            var tasks = template.data;

            PlusProject.generateTaskUID(tasks);

            var targetTask = project.getSelected();

            var action = new PlusProject.InsertTaskAction(project, tasks, insertAction, targetTask);
            project.executeAction(action);

            me.close('ok');
        });
    },

    onDelClick: function () {
        var me = this;
        var item = this.refs.grid.getSelected();

        if (!item) {
            alert('请先选择一个任务模板');
            return;
        }

        if (confirm('确定要删除任务模板“' + item.name + '”？\n注意：本操作无法恢复。')) {
            PlusProject.api.deleteTemplate(item.id, function (success) {
                if (success) {
                    me.refs.grid.removeRow(item);
                }
            });
        }
    },

    onEditClick: function (e) {
        var me = this;
        var item = this.refs.grid.getSelected();

        if (!item) {
            alert('请先选择一个任务模板');
            return;
        }

        var win = mini.prompt('任务模板名称：', '修改任务模板名称', function (action, value) {
            if (action == 'ok') {
                PlusProject.api.changeTemplateName(item.id, item.name, function (success) {
                    if (success) me.refs.grid.updateRow(item, 'name', value);
                });
            }
        });
        win.input.value = item.name;
    }
});

PlusProject.CreateTaskTemplateWindow = PlusProject.Window.extend({
    props: {
        title: '创建任务模板',
        width: 300,
        height: 'auto'
    },

    content:
        '<table style="margin-bottom:0px;">' +
        '<tr>' +
        '<td style="width:100px">任务模板名称：</td>' +
        '<td style="width:180px"><mini-textbox ref="name" width="100%"></mini-textbox></td>' +
        '</tr>' +
        '<tr>' +
        '<td>' +
        '</td>' +
        '<td>' +
        '<mini-checkbox ref="check">包含未选择的子节点</mini-checkbox>' +
        '</td>' +
        '</tr>' +
        '</table>',

    setData: function () {
        var project = this.project;

        this.selectedItems = project.getSelecteds().clone();

        this.refs.check.setChecked(true);
    },

    getData: function () {
        var data = [];
        var hash = {};

        function createNewItem(item) {
            var o = {};
            o.UID = item.UID;
            o.Name = item.Name;
            o.Duration = item.Duration;

            if (item.Milestone) o.Milestone = true;
            if (item.PredecessorLink) o.PredecessorLink = mini.clone(item.PredecessorLink);
            return o;
        }

        function addItem(item) {
            var o = createNewItem(item);

            var parent = hash[item.ParentTaskUID];
            if (parent) {
                if (!parent.children) parent.children = [];
                parent.children.push(o);
            } else {
                data.push(o);
            }
            hash[o.UID] = o;
        }

        function clearPredecessorLinks() {
            for (var UID in hash) {
                var item = hash[UID];
                if (item.PredecessorLink) {
                    for (var i = item.PredecessorLink.length - 1; i >= 0; i--) {
                        var link = item.PredecessorLink[i];
                        if (!hash[link.PredecessorUID]) {
                            item.PredecessorLink.removeAt(i);
                        }
                    }
                }
            }
        }

        this.selectedItems.sort(function (a, b) {
            if (a.ID > b.ID) return 1;
            else if (a.ID < b.ID) return -1;
        });

        var hasChildren = this.refs.check.getChecked();

        function each(items) {
            for (var i = 0, l = items.length; i < l; i++) {
                var item = items[i];
                if (hash[item.UID]) continue;
                addItem(item);
                if (hasChildren && item.children) {
                    each(item.children);
                }
            }
        }

        each(this.selectedItems);

        clearPredecessorLinks();

        return {
            name: this.refs.name.getValue(),
            type: 2,
            data: data
        };
    },

    onOkClick: function (event) {
        var me = this;
        var project = this.project;

        var template = this.getData();

        if (!template.name) {
            alert('任务模板名称不能为空');
            return;
        }

        PlusProject.api.saveTemplate(template, function (success) {
            if (success) {
                alert('任务模板 “' + template.name + '” 创建成功');
            }
            me.close('ok');
        });
    }
});

PlusProject.TimelinesWindow = PlusProject.Window.extend({
    props: {
        title: '设置项目时间线',
        width: 500,
        height: 'auto',
        highlight: false
    },
    footer:
        '<div style="display:flex;">' +
        '<div style="flex:1"></div>' +
        '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
        '</div>',
    content:
        '<mini-datagrid ref="grid" width="100%" height="180" showPager="false"' +
        'allowCellEdit="true" allowCellSelect="true" showHGridLines="false" showDirty="false"' +
        '@cellbeginedit="onCellBeginEdit" @drawcell="onDrawCell"' +
        '>' +
        '<columns>' +
        '<column field="date" header="时间" width="100" dateFormat="yyyy-MM-dd">' +
        '<editor>' +
        '<mini-datepicker></mini-datepicker>' +
        '</editor>' +
        '</column>' +
        '<column field="text" header="文本" width="100">' +
        '<editor>' +
        '<mini-textbox></mini-textbox>' +
        '</editor>' +
        '</column>' +
        '<column type="comboboxcolumn" field="position" header="文本位置" width="100">' +
        '<editor>' +
        "<mini-combobox config=\"{data: [{id:'top', text: '顶部'},{id:'center', text: '居中'},{id:'bottom', text: '底部'}]}\"></mini-combobox>" +
        '</editor>' +
        '</column>' +
        '<column field="width" header="线宽" width="60">' +
        '<editor>' +
        '<mini-spinner minValue="1" maxValue="3"></mini-spinner>' +
        '</editor>' +
        '</column>' +
        '<column field="color" header="颜色" width="100">' +
        '<editor>' +
        '<mini-textbox></mini-textbox>' +
        '</editor>' +
        '</column>' +
        '</columns>' +
        '</mini-datagrid>',

    setData: function () {
        var data = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}];

        var fields = this.project.timeLines || [];

        for (var i = 0, l = fields.length; i < l; i++) {
            var item = fields[i];
            data[i].date = item.date;
            data[i].text = item.text;
            data[i].width = item.width;
            data[i].color = item.color;
            data[i].position = item.position;
        }

        this.refs.grid.setData(data);

        this.refresh();
    },

    getData: function () {
        var data = mini.clone(this.refs.grid.getData());
        for (var i = data.length - 1; i >= 0; i--) {
            var item = data[i];
            if (!item.date) {
                data.removeAt(i);
            }
        }
        return data;
    },

    refresh: function () {},

    onOkClick: function (event) {
        var project = this.project;

        var fields = this.getData();

        var action = new PlusProject.TimeLinesAction(project, fields);

        project.executeAction(action);

        this.close('ok');
    }
});

PlusProject.TimeScaleWindow = PlusProject.Window.extend({
    props: {
        title: '设置时间刻度',
        width: 500,
        height: 280
    },
    footer:
        '<div style="display:flex;">' +
        '<mini-button ref="reset" @click="onResetClick" >恢复默认</mini-button>' +
        '<div style="flex:1"></div>' +
        '<mini-button ref="ok" @click="onOkClick" width="60" style="margin-right:10px;">确定</mini-button> <mini-button ref="cancel" @click="onCancelClick" width="60">取消</mini-button>' +
        '</div>',
    content:
        '<mini-tabs ref="tabs" height="auto" >' +
        '<div title="顶层刻度">' +
        '<table>' +
        '<tr>' +
        '<td style="width:60px">单位：</td>' +
        '<td style="width:150px"><mini-combobox ref="topType" ></mini-combobox></td>' +
        '<td style="width:60px">格式：</td>' +
        '<td>' +
        '<mini-combobox ref="topFormat" visible="false"></mini-combobox>' +
        '<span ref="topFormatText"></span>' +
        '</td>' +
        '</tr>' +
        '<tr>' +
        '<td>计数：</td>' +
        '<td><mini-spinner ref="topNumber" minValue="1" maxValue="10"></mini-spinner></td>' +
        '<td>对齐：</td>' +
        '<td><mini-combobox ref="topAlign"></mini-combobox></td>' +
        '</tr>' +
        '</table>' +
        '</div>' +
        '<div title="中层刻度">' +
        '<table>' +
        '<tr>' +
        '<td style="width:60px">单位：</td>' +
        '<td style="width:150px"><mini-combobox ref="middleType" ></mini-combobox></td>' +
        '<td style="width:60px">格式：</td>' +
        '<td>' +
        '<mini-combobox ref="middleFormat" visible="false"></mini-combobox>' +
        '<span ref="middleFormatText"></span>' +
        '</td>' +
        '</tr>' +
        '<tr>' +
        '<td>计数：</td>' +
        '<td><mini-spinner ref="middleNumber" minValue="1" maxValue="10"></mini-spinner></td>' +
        '<td>对齐：</td>' +
        '<td><mini-combobox ref="middleAlign"></mini-combobox></td>' +
        '</tr>' +
        '</table>' +
        '</div>' +
        '<div title="底层刻度">' +
        '<table>' +
        '<tr>' +
        '<td style="width:60px">单位：</td>' +
        '<td style="width:150px"><mini-combobox ref="bottomType"></mini-combobox></td>' +
        '<td style="width:60px">格式：</td>' +
        '<td>' +
        '<mini-combobox ref="bottomFormat" visible="false"></mini-combobox>' +
        '<span ref="bottomFormatText"></span>' +
        '</td>' +
        '</tr>' +
        '<tr>' +
        '<td>计数：</td>' +
        '<td><mini-spinner ref="bottomNumber" minValue="1" maxValue="10"></mini-spinner></td>' +
        '<td>对齐：</td>' +
        '<td><mini-combobox ref="bottomAlign"></mini-combobox></td>' +
        '</tr>' +
        '</table>' +
        '</div>' +
        '</mini-tabs>' +
        '<fieldset class="fieldset" style="margin-bottom:15px;">' +
        '<legend><span>时间刻度选项</span></legend>' +
        '<div class="fieldset-body">' +
        '<table>' +
        '<tr>' +
        '<td style="width:60px">显示：</td>' +
        '<td style="width:150px"><mini-combobox ref="viewType" width="160" @change="handleViewTypeChange" _enabled="false"></mini-combobox></td>' +
        '<td style="width:60px">比例：</td>' +
        '<td><mini-spinner ref="timelineRatio" maxValue="1000" width="60"></mini-spinner><span style="margin-left:5px;">%</span></td>' +
        '</tr>' +
        '</table>' +
        '</div>' +
        '</fieldset>',

    setData: function () {
        var viewTypeData = [
            { id: 2, text: '两层（顶层、底层）' },
            { id: 3, text: '三层（顶层、中层、底层）' }
        ];
        var alignData = [
            { id: 'left', text: '左' },
            { id: 'center', text: '居中' },
            { id: 'right', text: '右' }
        ];
        var timescaleData = [
            { id: 'year', text: '年' },
            { id: 'halfyear', text: '半年' },
            { id: 'quarter', text: '季度' },
            { id: 'month', text: '月' },
            { id: 'week', text: '周' },
            { id: 'day', text: '日' },
            { id: 'hour', text: '时' }
        ];

        var project = this.project;
        var topTimeScale = project.ganttView.topTimeScale;
        var bottomTimeScale = project.ganttView.bottomTimeScale;
        var middleTimeScale = project.ganttView.middleTimeScale;

        project.getDefaultTimeScales();

        this.topTimeScale = mini.apply({}, topTimeScale);
        this.bottomTimeScale = mini.apply({}, bottomTimeScale);
        this.middleTimeScale = mini.apply({}, middleTimeScale);

        var me = this;
        function updateTimeScale(timescale, position) {
            me.refs[position + 'Type'].setData(timescaleData);
            me.refs[position + 'Align'].setData(alignData);
            me.refs[position + 'Type'].setValue(timescale.type);
            me.refs[position + 'Align'].setValue(timescale.align);
            me.refs[position + 'Number'].setValue(timescale.number);
        }

        updateTimeScale(this.topTimeScale, 'top');
        updateTimeScale(this.middleTimeScale, 'middle');
        updateTimeScale(this.bottomTimeScale, 'bottom');

        this.refs.viewType.setData(viewTypeData);

        var viewType = this.middleTimeScale.visible ? 3 : 2;
        this.refs.viewType.setValue(viewType);
        this.refs.timelineRatio.setValue(this.project.timelineRatio * 100);

        this.refresh();
    },

    getData: function () {
        this.topTimeScale = mini.GanttView.getTimeScale(this.refs.topType.getValue());
        this.bottomTimeScale = mini.GanttView.getTimeScale(this.refs.bottomType.getValue());
        this.middleTimeScale = mini.GanttView.getTimeScale(this.refs.middleType.getValue());

        this.topTimeScale.number = this.refs.topNumber.getValue();
        this.topTimeScale.align = this.refs.topAlign.getValue();

        this.bottomTimeScale.number = this.refs.bottomNumber.getValue();
        this.bottomTimeScale.align = this.refs.bottomAlign.getValue();

        this.middleTimeScale.number = this.refs.middleNumber.getValue();
        this.middleTimeScale.align = this.refs.middleAlign.getValue();

        var viewType = this.refs.viewType.getValue();
        this.middleTimeScale.visible = viewType == 3;

        return {
            topTimeScale: this.topTimeScale,
            bottomTimeScale: this.bottomTimeScale,
            middleTimeScale: this.middleTimeScale,
            timelineRatio: this.refs.timelineRatio.getValue() / 100
        };
    },

    refresh: function () {
        var viewType = this.refs.viewType.getValue();
        this.refs.tabs.updateTab(1, { visible: viewType == 3 });
    },

    handleViewTypeChange: function () {
        this.refresh();
    },

    onOkClick: function (event) {
        var project = this.project;

        var data = this.getData();

        if (data.topTimeScale < data.bottomTimeScale.index) {
            alert('顶层刻度单位不能小于底层刻度单位');
            return;
        }

        var action = new PlusProject.ChangeTimeScaleAction(project, data);
        project.executeAction(action);

        this.close('ok');
    },

    onResetClick: function () {
        var project = this.project;
        var data = this.project.getDefaultTimeScales();

        var action = new PlusProject.ChangeTimeScaleAction(project, data);
        project.executeAction(action);
        this.close('ok');
    }
});
PlusProject.FindReplaceWindow = PlusProject.Window.extend({
    props: {
        title: '查找',
        width: 310,
        height: 'auto',
        showModal: false
    },
    footer:
        '<div style="display:flex;">' +
        '<mini-button ref="replaceMode" @click="onReplaceModeClick" style="margin-right:5px;" width="60" _visible="false">替换...</mini-button>' +
        '<mini-button ref="replace" @click="onReplaceClick" style="margin-right:5px;" visible="false" width="60">替换</mini-button>' +
        '<mini-button ref="replaceAll" @click="onReplaceAllClick" style="margin-right:5px;" visible="false">全部替换</mini-button>' +
        '<div style="flex:1;"></div>' +
        '<mini-button ref="reset" @click="onFindClick" style="margin-right:5px;">查找下一个</mini-button>' +
        '<mini-button ref="cancel" @click="onCancelClick" width="60">关闭</mini-button>' +
        '</div>',
    content:
        '<table>' +
        '<tr>' +
        '<td style="width:80px;">查找内容：</td>' +
        '<td style="width:200px;">' +
        '<mini-textbox ref="text" width="100%"></mini-textbox>' +
        '</td>' +
        '</tr>' +
        '<tr ref="tr1" style="display:none;">' +
        '<td style="width:80px;">替换为：</td>' +
        '<td >' +
        '<mini-textbox ref="replaceText" width="100%"></mini-textbox>' +
        '</td>' +
        '</tr>' +
        '<tr>' +
        '<td>查找列：</td>' +
        '<td ><mini-combobox ref="field" width="100%" config="{data: PlusProject.FindTextFields, value: \'Name\'}"></mini-combobox></td>' +
        '</tr>' +
        '<tr>' +
        '<td>条件：</td>' +
        '<td ><mini-combobox ref="operator" width="100%" config="{data: PlusProject.FilterOperators, value: \'like\'}"></mini-combobox></td>' +
        '</tr>' +
        '<tr>' +
        '<td>' +
        '搜索：' +
        '</td>' +
        '<td>' +
        '<mini-combobox ref="direction" width="60" config="{data: directionData, value: \'down\'}"></mini-combobox>' +
        '<mini-checkbox ref="caseSensitive" style="margin-left:5px;">区分大小写</mini-checkbox>' +
        '</td>' +
        '</tr>' +
        '</table>',

    directionData: [
        { id: 'up', text: '向上' },
        { id: 'down', text: '向下' }
    ],

    defaultFindOptions: {
        text: '',
        replaceText: '',
        field: 'Name',
        operator: 'like',
        direction: 'down',
        caseSensitive: false
    },

    setData: function () {
        var project = this.project;
        var findOptions = project._findOptions || this.defaultFindOptions;

        this.refs.text.setValue(findOptions.text);
        this.refs.replaceText.setValue(findOptions.replaceText);
        this.refs.field.setValue(findOptions.field);
        this.refs.operator.setValue(findOptions.operator);
        this.refs.direction.setValue(findOptions.direction);
        this.refs.caseSensitive.setValue(findOptions.caseSensitive);

        this.refs.text.selectText();
    },

    getData: function () {
        return {
            text: this.refs.text.getValue().trim(),
            replaceText: this.refs.replaceText.getValue().trim(),
            field: this.refs.field.getValue(),
            operator: this.refs.operator.getValue(),
            direction: this.refs.direction.getValue(),
            caseSensitive: this.refs.caseSensitive.getValue()
        };
    },

    onReplaceModeClick: function () {
        this.refs.tr1.show();
        this.refs.replaceMode.hide();
        this.refs.replace.show();
        this.refs.replaceAll.show();
        this.setTitle('替换');
    },

    closeHandler: function () {
        this.project._findOptions = this.getData();
    },

    onReplaceClick: function () {
        var data = this.getData();

        if (data.text == '') {
            alert('查找内容不能为空');
            return;
        }

        if (data.text == data.replaceText) {
            alert('替换内容不能与查找内容相同');
            return;
        }

        PlusProject.replaceText(this.project, data);
    },

    onReplaceAllClick: function () {
        var data = this.getData();

        if (data.text == '') {
            alert('查找内容不能为空');
            return;
        }

        if (data.text == data.replaceText) {
            alert('替换内容不能与查找内容相同');
            return;
        }

        PlusProject.replaceAllText(this.project, data);
    },

    onFindClick: function (event) {
        var project = this.project;

        var data = this.getData();

        if (data.text == '') {
            alert('查找内容不能为空');
            return;
        }

        var result = PlusProject.findText(project, data);

        if (result) {
            var key = JSON.stringify(data);
            if (this._fineKey != key) {
                this._fineKey = key;
                this._firstFindCell = null;
            }

            var cell = project.getCurrentCell();
            if (!this._firstFindCell) {
                this._firstFindCell = cell;
            } else {
                if (this._firstFindCell.record == cell.record && this._firstFindCell.column == cell.column) {
                    setTimeout(function () {
                        alert('已完成项目搜索');
                    }, 30);
                }
            }
        }
    }
});

PlusProject.FindTextFields = PlusProject.FilterTaskFields.clone();
PlusProject.FindTextFields.shift();
PlusProject.FindTextFields.unshift({ id: 'all', text: '全部' });

PlusProject.getFindTextTaskField = function (id) {
    return PlusProject.getItemById(id, PlusProject.FindTextFields, 'id');
};

PlusProject._createReplaceAction = function (project, options, item, column, rowIndex, columnIndex, _showAlert) {
    var table = project.tableView;
    var editor = column.editor;
    if (!editor && column.field != 'Assignments') {
        if (_showAlert !== false) {
            alert('只读列无法替换');
        }
        return false;
    }

    if (rowIndex === undefined) rowIndex = project.store.indexOf(item);
    if (columnIndex === undefined) columnIndex = project.indexOfColumn(column);

    var cellText = PlusProject._getCellText(project, item, column, rowIndex, columnIndex);

    var s1 = cellText,
        s2 = options.text;
    if (!options.caseSensitive) {
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();
    }
    var range = { start: -1, end: -1 };
    range.start = s1.indexOf(s2.toLowerCase());
    range.end = range.start + s2.length;

    var text = cellText.substring(0, range.start) + options.replaceText + cellText.substring(range.end);

    var value;

    if (options.operator != 'like') {
        text = options.replaceText;
    }

    if (editor) {
        if (editor.type == 'textbox' || editor.type == 'textarea') {
            value = text;

            if (column.field == 'PredecessorLink') {
            }
        } else if (editor instanceof mini.Spinner) {
            value = parseFloat(text);
            if (isNaN(value)) {
                if (_showAlert !== false) {
                    alert('替换的值无法转换为数字');
                }
                return false;
            }
        } else if (editor instanceof mini.DatePicker) {
            value = mini.parseDate(text);
            if (!(value instanceof Date)) {
                if (_showAlert !== false) {
                    alert('替换的值无法转换为日期');
                }
                return false;
            }
        } else if (editor instanceof mini.ComboBox) {
            var textArray = text.split(',');
            var values = [];

            for (var i = 0, l = textArray.length; i < l; i++) {
                var v = textArray[i].trim();
                var o = editor.findItemByText(v);
                if (o) {
                    v = o[editor.valueField];
                    if (values.indexOf(v) == -1) {
                        values.push(v);
                    }
                }
            }

            value = values.join(',');
        } else {
        }
    } else {
        if (column.field == 'Assignments') {
            var assignments = mini.clone(item.Assignments);
            for (var i = assignments.length - 1; i >= 0; i--) {
                var as = assignments[i];
                var value = as.ResourceUID;
                var re = project.getResource(value);
                var name = re.Name;

                var newName = name.replace(options.text, options.replaceText);
                if (name != newName) {
                    var newResource = project.getResourceByName(newName);
                    if (newResource) {
                        as.ResourceUID = newResource.UID;

                        if (newResource.Type == 1 && re.Type == 1) {
                        } else {
                            as.Work = 0;
                            as.Cost = 0;
                        }
                    } else {
                        assignments.removeAt(i);
                    }
                }
            }

            value = assignments;
        } else {
            return false;
        }
    }

    var action = new PlusProject.UpdateTaskAction(project, item, column.field, value);

    return action;
};

PlusProject.replaceText = function (project, options) {
    var result = PlusProject.findText(project, options, false);
    var cell = project.getCurrentCell();
    if (result) {
        result = PlusProject._createReplaceAction(project, options, cell.record, cell.column);

        if (result !== false) {
            project.executeAction(result);
            PlusProject.findText(project, options, true, false);
        }
    }
};

PlusProject.replaceAllText = function (project, options) {
    var groupAction = new PlusProject.ProjectGroupAction(project, []);
    var findNext = false;

    var hash = {};

    while (true) {
        var result = PlusProject.findText(project, options, findNext);
        var cell = project.getCurrentCell();
        if (!result) {
            break;
        }
        findNext = true;

        var id = cell.record._id + ':' + cell.column._id;
        if (hash[id]) {
            break;
        }
        hash[id] = true;

        var action = PlusProject._createReplaceAction(project, options, cell.record, cell.column, false);
        groupAction.actions.push(action);
    }
    if (groupAction.actions.length > 0) {
        project.executeAction(groupAction);
    } else {
    }
};

PlusProject.findText = function (project, options, _autoNext, _notFoundAlert) {
    var table = project.tableView,
        store = table.store,
        columns = table.columns;

    var cell = table.getCurrentCell();
    var findNext = true;

    if (!cell) {
        cell = { record: store.getAt(0), column: columns[0] };
        table.setCurrentCell(cell, false);
        findNext = false;
    }

    var rowIndex = store.indexOf(cell.record),
        columnIndex = columns.indexOf(cell.column);

    if (findNext && _autoNext !== false) {
        columnIndex += 1;
    }

    function eachColumn(start, end, row, rowIndex) {
        for (var i = start, l = end; i < l; i++) {
            var column = columns[i];

            if (!column.visible) continue;

            if (options.field != 'all' && options.field != column.field) {
                continue;
            }

            var result = PlusProject._findTextByCell(project, options, row, column, rowIndex, i);
            if (result) {
                cell = { record: row, column: column };
                return result;
            }
        }
    }

    function downItems(rowIndex) {
        function eachItems(start, end) {
            for (var i = start, l = end; i < l; i++) {
                if (i == 0 && project.showProjectSummary) continue;
                var item = store.getAt(i);
                var result = eachColumn(columnIndex, columns.length, item, i);
                if (result) {
                    return result;
                }
                columnIndex = 0;
            }
        }

        var result = eachItems(rowIndex, store.getCount());
        if (!result) {
            result = eachItems(0, rowIndex + 1);
        }
        return result;
    }

    function upItems(rowIndex) {
        function eachItems(start, end) {
            for (var i = start, l = end; i >= l; i--) {
                if (i == 0 && project.showProjectSummary) continue;
                var item = store.getAt(i);
                var result = eachColumn(columnIndex, columns.length, item, i);
                if (result) {
                    return result;
                }
                columnIndex = 0;
            }
        }

        var result = eachItems(rowIndex, 0);
        if (!result) {
            result = eachItems(store.getCount() - 1, rowIndex);
        }
        return result;
    }

    var result;
    if (options.direction == 'down') {
        result = downItems(rowIndex);
    } else {
        result = upItems(rowIndex);
    }
    if (!result) {
        if (_notFoundAlert !== false) {
            setTimeout(function () {
                alert('无法找到您要查找的内容');
            }, 30);
        }
    } else {
        table.setCurrentCell(cell);
        project.deselectAll();
        project.select(cell.record);
    }
    return result;
};

PlusProject._findTextByCell = function (project, options, item, column, rowIndex, columnIndex) {
    var value = options.text,
        caseSensitive = options.caseSensitive,
        operator = options.operator;

    var itemValue = PlusProject._getCellText(project, item, column, rowIndex, columnIndex);

    if (!caseSensitive) {
        value = value.toLowerCase();
        itemValue = itemValue.toLowerCase();
    }

    var flag = false;

    switch (operator) {
        case '!=':
            flag = !mini.isEquals(itemValue, value);
            break;
        case '==':
            flag = mini.isEquals(itemValue, value);
            break;
        case '>':
            flag = itemValue > value;
            break;
        case '>=':
            flag = itemValue >= value;
            break;
        case '<':
            flag = itemValue < value;
            break;
        case '<=':
            flag = itemValue <= value;
            break;
        case 'like':
            flag = String(itemValue).indexOf(value) != -1;
            break;
        case 'notlike':
            flag = String(itemValue).indexOf(value) == -1;
            break;
        default:
            throw new Error('operator error');
            break;
    }

    return flag;
};

PlusProject._getCellText = function (project, item, column, rowIndex, columnIndex) {
    if (!this._div) {
        this._div = document.createElement('div');
    }
    var div = this._div;

    var e = project.tableView._OnDrawCell(item, column, rowIndex, columnIndex);
    div.innerHTML = e.cellHtml;
    return div.innerText;
};

mini.locale = 'zh_CN';

mini.dateInfo = {
    monthsLong: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    monthsShort: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
    daysLong: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
    daysShort: ['日', '一', '二', '三', '四', '五', '六'],
    quarterLong: ['一季度', '二季度', '三季度', '四季度'],
    quarterShort: ['Q1', 'Q2', 'Q2', 'Q4'],
    halfYearLong: ['上半年', '下半年'],
    patterns: {
        d: 'yyyy-M-d',
        D: 'yyyy年M月d日',
        f: 'yyyy年M月d日 H:mm',
        F: 'yyyy年M月d日 H:mm:ss',
        g: 'yyyy-M-d H:mm',
        G: 'yyyy-M-d H:mm:ss',
        m: 'MMMd日',
        o: 'yyyy-MM-ddTHH:mm:ss.fff',
        s: 'yyyy-MM-ddTHH:mm:ss',
        t: 'H:mm',
        T: 'H:mm:ss',
        U: 'yyyy年M月d日 HH:mm:ss',
        y: 'yyyy年MM月'
    },
    tt: {
        AM: '上午',
        PM: '下午'
    },
    ten: {
        Early: '上旬',
        Mid: '中旬',
        Late: '下旬'
    },
    today: '今天',
    clockType: 24
};

if (mini.Calendar) {
    mini.copyTo(mini.Calendar.prototype, {
        firstDayOfWeek: 0,
        todayText: '今天',
        clearText: '清除',
        okText: '确定',
        cancelText: '取消',
        daysShort: ['日', '一', '二', '三', '四', '五', '六'],
        format: 'yyyy年MM月',

        timeFormat: 'H:mm'
    });
}

for (var id in mini) {
    var clazz = mini[id];
    if (clazz && clazz.prototype && clazz.prototype.isControl) {
        clazz.prototype.requiredErrorText = '不能为空';
        clazz.prototype.loadingMsg = '加载中...';
    }
}

if (mini.VTypes) {
    mini.copyTo(mini.VTypes, {
        uniqueErrorText: '字段不能重复',
        requiredErrorText: '不能为空',
        emailErrorText: '请输入邮件格式',
        urlErrorText: '请输入URL格式',
        floatErrorText: '请输入数字',
        intErrorText: '请输入整数',
        dateErrorText: '请输入日期格式 {0}',
        maxLengthErrorText: '不能超过 {0} 个字符',
        minLengthErrorText: '不能少于 {0} 个字符',
        maxErrorText: '数字不能大于 {0} ',
        minErrorText: '数字不能小于 {0} ',
        rangeLengthErrorText: '字符长度必须在 {0} 到 {1} 之间',
        rangeCharErrorText: '字符数必须在 {0} 到 {1} 之间',
        rangeErrorText: '数字必须在 {0} 到 {1} 之间'
    });
}

if (mini.Pager) {
    mini.copyTo(mini.Pager.prototype, {
        firstText: '首页',
        prevText: '上一页',
        nextText: '下一页',
        lastText: '尾页',
        pageInfoText: '每页 {0} 条, 共 {1} 条'
    });
}

if (mini.DataGrid) {
    mini.copyTo(mini.DataGrid.prototype, {
        emptyText: '没有返回的数据'
    });
}

if (mini.FileUpload) {
    mini.FileUpload.prototype.buttonText = '浏览...';
}
if (mini.HtmlFile) {
    mini.HtmlFile.prototype.buttonText = '浏览...';
}

if (window.mini.Gantt) {
    mini.GanttView.ShortWeeks = ['日', '一', '二', '三', '四', '五', '六'];
    mini.GanttView.LongWeeks = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];

    mini.Gantt.PredecessorLinkType = [
        { ID: 0, Name: '完成-完成(FF)', Short: 'FF' },
        { ID: 1, Name: '完成-开始(FS)', Short: 'FS' },
        { ID: 2, Name: '开始-完成(SF)', Short: 'SF' },
        { ID: 3, Name: '开始-开始(SS)', Short: 'SS' }
    ];

    mini.Gantt.ConstraintType = [
        { ID: 0, Name: '越早越好' },
        { ID: 1, Name: '越晚越好' },
        { ID: 2, Name: '必须开始于' },
        { ID: 3, Name: '必须完成于' },
        { ID: 4, Name: '不得早于...开始' },
        { ID: 5, Name: '不得晚于...开始' },
        { ID: 6, Name: '不得早于...完成' },
        { ID: 7, Name: '不得晚于...完成' }
    ];

    mini.Gantt.Manual = [
        { ID: 1, Name: '手动' },
        { ID: 0, Name: '自动' }
    ];

    mini.copyTo(mini.Gantt, {
        ID_Text: '标识号',
        Name_Text: '任务名称',
        PercentComplete_Text: '进度',
        Duration_Text: '工期',
        Start_Text: '开始日期',
        Finish_Text: '完成日期',
        Critical_Text: '关键任务',

        PredecessorLink_Text: '前置任务',
        Work_Text: '工时',
        Priority_Text: '重要级别',
        Weight_Text: '权重',
        OutlineNumber_Text: '大纲字段',
        OutlineLevel_Text: '任务层级',
        ActualStart_Text: '实际开始日期',
        ActualFinish_Text: '实际完成日期',
        EarlyStart_Text: '最早开始日期',
        EarlyFinish_Text: '最早完成日期',
        LateStart_Text: '最晚开始日期',
        LateFinish_Text: '最晚完成日期',
        WBS_Text: 'WBS',
        ConstraintType_Text: '限制类型',
        ConstraintDate_Text: '限制日期',
        Department_Text: '部门',
        Principal_Text: '负责人',
        Assignments_Text: '资源名称',

        DeleteLink: '是否删除此链接？',

        Summary_Text: '摘要任务',
        Task_Text: '任务',
        Baseline_Text: '比较基准',
        LinkType_Text: '链接类型',
        LinkLag_Text: '延隔时间',
        From_Text: '从',
        To_Text: '到',

        Goto_Text: '转到任务',
        UpGrade_Text: '升级',
        DownGrade_Text: '降级',
        Add_Text: '新增',
        Edit_Text: '编辑',
        Remove_Text: '删除',
        Move_Text: '移动',
        ZoomIn_Text: '放大',
        ZoomOut_Text: '缩小',
        Deselect_Text: '取消选择',
        Split_Text: '拆分任务',

        NoCalendarID: '日历没有UID标识号',
        WeekDayError: '工作周数据错误',
        ExceptionsError: '例外日期数据错误',
        PredecessorError: '前置任务出错, 有回环引用',
        SummaryPredecessorError: '摘要任务 ({0}) "{1}" 的前置任务必须是FS或SS',
        ManualCritical_Text: '关键任务（手动）',
        NoCalendar: '没有找到项目日历',
        NoCurrentCalendar: '必须有当前项目日历',
        Printing_Wait: '甘特图打印中，请稍后...',
        Printing_Text: '打印甘特图',

        Manual_Text: '任务模式',
        TaskStatus_Text: '任务状态',
        TotalSlack_Text: '可宽延的总时间',
        Deadline_Text: '最后期限',
        TaskType_Text: '任务类型',

        ShowProjectSummaryText: '显示项目摘要任务'
    });
}
