const path = require('path');
const fs = require('fs');

const { copyFolder, resolveIconConfig, generateStyle, replaceFileContent } = require('./src/util');

/**
 * 构建 iconfont，输出到指定目录
 * @param { string } context - 当前运行目录
 * @param { string } resourcePath - 存放iconfont资源的路径
 * @param { string } iconsFilePath - 图标清单的路径；最终生成的描述文件按照此清单的顺序输出
 * @param { string } mappingFilePath - 存放图标映射文件的路径，iconfont下载下来的图标名称按照此映射进行清洗处理
 * @param { string } outputPath - 输出目录
 * @param { object } [config] - iconfont配置项
 * @param { function } [callback] - 回调函数
 * @param { string } [config.fontFamily] - 生成的字体名称，默认 erd-iconfont
 * @param { string } [config.cssPrefixText] - 生成的样式前缀，默认 erd-icon-
 */
function build(
    { context = process.cwd(), resourcePath, iconsFilePath, mappingFilePath, outputPath, fontFamily, cssPrefixText },
    callback
) {
    let _resourcePath = path.isAbsolute(resourcePath) ? resourcePath : path.join(context, resourcePath);
    let _iconsFilePath = path.isAbsolute(iconsFilePath) ? iconsFilePath : path.join(context, iconsFilePath);
    let _mappingFilePath = path.isAbsolute(mappingFilePath) ? mappingFilePath : path.join(context, mappingFilePath);
    let _outputPath = path.isAbsolute(outputPath) ? outputPath : path.join(context, outputPath);

    return new Promise((resolve) => {
        if (!fs.existsSync(_iconsFilePath)) {
            throw new Error(`图标清单文件不存在，请检查路径 ${_iconsFilePath}`);
        }
        if (!fs.existsSync(_mappingFilePath)) {
            throw new Error(`图标映射文件存在，请检查路径 ${_mappingFilePath}`);
        }

        if (fs.existsSync(_outputPath) && fs.readdirSync(_outputPath).length) {
            fs.rmSync(_outputPath, { recursive: true, force: true });
        }

        copyFolder(_resourcePath, _outputPath, async function () {
            const iconfontFilePath = path.join(_resourcePath, 'iconfont.json');

            if (!fs.existsSync(iconfontFilePath)) {
                throw new Error(`iconfont.json 文件不存在，请检查路径 ${_resourcePath}`);
            }

            const originConfig = JSON.parse(fs.readFileSync(iconfontFilePath, 'utf-8'));
            const config = resolveIconConfig(originConfig, {
                fontFamily,
                cssPrefixText,
                iconsFilePath: _iconsFilePath,
                mappingFilePath: _mappingFilePath
            });

            const outputCss = path.join(_outputPath, `${config.font_family}.css`);
            const outputJson = path.join(_outputPath, `${config.font_family}.json`);
            const outputJs = path.join(_outputPath, 'iconfont.js');
            const outputIndex = path.join(_outputPath, 'demo_index.html');

            [outputJs, outputIndex].forEach(function (item) {
                replaceFileContent(item, function (content) {
                    if (outputJs !== item) {
                        content = content.replace(new RegExp(originConfig.font_family, 'g'), config.font_family);
                        content = content.replace(new RegExp(config.font_family + '.js', 'g'), 'iconfont.js');
                    }

                    const icons = config.icons;
                    const mapping = icons.reduce((prev, item) => {
                        prev[item] = prev[item] || item;
                        return prev;
                    }, config.mapping);
                    Object.keys(mapping).forEach(function (key) {
                        const value = Array.isArray(mapping[key]) ? mapping[key][0] : mapping[key];
                        content = content.replace(
                            new RegExp(originConfig.css_prefix_text + key + '"', 'g'),
                            config.css_prefix_text + value + '"'
                        );
                    });
                    return content;
                });
            });

            const css = await generateStyle(config);
            fs.writeFile(outputCss, css, function () {
                console.log(`iconfont 样式文件已生成 ${outputCss}`);
                fs.writeFileSync(outputJson, JSON.stringify(config));
                console.log(`iconfont 样式描述已更新 ${outputJson}`);
                resolve();
                callback && callback(outputJson);
            });
        });
    });
}

module.exports = {
    build
};
